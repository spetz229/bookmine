---
layout: page
title: "The Little Book on CoffeeScript"
prev: OEBPS/ch04s02.html
next: OEBPS/ch05s02.html
book_path: books/alex-maccaw-the-little-book-on-coffeescript-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre1"></div><div class="book" title="Chapter 5. The Good Parts"><div class="book"><div class="book"><div class="book"><div class="calibre1"></div><h1 class="title1"><a id="the_bad_parts" class="calibre2"></a>Chapter 5. The Good Parts</h1></div></div></div><p class="calibre8">JavaScript is a tricky beast, and knowing the parts that you should
  avoid is just as important as knowing about the parts you should use. As Sun
  Tzu says, “know your enemy,” and that’s exactly what we’re going to do in
  the chapter, exploring the dark side of JavaScript and revealing some of the
  lurking monsters ready to pounce on the unsuspecting developer.</p><p class="calibre8">As I mentioned in the <a class="ulink" href="pr01.html" title="Preface">Preface</a>, CoffeeScript’s
  awesomeness lies not only in its syntax, but in its ability to fix some of
  JavaScript’s warts. However, the language is not a silver bullet to all of
  JavaScript’s bugbears, and there are still some issues you need to be aware
  of.</p><div class="book" title="The Unfixed parts"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect15_d1e2087" class="calibre2"></a>The Unfixed parts</h1></div></div></div><p class="calibre8">While CoffeeScript goes some length to solving some of JavaScript’s
    design flaws, it can only go so far. As I mentioned previously,
    CoffeeScript is strictly limited to static analysis by design, and doesn’t
    do any runtime checking for performance reasons. CoffeeScript uses a
    straight source-to-source compiler, the idea being that every CoffeeScript statement results in an
    equivalent JavaScript statement. CoffeeScript doesn’t provide an
    abstraction over any of JavaScript’s keywords, such as <code class="literal">typeof</code>, and as such, some design flaws in
    JavaScript’s design also apply to CoffeeScript.</p><p class="calibre8">We’re going to first talk about some issues that CoffeeScript can’t
    fix, and then touch on a few JavaScript design flaws that CoffeeScript
    does fix.</p><div class="book" title="Using eval"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2690185" class="calibre2"></a>Using eval</h2></div></div></div><p class="calibre8">While CoffeeScript removes some of JavaScript’s foibles, other
      features are a necessary evil; you just need to be aware of their
      shortcomings. A case in point is the <code class="literal">eval()</code> function. While undoubtedly it has its
      uses, you should know about its drawbacks, and avoid it if possible. The
      <code class="literal">eval()</code> function will execute a string
      of JavaScript code in the local scope, and functions like <code class="literal">setTimeout()</code> and <code class="literal">setInterval()</code> can also both take a string as
      their first argument to be evaluated.</p><p class="calibre8">However, like <code class="literal">with</code>, <code class="literal">eval()</code> throws the compiler off track, and is a
      major performance hog. As the compiler has no idea what’s inside until
      runtime, it can’t perform any optimizations like inlining. Another
      concern is with security. If you give it dirty input, <code class="literal">eval</code> can easily open up your code for
      injection attacks. In almost every case, if you’re using <code class="literal">eval</code>, there are better and safer alternatives
      (such as square brackets):</p><pre class="screen"># Don't do this
model = eval(modelName)

# Use square brackets instead
model = window[modelName]</pre></div><div class="book" title="Using typeof"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2600231" class="calibre2"></a>Using typeof</h2></div></div></div><p class="calibre8">The <code class="literal">typeof</code> operator is probably
      the biggest design flaw of JavaScript, simply because it’s basically
      completely broken. In fact, it really has only one use—checking to see
      if a value is <code class="literal">undefined</code>:</p><pre class="screen">typeof undefinedVar is "undefined"</pre><p class="calibre8">For all other types of type checking, <code class="literal">typeof</code> fails rather miserably, returning
      inconsistent results depending on the browser and how instances were
      instantiated. This isn’t something that CoffeeScript can help you with
      either, since the language uses static analysis and has no runtime type
      checking. You’re on your own here.</p><p class="calibre8">To illustrate the problem, here’s a table taken from <a class="ulink" href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript
      Garden</a> which shows some of the major inconsistencies in the
      keyword’s type checking:</p><pre class="screen">Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object
new RegExp("meow")  RegExp     object
{}                  Object     object
new Object()        Object     object</pre><p class="calibre8">As you can see, depending on if you define a string with quotes or
      with the <code class="literal">String</code> class affects the
      result of <code class="literal">typeof</code>. Logically <code class="literal">typeof</code> should return <code class="literal">"string"</code> for both checks, but for the latter
      it returns <code class="literal">"object"</code>. Unfortunately,
      the inconsistencies only get worse from there.</p><p class="calibre8">So what can we use for type checking in JavaScript? Well, luckily
      <code class="literal">Object.prototype.toString()</code> comes to
      the rescue here. If we invoke that function in the context of a
      particular object, it’ll return the correct type. All we need to do is
      massage the string it returns, so we end up with the sort of string
      <code class="literal">typeof</code> should be returning. Here’s an
      example implementation ported from jQuery’s <code class="literal">$.type</code>:</p><pre class="screen">type = do -&gt;
  classToType = {}

  types = [
    "Boolean"
    "Number"
    "String"
    "Function"
    "Array"
    "Date"
    "RegExp"
    "Undefined"
    "Null"
  ]

  for name in types
    classToType["[object #{name}]"] = name.toLowerCase()

  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"

# Returns the sort of types we'd expect:
type("")         # "string"
type(new String) # "string"
type([])         # "array"
type(/\d/)       # "regexp"
type(new Date)   # "date"
type(true)       # "boolean"
type(null)       # "null"
type({})         # "object"</pre><p class="calibre8">If you’re checking to see if a variable has been defined, you’ll
      still need to use <code class="literal">typeof</code>; otherwise,
      you’ll get a <code class="literal">ReferenceError</code>:</p><pre class="screen">if typeof aVar isnt "undefined"
  objectType = type(aVar)</pre><p class="calibre8">Or more succinctly with the existential operator:</p><pre class="screen">objectType = type(aVar?)</pre><p class="calibre8">As an alternative to type checking, you can often use duck typing
      and the CoffeeScript existential operator together, which eliminates the
      need to resolve an object’s type. For example, let’s say we’re pushing a
      value onto an array. We could say that, as long as the “array like”
      object implements <code class="literal">push()</code>, we should
      treat it like an array:</p><pre class="screen">anArray?.push? aValue</pre><p class="calibre8">If <code class="literal">anArray</code> is an object other
      than an array, then the existential operator will ensure that <code class="literal">push()</code> is never called.</p></div><div class="book" title="Using instanceof"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2808394" class="calibre2"></a>Using instanceof</h2></div></div></div><p class="calibre8">JavaScript’s <code class="literal">instanceof</code> keyword
      is nearly as broken as <code class="literal">typeof</code>.
      Ideally, <code class="literal">instanceof</code> would compare the
      constructor of two objects, returning a boolean if one was an instance of the other. However, in
      reality, <code class="literal">instanceof</code> only works when
      comparing custom-made objects.
      When it comes to comparing built-in types, it’s as useless as <code class="literal">typeof</code>:</p><pre class="screen">new String("foo") instanceof String # true
"foo" instanceof String             # false</pre><p class="calibre8">Additionally, <code class="literal">instanceof</code> also
      doesn’t work when comparing objects from different frames in the
      browser. In fact, <code class="literal">instanceof</code> only
      returns a correct result for custom made objects, such as CoffeeScript
      classes:</p><pre class="screen">class Parent
class Child extends Parent

child = new Child
child instanceof Child  # true
child instanceof Parent # true</pre><p class="calibre8">Make sure you only use it for your own objects or, even better,
      stay clear of it.</p></div><div class="book" title="Using delete"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2660072" class="calibre2"></a>Using delete</h2></div></div></div><p class="calibre8">The <code class="literal">delete</code> keyword can only
      safely be used for removing properties inside objects:</p><pre class="screen">anObject = {one: 1, two: 2}
delete anObject.one
anObject.hasOwnProperty("one") # false</pre><p class="calibre8">Any other use, such as deleting variables or function’s won’t
      work:</p><pre class="screen">aVar = 1
delete aVar
typeof aVar # "integer"</pre><p class="calibre8">It’s rather peculiar behavior, but there you have it. If you want
      to remove a reference to a variable, just assign it to <code class="literal">null</code> instead:</p><pre class="screen">aVar = 1
aVar = null</pre></div><div class="book" title="Using parseInt"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2696770" class="calibre2"></a>Using parseInt</h2></div></div></div><p class="calibre8">JavaScript’s <code class="literal">parseInt()</code>
      function can return unexpected results if you pass a string to it
      without informing it of the proper base. For example:</p><pre class="screen"># Returns 8, not 10!
parseInt('010') is 8</pre><p class="calibre8">Always pass a base to the function to make it work
      correctly:</p><pre class="screen"># Use base 10 for the correct result
parseInt('010', 10) is 10</pre><p class="calibre8">This isn’t something CoffeeScript can do for you; you’ll just have
      to remember to always specify a base when using <code class="literal">parseInt()</code>.</p></div><div class="book" title="Strict Mode"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2852291" class="calibre2"></a>Strict Mode</h2></div></div></div><p class="calibre8">Strict mode is a new feature of ECMAScript 5 that allows you to
      run a JavaScript program or
      function in a <span class="firstname"><em class="calibre5">strict</em></span> context. This strict context
      throws more exceptions and warnings than the normal context, giving
      developers some indication when they’re straying from best practices,
      writing un-optimizable code or making common mistakes. In other words,
      strict mode reduces bugs, increases security, improves performance, and
      eliminates some difficult-to-use language features. What’s not to
      like?</p><p class="calibre8">Strict mode is currently supported in the following
      browsers:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre8">Chrome &gt;= 13.0</p></li><li class="listitem"><p class="calibre8">Safari &gt;= 5.0</p></li><li class="listitem"><p class="calibre8">Opera &gt;= 12.0</p></li><li class="listitem"><p class="calibre8">Firefox &gt;= 4.0</p></li><li class="listitem"><p class="calibre8">Internet Explorer &gt;= 10.0</p></li></ul></div><p class="calibre8">Having said that, strict mode is completely backwards compatible
      with older browsers. Programs using it should run fine in either a
      strict or normal context.</p></div><div class="book" title="Strict Mode Changes"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2700468" class="calibre2"></a>Strict Mode Changes</h2></div></div></div><p class="calibre8">Most of the changes strict mode introduces pertain to JavaScript’s
      syntax:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre8">Errors on duplicate property and function argument
          names</p></li><li class="listitem"><p class="calibre8">Errors on incorrect use of the <code class="literal">delete</code> operator</p></li><li class="listitem"><p class="calibre8">Access to <code class="literal">arguments.caller</code>
          &amp; <code class="literal">arguments.callee</code> throws an
          error (for performance reasons)</p></li><li class="listitem"><p class="calibre8">Using the <code class="literal">with</code> operator
          will raise a syntax error</p></li><li class="listitem"><p class="calibre8">Certain variables such as <code class="literal">undefined</code> are no longer writeable</p></li><li class="listitem"><p class="calibre8">Introduces additional reserved keywords, such as <code class="literal">implements</code>, <code class="literal">interface</code>, <code class="literal">let</code>, <code class="literal">package</code>, <code class="literal">private</code>, <code class="literal">protected</code>, <code class="literal">public</code>, <code class="literal">static</code>, and <code class="literal">yield</code></p></li></ul></div><p class="calibre8">However, strict mode also changes some runtime behavior:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre8">Global variables are explicit (<code class="literal">var</code> always required); the global value of
          <code class="literal">this</code> is <code class="literal">undefined</code></p></li><li class="listitem"><p class="calibre8"><code class="literal">eval</code> can’t introduce new
          variables into the local context</p></li><li class="listitem"><p class="calibre8">Function statements have to be defined before they’re used
          (previously, functions could be <a class="ulink" href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">defined
          anywhere</a>)</p></li><li class="listitem"><p class="calibre8"><code class="literal">arguments</code> is
          immutable</p></li></ul></div><p class="calibre8">CoffeeScript already abides by a lot of strict mode’s
      requirements, such as always using <code class="literal">var</code> when defining variables, but it’s still
      very useful to enable strict mode in your CoffeeScript programs. Indeed,
      CoffeeScript is taking this a step further, and in <a class="ulink" href="https://github.com/jashkenas/coffee-script/issues/1547">future
      versions</a> will check a program’s compliance to strict mode at
      compile time.</p></div><div class="book" title="Strict Mode Usage"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2810703" class="calibre2"></a>Strict Mode Usage</h2></div></div></div><p class="calibre8">All you need to do to enable strict checking is start your script
      or function with the following string:</p><pre class="screen">-&gt;
  "use strict"

  # ... your code ...</pre><p class="calibre8">That’s it, just the <code class="literal">"use
      strict"</code> string. Couldn’t be simpler and it’s completely
      backwards compatible. Let’s take a look at strict mode in action. The
      following function will raise a syntax error in strict mode, but run
      fine in the usual mode:</p><pre class="screen">do -&gt;
  "use strict"
  console.log(arguments.callee)</pre><p class="calibre8">Strict mode has removed access to <code class="literal">arguments.caller</code> and <code class="literal">arguments.callee</code>, as they’re major performance
      hogs, and is now throwing syntax errors whenever they’re used.</p><p class="calibre8">There’s a particular gotcha you should look out for when using
      strict mode, namely creating global variables with <code class="literal">this</code>. The following example will throw a
      <code class="literal">TypeError</code> in strict mode, but run
      fine in a normal context, creating a global variable:</p><pre class="screen">do -&gt;
  "use strict"
  class @Spine</pre><p class="calibre8">The reason behind this disparity is that in strict mode, <code class="literal">this</code> is <code class="literal">undefined</code>, whereas normally it refers to the <code class="literal">window</code> object. The solution to this is to
      explicitly set global variables on the <code class="literal">window</code> object:</p><pre class="screen">do -&gt;
  "use strict"
  class window.Spine</pre><p class="calibre8">While I recommend enabling strict mode, it’s worth noting that
      script mode doesn’t enable any new features that aren’t already possible
      in JavaScript, and will actually slow down your code a bit by having the
      VM do more checks at runtime. You may want to develop with strict mode,
      and deploy to production without it.</p></div></div></div></div>

{% endraw %}

