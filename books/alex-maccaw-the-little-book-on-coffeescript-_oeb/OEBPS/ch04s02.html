---
layout: page
title: "The Little Book on CoffeeScript"
prev: OEBPS/ch04.html
next: OEBPS/ch05.html
book_path: books/alex-maccaw-the-little-book-on-coffeescript-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Creating Applications"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect14_d1e1661" class="calibre2"></a>Creating Applications</h1></div></div></div><p class="calibre8">Using Cake for CoffeeScript compilation is fine for static sites,
    but for dynamic sites, we might as well integrate CoffeeScript compilation
    into the request/response cycle. Various integration solutions already
    exist for the popular backend languages and frameworks, such as <a class="ulink" href="http://rubyonrails.org/">Rails</a> and <a class="ulink" href="https://www.djangoproject.com/">Django</a>.</p><p class="calibre8">The rest of this chapter explores how to actually structure and
    deploy CoffeeScript client-side applications. If you’re just using
    CoffeeScript on the server side, or your framework, such as Rails, already
    manages this, feel free to skip to <a class="ulink" href="ch05.html" title="Chapter 5. The Good Parts">Chapter 5</a>.</p><p class="calibre8">For some reason, when developers build client-side JavaScript
    applications, tried and tested patterns and conventions often fly out the
    window, and the end result is a spaghetti mess of unmaintainable coupled
    JavaScript. I can’t stress enough how important application architecture is; if
    you’re writing any JavaScript/CoffeeScript beyond simple form validation, you should
    implement a form of application structure, such as <a class="ulink" href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>.</p><p class="calibre8">The secret to building maintainable large applications is not to
    build large applications. In other words, build a series of modular
    de-coupled components. Keep application logic as generic as possible,
    abstracting it out as appropriate. Lastly, separate out your logic into
    views, models, and controllers (MVC). Implementing MVC is beyond the scope
    of this chapter; for that, I recommend you check out my book on <a class="ulink" href="http://shop.oreilly.com/product/0636920018421.do">JavaScript Web
    Applications</a> and use a framework like <a class="ulink" href="http://documentcloud.github.com/backbone/">Backbone</a> or <a class="ulink" href="https://github.com/maccman/spine">Spine</a>. Rather than that,
    here we’re going to cover structuring applications using CommonJS
    modules.</p><div class="book" title="Structure and CommonJS"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2695880" class="calibre2"></a>Structure and CommonJS</h2></div></div></div><p class="calibre8">So what exactly are CommonJS modules? Well, If you’ve used <a class="ulink" href="http://nodejs.org/">NodeJS</a> before, you’ve used CommonJS
      modules, probably without realizing it. CommonJS modules were initially
      developed for writing server-side JavaScript libraries, in an attempt to
      deal with loading, namespacing, and scoping issues. They were a common
      format that would be compatible across all JavaScript implementations.
      The aim was that a library written for <a class="ulink" href="http://www.mozilla.org/rhino/">Rhino</a> would work for Node.
      Eventually these ideas transitioned back to browsers, and now we have
      great libraries like <a class="ulink" href="http://requirejs.org">RequireJS</a>
      and <a class="ulink" href="https://github.com/jbrantly/yabble">Yabble</a> to
      help us use modules on the client side.</p><p class="calibre8">Practically speaking, modules ensure that your code is run in a
      local namespace (code encapsulation), that you can load other modules
      with the <code class="literal">require()</code> function, and that
      you can expose module properties
      via <code class="literal">module.exports</code>. Let’s dive into
      that in a bit more depth now.</p><div class="book" title="Requiring files"><div class="book"><div class="book"><div class="book"><h3 class="title5"><a id="id2721726" class="calibre2"></a>Requiring files</h3></div></div></div><p class="calibre8">You can load in other modules and libraries using <code class="literal">require()</code>. Simply pass a module name and, if
        it’s in the load path, it’ll return an object representing that
        module. For example:</p><pre class="screen">User = require("models/user")</pre><p class="calibre8">Synchronous require support is a contentious issue, but has
        mostly been resolved with the mainstream loader libraries and latest
        CommonJS <a class="ulink" href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">proposals</a>.
        It may be something you’ll have to look into if you decided to take a
        separate route than the one I’m advocating with Stitch below.</p></div><div class="book" title="Exporting properties"><div class="book"><div class="book"><div class="book"><h3 class="title5"><a id="id2817461" class="calibre2"></a>Exporting properties</h3></div></div></div><p class="calibre8">By default, modules don’t expose any properties, so their
        contents are completely invisible to <code class="literal">require()</code> calls. If you want a particular
        property to be accessible from your module, you’ll need to set it on
        <code class="literal">module.exports</code>:</p><pre class="screen"># random_module.js
module.exports.myFineProperty = -&gt;
  # Some shizzle</pre><p class="calibre8">Now whenever this module is required, <code class="literal">myFineProperty</code> will be exposed:</p><pre class="screen">myFineProperty = require("random_module").myFineProperty</pre></div></div><div class="book" title="Stitch It Up"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2805187" class="calibre2"></a>Stitch It Up</h2></div></div></div><p class="calibre8">Formatting your code as CommonJS modules is all fine and dandy,
      but how do you actually get this working on the client in practice?
      Well, my method of choice is the rather unheard of <a class="ulink" href="https://github.com/sstephenson/stitch">Stitch</a> library.
      Stitch is by Sam Stephenson, the mind behind <a class="ulink" href="http://www.prototypejs.org">Prototype.js</a> among
      other things, and solves the module problem so elegantly it makes me
      want to dance for joy! Rather than try to dynamically resolve
      dependencies, Stitch simply bundles up all your JavaScript files into
      one, wrapping them in some CommonJS magic. Oh, and did I mention it’ll
      compile your CoffeeScript, JS templates, <a class="ulink" href="http://lesscss.org">LESS CSS</a>, and <a class="ulink" href="http://sass-lang.com">Sass</a> files too?</p><p class="calibre8">First things first, you’ll need to install <a class="ulink" href="http://nodejs.org/">Node.js</a> and <a class="ulink" href="http://npmjs.org/">npm</a> if you haven’t already. We’ll be
      using those throughout this chapter.</p><p class="calibre8">Now let’s create our application structure. If you’re using <a class="ulink" href="https://github.com/maccman/spine">Spine</a>, you can automate
      this with <a class="ulink" href="http://github.com/maccman/spine.app">Spine.App</a>; otherwise,
      it’s something you’ll need to do manually. I usually have an <code class="literal">app</code> folder for all the application specific
      code, and a <code class="literal">lib</code> folder for general
      libraries. Then anything else, including static assets, goes in the
      <code class="literal">public</code> directory:</p><pre class="screen">app
app/controllers
app/views
app/models
app/lib
lib
public
public/index.html</pre><p class="calibre8">Now to actually boot up the Stitch server. Let’s create a file
      called <code class="literal">index.coffee</code> and fill it with
      the following script:</p><pre class="screen">require("coffee-script")
stitch  = require("stitch")
express = require("express")
argv    = process.argv.slice(2)

package = stitch.createPackage(
  # Specify the paths you want Stitch to automatically bundle up
  paths: [ __dirname + "/app" ]

  # Specify your base libraries
  dependencies: [
    # __dirname + '/lib/jquery.js'
  ]
)
app = express.createServer()

app.configure -&gt;
  app.set "views", __dirname + "/views"
  app.use app.router
  app.use express.static(__dirname + "/public")
  app.get "/application.js", package.createServer()

port = argv[0] or process.env.PORT or 9294
console.log "Starting server on port: #{port}"
app.listen port</pre><p class="calibre8">You can see some dependencies listed: <code class="literal">coffee-script</code>, <code class="literal">stitch</code>, and <code class="literal">express</code>. We need to create a <code class="literal">package.json</code> file, listing these dependencies
      so npm can pick them up. Our <code class="literal">./package.json</code> file will look like
      this:</p><pre class="screen">{
  "name": "app",
  "version": "0.0.1",
  "dependencies": { 
    "coffee-script": "~1.1.2",
    "stitch": "~0.3.2",
    "express": "~2.5.0",
    "eco": "1.1.0-rc-1"
  }
}</pre><p class="calibre8">And let’s install those dependencies with npm:</p><pre class="screen">npm install .
npm install -g coffee-script</pre><p class="calibre8">Rightio, we’re almost there. Now run:</p><pre class="screen">coffee index.coffee</pre><p class="calibre8">You’ll hopefully have a Stitch server up and running. Let’s go
      ahead and test it out by putting an <code class="literal">app.coffee</code> script in the <code class="literal">app</code> folder. This will be the file that’ll
      bootstrap our application:</p><pre class="screen">module.exports = App =
  init: -&gt;
    # Bootstrap the app</pre><p class="calibre8">Now let’s create our main page <code class="literal">index.html</code> which, if we’re building a single
      page app, will be the only page the user actually navigates to. This is
      a static asset, so it’s located under the <code class="literal">public</code> directory:</p><pre class="screen">&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;Application&lt;/title&gt;
  &lt;!-- Require the main Stitch file --&gt;
  &lt;script src="/application.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" charset="utf-8"&gt;
    document.addEventListener("DOMContentLoaded", function(){
      var App = require("app");
      App.init();
    }, false);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p class="calibre8">When the page loads, our <span class="firstname"><em class="calibre5">DOMContentLoaded</em></span>
      event callback is requiring the <code class="literal">app.coffee</code> script (which is
      automatically compiled), and invoking our <code class="literal">init()</code> function. That’s all there is to it.
      We’ve got CommonJS modules up and running, as well as a HTTP server and
      CoffeeScript compiler. If, say, we wanted to include a module, it’s just
      a case of calling <code class="literal">require()</code>. Let’s
      create a new class, <code class="literal">User</code>, and
      reference it from <code class="literal">app.coffee</code>:</p><pre class="screen"># app/models/user.coffee
module.exports = class User
  constructor: (@name) -&gt;

# app/app.coffee
User = require("models/user")</pre></div><div class="book" title="JavaScript Templates"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2803009" class="calibre2"></a>JavaScript Templates</h2></div></div></div><p class="calibre8">If you’re moving logic to the client side, then you’ll definitely
      need some sort of templating
      library. JavaScript templating is very similar to templates on the
      server, such as Ruby’s ERB or Python’s text interpolation, except of
      course it runs client side. There are a whole host of templating
      libraries out there, so I encourage you to do some research and check them out. By default,
      Stitch comes with support for <a class="ulink" href="https://github.com/sstephenson/eco">Eco</a> templates baked
      right in.</p><p class="calibre8">JavaScript templates are very similar to server-side ones. You
      have template tags interoperated with HTML, and during rendering, those
      tags get evaluated and replaced. The great thing about <a class="ulink" href="https://github.com/sstephenson/eco">Eco</a> templates is
      they’re actually written in CoffeeScript.</p><p class="calibre8">Here’s an example:</p><pre class="screen">&lt;% if @projects.length: %&gt;
  &lt;% for project in @projects: %&gt;
    &lt;a href="&lt;%= project.url %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt;
    &lt;p&gt;&lt;%= project.description %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% else: %&gt;
  No projects
&lt;% end %&gt;</pre><p class="calibre8">As you can see, the syntax is remarkably straightforward. Just use
      <code class="literal">&lt;%</code> tags for evaluating
      expressions, and <code class="literal">&lt;%=</code> tags for
      printing them. A partial list of template tags is as follows:</p><div class="book"><dl class="book"><dt class="calibre9"><span class="firstname"><code class="literal">&lt;% expression
          %&gt;</code></span></dt><dd class="calibre10"><p class="calibre8">Evaluate a CoffeeScript expression without printing its
            return value.</p></dd><dt class="calibre9"><span class="firstname"><code class="literal">&lt;%= expression
          %&gt;</code></span></dt><dd class="calibre10"><p class="calibre8">Evaluate a CoffeeScript expression, escape its return value,
            and print it.</p></dd><dt class="calibre9"><span class="firstname"><code class="literal">&lt;%- expression
          %&gt;</code></span></dt><dd class="calibre10"><p class="calibre8">Evaluate a CoffeeScript expression and print its return
            value without escaping it.</p></dd></dl></div><p class="calibre8">You can use any CoffeeScript expression inside the templating
      tags, but there’s one thing to look out for. CoffeeScript is white space
      sensitive, but your Eco templates aren’t. Therefore, Eco template tags
      that begin an indented CoffeeScript block must be suffixed with a colon.
      To indicate the end of an indented block, use the special tag <code class="literal">&lt;% end
      %&gt;</code>. For example:</p><pre class="screen">&lt;% if @project.isOnHold(): %&gt;
  On Hold
&lt;% end %&gt;</pre><p class="calibre8">You don’t need to write the <code class="literal">if</code>
      and <code class="literal">end</code> tags on separate
      lines:</p><pre class="screen">&lt;% if @project.isOnHold(): %&gt; On Hold &lt;% end %&gt;</pre><p class="calibre8">And you can use the single-line postfix form of <code class="literal">if</code> as you’d expect:</p><pre class="screen">&lt;%= "On Hold" if @project.isOnHold() %&gt;</pre><p class="calibre8">Now that we’ve got a handle on the syntax, let’s define an Eco
      template in <code class="literal">views/users/show.eco</code>:</p><pre class="screen">&lt;label&gt;Name: &lt;%= @name %&gt;&lt;/label&gt;</pre><p class="calibre8">Stitch will automatically compile our template and include it in
      <code class="literal">application.js</code>. Then, in our
      application’s controllers, we can require the template, like it was a
      module, and execute it passing any data required:</p><pre class="screen">require("views/users/show")(new User("Brian"))</pre><p class="calibre8">Our <code class="literal">app.coffee</code> file should now
      look like this, rendering the template and appending it to the page when
      the document loads:</p><pre class="screen">User = require("models/user")

App =
  init: -&gt;
    template = require("views/users/show")
    view     = template(new User("Brian"))

    # Obviously this could be spruced up by jQuery
    element = document.createElement("div")
    element.innerHTML = view
    document.body.appendChild(element)

module.exports = App</pre><p class="calibre8">Open up <a class="ulink" href="http://localhost:9294/">the
      application</a> and give it a whirl! Hopefully this tutorial has
      given you a good idea of how to structure client-side CoffeeScript
      applications. For your next steps, I recommend checking out a
      client-side framework like <a class="ulink" href="http://documentcloud.github.com/backbone/">Backbone</a> or
      <a class="ulink" href="http://spinejs.com">Spine</a>, They’ll provide a basic
      MVC structure for you, freeing you up for the interesting stuff.</p></div><div class="book" title="Bonus: 30-Second Deployment with Heroku"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2736479" class="calibre2"></a>Bonus: 30-Second Deployment with Heroku</h2></div></div></div><p class="calibre8"><a class="ulink" href="http://heroku.com/">Heroku</a> is an incredibly
      awesome web host that manages all the servers and scaling for you,
      letting you get on with the exciting stuff (building awesome JavaScript
      applications). You’ll need an account with Heroku for this tutorial to
      work, but the great news is that their basic plan is completely free.
      While traditionally a Ruby host, Heroku have recently released their
      Cedar stack, which includes Node support.</p><p class="calibre8">First, we need to make a <code class="literal">Procfile</code>, which will inform Heroku about our
      application:</p><pre class="screen">echo "web: coffee index.coffee" &gt; Procfile</pre><p class="calibre8">Now, if you haven’t already, you’ll need to create a local git
      repository for your application:</p><pre class="screen">git init
git add .
git commit -m "First commit"</pre><p class="calibre8">And now to deploy the application, we’ll use the <code class="literal">heroku</code> gem (which you’ll need to install if
      you haven’t already).</p><pre class="screen">heroku create myAppName --stack cedar
git push heroku master
heroku open</pre><p class="calibre8">That’s it! Seriously, that’s all there is to it. Hosting Node
      applications has never been easier.</p></div><div class="book" title="Additional Libraries"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2806870" class="calibre2"></a>Additional Libraries</h2></div></div></div><p class="calibre8"><a class="ulink" href="https://github.com/sstephenson/stitch">Stitch</a>
      and <a class="ulink" href="https://github.com/sstephenson/eco">Eco</a> aren’t
      the only libraries you can use for creating CoffeeScript and Node
      applications. There are a variety of alternatives.</p><p class="calibre8">For example, when it comes to templating, you can use <a class="ulink" href="http://mustache.github.com">Mustache</a>, <a class="ulink" href="http://jade-lang.com">Jade</a>, or write your HTML in pure
      CoffeeScript using <a class="ulink" href="http://coffeekup.org">CoffeeKup</a>.</p><p class="calibre8">As for serving your application, <a class="ulink" href="http://github.com/maccman/hem">Hem</a> is a great choice,
      supporting both CommonJS and NPM modules and integrating seamlessly with
      the CoffeeScript MVC framework <a class="ulink" href="http://spinejs.com">Spine</a>. <a class="ulink" href="https://github.com/substack/node-browserify">node-browsify</a>
      is another similar project. Or if you want to go lower level with <a class="ulink" href="http://expressjs.com/">express</a> integration, there’s Trevor
      Burnham’s <a class="ulink" href="https://github.com/TrevorBurnham/connect-assets">connect-assets</a></p><p class="calibre8">You can find a full list of CoffeeScript web framework plug-ins on
      the <a class="ulink" href="https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins">project’s
      wiki</a>.</p></div></div></div>

{% endraw %}

