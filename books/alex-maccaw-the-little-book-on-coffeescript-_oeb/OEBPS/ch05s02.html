---
layout: page
title: "The Little Book on CoffeeScript"
prev: OEBPS/ch05.html
next: OEBPS/ch05s03.html
book_path: books/alex-maccaw-the-little-book-on-coffeescript-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="The Fixed Parts"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect15_d1e2495" class="calibre2"></a>The Fixed Parts</h1></div></div></div><p class="calibre8">Now that we’ve covered some of JavaScript’s warts that CoffeeScript
    can’t fix, let’s talk about a few that CoffeeScript does fix. In my mind,
    the following features are some of the best reasons to use CoffeeScript;
    they fix some of the most common mistakes developers make when writing JavaScript.
    While this is more of an academic discussion, you should still find the
    rest of this chapter useful, especially when making the case to use
    CoffeeScript!</p><div class="book" title="A JavaScript Subset"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2674399" class="calibre2"></a>A JavaScript Subset</h2></div></div></div><p class="calibre8">CoffeeScript’s syntax only covers a subset of JavaScript’s, the
      famous <span class="firstname"><em class="calibre5">Good Parts</em></span>, so already there’s less to fix.
      Let’s take the <code class="literal">with</code> statement for
      example. This statement has for a long time been “considered harmful,”
      and should be avoided. <code class="literal">with</code> was
      intended to provide a shorthand for writing recurring property lookups
      on objects. For example, instead of writing:</p><pre class="screen">dataObj.users.alex.email = "info@eribium.org";</pre><p class="calibre8">You could write:</p><pre class="screen">with(dataObj.users.alex) {
  email = "info@eribium.org";
}</pre><p class="calibre8">Setting aside the fact that we shouldn’t have such a deep object
      in the first place, the syntax is quite clean. Except for one thing.
      It’s confusing to the JavaScript interpreter, which doesn’t know exactly
      what you’re going to do in the <code class="literal">with</code>
      context, and forces the specified object to be searched first for all
      name lookups.</p><p class="calibre8">This really hurts performance and means the interpreter has to
      turn off all sorts of JIT optimizations. Additionally, <code class="literal">with</code> statements can’t be minified using tools
      like <a class="ulink" href="https://github.com/mishoo/UglifyJS">uglify-js</a>.
      They’re also deprecated and removed from future JavaScript versions. All
      things considered, it’s much better just to avoid using them, and
      CoffeeScript takes this a step further by eliminating them from its
      syntax. In other words, using <code class="literal">with</code> in
      CoffeeScript will throw a syntax
      error.</p></div><div class="book" title="Global Variables"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2767775" class="calibre2"></a>Global Variables</h2></div></div></div><p class="calibre8">By default, your JavaScript programs run in a global scope, and by
      default, any variables created are in that global scope. If you want to
      create a variable in the local scope, JavaScript requires explicitly
      indicating that fact using the <code class="literal">var</code>
      keyword.</p><pre class="screen">usersCount = 1;        // Global
var groupsCount = 2;   // Global

(function(){              
  pagesCount = 3;      // Global
  var postsCount = 4;  // Local
})()</pre><p class="calibre8">This is a bit of an odd decision since the vast majority of the
      time you’ll be creating local variables not global ones, so why not make
      that the default? As it stands, developers have to remember to put
      <code class="literal">var</code> statements before any variables
      they’re initializing, or face weird bugs when variables accidentally
      conflict and overwrite each other.</p><p class="calibre8">Luckily, CoffeeScript comes to your rescue here by eliminating
      implicit global variable assignment entirely. In other words, the
      <code class="literal">var</code> keyword is reserved in
      CoffeeScript, and will trigger a syntax error if used. Local variables
      are created implicitly by default, and it’s very difficult to create
      global variables without explicitly assigning them as properties on <code class="literal">window</code>.</p><p class="calibre8">Let’s have a look at an example of CoffeeScript’s variable
      assignment:</p><pre class="screen">outerScope = true
do -&gt;
  innerScope = true</pre><p class="calibre8">Compiles down to:</p><pre class="screen">var outerScope;
outerScope = true;
(function() {
  var innerScope;
  return innerScope = true;
})();</pre><p class="calibre8">Notice how CoffeeScript initializes variables (using <code class="literal">var</code>) automatically in the context they are
      first used. While CoffeeScript makes it difficult to shadow outer
      variables, you can still refer to and access them. You need to watch out
      for this; be careful that you’re not reusing the name of an external
      variable accidentally if you’re writing a deeply nested function or
      class. For example, here we’re accidentally overwriting the <code class="literal">package</code>
      variable in a Class function:</p><pre class="screen">package = require('./package')

class Hem
  build: -&gt;
    # Overwrites outer variable!
    package = @hemPackage.compile()

  hemPackage: -&gt;
    package.create()</pre><p class="calibre8">Global variables are needed from time to time, and to create those
      you need to set them as properties on <code class="literal">window</code>:</p><pre class="screen">class window.Asset
  constructor: -&gt;</pre><p class="calibre8">By ensuring global variables are explicit, rather than implicit,
      CoffeeScript removes one of the major sources of bugs in JavaScript
      programs.</p></div><div class="book" title="Semicolons"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2843383" class="calibre2"></a>Semicolons</h2></div></div></div><p class="calibre8">JavaScript does not enforce the use of semicolons in source code,
      so it’s possible to omit them. However, behind the scenes, the
      JavaScript compiler still needs them, so the parser automatically
      inserts them whenever it encounters a parse error due to a missing
      semicolon. In other words, it’ll try to evaluate a statement without
      semicolons and, if that fails, tries again using semicolons.</p><p class="calibre8">Unfortunately, this is a tremendously bad idea, and can actually
      change the behavior of your code. Take the following example, which
      seems like valid JavaScript, right?</p><pre class="screen">function() {}
(window.options || {}).property</pre><p class="calibre8">Wrong. Well, at least according to the parser; it raises a syntax
      error. In case of a leading parenthesis, the parser will not insert a
      semicolon. The code gets transformed onto one line:</p><pre class="screen">function() {}(window.options || {}).property</pre><p class="calibre8">Now you can see the issue, and why the parser is complaining. When
      you’re writing JavaScript, you should always include semicolons after
      statements. Fortunately, CoffeeScript gets around all this hassle
      by not having semicolons in its syntax. Rather, the semicolons are
      inserted automatically (at the right places) when the CoffeeScript is
      compiled down to JavaScript.</p></div><div class="book" title="Reserved Words"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2695811" class="calibre2"></a>Reserved Words</h2></div></div></div><p class="calibre8">Certain keywords in JavaScript are reserved for future versions of
      JavaScript, such as <code class="literal">const</code>, <code class="literal">enum</code>, and <code class="literal">class</code>. Using these as variable names in your
      JavaScript programs can result in unpredictable results; some browsers
      will cope with them just fine, and others will choke. CoffeeScript
      neatly sidesteps this issue, by detecting if you’re using a reserved keyword, and escaping it if
      necessary.</p><p class="calibre8">For example, let’s say you were to use the reserved keyword
      <code class="literal">class</code> as a property on an object.
      Your CoffeeScript might look like this:</p><pre class="screen">myObj = {
  delete: "I am a keyword!"
}
myObj.class = -&gt;</pre><p class="calibre8">The CoffeeScript parser notices you’re using a reserved keyword,
      and quotes it for you:</p><pre class="screen">var myObj;
myObj = {
  "delete": "I am a keyword!"
};
myObj["class"] = function() {};</pre></div><div class="book" title="Equality Comparisons"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2749796" class="calibre2"></a>Equality Comparisons</h2></div></div></div><p class="calibre8">The weak equality comparison in JavaScript has some confusing
      behavior and is often the source of confusing bugs. The example below is
      taken from <a class="ulink" href="http://bonsaiden.github.com/JavaScript-Garden/#types.equality">JavaScript
      Garden’s equality section</a>, which delves into the issue in some
      depth:</p><pre class="screen">""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true</pre><p class="calibre8">The reason behind this behavior is that the weak equality coerces
      types automatically. I’m sure you’ll agree this is all pretty ambiguous,
      and can lead to unexpected results and bugs.</p><p class="calibre8">The solution is to instead use the strict equality operator, which
      consists of three equal signs (<code class="literal">===</code>).
      It works exactly like the normal equality operator, but without any type
      coercion. It’s recommended to always use the strict equality operator,
      and explicitly convert types if needs be.</p><p class="calibre8">CoffeeScript solves this by simply replacing all weak comparisons
      with strict ones (in other words, converting all <code class="literal">==</code> comparators into <code class="literal">===</code>). You can’t do a a weak equality
      comparison in CoffeeScript, and you should explicitly convert types
      before comparing them if necessary.</p><p class="calibre8">This doesn’t mean you can ignore type coercion in CoffeeScript
      completely though, especially when it comes to checking the
      “truthfulness” of variables during flow control. Blank strings, <code class="literal">null</code>, <code class="literal">undefined</code>, and the number <code class="literal">0</code> are all coerced to <code class="literal">false</code>:</p><pre class="screen">alert("Empty Array")  unless [].length
alert("Empty String") unless ""
alert("Number 0")     unless 0</pre><p class="calibre8">If you want to explicitly check for <code class="literal">null</code> and <code class="literal">undefined</code>, then you can use CoffeeScript’s
      existential operator:</p><pre class="screen">alert("This is not called") unless ""?</pre><p class="calibre8">The <code class="literal">alert()</code> in this example
      won’t be called, as the empty string isn’t equal to <code class="literal">null</code>.</p></div><div class="book" title="Function Definition"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2688143" class="calibre2"></a>Function Definition</h2></div></div></div><p class="calibre8">Oddly enough, in JavaScript, functions can be defined after
      they’re used. For example, the following runs absolutely fine, even
      though <code class="literal">wem</code> is defined after it’s
      called:</p><pre class="screen">wem();
function wem() {}</pre><p class="calibre8">This is because of function scope. Functions get hoisted before
      the program’s execution and as such are available everywhere in the
      scope they were defined in, even if called before the actual definition
      in the source. The trouble is, hoisting behavior differs between browser. For example:</p><pre class="screen">if (true) {
  function declaration() {
    return "first";
  }
} else {
  function declaration() {
    return "second";
  }
}
declaration();</pre><p class="calibre8">In some browsers (e.g., Firefox), <code class="literal">declaration()</code> will return <code class="literal">"first"</code>, and in other browsers (e.g., Chrome), it’ll return
      <code class="literal">"second"</code>, even though it looks like
      the <code class="literal">else</code> statement is never
      run.</p><p class="calibre8">If you want to know more about declarative functions, then you
      should read <a class="ulink" href="http://kangax.github.com/nfe/">Juriy Zaytsev’s
      guide</a>, where he delves into the specifics. Suffice to say, they
      have fairly ambiguous behavior,
      and can lead to problems later down the road. All things considered,
      it’s best to steer clear of them by using function expressions
      instead:</p><pre class="screen">var wem = function(){};
wem();</pre><p class="calibre8">CoffeeScript’s approach to this is to remove declarative functions
      entirely, using function expressions instead.</p></div><div class="book" title="Number Property Lookups"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id2625944" class="calibre2"></a>Number Property Lookups</h2></div></div></div><p class="calibre8">A flaw in JavaScript’s parser means that the <span class="firstname"><em class="calibre5">dot
      notation</em></span> on numbers is interpreted as a floating point
      literal, rather than a property lookup. For example, the following
      JavaScript will cause a syntax error:</p><pre class="screen">5.toString();</pre><p class="calibre8">JavaScript’s parser is looking for another number after the dot,
      and so raises an <code class="literal">Unexpected</code><code class="literal">
      token</code> error when it encounters <code class="literal">toString()</code>. The solution to this is to either
      use parenthesis, or add an additional dot:</p><pre class="screen">(5).toString();
5..toString();</pre><p class="calibre8">Fortunately, CoffeeScript’s parsers are clever enough to deal with
      this issue by using double dot notations automatically (as in the
      preceding example) whenever you access properties on numbers.</p></div></div></div>

{% endraw %}

