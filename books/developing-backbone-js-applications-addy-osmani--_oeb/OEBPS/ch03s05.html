---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch03s04.html
next: OEBPS/ch04.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Practical"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="practical-1" class="calibre1"></a>Practical</h1></div></div></div><p class="calibre6">
    We’re going to use Sinatra in a similar manner to how we used
    Express in the last chapter. It will power a RESTful API supporting
    CRUD operations. Together with a MongoDB data store, this will allow
    us to easily persist data (todo items) whilst ensuring they are
    stored in a database. If you’ve read the previous chapter or have
    gone through any of the Todo examples covered so far, you will find
    this surprisingly straight-forward.
  </p><p class="calibre6">
    Remember that the default Todo example included with Backbone.js
    already persists data, although it does this via a localStorage
    adapter. Luckily there aren’t a great deal of changes needed to
    switch over to using our Sinatra-based API. Let’s briefly review the
    code that will be powering the CRUD operations for this sections
    practical, as we go course won’t be starting off with a
    near-complete base for most of our real world applications.
  </p><div class="book" title="Installing The Prerequisites" id="preq"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="installing-the-prerequisites" class="calibre1"></a>Installing The Prerequisites</h2></div></div></div><div class="book" title="Ruby"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="ruby" class="calibre1"></a>Ruby</h3></div></div></div><p class="calibre6">
        If using OSX or Linux, Ruby may be one of a number of
        open-source packages that come pre-installed and you can skip
        over to the next paragraph. In case you would like to check if
        check if you have Ruby installed, open up the terminal prompt
        and type:
      </p><p class="calibre6">
        <code class="literal">$ ruby -v</code>
      </p><p class="calibre6">
        The output of this will either be the version of Ruby installed
        or an error complaining that Ruby wasn’t found.
      </p><p class="calibre6">
        Should you need to install Ruby manually (e.g for an operating
        system such as Windows), you can do so by downloading the latest
        version from http://www.ruby-lang.org/en/downloads/.
        Alternatively, (RVM)[http://beginrescueend.com/rvm/install/]
        (Ruby Version Manager) is a command-line tool that allows you to
        easily install and manage multiple ruby environments with ease.
      </p></div><div class="book" title="Ruby Gems"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="ruby-gems" class="calibre1"></a>Ruby Gems</h3></div></div></div><p class="calibre6">
        Next, we will need to install Ruby Gems. Gems are a standard way
        to package programs or libraries written in Ruby and with Ruby
        Gems it’s possible to install additional dependencies for Ruby
        applications very easily.
      </p><p class="calibre6">
        On OSX, Linux or Windows go to
        <a class="ulink" href="http://rubyforge.org/projects/rubygems">http://rubyforge.org/projects/rubygems</a>
        and download the latest version of Ruby Gems. Once downloaded,
        open up a terminal, navigate to the folder where this resides
        and enter:
      </p><pre class="programlistingjavascript">
$&gt; tar xzvf rubygems.tgz
$&gt; cd rubygems
$&gt; sudo ruby setup.rb
</pre><p class="calibre6">
        There will likely be a version number included in your download
        and you should make sure to include this when tying the above.
        Finally, a symlink (symbolic link) to tie everything togther
        should be fun as follows:
      </p><p class="calibre6">
        <code class="literal">$ sudo ln -s /usr/bin/gem1.8.17 /usr/bin/gem</code>
      </p><p class="calibre6">
        To check that Ruby Gems has been correctly installed, type the
        following into your terminal:
      </p><pre class="programlistingjavascript">
$ gem -v
</pre></div><div class="book" title="Sinatra"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="sinatra" class="calibre1"></a>Sinatra</h3></div></div></div><p class="calibre6">
        With Ruby Gems setup, we can now easily install Sinatra. For
        Linux or OSX type this in your terminal:
      </p><p class="calibre6">
        <code class="literal">$ sudo gem install sinatra</code>
      </p><p class="calibre6">
        and if you’re on Windows, enter the following at a command
        prompt:
      </p><p class="calibre6">
        <code class="literal">c:\\ &gt; gem install sinatra</code>
      </p></div><div class="book" title="Haml"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="haml-1" class="calibre1"></a>Haml</h3></div></div></div><p class="calibre6">
        As with other DSLs and frameworks, Sinatra supports a wide range
        of different templating engines.
        <a class="ulink" href="http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html">ERB</a>
        is the one most often recommended by the Sinatra camp, however
        as a part of this chapter, we’re going to explore the use of
        <a class="ulink" href="http://haml.hamptoncatlin.com/">Haml</a> to
        define our application templates.
      </p><p class="calibre6">
        Haml stands for HTML Abstractional Markup Language and is a
        lightweight markup language abstraction that can be used to
        describe HTML without the need to use traditional markup
        language semantics (such as opening and closing tags).
      </p><p class="calibre6">
        Installing Haml can be done in just a line using Ruby Gems as
        follows:
      </p><p class="calibre6">
        <code class="literal">$ gem install haml</code>
      </p></div><div class="book" title="MongoDB"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="mongodb-1" class="calibre1"></a>MongoDB</h3></div></div></div><p class="calibre6">
        If you haven’t already downloaded and installed MongoDB from an
        earlier chapter, please
        <a class="ulink" href="http://www.mongodb.org/downloads">do so</a> now.
        With Ruby Gems, Mongo can be installed in just one line:
      </p><p class="calibre6">
        <code class="literal">$ gem install mongodb</code>
      </p><p class="calibre6">
        We now require two further steps to get everything up and
        running.
      </p><div class="book" title="1.Data directories"><div class="book"><div class="book"><div class="book"><h4 class="title5"><a id="data-directories" class="firstname"></a>1.Data directories</h4></div></div></div><p class="calibre6">
          MongoDB stores data in the bin/data/db folder but won’t
          actually create this directory for you. Navigate to where
          you’ve downloaded and extracted Mongo and run the following
          from terminal:
        </p><pre class="programlistingjavascript">
sudo mkdir -p /data/db/
sudo chown `id -u` /data/db
</pre></div><div class="book" title="2.Running and connecting to your server"><div class="book"><div class="book"><div class="book"><h4 class="title5"><a id="running-and-connecting-to-your-server" class="firstname"></a>2.Running and connecting to your server</h4></div></div></div><p class="calibre6">
          Once this is done, open up two terminal windows.
        </p><p class="calibre6">
          In the first, cd to your MongoDB bin directory or type in the
          complete path to it. You’ll need to start mongod.
        </p><pre class="programlistingjavascript">
$ ./bin/mongod
</pre><p class="calibre6">
          Finally, in the second terminal, start the mongo shell which
          will connect up to localhost by default.
        </p><pre class="programlistingjavascript">
$ ./bin/mongo
</pre></div></div><div class="book" title="MongoDB Ruby Driver"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="mongodb-ruby-driver-1" class="calibre1"></a>MongoDB Ruby Driver</h3></div></div></div><p class="calibre6">
        As we’ll be using the
        <a class="ulink" href="https://github.com/mongodb/mongo-ruby-driver">MongoDB
        Ruby Driver</a>, we’ll also require the following gems:
      </p><p class="calibre6">
        The gem for the driver itself:
      </p><pre class="programlistingjavascript">
$ gem install mongo
</pre><p class="calibre6">
        and the driver’s other prerequisite, bson:
      </p><pre class="programlistingjavascript">
$ gem install bson_ext
</pre><p class="calibre6">
        This is basically a collection of extensions used to increase
        serialization speed.
      </p><p class="calibre6">
        That’s it for our prerequisites!.
      </p></div></div><div class="book" title="Tutorial"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="tutorial" class="calibre1"></a>Tutorial</h2></div></div></div><p class="calibre6">
      To get started, let’s get a local copy of the practical
      application working on our system.
    </p><div class="book" title="Application Files"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="application-files" class="calibre1"></a>Application Files</h3></div></div></div><p class="calibre6">
        Clone
        <a class="ulink" href="http://github.com/addyosmani/backbone-fundamentals">this</a>
        repository and navigate to
        <code class="literal">/practicals/stacks/option3</code>. Now run the
        following lines at the terminal:
      </p><pre class="programlistingjavascript">
ruby app.rb
</pre><p class="calibre6">
        Finally, navigate to <code class="literal">http://localhost:4567/todo</code> to
        see the application running successfully.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Note:</strong></span> The Haml layout files
        for Option 3 can be found in the /views folder.
      </p><p class="calibre6">
        The directory structure for our practical application is as
        follows:
      </p><pre class="programlistingjavascript">
--public
----css
----img
----js
-----script.js
----test
--views
app.rb
</pre><p class="calibre6">
        The <code class="literal">public</code> directory contains the scripts and
        stylesheets for our application and uses HTML5 Boilerplate as a
        base. You can find the Models, Views and Collections for this
        section within <code class="literal">public/js/scripts.js</code> (however,
        this can of course be expanded into sub-directories for each
        component if desired).
      </p><p class="calibre6">
        <code class="literal">scripts.js</code> contains the following Backbone
        component definitions:
      </p><pre class="programlistingjavascript">
--Models
----Todo

--Collections
----TodoList

--Views
---TodoView
---AppView
</pre><p class="calibre6">
        <code class="literal">app.rb</code> is the small Sinatra application that
        powers our backend API.
      </p><p class="calibre6">
        Lastly, the <code class="literal">views</code> directory hosts the Haml
        source files for our application’s index and templates, both of
        which are compiled to standard HTML markup at runtime.
      </p><p class="calibre6">
        These can be viewed along with other note-worthy snippets of
        code from the application below.
      </p></div><div class="book" title="Backbone"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="backbone" class="calibre1"></a>Backbone</h3></div></div></div><div class="book" title="Views"><div class="book"><div class="book"><div class="book"><h4 class="title5"><a id="views-2" class="firstname"></a>Views</h4></div></div></div><p class="calibre6">
          In our main application view (AppView), we want to load any
          previously stored Todo items in our Mongo database when the
          view initializes. This is done below with the line
          <code class="literal">Todos.fetch()</code> in the
          <code class="literal">initialize()</code> method where we also bind to
          the relevant events on the <code class="literal">Todos</code> collection
          for when items are added or changed.
        </p><pre class="programlistingjavascript"><code class="c">// Our overall **AppView** is the top-level piece of UI.</code>
<code class="kd">var</code> <code class="nx">AppView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">// Instead of generating a new element, bind to the existing skeleton of</code>
    <code class="c">// the App already present in the HTML.</code>
    <code class="nx">el</code><code class="o">:</code> <code class="nx">$</code><code class="p">(</code><code class="s">"#todoapp"</code><code class="p">),</code>

    <code class="c">// Our template for the line of statistics at the bottom of the app.</code>
    <code class="nx">statsTemplate</code><code class="o">:</code> <code class="nx">_</code><code class="p">.</code><code class="nx">template</code><code class="p">(</code><code class="nx">$</code><code class="p">(</code><code class="s">'#stats-template'</code><code class="p">).</code><code class="nx">html</code><code class="p">()),</code>

    <code class="c">// Delegated events for creating new items, and clearing completed ones.</code>
    <code class="nx">events</code><code class="o">:</code> <code class="p">{</code>
      <code class="s">"keypress #new-todo"</code><code class="o">:</code>  <code class="s">"createOnEnter"</code><code class="p">,</code>
      <code class="s">"keyup #new-todo"</code><code class="o">:</code>     <code class="s">"showTooltip"</code><code class="p">,</code>
      <code class="s">"click .todo-clear a"</code><code class="o">:</code> <code class="s">"clearCompleted"</code>
    <code class="p">},</code>

    <code class="c">// At initialization</code>
    <code class="nx">initialize</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">input</code>    <code class="o">=</code> <code class="kd">this</code><code class="p">.</code><code class="nx">$</code><code class="p">(</code><code class="s">"#new-todo"</code><code class="p">);</code>

      <code class="nx">Todos</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'add'</code><code class="p">,</code>   <code class="kd">this</code><code class="p">.</code><code class="nx">addOne</code><code class="p">,</code> <code class="kd">this</code><code class="p">);</code>
      <code class="nx">Todos</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'reset'</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">addAll</code><code class="p">,</code> <code class="kd">this</code><code class="p">);</code>
      <code class="nx">Todos</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'all'</code><code class="p">,</code>   <code class="kd">this</code><code class="p">.</code><code class="nx">render</code><code class="p">,</code> <code class="kd">this</code><code class="p">);</code>

      <code class="nx">Todos</code><code class="p">.</code><code class="nx">fetch</code><code class="p">();</code>
    <code class="p">},</code>

    <code class="c">// Re-rendering the App just means refreshing the statistics -- the rest</code>
    <code class="c">// of the app doesn't change.</code>
    <code class="nx">render</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">$</code><code class="p">(</code><code class="s">'#todo-stats'</code><code class="p">).</code><code class="nx">html</code><code class="p">(</code><code class="kd">this</code><code class="p">.</code><code class="nx">statsTemplate</code><code class="p">({</code>
        <code class="nx">total</code><code class="o">:</code>      <code class="nx">Todos</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code>
        <code class="nx">done</code><code class="o">:</code>   
 <code class="err">…</code><code class="p">.</code>
</pre></div></div><div class="book" title="Collections"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="collections-1" class="calibre1"></a>Collections</h3></div></div></div><p class="calibre6">
        In the TodoList collection below, we’ve set the
        <code class="literal">url</code> property to point to
        <code class="literal">/api/todos</code> to reference the collection’s
        location on the server. When we attempt to access this from our
        Sinatra-backed API, it should return a list of all the Todo
        items that have been previously stored in Mongo.
      </p><p class="calibre6">
        For the sake of thoroughness, our API will also support
        returning the data for a specific Todo item via
        <code class="literal">/api/todos/itemID</code>. We’ll take a look at this
        again when writing the Ruby code powering our backend.
      </p><pre class="programlistingjavascript"> <code class="c">// Todo Collection</code>

  <code class="kd">var</code> <code class="nx">TodoList</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Collection</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">// Reference to this collection's model.</code>
    <code class="nx">model</code><code class="o">:</code> <code class="nx">Todo</code><code class="p">,</code>

    <code class="c">// Save all of the todo items under the `"todos"` namespace.</code>
    <code class="c">// localStorage: new Store("todos"),</code>
    <code class="nx">url</code><code class="o">:</code> <code class="s">'/api/todos'</code><code class="p">,</code>

    <code class="c">// Filter down the list of all todo items that are finished.</code>
    <code class="nx">done</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">todo</code><code class="p">){</code> <code class="kd">return</code> <code class="nx">todo</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'done'</code><code class="p">);</code> <code class="p">});</code>
    <code class="p">},</code>

    <code class="c">// Filter down the list to only todo items that are still not finished.</code>
    <code class="nx">remaining</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">without</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">done</code><code class="p">());</code>
    <code class="p">},</code>

    <code class="c">// We keep the Todos in sequential order, despite being saved by unordered</code>
    <code class="c">// GUID in the database. This generates the next order number for new items.</code>
    <code class="nx">nextOrder</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="kd">this</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="kd">return</code> <code class="mi">1</code><code class="p">;</code>
      <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">().</code><code class="nx">get</code><code class="p">(</code><code class="s">'order'</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="c">// Todos are sorted by their original insertion order.</code>
    <code class="nx">comparator</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">todo</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="nx">todo</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'order'</code><code class="p">);</code>
    <code class="p">}</code>

  <code class="p">});</code>
</pre></div><div class="book" title="Model"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="model" class="calibre1"></a>Model</h3></div></div></div><p class="calibre6">
        The model for our Todo application remains largely unchanged
        from the versions previously covered in this book. It is however
        worth noting that calling the function
        <code class="literal">model.url()</code> within the below would return the
        relative URL where a specific Todo item could be located on the
        server.
      </p><pre class="programlistingjavascript">  <code class="c">// Our basic **Todo** model has `text`, `order`, and `done` attributes.</code>
  <code class="kd">var</code> <code class="nx">Todo</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Model</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>
    <code class="nx">idAttribute</code><code class="o">:</code> <code class="s">"_id"</code><code class="p">,</code>

    <code class="c">// Default attributes for a todo item.</code>
    <code class="nx">defaults</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="p">{</code>
        <code class="nx">done</code><code class="o">:</code>  <code class="kd">false</code><code class="p">,</code>
        <code class="nx">order</code><code class="o">:</code> <code class="nx">Todos</code><code class="p">.</code><code class="nx">nextOrder</code><code class="p">()</code>
      <code class="p">};</code>
    <code class="p">},</code>

    <code class="c">// Toggle the `done` state of this todo item.</code>
    <code class="nx">toggle</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">save</code><code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="o">!</code><code class="kd">this</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">"done"</code><code class="p">)});</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div><div class="book" title="Ruby/Sinatra"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="rubysinatra" class="calibre1"></a>Ruby/Sinatra</h3></div></div></div><p class="calibre6">
        Now that we’ve defined our main models, views and collections
        let’s get the CRUD operations required by our Backbone
        application supported in our Sinatra API.
      </p><p class="calibre6">
        We want to make sure that for any operations changing underlying
        data (create, update, delete) that our Mongo data store
        correctly reflects these.
      </p></div><div class="book" title="app.rb"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="app.rb" class="calibre1"></a>app.rb</h3></div></div></div><p class="calibre6">
        For <code class="literal">app.rb</code>, we first define the dependencies
        required by our application. These include Sinatra, Ruby Gems,
        the MongoDB Ruby driver and the JSON gem.
      </p><pre class="programlistingjavascript"><code class="nb">require</code> <code class="s">'rubygems'</code>
<code class="nb">require</code> <code class="s">'sinatra'</code>
<code class="nb">require</code> <code class="s">'mongo'</code>
<code class="nb">require</code> <code class="s">'json'</code>
</pre><p class="calibre6">
        Next, we create a new connection to Mongo, specifying any custom
        configuration desired. If running a multi-threaded application,
        setting the <span class="firstname">“<span class="firstname">pool_size</span>”</span> allows us to specify a
        maximum pool size and <span class="firstname">“<span class="firstname">timeout</span>”</span> a maximum timeout
        for waiting for old connections to be released to the pool.
      </p><pre class="programlistingjavascript"><code class="no">DB</code> <code class="o">=</code> <code class="no">Mongo</code><code class="o">::</code><code class="no">Connection</code><code class="o">.</code><code class="nx">new</code><code class="o">.</code><code class="nx">db</code><code class="p">(</code><code class="s">"mydb"</code><code class="p">,</code> <code class="ss">:pool_size</code> <code class="o">=&gt;</code> <code class="mi">5</code><code class="p">,</code> <code class="ss">:timeout</code> <code class="o">=&gt;</code> <code class="mi">5</code><code class="p">)</code>
</pre><p class="calibre6">
        Finally we define the routes to be supported by our API. Note
        that in the first two blocks - one for our application root
        (<code class="literal">/</code>) and the other for our todo items route
        <code class="literal">/todo</code> - we’re using Haml for template
        rendering.
      </p><pre class="programlistingjavascript"><code class="kd">class</code> <code class="nc">TodoApp</code> <code class="o">&lt;</code> <code class="no">Sinatra</code><code class="o">::</code><code class="no">Base</code>

    <code class="nx">get</code> <code class="s">'/'</code> <code class="kd">do</code>
      <code class="nx">haml</code> <code class="ss">:index</code><code class="p">,</code> <code class="ss">:attr_wrapper</code> <code class="o">=&gt;</code> <code class="s">'"'</code><code class="p">,</code> <code class="ss">:locals</code> <code class="o">=&gt;</code> <code class="p">{</code><code class="ss">:title</code> <code class="o">=&gt;</code> <code class="s">'hello'</code><code class="p">}</code>
    <code class="kd">end</code>

    <code class="nx">get</code> <code class="s">'/todo'</code> <code class="kd">do</code>
      <code class="nx">haml</code> <code class="ss">:todo</code><code class="p">,</code> <code class="ss">:attr_wrapper</code> <code class="o">=&gt;</code> <code class="s">'"'</code><code class="p">,</code> <code class="ss">:locals</code> <code class="o">=&gt;</code> <code class="p">{</code><code class="ss">:title</code> <code class="o">=&gt;</code> <code class="s">'Our Sinatra Todo app'</code><code class="p">}</code>
    <code class="kd">end</code>
</pre><p class="calibre6">
        <code class="literal">haml :index</code> instructs Sinatra to use the
        <code class="literal">views/index.haml</code> for the application index,
        whilst `<code class="literal">attr_wrapper</code> is simply defining the
        values to be used for any local variables defined inside the
        template. This similarly applies Todo items with the template
        `views/todo.haml’.
      </p><p class="calibre6">
        The rest of our routes make use of the <code class="literal">params</code>
        hash and a number of useful helper methods included with the
        MongoDB Ruby driver. For more details on these, please read the
        comments I’ve made inline below:
      </p><pre class="programlistingjavascript"><code class="nx">get</code> <code class="s">'/api/:thing'</code> <code class="kd">do</code>
  <code class="c"># query a collection :thing, convert the output to an array, map the _id </code>
  <code class="c"># to a string representation of the object's _id and finally output to JSON</code>
  <code class="no">DB</code><code class="o">.</code><code class="nx">collection</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:thing</code><code class="o">]</code><code class="p">)</code><code class="o">.</code><code class="nx">find</code><code class="o">.</code><code class="nx">to_a</code><code class="o">.</code><code class="nx">map</code><code class="p">{</code><code class="o">|</code><code class="nx">t</code><code class="o">|</code> <code class="nx">from_bson_id</code><code class="p">(</code><code class="nx">t</code><code class="p">)}</code><code class="o">.</code><code class="nx">to_json</code>
<code class="kd">end</code>

<code class="nx">get</code> <code class="s">'/api/:thing/:id'</code> <code class="kd">do</code>
  <code class="c"># get the first document with the id :id in the collection :thing as a single document (rather </code>
  <code class="c"># than a Cursor, the standard output) using find_one(). Our bson utilities assist with</code>
  <code class="c"># ID conversion and the final output returned is also JSON</code>
  <code class="nx">from_bson_id</code><code class="p">(</code><code class="no">DB</code><code class="o">.</code><code class="nx">collection</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:thing</code><code class="o">]</code><code class="p">)</code><code class="o">.</code><code class="nx">find_one</code><code class="p">(</code><code class="nx">to_bson_id</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:id</code><code class="o">]</code><code class="p">)))</code><code class="o">.</code><code class="nx">to_json</code>
<code class="kd">end</code>

<code class="nx">post</code> <code class="s">'/api/:thing'</code> <code class="kd">do</code>
  <code class="c"># parse the post body of the content being posted, convert to a string, insert into</code>
  <code class="c"># the collection #thing and return the ObjectId as a string for reference</code>
  <code class="nx">oid</code> <code class="o">=</code> <code class="no">DB</code><code class="o">.</code><code class="nx">collection</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:thing</code><code class="o">]</code><code class="p">)</code><code class="o">.</code><code class="nx">insert</code><code class="p">(</code><code class="no">JSON</code><code class="o">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">request</code><code class="o">.</code><code class="nx">body</code><code class="o">.</code><code class="nx">read</code><code class="o">.</code><code class="nx">to_s</code><code class="p">))</code>
  <code class="s">"{</code><code class="se">\"</code><code class="s">_id</code><code class="se">\"</code><code class="s">: </code><code class="se">\"</code><code class="err">#{</code><code class="nx">oid</code><code class="o">.</code><code class="nx">to_s</code><code class="err">}</code><code class="se">\"</code><code class="s">}"</code>
<code class="kd">end</code>

<code class="nx">delete</code> <code class="s">'/api/:thing/:id'</code> <code class="kd">do</code>
  <code class="c"># remove the item with id :id from the collection :thing, based on the bson</code>
  <code class="c"># representation of the object id</code>
  <code class="no">DB</code><code class="o">.</code><code class="nx">collection</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:thing</code><code class="o">]</code><code class="p">)</code><code class="o">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'_id'</code> <code class="o">=&gt;</code> <code class="nx">to_bson_id</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:id</code><code class="o">]</code><code class="p">))</code>
<code class="kd">end</code>

<code class="nx">put</code> <code class="s">'/api/:thing/:id'</code> <code class="kd">do</code>
  <code class="c"># collection.update() when used with $set (as covered earlier) allows us to set single values</code>
  <code class="c"># in this case, the put request body is converted to a string, rejecting keys with the name '_id' for security purposes</code>
  <code class="no">DB</code><code class="o">.</code><code class="nx">collection</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:thing</code><code class="o">]</code><code class="p">)</code><code class="o">.</code><code class="nx">update</code><code class="p">({</code><code class="s">'_id'</code> <code class="o">=&gt;</code> <code class="nx">to_bson_id</code><code class="p">(</code><code class="nx">params</code><code class="o">[</code><code class="ss">:id</code><code class="o">]</code><code class="p">)},</code> <code class="p">{</code><code class="s">'$set'</code> <code class="o">=&gt;</code> <code class="no">JSON</code><code class="o">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">request</code><code class="o">.</code><code class="nx">body</code><code class="o">.</code><code class="nx">read</code><code class="o">.</code><code class="nx">to_s</code><code class="p">)</code><code class="o">.</code><code class="nx">reject</code><code class="p">{</code><code class="o">|</code><code class="nx">k</code><code class="p">,</code><code class="nx">v</code><code class="o">|</code> <code class="nx">k</code> <code class="o">==</code> <code class="s">'_id'</code><code class="p">}})</code>
<code class="kd">end</code>

<code class="c"># utilities for generating/converting MongoDB ObjectIds</code>
<code class="kd">def</code> <code class="nf">to_bson_id</code><code class="p">(</code><code class="nb">id</code><code class="p">)</code> <code class="no">BSON</code><code class="o">::</code><code class="no">ObjectId</code><code class="o">.</code><code class="nx">from_string</code><code class="p">(</code><code class="nb">id</code><code class="p">)</code> <code class="kd">end</code>
<code class="kd">def</code> <code class="nf">from_bson_id</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="nx">obj</code><code class="o">.</code><code class="nx">merge</code><code class="p">({</code><code class="s">'_id'</code> <code class="o">=&gt;</code> <code class="nx">obj</code><code class="o">[</code><code class="s">'_id'</code><code class="o">].</code><code class="nx">to_s</code><code class="p">})</code> <code class="kd">end</code>

<code class="kd">end</code>
</pre><p class="calibre6">
        That’s it. The above is extremely lean for an entire API, but
        does allow us to read and write data to support the
        functionality required by our client-side application.
      </p><p class="calibre6">
        For more on what MongoDB and the MongoDB Ruby driver are capable
        of, please do feel free to read their documentation for more
        information.
      </p><p class="calibre6">
        If you’re a developer wishing to take this example further, why
        not try to add some additional capabilities to the service:
      </p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre6">
            Validation: improved validation of data in the API. What
            more could be done to ensure data sanitization?
          </p></li><li class="listitem"><p class="calibre6">
            Search: search or filter down Todo items based on a set of
            keywords or within a certain date range
          </p></li><li class="listitem"><p class="calibre6">
            Pagination: only return the Nth number of Todo items or
            items from a start and end-point
          </p></li></ul></div></div><div class="book" title="Haml/Templates"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="hamltemplates" class="calibre1"></a>Haml/Templates</h3></div></div></div><p class="calibre6">
        Finally, we move on to the Haml files that define our
        application index (layout.haml) and the template for a specific
        Todo item (todo.haml). Both of these are largely
        self-explanatory, but it’s useful to see the differences between
        the Jade approach we reviewed in the last chapter vs. using Haml
        for this implementation.
      </p><p class="calibre6">
        Note: In our Haml snippets below, the forward slash character is
        used to indicate a comment. When this character is placed at the
        beginning of a line, it wraps all of the text after it into a
        HTML comment. e.g
      </p><p class="calibre6">
        <code class="literal">/ These are templates</code>
      </p><p class="calibre6">
        compiles to:
      </p><p class="calibre6">
        <code class="literal">&lt;!-- These are templates --&gt;</code>
      </p></div><div class="book" title="index.haml"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="index.haml" class="calibre1"></a>index.haml</h3></div></div></div><pre class="programlistingjavascript">%head
  %meta{'charset' =&gt; 'utf-8'}/
  %title=title
  %meta{'name' =&gt; 'description', 'content' =&gt; ''}/
  %meta{'name' =&gt; 'author', 'content' =&gt; ''}/
  %meta{'name' =&gt; 'viewport', 'content' =&gt; 'width=device-width,initial-scale=1'}/

  / CSS concatenated and minified via ant build script
  %link{'rel' =&gt; 'stylesheet', 'href' =&gt; 'css/style.css'}/
  / end CSS

  %script{'src' =&gt; 'js/libs/modernizr.min.js'}
%body
  %div#container
    %header
    %div#main
      = yield
    %footer
  /! end of #container

  %script{'src' =&gt; 'http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js'}

  / scripts concatenated and minified via ant build script
  %script{'src' =&gt; 'js/mylibs/underscore.js'}
  %script{'src' =&gt; 'js/mylibs/backbone.js'}
  %script{'defer' =&gt; true, 'src' =&gt; 'js/plugins.js'}
  %script{'defer' =&gt; true, 'src' =&gt; 'js/script.js'}
  / end scripts
</pre></div><div class="book" title="todo.haml"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="todo.haml" class="calibre1"></a>todo.haml</h3></div></div></div><pre class="programlistingjavascript">%div#todoapp
  %div.title
    %h1
      Todos
      %div.content
        %div#create-todo
          %input#new-todo{"placeholder" =&gt; "What needs to be done?", "type" =&gt; "text"}/
          %span.ui-tooltip-top{"style" =&gt; "display:none;"} Press Enter to save this task
        %div#todos
          %ul#todo-list
        %div#todo-stats

/ Templates

%script#item-template{"type" =&gt; "text/template"}
  <code class="nt">&lt;div</code> <code class="na">class=</code><code class="s">"todo &lt;%= done ? 'done' : '' %&gt;"</code><code class="nt">&gt;</code>
  %div.display
    <code class="nt">&lt;input</code> <code class="na">class=</code><code class="s">"check"</code> <code class="na">type=</code><code class="s">"checkbox"</code> <code class="err">&lt;%=</code> <code class="na">done</code> <code class="err">?</code> <code class="err">'</code><code class="na">checked=</code><code class="s">"checked"</code><code class="err">'</code> <code class="na">:</code> <code class="err">''</code> <code class="err">%</code><code class="nt">&gt;</code> /&gt;
    %div.todo-text 
    %span#todo-destroy
  %div.edit
    %input.todo-input{"type" =&gt; "text", "value" =&gt;""}/
  <code class="nt">&lt;/div&gt;</code>

%script#stats-template{"type" =&gt; "text/template"}
  <code class="err">&lt;</code>% if (total) { %&gt;
  %span.todo-count
    %span.number <code class="err">&lt;</code>%= remaining %&gt;
    %span.word <code class="err">&lt;</code>%= remaining == 1 ? 'item' : 'items' %&gt;
    left.
  <code class="err">&lt;</code>% } %&gt;
  <code class="err">&lt;</code>% if (done) { %&gt;
  %span.todo-clear
    %a{"href" =&gt; "#"}
      Clear
      %span.number-done <code class="err">&lt;</code>%= done %&gt;
      completed
      %span.word-done <code class="err">&lt;</code>%= done == 1 ? 'item' : 'items' %&gt;
  <code class="err">&lt;</code>% } %&gt;
</pre></div></div><div class="book" title="Conclusions"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="conclusions" class="calibre1"></a>Conclusions</h2></div></div></div><p class="calibre6">
      In this chapter, we looked at creating a Backbone application
      backed by an API powered by Ruby, Sinatra, Haml, MongoDB and the
      MongoDB driver. I personally found developing APIs with Sinatra a
      relatively painless experience and one which I felt was on-par
      with the effort required for the Node/Express implementation of
      the same application.
    </p><p class="calibre6">
      This section is by no means the most comprehensive guide on
      building complex apps using all of the items in this particular
      stack. I do however hope it was an introduction sufficient enough
      to help you decide on what stack to try out for your next project.
    </p></div></div></div>

{% endraw %}

