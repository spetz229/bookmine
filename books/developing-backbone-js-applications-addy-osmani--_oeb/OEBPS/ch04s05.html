---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch04s04.html
next: OEBPS/ch04s06.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Practical: Building a modular Backbone app with AMD &amp; RequireJS"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="practical-building-a-modular-backbone-app-with-amd-requirejs" class="calibre1"></a>Practical: Building a modular
    Backbone app with AMD &amp; RequireJS</h1></div></div></div><p class="calibre6">
      In this chapter, we’ll look at our first practical Backbone &amp;
      RequireJS project - how to build a modular Todo application. The
      application will allow us to add new todos, edit new todos and
      clear todo items that have been marked as completed. For a more
      advanced practical, see the section on mobile Backbone
      development.
    </p><p class="calibre6">
      The complete code for the application can can be found in the
      <code class="literal">practicals/modular-todo-app</code> folder of this repo
      (thanks to Thomas Davis and Jérôme Gravel-Niquet). Alternatively
      grab a copy of my side-project
      <a class="ulink" href="https://github.com/addyosmani/todomvc">TodoMVC</a>
      which contains the sources to both AMD and non-AMD versions.
    </p><p class="calibre6">
      <span class="firstname"><strong class="calibre8">Note:</strong></span> Thomas may be covering a
      practical on this exercise in more detail on
      <a class="ulink" href="http://backbonetutorials.com">backbonetutorials.com</a>
      at some point soon, but for this section I’ll be covering what I
      consider the core concepts.
    </p><div class="book" title="Overview"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="overview" class="calibre1"></a>Overview</h2></div></div></div><p class="calibre6">
        Writing a <span class="firstname">“<span class="firstname">modular</span>”</span> Backbone application can be a
        straight-forward process. There are however, some key conceptual
        differences to be aware of if opting to use AMD as your module
        format of choice:
      </p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre6">
            As AMD isn’t a standard native to JavaScript or the browser,
            it’s necessary to use a script loader (such as RequireJS or
            curl.js) in order to support defining components and modules
            using this module format. As we’ve already reviewed, there
            are a number of advantages to using the AMD as well as
            RequireJS to assist here.
          </p></li><li class="listitem"><p class="calibre6">
            Models, views, controllers and routers need to be
            encapsulated <span class="firstname"><em class="calibre9">using</em></span> the AMD-format. This
            allows each component of our Backbone application to cleanly
            manage dependencies (e.g collections required by a view) in
            the same way that AMD allows non-Backbone modules to.
          </p></li><li class="listitem"><p class="calibre6">
            Non-Backbone components/modules (such as utilities or
            application helpers) can also be encapsulated using AMD. I
            encourage you to try developing these modules in such a way
            that they can both be used and tested independent of your
            Backbone code as this will increase their ability to be
            re-used elsewhere.
          </p></li></ul></div><p class="calibre6">
        Now that we’ve reviewed the basics, let’s take a look at
        developing our application. For reference, the structure of our
        app is as follows:
      </p><pre class="programlistingjavascript">
index.html
...js/
    main.js
    .../models
            todo.js
    .../views
            app.js
            todos.js
    .../collections
            todos.js
    .../templates
            stats.html
            todos.html
    ../libs
        .../backbone
        .../jquery
        .../underscore
        .../require
                require.js
                text.js
...css/
</pre></div><div class="book" title="Markup"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="markup" class="calibre1"></a>Markup</h2></div></div></div><p class="calibre6">
        The markup for the application is relatively simple and consists
        of three primary parts: an input section for entering new todo
        items (<code class="literal">create-todo</code>), a list section to
        display existing items (which can also be edited in-place)
        (<code class="literal">todo-list</code>) and finally a section summarizing
        how many items are left to be completed
        (<code class="literal">todo-stats</code>).
      </p><pre class="programlistingjavascript">
&lt;div id="todoapp"&gt;

      &lt;div class="content"&gt;

        &lt;div id="create-todo"&gt;
          &lt;input id="new-todo" placeholder="What needs to be done?" type="text" /&gt;
          &lt;span class="ui-tooltip-top"&gt;Press Enter to save this task&lt;/span&gt;
        &lt;/div&gt;

        &lt;div id="todos"&gt;
          &lt;ul id="todo-list"&gt;&lt;/ul&gt;
        &lt;/div&gt;

        &lt;div id="todo-stats"&gt;&lt;/div&gt;

      &lt;/div&gt;

&lt;/div&gt;
</pre><p class="calibre6">
        The rest of the tutorial will now focus on the JavaScript side
        of the practical.
      </p></div><div class="book" title="Configuration options"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="configuration-options" class="calibre1"></a>Configuration options</h2></div></div></div><p class="calibre6">
        If you’ve read the earlier chapter on AMD, you may have noticed
        that explicitly needing to define each dependency a Backbone
        module (view, collection or other module) may require with it
        can get a little tedious. This can however be improved.
      </p><p class="calibre6">
        In order to simplify referencing common paths the modules in our
        application may use, we use a RequireJS
        <a class="ulink" href="http://requirejs.org/docs/api.html#config">configuration
        object</a>, which is typically defined as a top-level script
        file. Configuration objects have a number of useful
        capabilities, the most useful being mode name-mapping. Name-maps
        are basically a key:value pair, where the key defines the alias
        you wish to use for a path and the value represents the true
        location of the path.
      </p><p class="calibre6">
        In the code-sample below, you can see some typical examples of
        common name-maps which include: <code class="literal">backbone</code>,
        <code class="literal">underscore</code>, <code class="literal">jquery</code> and
        depending on your choice, the RequireJS <code class="literal">text</code>
        plugin, which assists with loading text assets like templates.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">main.js</strong></span>
      </p><pre class="programlistingjavascript"><code class="nx">require</code><code class="p">.</code><code class="nx">config</code><code class="p">({</code>
  <code class="nx">baseUrl</code><code class="o">:</code><code class="s">'../'</code><code class="p">,</code>
  <code class="nx">paths</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">jquery</code><code class="o">:</code> <code class="s">'libs/jquery/jquery-min'</code><code class="p">,</code>
    <code class="nx">underscore</code><code class="o">:</code> <code class="s">'libs/underscore/underscore-min'</code><code class="p">,</code>
    <code class="nx">backbone</code><code class="o">:</code> <code class="s">'libs/backbone/backbone-optamd3-min'</code><code class="p">,</code>
    <code class="nx">text</code><code class="o">:</code> <code class="s">'libs/require/text'</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="nx">require</code><code class="p">([</code><code class="s">'views/app'</code><code class="p">],</code> <code class="kd">function</code><code class="p">(</code><code class="nx">AppView</code><code class="p">){</code>
  <code class="kd">var</code> <code class="nx">app_view</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">AppView</code><code class="p">;</code>
<code class="p">});</code>
</pre><p class="calibre6">
        The <code class="literal">require()</code> at the end of our main.js file
        is simply there so we can load and instantiation the primary
        view for our application (<code class="literal">views/app.js</code>).
        You’ll commonly see both this and the configuration object
        included the most top-level script file for a project.
      </p><p class="calibre6">
        In addition to offering name-mapping, the configuration object
        can be used to define additional properties such as
        <code class="literal">waitSeconds</code> - the number of seconds to wait
        before script loading times out and <code class="literal">locale</code>,
        should you wish to load up i18n bundles for custom languages.
        The <code class="literal">baseUrl</code> is simply the path to use for
        module lookups.
      </p><p class="calibre6">
        For more information on configuration objects, please feel free
        to check out the excellent guide to them in the
        <a class="ulink" href="http://requirejs.org/docs/api.html#config">RequireJS
        docs</a>.
      </p></div><div class="book" title="Modularizing our models, views and collections"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="modularizing-our-models-views-and-collections" class="calibre1"></a>Modularizing our models, views and collections</h2></div></div></div><p class="calibre6">
        Before we dive into AMD-wrapped versions of our Backbone
        components, let’s review a sample of a non-AMD view. The
        following view listens for changes to its model (a Todo item)
        and re-renders if a user edits the value of the item.
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">TodoView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">//... is a list tag.</code>
    <code class="nx">tagName</code><code class="o">:</code>  <code class="s">"li"</code><code class="p">,</code>

    <code class="c">// Cache the template function for a single item.</code>
    <code class="nx">template</code><code class="o">:</code> <code class="nx">_</code><code class="p">.</code><code class="nx">template</code><code class="p">(</code><code class="nx">$</code><code class="p">(</code><code class="s">'#item-template'</code><code class="p">).</code><code class="nx">html</code><code class="p">()),</code>

    <code class="c">// The DOM events specific to an item.</code>
    <code class="nx">events</code><code class="o">:</code> <code class="p">{</code>
      <code class="s">"click .check"</code>              <code class="o">:</code> <code class="s">"toggleDone"</code><code class="p">,</code>
      <code class="s">"dblclick div.todo-content"</code> <code class="o">:</code> <code class="s">"edit"</code><code class="p">,</code>
      <code class="s">"click span.todo-destroy"</code>   <code class="o">:</code> <code class="s">"clear"</code><code class="p">,</code>
      <code class="s">"keypress .todo-input"</code>      <code class="o">:</code> <code class="s">"updateOnEnter"</code>
    <code class="p">},</code>

    <code class="c">// The TodoView listens for changes to its model, re-rendering. Since there's</code>
    <code class="c">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</code>
    <code class="c">// app, we set a direct reference on the model for convenience.</code>
    <code class="nx">initialize</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>      
      <code class="kd">this</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'change'</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">render</code><code class="p">,</code> <code class="kd">this</code><code class="p">);</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">view</code> <code class="o">=</code> <code class="kd">this</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="p">...</code>
</pre><p class="calibre6">
        Note how for templating the common practice of referencing a
        script by an ID (or other selector) and obtaining its value is
        used. This of course requires that the template being accessed
        is implicitly defined in our markup. The following is the
        <span class="firstname">“<span class="firstname">embedded</span>”</span> version of our template being referenced
        above:
      </p><pre class="programlistingjavascript">
&lt;script type="text/template" id="item-template"&gt;
      &lt;div class="todo &lt;%= done ? 'done' : '' %&gt;"&gt;
        &lt;div class="display"&gt;
          &lt;input class="check" type="checkbox" &lt;%= done ? 'checked="checked"' : '' %&gt; /&gt;
          &lt;div class="todo-content"&gt;&lt;/div&gt;
          &lt;span class="todo-destroy"&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="edit"&gt;
          &lt;input class="todo-input" type="text" value="" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
&lt;/script&gt;
</pre><p class="calibre6">
        Whilst there is nothing wrong with the template itself, once we
        begin to develop larger applications requiring multiple
        templates, including them all in our markup on page-load can
        quickly become both unmanageable and come with performance
        costs. We’ll look at solving this problem in a minute.
      </p><p class="calibre6">
        Let’s now take a look at the AMD-version of our view. As
        discussed earlier, the <span class="firstname">“<span class="firstname">module</span>”</span> is wrapped using
        AMD’s <code class="literal">define()</code> which allows us to specify the
        dependencies our view requires. Using the mapped paths to
        <span class="firstname">“<span class="firstname">jquery</span>”</span> etc. simplifies referencing common
        dependencies and instances of dependencies are themselves mapped
        to local variables that we can access (e.g <span class="firstname">“<span class="firstname">jquery</span>”</span>
        is mapped to <code class="literal">$</code>).
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">views/todos.js</strong></span>
      </p><pre class="programlistingjavascript"><code class="nx">define</code><code class="p">([</code>
  <code class="s">'jquery'</code><code class="p">,</code> 
  <code class="s">'underscore'</code><code class="p">,</code> 
  <code class="s">'backbone'</code><code class="p">,</code>
  <code class="s">'text!templates/todos.html'</code>
  <code class="p">],</code> <code class="kd">function</code><code class="p">(</code><code class="nx">$</code><code class="p">,</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">Backbone</code><code class="p">,</code> <code class="nx">todosTemplate</code><code class="p">){</code>
  <code class="kd">var</code> <code class="nx">TodoView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">//... is a list tag.</code>
    <code class="nx">tagName</code><code class="o">:</code>  <code class="s">"li"</code><code class="p">,</code>

    <code class="c">// Cache the template function for a single item.</code>
    <code class="nx">template</code><code class="o">:</code> <code class="nx">_</code><code class="p">.</code><code class="nx">template</code><code class="p">(</code><code class="nx">todosTemplate</code><code class="p">),</code>

    <code class="c">// The DOM events specific to an item.</code>
    <code class="nx">events</code><code class="o">:</code> <code class="p">{</code>
      <code class="s">"click .check"</code>              <code class="o">:</code> <code class="s">"toggleDone"</code><code class="p">,</code>
      <code class="s">"dblclick div.todo-content"</code> <code class="o">:</code> <code class="s">"edit"</code><code class="p">,</code>
      <code class="s">"click span.todo-destroy"</code>   <code class="o">:</code> <code class="s">"clear"</code><code class="p">,</code>
      <code class="s">"keypress .todo-input"</code>      <code class="o">:</code> <code class="s">"updateOnEnter"</code>
    <code class="p">},</code>

    <code class="c">// The TodoView listens for changes to its model, re-rendering. Since there's</code>
    <code class="c">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</code>
    <code class="c">// app, we set a direct reference on the model for convenience.</code>
    <code class="nx">initialize</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>      
      <code class="kd">this</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'change'</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">render</code><code class="p">,</code> <code class="kd">this</code><code class="p">);</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">view</code> <code class="o">=</code> <code class="kd">this</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="c">// Re-render the contents of the todo item.</code>
    <code class="nx">render</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">$el</code><code class="p">.</code><code class="nx">html</code><code class="p">(</code><code class="kd">this</code><code class="p">.</code><code class="nx">template</code><code class="p">(</code><code class="kd">this</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">toJSON</code><code class="p">()));</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">setContent</code><code class="p">();</code>
      <code class="kd">return</code> <code class="kd">this</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="c">// Use `jQuery.text` to set the contents of the todo item.</code>
    <code class="nx">setContent</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">var</code> <code class="nx">content</code> <code class="o">=</code> <code class="kd">this</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'content'</code><code class="p">);</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">$</code><code class="p">(</code><code class="s">'.todo-content'</code><code class="p">).</code><code class="nx">text</code><code class="p">(</code><code class="nx">content</code><code class="p">);</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">input</code> <code class="o">=</code> <code class="kd">this</code><code class="p">.</code><code class="nx">$</code><code class="p">(</code><code class="s">'.todo-input'</code><code class="p">);</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'blur'</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">close</code><code class="p">);</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">input</code><code class="p">.</code><code class="nx">val</code><code class="p">(</code><code class="nx">content</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="p">...</code>
</pre><p class="calibre6">
        From a maintenance perspective, there’s nothing logically
        different in this version of our view, except for how we
        approach templating.
      </p><p class="calibre6">
        Using the RequireJS text plugin (the dependency marked
        <code class="literal">text</code>), we can actually store all of the
        contents for the template we looked at earlier in an external
        file (todos.html).
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">templates/todos.html</strong></span>
      </p><pre class="programlistingjavascript"><code class="nt">&lt;div</code> <code class="na">class=</code><code class="s">"todo &lt;%= done ? 'done' : '' %&gt;"</code><code class="nt">&gt;</code>
    <code class="nt">&lt;div</code> <code class="na">class=</code><code class="s">"display"</code><code class="nt">&gt;</code>
      <code class="nt">&lt;input</code> <code class="na">class=</code><code class="s">"check"</code> <code class="na">type=</code><code class="s">"checkbox"</code> <code class="err">&lt;%=</code> <code class="na">done</code> <code class="err">?</code> <code class="err">'</code><code class="na">checked=</code><code class="s">"checked"</code><code class="err">'</code> <code class="na">:</code> <code class="err">''</code> <code class="err">%</code><code class="nt">&gt;</code> /&gt;
      <code class="nt">&lt;div</code> <code class="na">class=</code><code class="s">"todo-content"</code><code class="nt">&gt;&lt;/div&gt;</code>
      <code class="nt">&lt;span</code> <code class="na">class=</code><code class="s">"todo-destroy"</code><code class="nt">&gt;&lt;/span&gt;</code>
    <code class="nt">&lt;/div&gt;</code>
    <code class="nt">&lt;div</code> <code class="na">class=</code><code class="s">"edit"</code><code class="nt">&gt;</code>
      <code class="nt">&lt;input</code> <code class="na">class=</code><code class="s">"todo-input"</code> <code class="na">type=</code><code class="s">"text"</code> <code class="na">value=</code><code class="s">""</code> <code class="nt">/&gt;</code>
    <code class="nt">&lt;/div&gt;</code>
<code class="nt">&lt;/div&gt;</code>
</pre><p class="calibre6">
        There’s no longer a need to be concerned with IDs for the
        template as we can map it’s contents to a local variable (in
        this case <code class="literal">todosTemplate</code>). We then simply pass
        this to the Underscore.js templating function
        <code class="literal">_.template()</code> the same way we normally would
        have the value of our template script.
      </p><p class="calibre6">
        Next, let’s look at how to define models as dependencies which
        can be pulled into collections. Here’s an AMD-compatible model
        module, which has two default values: a
        <code class="literal">content</code> attribute for the content of a Todo
        item and a boolean <code class="literal">done</code> state, allowing us to
        trigger whether the item has been completed or not.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">models/todo.js</strong></span>
      </p><pre class="programlistingjavascript"><code class="nx">define</code><code class="p">([</code><code class="s">'underscore'</code><code class="p">,</code> <code class="s">'backbone'</code><code class="p">],</code> <code class="kd">function</code><code class="p">(</code><code class="nx">_</code><code class="p">,</code> <code class="nx">Backbone</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="nx">TodoModel</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Model</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">// Default attributes for the todo.</code>
    <code class="nx">defaults</code><code class="o">:</code> <code class="p">{</code>
      <code class="c">// Ensure that each todo created has `content`.</code>
      <code class="nx">content</code><code class="o">:</code> <code class="s">"empty todo..."</code><code class="p">,</code>
      <code class="nx">done</code><code class="o">:</code> <code class="kd">false</code>
    <code class="p">},</code>

    <code class="nx">initialize</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="p">},</code>

    <code class="c">// Toggle the `done` state of this todo item.</code>
    <code class="nx">toggle</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">save</code><code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="o">!</code><code class="kd">this</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">"done"</code><code class="p">)});</code>
    <code class="p">},</code>

    <code class="c">// Remove this Todo from *localStorage* and delete its view.</code>
    <code class="nx">clear</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">destroy</code><code class="p">();</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">view</code><code class="p">.</code><code class="nx">remove</code><code class="p">();</code>
    <code class="p">}</code>

  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">TodoModel</code><code class="p">;</code>
<code class="p">});</code>
</pre><p class="calibre6">
        As per other types of dependencies, we can easily map our model
        module to a local variable (in this case
        <code class="literal">Todo</code>) so it can be referenced as the model to
        use for our <code class="literal">TodosCollection</code>. This collection
        also supports a simple <code class="literal">done()</code> filter for
        narrowing down Todo items that have been completed and a
        <code class="literal">remaining()</code> filter for those that are still
        outstanding.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">collections/todos.js</strong></span>
      </p><pre class="programlistingjavascript"><code class="nx">define</code><code class="p">([</code>
  <code class="s">'underscore'</code><code class="p">,</code> 
  <code class="s">'backbone'</code><code class="p">,</code> 
  <code class="s">'libs/backbone/localstorage'</code><code class="p">,</code> 
  <code class="s">'models/todo'</code>
  <code class="p">],</code> <code class="kd">function</code><code class="p">(</code><code class="nx">_</code><code class="p">,</code> <code class="nx">Backbone</code><code class="p">,</code> <code class="nx">Store</code><code class="p">,</code> <code class="nx">Todo</code><code class="p">){</code>

    <code class="kd">var</code> <code class="nx">TodosCollection</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Collection</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">// Reference to this collection's model.</code>
    <code class="nx">model</code><code class="o">:</code> <code class="nx">Todo</code><code class="p">,</code>

    <code class="c">// Save all of the todo items under the `"todos"` namespace.</code>
    <code class="nx">localStorage</code><code class="o">:</code> <code class="kd">new</code> <code class="nx">Store</code><code class="p">(</code><code class="s">"todos"</code><code class="p">),</code>

    <code class="c">// Filter down the list of all todo items that are finished.</code>
    <code class="nx">done</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">todo</code><code class="p">){</code> <code class="kd">return</code> <code class="nx">todo</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'done'</code><code class="p">);</code> <code class="p">});</code>
    <code class="p">},</code>

    <code class="c">// Filter down the list to only todo items that are still not finished.</code>
    <code class="nx">remaining</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">without</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">done</code><code class="p">());</code>
    <code class="p">},</code>
    <code class="p">...</code>
</pre><p class="calibre6">
        In addition to allowing users to add new Todo items from views
        (which we then insert as models in a collection), we ideally
        also want to be able to display how many items have been
        completed and how many are remaining. We’ve already defined
        filters that can provide us this information in the above
        collection, so let’s use them in our main application view.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">views/app.js</strong></span>
      </p><pre class="programlistingjavascript"><code class="nx">define</code><code class="p">([</code>
  <code class="s">'jquery'</code><code class="p">,</code>
  <code class="s">'underscore'</code><code class="p">,</code> 
  <code class="s">'backbone'</code><code class="p">,</code>
  <code class="s">'collections/todos'</code><code class="p">,</code>
  <code class="s">'views/todos'</code><code class="p">,</code>
  <code class="s">'text!templates/stats.html'</code>
  <code class="p">],</code> <code class="kd">function</code><code class="p">(</code><code class="nx">$</code><code class="p">,</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">Backbone</code><code class="p">,</code> <code class="nx">Todos</code><code class="p">,</code> <code class="nx">TodoView</code><code class="p">,</code> <code class="nx">statsTemplate</code><code class="p">){</code>

  <code class="kd">var</code> <code class="nx">AppView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code>

    <code class="c">// Instead of generating a new element, bind to the existing skeleton of</code>
    <code class="c">// the App already present in the HTML.</code>
    <code class="nx">el</code><code class="o">:</code> <code class="nx">$</code><code class="p">(</code><code class="s">"#todoapp"</code><code class="p">),</code>

    <code class="c">// Our template for the line of statistics at the bottom of the app.</code>
    <code class="nx">statsTemplate</code><code class="o">:</code> <code class="nx">_</code><code class="p">.</code><code class="nx">template</code><code class="p">(</code><code class="nx">statsTemplate</code><code class="p">),</code>

    <code class="c">// ...events, initialize() etc. can be seen in the complete file</code>

    <code class="c">// Re-rendering the App just means refreshing the statistics -- the rest</code>
    <code class="c">// of the app doesn't change.</code>
    <code class="nx">render</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
      <code class="kd">var</code> <code class="nx">done</code> <code class="o">=</code> <code class="nx">Todos</code><code class="p">.</code><code class="nx">done</code><code class="p">().</code><code class="nx">length</code><code class="p">;</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">$</code><code class="p">(</code><code class="s">'#todo-stats'</code><code class="p">).</code><code class="nx">html</code><code class="p">(</code><code class="kd">this</code><code class="p">.</code><code class="nx">statsTemplate</code><code class="p">({</code>
        <code class="nx">total</code><code class="o">:</code>      <code class="nx">Todos</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code>
        <code class="nx">done</code><code class="o">:</code>       <code class="nx">Todos</code><code class="p">.</code><code class="nx">done</code><code class="p">().</code><code class="nx">length</code><code class="p">,</code>
        <code class="nx">remaining</code><code class="o">:</code>  <code class="nx">Todos</code><code class="p">.</code><code class="nx">remaining</code><code class="p">().</code><code class="nx">length</code>
      <code class="p">}));</code>
    <code class="p">},</code>
    <code class="p">...</code>
</pre><p class="calibre6">
        Above, we map the second template for this project,
        <code class="literal">templates/stats.html</code> to
        <code class="literal">statsTemplate</code> which is used for rendering the
        overall <code class="literal">done</code> and <code class="literal">remaining</code>
        states. This works by simply passing our template the length of
        our overall Todos collection (<code class="literal">Todos.length</code> -
        the number of Todo items created so far) and similarly the
        length (counts) for items that have been completed
        (<code class="literal">Todos.done().length</code>) or are remaining
        (<code class="literal">Todos.remaining().length</code>).
      </p><p class="calibre6">
        The contents of our <code class="literal">statsTemplate</code> can be seen
        below. It’s nothing too complicated, but does use ternary
        conditions to evaluate whether we should state there’s <span class="firstname">“<span class="firstname">1
        item</span>”</span> or <span class="firstname">“<span class="firstname">2 item<span class="firstname"><em class="calibre9">s</em></span></span>”</span> in a particular
        state.
      </p><pre class="programlistingjavascript">
&lt;% if (total) { %&gt;
        &lt;span class="todo-count"&gt;
          &lt;span class="number"&gt;&lt;%= remaining %&gt;&lt;/span&gt;
          &lt;span class="word"&gt;&lt;%= remaining == 1 ? 'item' : 'items' %&gt;&lt;/span&gt; left.
        &lt;/span&gt;
      &lt;% } %&gt;
      &lt;% if (done) { %&gt;
        &lt;span class="todo-clear"&gt;
          &lt;a href="#"&gt;
            Clear &lt;span class="number-done"&gt;&lt;%= done %&gt;&lt;/span&gt;
            completed &lt;span class="word-done"&gt;&lt;%= done == 1 ? 'item' : 'items' %&gt;&lt;/span&gt;
          &lt;/a&gt;
        &lt;/span&gt;
      &lt;% } %&gt;
</pre><p class="calibre6">
        The rest of the source for the Todo app mainly consists of code
        for handling user and application events, but that rounds up
        most of the core concepts for this practical.
      </p><p class="calibre6">
        To see how everything ties together, feel free to grab the
        source by cloning this repo or browse it
        <a class="ulink" href="https://github.com/addyosmani/backbone-fundamentals/tree/master/practicals/modular-todo-app">online</a>
        to learn more. I hope you find it helpful!.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Note:</strong></span> While this first
        practical doesn’t use a build profile as outlined in the chapter
        on using the RequireJS optimizer, we will be using one in the
        section on building mobile Backbone applications.
      </p></div></div></div>

{% endraw %}

