---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch04s13.html
next: OEBPS/ch05.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Backbone &amp; jQuery Mobile"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="backbone-jquery-mobile" class="calibre1"></a>Backbone &amp; jQuery Mobile</h1></div></div></div><div class="book" title="Resolving the routing conflicts"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="resolving-the-routing-conflicts" class="calibre1"></a>Resolving the routing conflicts</h2></div></div></div><p class="calibre6">
        The first major hurdle developers typically run into when
        building Backbone applications with jQuery Mobile is that both
        frameworks have their own opinions about how to handle
        application navigation.
      </p><p class="calibre6">
        Backbone’s routers offer an explicit way to define custom
        navigation routes through <code class="literal">Backbone.Router</code>,
        whilst jQuery Mobile encourages the use of URL hash fragments to
        reference separate <span class="firstname">“<span class="firstname">pages</span>”</span> or views in the same
        document. jQuery Mobile also supports automatically pulling in
        external content for links through XHR calls meaning that there
        can be quite a lot of inter-framework confusion about what a
        link pointing at <span class="firstname">“<span class="firstname">#photo/id</span>”</span> should actually be
        doing.
      </p><p class="calibre6">
        Some of the solutions that have been previously proposed to
        work-around this problem included manually patching Backbone or
        jQuery Mobile. I discourage opting for these techniques as it
        becomes necessary to manually patch your framework builds when
        new releases get made upstream.
      </p><p class="calibre6">
        There’s also
        <a class="ulink" href="https://github.com/azicchetti/jquerymobile-router">jQueryMobile
        router</a>, which tries to solve this problem differently,
        however I think my proposed solution is both simpler and allows
        both frameworks to cohabit quite peacefully without the need to
        extend either. What we’re after is a way to prevent one
        framework from listening to hash changes so that we can fully
        rely on the other (e.g. <code class="literal">Backbone.Router</code>) to
        handle this for us exclusively.
      </p><p class="calibre6">
        Using jQuery Mobile this can be done by setting:
      </p><pre class="programlistingjavascript"><code class="nx">$</code><code class="p">.</code><code class="nx">mobile</code><code class="p">.</code><code class="nx">hashListeningEnabled</code> <code class="o">=</code> <code class="kd">false</code><code class="p">;</code>
</pre><p class="calibre6">
        prior to initializing any of your other code.
      </p><p class="calibre6">
        I discovered this method looking through some jQuery Mobile
        commits that didn’t make their way into the official docs, but
        am happy to see that they are now covered here
        http://jquerymobile.com/test/docs/api/globalconfig.html in more
        detail.
      </p><p class="calibre6">
        The next question that arises is, if we’re preventing jQuery
        Mobile from listening to URL hash changes, how can we still get
        the benefit of being able to navigate to other sections in a
        document using the built-in transitions and effects supported?
        Good question. This can now be solve by simply calling
        <code class="literal">$.mobile.changePage()</code> as follows:
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">url</code> <code class="o">=</code> <code class="s">'#about'</code><code class="p">,</code>
    <code class="nx">effect</code> <code class="o">=</code> <code class="s">'slideup'</code><code class="p">,</code>
    <code class="nx">reverse</code> <code class="o">=</code> <code class="kd">false</code><code class="p">,</code>
    <code class="nx">changeHash</code> <code class="o">=</code> <code class="kd">false</code><code class="p">;</code>

<code class="nx">$</code><code class="p">.</code><code class="nx">mobile</code><code class="p">.</code><code class="nx">changePage</code><code class="p">(</code> <code class="nx">url</code> <code class="p">,</code> <code class="p">{</code> <code class="nx">transition</code><code class="o">:</code> <code class="nx">effect</code><code class="p">},</code> <code class="nx">reverse</code><code class="p">,</code> <code class="nx">changeHash</code> <code class="p">);</code>
</pre><p class="calibre6">
        In the above sample, <code class="literal">url</code> can refer to a URL
        or a hash identifier to navigate to, <code class="literal">effect</code>
        is simply the transition effect to animate the page in with and
        the final two parameters decide the direction for the transition
        (<code class="literal">reverse</code>) and whether or not the hash in the
        address bar should be updated (<code class="literal">changeHash</code>).
        With respect to the latter, I typically set this to false to
        avoid managing two sources for hash updates, but feel free to
        set this to true if you’re comfortable doing so.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Note:</strong></span> For some parallel work
        being done to explore how well the jQuery Mobile Router plugin
        works with Backbone, you may be interested in checking out
        https://github.com/Filirom1/jquery-mobile-backbone-requirejs.
      </p></div><div class="book" title="Practical: A Backbone, RequireJS/AMD app with jQuery Mobile"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="practical-a-backbone-requirejsamd-app-with-jquery-mobile" class="calibre1"></a>Practical: A Backbone, RequireJS/AMD app with jQuery
      Mobile</h2></div></div></div><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Note:</strong></span> The code for this
        practical can be found in
        <code class="literal">practicals/modular-mobile-app</code>.
      </p></div><div class="book" title="Getting started"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="getting-started-1" class="calibre1"></a>Getting started</h2></div></div></div><p class="calibre6">
        Once you feel comfortable with the
        <a class="ulink" href="http://msdn.microsoft.com/en-us/scriptjunkie/hh377172.aspx">Backbone
        fundamentals</a> and you’ve put together a rough wireframe
        of the app you may wish to build, start to think about your
        application architecture. Ideally, you’ll want to logically
        separate concerns so that it’s as easy as possible to maintain
        the app in the future.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Namespacing</strong></span>
      </p><p class="calibre6">
        For this application, I opted for the nested namespacing
        pattern. Implemented correctly, this enables you to clearly
        identify if items being referenced in your app are views, other
        modules and so on. This initial structure is a sane place to
        also include application defaults (unless you prefer maintaining
        those in a separate file).
      </p><pre class="programlistingjavascript"><code class="nb">window</code><code class="p">.</code><code class="nx">mobileSearch</code> <code class="o">=</code> <code class="nb">window</code><code class="p">.</code><code class="nx">mobileSearch</code> <code class="o">||</code> <code class="p">{</code>
    <code class="nx">views</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">appview</code><code class="o">:</code> <code class="kd">new</code> <code class="nx">AppView</code>
    <code class="p">},</code>
    <code class="nx">routers</code><code class="o">:</code><code class="p">{</code>
        <code class="nx">workspace</code><code class="o">:</code><code class="kd">new</code> <code class="nx">Workspace</code><code class="p">()</code>
    <code class="p">},</code>
    <code class="nx">utils</code><code class="o">:</code> <code class="nx">utils</code><code class="p">,</code>
    <code class="nx">defaults</code><code class="o">:</code><code class="p">{</code>
        <code class="nx">resultsPerPage</code><code class="o">:</code> <code class="mi">16</code><code class="p">,</code>
        <code class="nx">safeSearch</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
        <code class="nx">maxDate</code><code class="o">:</code><code class="s">''</code><code class="p">,</code>
        <code class="nx">minDate</code><code class="o">:</code><code class="s">'01/01/1970'</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Models</strong></span>
      </p><p class="calibre6">
        In the Flickly application, there are at least two unique types
        of data that need to be modeled - search results and individual
        photos, both of which contain additional meta-data like photo
        titles. If you simplify this down, search results are actually
        groups of photos in their own right, so the application only
        requires:
      </p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre6">
            A single model (a photo or <span class="firstname">“<span class="firstname">result</span>”</span> entry)
          </p></li><li class="listitem"><p class="calibre6">
            A result collection (containing a group of result entries)
            for search results
          </p></li><li class="listitem"><p class="calibre6">
            A photo collection (containing one or more result entries)
            for individual photos or photos with more than one image
          </p></li></ul></div><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Views</strong></span>
      </p><p class="calibre6">
        The views we’ll need include an application view, a search
        results view and a photo view. Static views or pages of the
        single-page application which do not require a dynamic element
        to them (e.g an <span class="firstname">“<span class="firstname">about</span>”</span> page) can be easily coded
        up in your document’s markup, independent of Backbone.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Routers</strong></span>
      </p><p class="calibre6">
        A number of possible routes need to be taken into consideration:
      </p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre6">
            Basic search queries <code class="literal">#search/kiwis</code>
          </p></li><li class="listitem"><p class="calibre6">
            Search queries with additional parameters (e.g sort,
            pagination) <code class="literal">#search/kiwis/srelevance/p7</code>
          </p></li><li class="listitem"><p class="calibre6">
            Queries for specific photos <code class="literal">#photo/93839</code>
          </p></li><li class="listitem"><p class="calibre6">
            A default route (no parameters passed)
          </p></li></ul></div><p class="calibre6">
        This tutorial will be expanded shortly to fully cover the demo
        application. In the mean time, please see the practicals folder
        for the completed application that demonstrates the router
        resolution discussed earlier between Backbone and jQuery Mobile.
      </p></div><div class="book" title="jQuery Mobile: Going beyond mobile application development"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="jquery-mobile-going-beyond-mobile-application-development" class="calibre1"></a>jQuery Mobile: Going beyond mobile application
      development</h2></div></div></div><p class="calibre6">
        The majority of jQM apps I’ve seen in production have been
        developed for the purpose of providing an optimal experience to
        users on mobile devices. Given that the framework was developed
        for this purpose, there’s nothing fundamentally wrong with this,
        but many developers forget that jQM is a UI framework not
        dissimilar to jQuery UI. It’s using the widget factory and is
        capable of being used for a lot more than we give it credit for.
      </p><p class="calibre6">
        If you open up Flickly in a desktop browser, you’ll get an image
        search UI that’s modeled on Google.com, however, review the
        components (buttons, text inputs, tabs) on the page for a
        moment. The desktop UI doesn’t look anything like a mobile
        application yet I’m still using jQM for theming mobile
        components; the tabs, date-picker, sliders - everything in the
        desktop UI is re-using what jQM would be providing users on
        mobile devices. Thanks to some media queries, the desktop UI can
        make optimal use of whitespace, expanding component blocks out
        and providing alternative layouts whilst still making use of jQM
        as a component framework.
      </p><p class="calibre6">
        The benefit of this is that I don’t need to go pulling in jQuery
        UI separately to be able to take advantage of these features.
        Thanks to the recent ThemeRoller my components can look pretty
        much exactly how I would like them to and users of the app can
        get a jQM UI for lower-resolutions and a jQM-ish UI for
        everything else.
      </p><p class="calibre6">
        The takeaway here is just to remember that if you’re not
        (already) going through the hassle of conditional script/style
        loading based on screen-resolution (using matchMedia.js etc),
        there are simpler approaches that can be taken to cross-device
        component theming.
      </p></div></div></div>

{% endraw %}

