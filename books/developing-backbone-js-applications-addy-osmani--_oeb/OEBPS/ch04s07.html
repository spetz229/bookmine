---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch04s06.html
next: OEBPS/ch04s08.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Paginating Backbone.js Requests &amp; Collections"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="paginating-backbone.js-requests-collections" class="calibre1"></a>Paginating Backbone.js Requests &amp;
    Collections</h1></div></div></div><p class="calibre6">
      Pagination is a ubiquitous problem we often find ourselves needing
      to solve on the web. Perhaps most predominantly when working with
      back-end APIs and JavaScript-heavy clients which consume them.
    </p><p class="calibre6">
      On this topic, we’re going to go through a set of **pagination
      components ** I wrote for Backbone.js, which should hopefully come
      in useful if you’re working on applications which need to tackle
      this problem. They’re part of an extension called
      <a class="ulink" href="http://github.com/addyosmani/backbone.paginator">Backbone.Paginator</a>.
    </p><p class="calibre6">
      When working with a structural framework like Backbone.js, the
      three types of pagination we are most likely to run into are:
    </p><p class="calibre6">
      **Requests to a service layer (API) **- e.g query for results
      containing the term <span class="firstname">“<span class="firstname">Brendan</span>”</span> - if 5,000 results are
      available only display 20 results per page (leaving us with 250
      possible result pages that can be navigated to).
    </p><p class="calibre6">
      This problem actually has quite a great deal more to it, such as
      maintaining persistence of other URL parameters (e.g sort, query,
      order) which can change based on a user’s search configuration in
      a UI. One also had to think of a clean way of hooking views up to
      this pagination so you can easily navigate between pages (e.g
      First, Last, Next, Previous, 1,2,3), manage the number of results
      displayed per page and so on.
    </p><p class="calibre6">
      <span class="firstname"><strong class="calibre8">Further client-side pagination of data
      returned -</strong></span> e.g we’ve been returned a JSON esponse
      containing 100 results. Rather than displaying all 100 to the
      user, we only display 20 of these results within a navigatable UI
      in the browser.
    </p><p class="calibre6">
      Similar to the request problem, client-pagination has its own
      challenges like navigation once again (Next, Previous, 1,2,3),
      sorting, order, switching the number of results to display per
      page and so on.
    </p><p class="calibre6">
      <span class="firstname"><strong class="calibre8">Infinite results</strong></span> - with
      services such as Facebook, the concept of numeric pagination is
      instead replaced with a <span class="firstname">“<span class="firstname">Load More</span>”</span> or <span class="firstname">“<span class="firstname">View
      More</span>”</span> button. Triggering this normally fetches the next
      <span class="firstname">“<span class="firstname">page</span>”</span> of N results but rather than replacing the
      previous set of results loaded entirely, we simply append to them
      instead.
    </p><p class="calibre6">
      A request pager which simply appends results in a view rather than
      replacing on each new fetch is effectively an
      <span class="firstname">“<span class="firstname">infinite</span>”</span> pager.
    </p><p class="calibre6">
      <span class="firstname"><strong class="calibre8">Let’s now take a look at exactly what
      we’re getting out of the box:</strong></span>
    </p><p class="calibre6">
      <span class="firstname"><em class="calibre9"><a class="ulink" href="http://addyosmani.github.com/backbone.paginator/">Backbone.Paginator</a>
      is a set of opinionated components for paginating collections of
      data using Backbone.js. It aims to provide both solutions for
      assisting with pagination of requests to a server (e.g an API) as
      well as pagination of single-loads of data, where we may wish to
      further paginate a collection of N results into M pages within a
      view.</em></span>
    </p></div></div>

{% endraw %}

