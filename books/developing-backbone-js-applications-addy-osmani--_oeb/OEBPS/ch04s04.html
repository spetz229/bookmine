---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch04s03.html
next: OEBPS/ch04s05.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Optimizing Backbone apps for production with the RequireJS Optimizer"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="optimizing-backbone-apps-for-production-with-the-requirejs-optimizer" class="calibre1"></a>Optimizing Backbone apps for
    production with the RequireJS Optimizer</h1></div></div></div><p class="calibre6">
      As experienced developers may know, an essential final step when
      writing both small and large JavaScript web applications is the
      build process. The majority of non-trivial apps are likely to
      consist of more than one or two scripts and so optimizing,
      minimizing and concatenating your scripts prior to pushing them to
      production will require your users to download a reduced number
      (if not just one) script file.
    </p><p class="calibre6">
      Note: If you haven’t looked at build processes before and this is
      your first time hearing about them, you might find
      <a class="ulink" href="http://addyosmani.com/blog/client-side-build-process/">my
      post and screencast on this topic</a> useful.
    </p><p class="calibre6">
      With some other structural JavaScript frameworks, my
      recommendation would normally be to implicitly use YUI Compressor
      or Google’s closure compiler tools, but we have a slightly more
      elegant method available, when it comes to Backbone if you’re
      using RequireJS. RequireJS has a command line optimization tool
      called r.js which has a number of capabilities, including:
    </p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre6">
          Concatenating specific scripts and minifying them using
          external tools such as UglifyJS (which is used by default) or
          Google’s Closure Compiler for optimal browser delivery, whilst
          preserving the ability to dynamically load modules
        </p></li><li class="listitem"><p class="calibre6">
          Optimizing CSS and stylesheets by inlining CSS files imported
          using @import, stripping out comments etc.
        </p></li><li class="listitem"><p class="calibre6">
          The ability to run AMD projects in both Node and Rhino (more
          on this later)
        </p></li></ul></div><p class="calibre6">
      You’ll notice that I mentioned the word <span class="firstname">“<span class="firstname">specific</span>”</span> in
      the first bullet point. The RequireJS optimizer only concatenates
      module scripts that have been specified in arrays of string
      literals passed to top-level (i.e non-local) require and define
      calls. As clarified by the
      <a class="ulink" href="http://requirejs.org/docs/optimization.html">optimizer
      docs</a> this means that Backbone modules defined like this:
    </p><pre class="programlistingjavascript"><code class="nx">define</code><code class="p">([</code><code class="s">'jquery'</code><code class="p">,</code><code class="s">'backbone'</code><code class="p">,</code><code class="s">'underscore'</code><code class="p">,</code> <code class="s">'collections/sample'</code><code class="p">,</code><code class="s">'views/test'</code><code class="p">],</code> 
    <code class="kd">function</code><code class="p">(</code><code class="nx">$</code><code class="p">,</code><code class="nx">Backbone</code><code class="p">,</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">Sample</code><code class="p">,</code> <code class="nx">Test</code><code class="p">){</code>
        <code class="c">//...</code>
    <code class="p">});</code>
</pre><p class="calibre6">
      will combine fine, however inline dependencies such as:
    </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">models</code> <code class="o">=</code> <code class="nx">someCondition</code> <code class="o">?</code> <code class="p">[</code><code class="s">'models/ab'</code><code class="p">,</code><code class="s">'models/ac'</code><code class="p">]</code> <code class="o">:</code> <code class="p">[</code><code class="s">'models/ba'</code><code class="p">,</code><code class="s">'models/bc'</code><code class="p">];</code>
</pre><p class="calibre6">
      will be ignored. This is by design as it ensures that dynamic
      dependency/module loading can still take place even after
      optimization.
    </p><p class="calibre6">
      Although the RequireJS optimizer works fine in both Node and Java
      environments, it’s strongly recommended to run it under Node as it
      executes significantly faster there. In my experience, it’s a
      piece of cake to get setup with either environment, so go for
      whichever you feel most comfortable with.
    </p><p class="calibre6">
      To get started with r.js, grab it from the
      <a class="ulink" href="http://requirejs.org/docs/download.html#rjs">RequireJS
      download page</a> or
      <a class="ulink" href="http://requirejs.org/docs/optimization.html#download">through
      NPM</a>. Now, the RequireJS optimizer works absolutely fine
      for single script and CSS files, but for most cases you’ll want to
      actually optimize an entire Backbone project. You
      <span class="firstname"><em class="calibre9">could</em></span> do this completely from the
      command-line, but a cleaner option is using build profiles.
    </p><p class="calibre6">
      Below is an example of a build file taken from the modular jQuery
      Mobile app referenced later in this book. A
      <span class="firstname"><strong class="calibre8">build profile</strong></span> (commonly named
      <code class="literal">app.build.js</code>) informs RequireJS to copy all of
      the content of <code class="literal">appDir</code> to a directory defined by
      <code class="literal">dir</code> (in this case
      <code class="literal">../release</code>). This will apply all of the
      necessary optimizations inside the release folder. The
      <code class="literal">baseUrl</code> is used to resolve the paths for your
      modules. It should ideally be relative to
      <code class="literal">appDir</code>.
    </p><p class="calibre6">
      Near the bottom of this sample file, you’ll see an array called
      <code class="literal">modules</code>. This is where you specify the module
      names you wish to have optimized. In this case we’re optimizing
      the main application called <span class="firstname">“<span class="firstname">app</span>”</span>, which maps to
      <code class="literal">appDir/app.js</code>. If we had set the
      <code class="literal">baseUrl</code> to <span class="firstname">“<span class="firstname">scripts</span>”</span>, it would be
      mapped to <code class="literal">appDir/scripts/app.js</code>.
    </p><pre class="programlistingjavascript"><code class="p">({</code>
    <code class="nx">appDir</code><code class="o">:</code> <code class="s">"./"</code><code class="p">,</code>
    <code class="nx">baseUrl</code><code class="o">:</code> <code class="s">"./"</code><code class="p">,</code>
    <code class="nx">dir</code><code class="o">:</code> <code class="s">"../release"</code><code class="p">,</code>
    <code class="nx">paths</code><code class="o">:</code> <code class="p">{</code>
       <code class="s">'backbone'</code><code class="o">:</code>          <code class="s">'libs/AMDbackbone-0.5.3'</code><code class="p">,</code>
        <code class="s">'underscore'</code><code class="o">:</code>       <code class="s">'libs/underscore-1.2.2'</code><code class="p">,</code>
        <code class="s">'jquery'</code><code class="o">:</code>           <code class="s">'libs/jQuery-1.7.1'</code><code class="p">,</code>
        <code class="s">'json2'</code><code class="o">:</code>            <code class="s">'libs/json2'</code><code class="p">,</code>
        <code class="s">'datepicker'</code><code class="o">:</code>       <code class="s">'libs/jQuery.ui.datepicker'</code><code class="p">,</code>
        <code class="s">'datepickermobile'</code><code class="o">:</code> <code class="s">'libs/jquery.ui.datepicker.mobile'</code><code class="p">,</code>
        <code class="s">'jquerymobile'</code><code class="o">:</code>     <code class="s">'libs/jquery.mobile-1.0'</code>
    <code class="p">},</code>
    <code class="nx">optimize</code><code class="o">:</code> <code class="s">"uglify"</code><code class="p">,</code>
    <code class="nx">modules</code><code class="o">:</code> <code class="p">[</code>
        <code class="p">{</code>
            <code class="nx">name</code><code class="o">:</code> <code class="s">"app"</code><code class="p">,</code>
            <code class="nx">exclude</code><code class="o">:</code> <code class="p">[</code>
                <code class="c">// If you prefer not to include certain libs exclude them here</code>
            <code class="p">]</code>
        <code class="p">}</code>
    <code class="p">]</code>
<code class="p">})</code>
</pre><p class="calibre6">
      The way the build system in r.js works is that it traverses app.js
      (whatever modules you’ve passed) and resolved dependencies,
      concatenating them into the final <code class="literal">release</code>(dir)
      folder. CSS is treated the same way.
    </p><p class="calibre6">
      The build profile is usually placed inside the
      <span class="firstname">“<span class="firstname">scripts</span>”</span> or <span class="firstname">“<span class="firstname">js</span>”</span> directory of your
      project. As per the docs, this file can however exist anywhere you
      wish, but you’ll need to edit the contents of your build profile
      accordingly.
    </p><p class="calibre6">
      Finally, to run the build, execute the following command once
      inside your <code class="literal">appDir</code> or
      <code class="literal">appDir/scripts</code> directory:
    </p><pre class="programlistingjavascript"><code class="nx">node</code> <code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="nx">r</code><code class="p">.</code><code class="nx">js</code> <code class="o">-</code><code class="nx">o</code> <code class="nx">app</code><code class="p">.</code><code class="nx">build</code><code class="p">.</code><code class="nx">js</code>
</pre><p class="calibre6">
      That’s it. As long as you have UglifyJS/Closure tools setup
      correctly, r.js should be able to easily optimize your entire
      Backbone project in just a few key-strokes. If you would like to
      learn more about build profiles, James Burke has a
      <a class="ulink" href="https://github.com/jrburke/r.js/blob/master/build/example.build.js">heavily
      commented sample file</a> with all the possible options
      available.
    </p></div></div>

{% endraw %}

