---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch03s05.html
next: OEBPS/ch04s02.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre7"></div><div class="book" title="Chapter 4. Advanced"><div class="book"><div class="book"><div class="book"><div class="calibre7"></div><h1 class="title1"><a id="advanced" class="calibre1"></a>Chapter 4. Advanced</h1></div></div></div><div class="book" title="Modular JavaScript"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="modular-javascript" class="calibre1"></a>Modular JavaScript</h1></div></div></div><p class="calibre6">
      When we say an application is modular, we generally mean it’s
      composed of a set of highly decoupled, distinct pieces of
      functionality stored in modules. As you probably know, loose
      coupling facilitates easier maintainability of apps by removing
      dependencies where possible. When this is implemented efficiently,
      its quite easy to see how changes to one part of a system may
      affect another.
    </p><p class="calibre6">
      Unlike some more traditional programming languages however, the
      current iteration of JavaScript (ECMA-262) doesn’t provide
      developers with the means to import such modules of code in a
      clean, organized manner. It’s one of the concerns with
      specifications that haven’t required great thought until more
      recent years where the need for more organized JavaScript
      applications became apparent.
    </p><p class="calibre6">
      Instead, developers at present are left to fall back on variations
      of the module or object literal patterns. With many of these,
      module scripts are strung together in the DOM with namespaces
      being described by a single global object where it’s still
      possible to incur naming collisions in your architecture. There’s
      also no clean way to handle dependency management without some
      manual effort or third party tools.
    </p><p class="calibre6">
      Whilst native solutions to these problems will be arriving in ES
      Harmony, the good news is that writing modular JavaScript has
      never been easier and you can start doing it today.
    </p><p class="calibre6">
      In this next part of the book, we’re going to look at how to use
      AMD modules and RequireJS for cleanly wrapping units of code in
      your application into manageable modules.
    </p></div></div></div>

{% endraw %}

