---
layout: page
title: "Developing Backbone.js Applications"
prev: OEBPS/ch02s07.html
next: OEBPS/ch02s09.html
book_path: books/developing-backbone-js-applications-addy-osmani--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Namespacing"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="namespacing" class="calibre1"></a>Namespacing</h1></div></div></div><p class="calibre6">
      When learning how to use Backbone, an important and commonly
      overlooked area by tutorials is namespacing. If you already have
      experience with namespacing in JavaScript, the following section
      will provide some advice on how to specifically apply concepts you
      know to Backbone, however I will also be covering explanations for
      beginners to ensure everyone is on the same page.
    </p><div class="book" title="What is namespacing?"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="what-is-namespacing" class="calibre1"></a>What is namespacing?</h2></div></div></div><p class="calibre6">
        The basic idea around namespacing is to avoid collisions with
        other objects or variables in the global namespace. They’re
        important as it’s best to safeguard your code from breaking in
        the event of another script on the page using the same variable
        names as you are. As a good <span class="firstname">“<span class="firstname">citizen</span>”</span> of the global
        namespace, it’s also imperative that you do your best to
        similarly not prevent other developer’s scripts executing due to
        the same issues.
      </p><p class="calibre6">
        JavaScript doesn’t really have built-in support for namespaces
        like other languages, however it does have closures which can be
        used to achieve a similar effect.
      </p><p class="calibre6">
        In this section we’ll be taking a look shortly at some examples
        of how you can namespace your models, views, routers and other
        components specifically. The patterns we’ll be examining are:
      </p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre6">
            Single global variables
          </p></li><li class="listitem"><p class="calibre6">
            Object Literals
          </p></li><li class="listitem"><p class="calibre6">
            Nested namespacing
          </p></li></ul></div><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Single global variables</strong></span>
      </p><p class="calibre6">
        One popular pattern for namespacing in JavaScript is opting for
        a single global variable as your primary object of reference. A
        skeleton implementation of this where we return an object with
        functions and properties can be found below:
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">(){</code>
    <code class="kd">function</code><code class="p">(){</code>
      <code class="c">// ...</code>
    <code class="p">},</code>
    <code class="kd">return</code> <code class="p">{</code>
      <code class="c">// ...</code>
    <code class="p">}</code>
<code class="p">})();</code>
</pre><p class="calibre6">
        You’ve probably seen this technique before. A Backbone-specific
        example might look like this:
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">myViews</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">(){</code>
    <code class="kd">return</code> <code class="p">{</code>
        <code class="nx">PhotoView</code><code class="o">:</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code> <code class="p">..</code> <code class="p">}),</code>
        <code class="nx">GalleryView</code><code class="o">:</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code> <code class="p">..</code> <code class="p">}),</code>
        <code class="nx">AboutView</code><code class="o">:</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code> <code class="p">..</code> <code class="p">});</code>
        <code class="c">//etc.</code>
    <code class="p">};</code>
<code class="p">})();</code>
</pre><p class="calibre6">
        Here we can return a set of views, but the same technique could
        return an entire collection of models, views and routers
        depending on how you decide to structure your application.
        Although this works for certain situations, the biggest
        challenge with the single global variable pattern is ensuring
        that no one else has used the same global variable name as you
        have in the page.
      </p><p class="calibre6">
        One solution to this problem, as mentioned by Peter Michaux, is
        to use prefix namespacing. It’s a simple concept at heart, but
        the idea is you select a common prefix name (in this example,
        <code class="literal">myApplication_</code>) and then define any methods,
        variables or other objects after the prefix.
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">myApplication_photoView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({}),</code>
<code class="nx">myApplication_galleryView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code>
</pre><p class="calibre6">
        This is effective from the perspective of trying to lower the
        chances of a particular variable existing in the global scope,
        but remember that a uniquely named object can have the same
        effect. This aside, the biggest issue with the pattern is that
        it can result in a large number of global objects once your
        application starts to grow.
      </p><p class="calibre6">
        For more on Peter’s views about the single global variable
        pattern, read his
        <a class="ulink" href="http://michaux.ca/articles/javascript-namespacing">excellent
        post on them</a>.
      </p><p class="calibre6">
        Note: There are several other variations on the single global
        variable pattern out in the wild, however having reviewed quite
        a few, I felt the prefixing approach applied best to Backbone.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Object Literals</strong></span>
      </p><p class="calibre6">
        Object Literals have the advantage of not polluting the global
        namespace but assist in organizing code and parameters
        logically. They’re beneficial if you wish to create easily
        readable structures that can be expanded to support deep
        nesting. Unlike simple global variables, Object Literals often
        also take into account tests for the existence of a variable by
        the same name, which helps reduce the chances of collision.
      </p><p class="calibre6">
        This example demonstrates two ways you can check to see if a
        namespace already exists before defining it. I commonly use
        Option 2.
      </p><pre class="programlistingjavascript"><code class="c">/*Doesn't check for existence of myApplication*/</code>
<code class="kd">var</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{};</code>

<code class="c">/*</code>
<code class="c">Does check for existence. If already defined, we use that instance.</code>
<code class="c">Option 1:   if(!myApplication) myApplication = {};</code>
<code class="c">Option 2:   var myApplication = myApplication || {};</code>
<code class="c">We can then populate our object literal to support models, views and collections (or any data, really):</code>
<code class="c">*/</code>

<code class="kd">var</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">models</code> <code class="o">:</code> <code class="p">{},</code>
    <code class="nx">views</code> <code class="o">:</code> <code class="p">{</code>
        <code class="nx">pages</code> <code class="o">:</code> <code class="p">{}</code>
    <code class="p">},</code>
    <code class="nx">collections</code> <code class="o">:</code> <code class="p">{}</code>
<code class="p">};</code>
</pre><p class="calibre6">
        One can also opt for adding properties directly to the namespace
        (such as your views, in the following example):
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">myGalleryViews</code> <code class="o">=</code> <code class="nx">myGalleryViews</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">myGalleryViews</code><code class="p">.</code><code class="nx">photoView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code>
<code class="nx">myGalleryViews</code><code class="p">.</code><code class="nx">galleryView</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">View</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code>
</pre><p class="calibre6">
        The benefit of this pattern is that you’re able to easily
        encapsulate all of your models, views, routers etc. in a way
        that clearly separates them and provides a solid foundation for
        extending your code.
      </p><p class="calibre6">
        This pattern has a number of benefits. It’s often a good idea to
        decouple the default configuration for your application into a
        single area that can be easily modified without the need to
        search through your entire codebase just to alter it. Here’s an
        example of a hypothetical object literal that stores application
        configuration settings:
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">myConfig</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">language</code><code class="o">:</code> <code class="s">'english'</code><code class="p">,</code>
    <code class="nx">defaults</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">enableGeolocation</code><code class="o">:</code> <code class="kd">true</code><code class="p">,</code>
        <code class="nx">enableSharing</code><code class="o">:</code> <code class="kd">false</code><code class="p">,</code>
        <code class="nx">maxPhotos</code><code class="o">:</code> <code class="mi">20</code>
    <code class="p">},</code>
    <code class="nx">theme</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">skin</code><code class="o">:</code> <code class="s">'a'</code><code class="p">,</code>
        <code class="nx">toolbars</code><code class="o">:</code> <code class="p">{</code>
            <code class="nx">index</code><code class="o">:</code> <code class="s">'ui-navigation-toolbar'</code><code class="p">,</code>
            <code class="nx">pages</code><code class="o">:</code> <code class="s">'ui-custom-toolbar'</code>    
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre><p class="calibre6">
        Note that there are really only minor syntactical differences
        between the Object Literal pattern and a standard JSON data set.
        If for any reason you wish to use JSON for storing your
        configurations instead (e.g. for simpler storage when sending to
        the back-end), feel free to.
      </p><p class="calibre6">
        For more on the Object Literal pattern, I recommend reading
        Rebecca Murphey’s
        <a class="ulink" href="http://rmurphey.com/blog/2009/10/15/using-objects-to-organize-your-code">excellent
        article on the topic</a>.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Nested namespacing</strong></span>
      </p><p class="calibre6">
        An extension of the Object Literal pattern is nested
        namespacing. It’s another common pattern used that offers a
        lower risk of collision due to the fact that even if a top-level
        namespace already exists, it’s unlikely the same nested children
        do. For example, Yahoo’s YUI uses the nested object namespacing
        pattern extensively:
      </p><pre class="programlistingjavascript"><code class="nx">YAHOO</code><code class="p">.</code><code class="nx">util</code><code class="p">.</code><code class="nx">Dom</code><code class="p">.</code><code class="nx">getElementsByClassName</code><code class="p">(</code><code class="s">'test'</code><code class="p">);</code>
</pre><p class="calibre6">
        Yahoo’s YUI uses the nested object namespacing pattern regularly
        and even DocumentCloud (the creators of Backbone) use the nested
        namespacing pattern in their main applications. A sample
        implementation of nested namespacing with Backbone may look like
        this:
      </p><pre class="programlistingjavascript"><code class="kd">var</code> <code class="nx">galleryApp</code> <code class="o">=</code>  <code class="nx">galleryApp</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c">// perform similar check for nested children</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">routers</code> <code class="o">=</code> <code class="nx">galleryApp</code><code class="p">.</code><code class="nx">routers</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code> <code class="o">=</code> <code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">special</code> <code class="o">=</code> <code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">special</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c">// routers</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">routers</code><code class="p">.</code><code class="nx">Workspace</code>   <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Router</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code> 
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">routers</code><code class="p">.</code><code class="nx">PhotoSearch</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Router</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code> 

<code class="c">// models</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">Photo</code>   <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Model</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">Comment</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Model</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code> 

<code class="c">// special models</code>
<code class="nx">galleryApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">special</code><code class="p">.</code><code class="nx">Admin</code> <code class="o">=</code> <code class="nx">Backbone</code><code class="p">.</code><code class="nx">Model</code><code class="p">.</code><code class="nx">extend</code><code class="p">({});</code>
</pre><p class="calibre6">
        This is readable, clearly organized, and is a relatively safe
        way of namespacing your Backbone application. The only real
        caveat however is that it requires your browser’s JavaScript
        engine to first locate the galleryApp object, then dig down
        until it gets to the function you’re calling. However,
        developers such as Juriy Zaytsev (kangax) have tested and found
        the performance differences between single object namespacing vs
        the <span class="firstname">“<span class="firstname">nested</span>”</span> approach to be quite negligible.
      </p><p class="calibre6">
        <span class="firstname"><strong class="calibre8">Recommendation</strong></span>
      </p><p class="calibre6">
        Reviewing the namespace patterns above, the option that I prefer
        when writing Backbone applications is nested object namespacing
        with the object literal pattern.
      </p><p class="calibre6">
        Single global variables may work fine for applications that are
        relatively trivial. However, larger codebases requiring both
        namespaces and deep sub-namespaces require a succinct solution
        that’s both readable and scalable. I feel this pattern achieves
        both of these objectives and is a good choice for most Backbone
        development.
      </p></div></div></div>

{% endraw %}

