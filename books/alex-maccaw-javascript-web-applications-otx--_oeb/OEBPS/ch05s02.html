---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch05.html
next: OEBPS/ch05s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Templates"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect15_d1e5075" class="calibre1"></a>Templates</h1></div></div></div><p class="calibre3"><a id="index-884Q000FV0S" class="calibre1"></a><a id="I_indexterm5_d1e5082" class="calibre1"></a>If you’re used to interpolating server variables in HTML,
    templating will be familiar. There are a variety of templating libraries
    <a id="I_indexterm5_d1e5088" class="calibre1"></a>out there—your choice will probably depend on which DOM
    library you’re using. However, most of them share a similar syntax, which
    I’ll describe below.</p><p class="calibre3">The gist of JavaScript templates is that you can take an HTML
    fragment interpolated with template variables and combine it with a
    JavaScript object, replacing those template variables with values from the
    object. Overall, JavaScript templating works in much the same way as
    templating libraries in other languages, such as PHP’s Smarty, Ruby’s ERB,
    and Python’s string formatting.</p><p class="calibre3">We’re going to use the <a class="ulink" href="http://api.jquery.com/category/plugins/templates/">jQuery.tmpl</a>
    library <a id="I_indexterm5_d1e5101" class="calibre1"></a>as the basis for the templating examples. If you aren’t
    using jQuery, or if you want to use a different templating library, the
    examples should still be useful; the templating syntax for most libraries
    is very similar, if not identical. If you want a good alternative, check
    out <a class="ulink" href="http://mustache.github.com">Mustache</a><a id="I_indexterm5_d1e5107" class="calibre1"></a>, which has implementations in a lot of languages, including
    JavaScript.</p><p class="calibre3">Created by Microsoft, jQuery.tmpl is a templating plug-in <a id="I_indexterm5_d1e5113" class="calibre1"></a>based on John Resig’s <a class="ulink" href="http://ejohn.org/blog/javascript-micro-templating/">original
    work</a>. It’s a well-maintained <span class="calibre1">library</span> and is fully documented on the
    <a class="ulink" href="http://api.jquery.com/jquery.tmpl">jQuery site</a>. The
    library has one main function,<a id="I_indexterm5_d1e5128" class="calibre1"></a> <code class="literal">jQuery.tmpl()</code>, to which
    you can pass a template and some data. It renders a template element that
    you can append to the document. If the data is an array, the template is
    rendered once for every data item in the array; otherwise, a single
    template is rendered:</p><pre class="screen">var object = {
  url: "http://example.com",
  getName: function(){ return "Trevor"; }
};

var template = '&lt;li&gt;&lt;a href="${url}"&gt;${getName()}&lt;/a&gt;&lt;/li&gt;';

var element = jQuery.tmpl(template, object);
// Produces: &lt;li&gt;&lt;a href="http://example.com"&gt;Trevor&lt;/a&gt;&lt;/li&gt;

$("body").append(element);</pre><p class="calibre3">So, you can see we’re interpolating variables <a id="I_indexterm5_d1e5142" class="calibre1"></a><a id="I_indexterm5_d1e5145" class="calibre1"></a>using the <code class="literal">${}</code> syntax.
    Whatever is inside the brackets is evaluated in the context of the object
    passed to <code class="literal">jQuery.tmpl()</code>, regardless of
    whether it is a property or a function.</p><p class="calibre3">However, templates are much more powerful than mere interpolation.
    Most templating libraries have advanced features like conditional flow and
    iteration. You can control flow by using <code class="literal">if</code> and <code class="literal">else</code>
    statements, the same as with pure JavaScript. The difference here is that
    we need to wrap the keyword with double brackets so that the templating
    engine can pick them up:</p><pre class="screen">{{if url}}
  ${url}
{{/if}}</pre><p class="calibre3">The <code class="literal">if</code> block will be executed if
    the specified attribute value doesn’t evaluate to <code class="literal">false</code>, <span class="calibre1"><code class="literal">0</code>, <code class="literal">null</code></span>, <code class="literal">""</code>, <code class="literal">Nan</code>, or
    <code class="literal">undefined</code>. As you can see, the block is
    closed with a <code class="literal">{{/if}}</code>, so don’t forget
    to include that! A common pattern is to display a message when an <span class="calibre1">array—</span>say, of chat messages—is empty:</p><pre class="screen">{{if messages.length}}
  &lt;!-- Display messages... --&gt;
{{else}}
  &lt;p&gt;Sorry, there are no messages&lt;/p&gt;
{{/if}}</pre><p class="calibre3">No templating library can afford to be without iteration. With JS
    templating libraries, you can iterate over any JavaScript
    type—<code class="literal">Object</code> or <code class="literal">Array</code>—using the
    <code class="literal">{{each}}</code> keyword. If you pass an Object
    to <code class="literal">{{each}}</code>, it will iterate a block
    over the object’s properties. Likewise, passing an array results in the
    block iterating over every index in the array.</p><p class="calibre3">When inside the block, you can access the value currently being
    iterated over using the <code class="literal">$value</code>
    variable. Displaying the value is the same as the interpolation example
    above, which uses <code class="literal">${$value}</code>. Consider
    this object:</p><pre class="screen">var object = {
  foo: "bar",
  messages: ["Hi there", "Foo bar"]
};</pre><p class="calibre3">Then, use the following template to iterate through the <code class="literal">messages</code> array, displaying each message.
    Additionally, the current iteration’s index is also exposed using the
    <code class="literal">$index</code> variable.</p><pre class="screen">&lt;ul&gt;
  {{each messages}}
    &lt;li&gt;${$index + 1}: &lt;em&gt;${$value}&lt;/em&gt;&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre><p class="calibre3">As you can see, the jQuery.tmpl templating API <a id="I_indexterm5_d1e5237" class="calibre1"></a>is very straightforward. As I mentioned earlier, most of the
    alternative templating libraries have a similar API, although <span class="calibre1">many offer</span> more advanced features, such as
    lambdas, partials, and comments.</p><div class="book" title="Template Helpers"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2921345" class="calibre12"></a>Template Helpers</h2></div></div></div><p class="calibre3"><a id="I_indexterm5_d1e5250" class="calibre1"></a><a id="I_indexterm5_d1e5255" class="calibre1"></a>Sometimes it’s useful to use<a id="I_indexterm5_d1e5261" class="calibre1"></a> generic helper functions inside the view, perhaps to
      format a date or a number. However, it’s important to keep your MVC
      architecture in mind, rather than arbitrarily inserting functions
      directly into the view. For example, let’s replace links in some plain
      text with <code class="literal">&lt;a&gt;&lt;/a&gt;</code> tags.
      This would certainly be the wrong way to go about doing it:</p><pre class="screen">&lt;div&gt;
  ${ this.data.replace(
/((http|https|ftp):\/\/[\w?=&amp;.\/-;#~%-]+(?![\w\s?&amp;.\/;#~%"=-]*&gt;))/g, 
'&lt;a target="_blank" href="$1"&gt;$1&lt;/a&gt; ') }
&lt;/div&gt;</pre><p class="calibre3">Rather than injecting the function straight into the view, we
      should abstract and namespace it, keeping logic separate from views. In
      this case, we’re going to create a separate
      <em class="calibre4">helpers.js</em> file, containing all our application’s
      helpers, such as the <code class="literal">autoLink()</code>
      function.<a id="I_indexterm5_d1e5280" class="calibre1"></a><a id="I_indexterm5_d1e5283" class="calibre1"></a> Then, we can tidy up the view with our helper:</p><pre class="screen">// helper.js
var helper = {};
helper.autoLink = function(data){ 
  var re = /((http|https|ftp):\/\/[\w?=&amp;.\/-;#~%-]+(?![\w\s?&amp;.\/;#~%"=-]*&gt;))/g;
  return(data.replace(re, '&lt;a target="_blank" href="$1"&gt;$1&lt;/a&gt; ') );
};

// template.html
&lt;div&gt;
  ${ helper.autoLink(this.data) }
&lt;/div&gt;</pre><p class="calibre3">There’s an added advantage: the <code class="literal">autoLink()</code> function is now generic and can be
      reused elsewhere inside the application.</p></div><div class="book" title="Template Storage"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2921477" class="calibre12"></a>Template Storage</h2></div></div></div><p class="calibre3"><a id="I_indexterm5_d1e5300" class="calibre1"></a><a id="I_indexterm5_d1e5305" class="calibre1"></a>When it comes to storing view templates, there are a few
      options:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Inline in the JavaScript</p></li><li class="listitem"><p class="calibre3">Inline in a custom script tag</p></li><li class="listitem"><p class="calibre3">Loaded remotely</p></li><li class="listitem"><p class="calibre3">Inline in the HTML</p></li></ul></div><p class="calibre3">Some of these, however, are better at respecting the MVC
      architecture. I personally advocate storing templates inline in custom
      script tags for the reasons outlined below.</p><p class="calibre3">You can store templates inside your JavaScript files. This isn’t
      really recommended, though, because it entails putting view code inside
      the controller, violating the MVC architecture.</p><p class="calibre3">By sending an Ajax call, you can dynamically load in templates
      when they’re needed. The advantage of this is that the initial page load
      is smaller; the disadvantage is that you could slow the UI down while
      templates are loading. One of the main reasons to build JavaScript apps
      is for their enhanced speed, so you should be careful about squandering
      this advantage when loading in remote resources.</p><p class="calibre3">You can store templates inline, inside the page’s HTML. The
      advantage to this approach is that it doesn’t have the slow loading
      problem that fetching remote templates has. The source code is much more
      obvious—templates are inline where they’re being displayed and used. The
      obvious disadvantage is that it results in a large page size. To be
      honest, though, this speed difference should be negligible—especially if
      you’re using page compression and caching.</p><p class="calibre3">I recommend using custom script tags and referencing them by ID
      from JavaScript. This is a convenient way of storing templates,
      especially if you want to use them in multiple places. Custom script
      tags also have the advantage of not being rendered by the browser, which
      just interprets their contents as text.</p><p class="calibre3">If the template is defined inline in the page, you can use
      <code class="literal">jQuery.fn.tmpl(data)</code>—i.e., call
      <code class="literal">tmpl()</code> on a jQuery element:</p><pre class="screen">&lt;script type="text/x-jquery-tmpl" id="someTemplate"&gt;
  &lt;span&gt;${getName()}&lt;/span&gt;
&lt;/script&gt;

&lt;script&gt;
  var data = {
    getName: function(){ return "Bob" }
  };
  var element = $("#someTemplate").tmpl(data);
  element.appendTo($("body"));
&lt;/script&gt;</pre><p class="calibre3">Behind the scenes, jQuery.tmpl makes sure that the compiled
      template, once generated, is cached. This speeds things up because the
      template doesn’t have to be recompiled when you next use it. Notice
      we’re generating the element before appending it to the page; this
      method performs better than manipulating elements already attached to
      the page, making it a recommended practice.</p><p class="calibre3">Even if you’re rendering <a id="I_indexterm5_d1e5349" class="calibre1"></a>all the templates inline into the page, it doesn’t mean
      your server side should be structured like that. Try to keep each
      template in a separate file (or partial), and then concatenate them into
      the one document when the page is requested. Some of the
      dependency-management tools covered in <a class="ulink" href="ch06.html" title="Chapter 6. Dependency Management">Chapter 6</a>, like <span class="calibre1">RequireJS</span>, will do this for you.<a id="I_indexterm5_d1e5360" class="calibre1"></a></p></div></div></div>

{% endraw %}

