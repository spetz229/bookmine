---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch06s02.html
next: OEBPS/ch06s04.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Wrapping Up Modules"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect16_d1e5852" class="calibre1"></a>Wrapping Up Modules</h1></div></div></div><p class="calibre3"><a id="I_indexterm6_d1e5856" class="calibre1"></a><a id="I_indexterm6_d1e5861" class="calibre1"></a><a id="I_indexterm6_d1e5866" class="calibre1"></a>At this stage, we’ve got dependency management and
    namespacing, but there’s still the original problem: all those HTTP
    requests. Any module we depend on has to be loaded in remotely, and even
    though this happens asynchronously, it’s still a big performance overhead,
    slowing the startup of our application.</p><p class="calibre3">We’re also hand-wrapping our modules in the transport format which,
    while necessary for asynchronous loading, is fairly verbose. Let’s kill
    two birds with one stone by using a server-side step to
    concatenate<a id="I_indexterm6_d1e5874" class="calibre1"></a> the modules into one file. This means the browser has to
    fetch only one resource to load all the modules, which is much more
    efficient. The build tools available are intelligent, too—they don’t just
    bundle the modules arbitrarily, but statically analyze them to resolve
    their dependencies recursively. They’ll also take care of wrapping the
    modules up in the transport format, saving some typing.</p><p class="calibre3">In addition to concatenation, many module build tools also support
    minification,<a id="I_indexterm6_d1e5880" class="calibre1"></a> <span class="calibre1">further</span> reducing the
    request size. In fact, some tools—such as <a class="ulink" href="https://github.com/maccman/rack-modulr">rack-modulr</a> and
    <span class="calibre1"><a class="ulink" href="http://github.com/kriszyp/transporter">Transporter</a>—</span>integrate
    with your web server, handling module processing automatically when
    they’re first requested.</p><p class="calibre3">For example, here’s a simple <a class="ulink" href="http://rack.rubyforge.org">Rack</a> CommonJS module server using
    rack-modulr:<a id="I_indexterm6_d1e5902" class="calibre1"></a></p><pre class="screen">require "rack/modulr"

use Rack::Modulr, :source =&gt; "lib", :hosted_at =&gt; "/lib"
run Rack::Directory.new("public")</pre><p class="calibre3">You can start the server with the <code class="literal">rackup</code> command.<a id="I_indexterm6_d1e5912" class="calibre1"></a> Any CommonJS modules contained inside the <span class="calibre1">lib</span> folder are now concatenated automatically with all
    their dependencies and are wrapped in a transport callback. Our script
    loader can then request modules when they’re needed, loading them into the
    page:</p><pre class="screen">&gt;&gt; curl "http://localhost:9292/lib/application.js"
      require.define("maths"....</pre><p class="calibre3">If Ruby’s not your thing, there is a multitude of other options from
    which to choose. <a class="ulink" href="http://www.flyscript.org">FlyScript</a><a id="I_indexterm6_d1e5925" class="calibre1"></a> is a CommonJS module wrapper written in PHP, Transporter is
    one for <a class="ulink" href="http://jackjs.org">JSGI</a> servers, and <a class="ulink" href="https://github.com/sstephenson/stitch">Stitch</a><a id="I_indexterm6_d1e5934" class="calibre1"></a> integrates with Node.js servers.</p></div></div>

{% endraw %}

