---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch01s08.html
next: OEBPS/ch01s10.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Function Invocation"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect11_d1e1180" class="calibre1"></a>Function Invocation</h1></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e1184" class="calibre1"></a><a id="I_indexterm1_d1e1189" class="calibre1"></a><a id="I_indexterm1_d1e1194" class="calibre1"></a>Like everything else in JavaScript, functions are just
    objects. However, unlike other objects, they can be invoked. The context
    inside the function—i.e., the value of <span class="calibre1"><code class="literal">this</code>—</span>depends on where and how it’s
    invoked.<a id="I_indexterm1_d1e1203" class="calibre1"></a></p><p class="calibre3">Apart from using brackets, there are two other ways to invoke a
    function: <code class="literal">apply()</code><a id="I_indexterm1_d1e1212" class="calibre1"></a> and <code class="literal">call()</code><a id="I_indexterm1_d1e1218" class="calibre1"></a>. The difference between them has to do with the arguments
    you want to pass to the function.</p><p class="calibre3">The <code class="literal">apply()</code> function takes two parameters: a
    context and an array of arguments. If the context is null, the global
    context is used. For example:</p><pre class="screen">function.apply(this, [1, 2, 3])</pre><p class="calibre3">The <code class="literal">call()</code> function has exactly
    the same behavior, yet it is used differently. The first argument is the
    context, while each subsequent argument is delegated to the invocation. In
    other words, you use multiple arguments—rather than an array like with
    <code class="literal">apply()</code>—to pass arguments to the
    function.</p><pre class="screen">function.call(this, 1, 2, 3);</pre><p class="calibre3">Why would you want to change the context?<a id="I_indexterm1_d1e1241" class="calibre1"></a> This is a valid question because other languages get on
    fine without allowing explicit context changes. JavaScript uses context
    changes to share state, especially during event callbacks. (Personally, I
    feel this was a mistake in the design of the language, as it can be
    confusing for beginners and introduce bugs. However, it’s too late to
    change it now, so you need to learn how it works.)</p><p class="calibre3">jQuery <a id="I_indexterm1_d1e1249" class="calibre1"></a>takes advantage of <code class="literal">apply()</code> and <code class="literal">call()</code> throughout its API to change context—for
    example, when using event handlers or iterating using <code class="literal">each()</code>. This can be confusing at first, but it’s
    useful when you understand what’s happening:</p><pre class="screen">$('.clicky').click(function(){
  // 'this' refers to the element
  $(this).hide();
});

$('p').each(function(){
  // 'this' refers to the current iteration
  $(this).remove();
});</pre><p class="calibre3">To access the original context, a common pattern stores the value of
    <code class="literal">this</code> in a local variable. For
    example:</p><pre class="screen">var clicky = {
  wasClicked: function(){
    /* ... */
  },

  addListeners: function(){
    var self = this;
    $('.clicky').click(function(){
      self.wasClicked()
    });
  }
};

clicky.addListeners();</pre><p class="calibre3">However, we can use <code class="literal">apply</code> to make
    this much cleaner, wrapping the callback within another anonymous
    function, which preserves the original context:</p><pre class="screen">var proxy = function(func, thisObject){
  return(function(){ 
    return func.apply(thisObject, arguments); 
  });
};

var clicky = {
  wasClicked: function(){
    /* ... */
  },

  addListeners: function(){
    var self = this;
    $('.clicky').click(proxy(this.wasClicked, this));
  }
};</pre><p class="calibre3">So, in the above example, we specify the context to be used inside
    the click callback; the context jQuery invokes the function in is ignored.
    In fact, jQuery’s API includes something to do just this—you guessed it,
    <code class="literal">jQuery.proxy()</code>:</p><pre class="screen">$('.clicky').click($.proxy(function(){ /* ... */ }, this));</pre><p class="calibre3">There are other useful reasons to use <code class="literal">apply()</code> and <code class="literal">call()</code>, such as delegating. We can delegate
    calls from one function to another, and even alter the passed
    arguments:</p><pre class="screen">var App {
  log: function(){
    if (typeof console == "undefined") return;

    // Turn arguments into a proper array
    var args = jQuery.makeArray(arguments);

    // Insert a new argument
    args.unshift("(App)");

    // Delegate to the console
    console.log.apply(console, args);
  }
};</pre><p class="calibre3">Above, we’re making an array of arguments and then adding our own.
    Finally, the call is delegated to <code class="literal">console.log()</code>. If you’re not familiar with the
    <code class="literal">arguments</code> variable,<a id="I_indexterm1_d1e1306" class="calibre1"></a><a id="I_indexterm1_d1e1309" class="calibre1"></a> it’s set by the interpreter and contains an array of
    arguments with which the current scope was called. It’s not a true array
    though—for example, it’s not mutable—so we have to convert it to something
    usable with <code class="literal">jquery.makeArray()</code>.</p></div></div>

{% endraw %}

