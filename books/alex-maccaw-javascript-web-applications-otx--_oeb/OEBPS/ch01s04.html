---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch01s03.html
next: OEBPS/ch01s05.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Toward Modularity, Creating Classes"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect11_d1e776" class="calibre1"></a>Toward Modularity, Creating Classes</h1></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e780" class="calibre1"></a><a id="I_indexterm1_d1e785" class="calibre1"></a><a id="I_indexterm1_d1e790" class="calibre1"></a>Before we get to the nitty-gritty of MVC, we’re going to
    cover some preliminary concepts, such as JavaScript classes and events.
    This will give you a solid foundation before moving on to some of the more
    advanced concepts.</p><p class="calibre3">JavaScript object<a id="I_indexterm1_d1e796" class="calibre1"></a> literals <a id="I_indexterm1_d1e802" class="calibre1"></a>are fine for static classes, but it’s often useful to create
    classical classes with inheritance and instances. It’s important to
    emphasize that JavaScript is a prototype language, and as such doesn’t
    include a native class implementation. However, support can be emulated
    fairly easily.</p><p class="calibre3">Classes in JavaScript often get a bad rap, criticized for not being
    part of the “JavaScript Way,” a term that means essentially nothing.
    jQuery is effectively neutral when it comes to structural methodology or
    inheritance patterns. This can lead JavaScript developers to believe they
    shouldn’t consider structure—i.e., that classes aren’t available or
    shouldn’t be used. In reality, classes are just another tool, and as a
    pragmatist, I believe they’re as useful in JavaScript as in any other
    modern language.</p><p class="calibre3">Rather than class definitions, JavaScript has constructor functions
    <a id="I_indexterm1_d1e810" class="calibre1"></a><a id="I_indexterm1_d1e813" class="calibre1"></a>and the <code class="literal">new</code>
    operator.<a id="I_indexterm1_d1e822" class="calibre1"></a><a id="I_indexterm1_d1e825" class="calibre1"></a> A constructor function can specify an object’s initial
    properties and values when it is instantiated. Any JavaScript function can
    be used as a constructor. Use the <code class="literal">new</code>
    operator with a constructor function to create a new instance.</p><p class="calibre3">The <code class="literal">new</code> operator changes a
    function’s context, as well as the behavior of the return
    statement.<a id="I_indexterm1_d1e839" class="calibre1"></a> In practice, using <code class="literal">new</code>
    and constructors is fairly similar to languages with native class
    implementations:</p><pre class="screen">var Person = function(name) {
  this.name = name;
};

// Instantiate Person
var alice = new Person('alice');

// Check instance
assert( alice instanceof Person );</pre><p class="calibre3">By convention, constructor functions are upper camel-cased to
    differentiate them from normal functions. This is important because you
    don’t ever want to call a constructor function without the <code class="literal">new</code> prefix.</p><pre class="screen">// Don't do this!
Person('bob'); //=&gt; undefined</pre><p class="calibre3">The function will just return undefined, and since the context is
    the window (global) object, you’ve unintentionally created a global
    variable, <code class="literal">name</code>. Always call constructor
    functions using the <code class="literal">new</code> keyword.</p><p class="calibre3">When a constructor function is called with the <code class="literal">new</code> keyword,<a id="I_indexterm1_d1e868" class="calibre1"></a> the context switches from global (window) to a new and
    empty context specific to that instance. So, the <code class="literal">this</code> keyword refers to the current instance.
    Although it might sound complicated, in practice, you can treat it like
    native class implementations in other languages.</p><p class="calibre3">By default,<a id="I_indexterm1_d1e880" class="calibre1"></a> if you don’t return anything from a constructor function,
    <code class="literal">this</code>—the current context—will be
    returned. Otherwise, you can return any nonprimitive type. For example, we
    could return a function that would set up a new class, the first step in
    building our own class emulation library:</p><pre class="screen">var Class = function(){
  var klass = function(){
    this.init.apply(this, arguments);
  };
  klass.prototype.init  = function(){};
  return klass;
};

var Person = new Class;

Person.prototype.init = function(){
  // Called on Person instantiation
};

// Usage:
var person = new Person;</pre><p class="calibre3">Confusingly, due to a <a class="ulink" href="http://www.mozilla.org/js/language/js20-1999-02-18/classes.html">JavaScript
    2</a> specification that was never implemented, <code class="literal">class</code> <a id="I_indexterm1_d1e899" class="calibre1"></a><a id="I_indexterm1_d1e902" class="calibre1"></a>is a reserved keyword. The common convention is instead to
    name <code class="literal">class</code> variables as <code class="literal">_class</code> or <code class="literal">klass</code><a id="I_indexterm1_d1e917" class="calibre1"></a>.</p></div></div>

{% endraw %}

