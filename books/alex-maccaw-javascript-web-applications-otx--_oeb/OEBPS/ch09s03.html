---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch09s02.html
next: OEBPS/ch09s04.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Headless Testing"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect19_d1e8668" class="calibre1"></a>Headless Testing</h1></div></div></div><p class="calibre3"><a id="index-543M215BV3N" class="calibre1"></a><a id="index-175K511LA8U" class="calibre1"></a>With the development of server-side JavaScript
    implementations such as Node.js <span class="calibre1">and
    Rhino</span> comes the possibility of running your tests outside the
    browser in a headless environment via the command line. This has the
    advantage of speed and ease of setup, as it does away with the multitude
    of browsers and the continuous integration environment. The disadvantage,
    of course, is that the tests aren’t being run in a real-world
    environment.</p><p class="calibre3">This might not be as big a problem as it sounds, as you’ll find that
    most of the JavaScript you write is application logic and not
    browser-dependent. In addition, libraries like jQuery have taken care of a
    lot of browser incompatibilities when it comes to the DOM and event
    management. For smaller applications, as long as you have a staging
    environment when deploying and some high-level cross-browser integration
    tests (whether manual or automated), you should be fine.</p><p class="calibre3"><a class="ulink" href="http://www.envjs.com">Envjs</a><a id="I_indexterm9_d1e8689" class="calibre1"></a> is a library <a id="I_indexterm9_d1e8693" class="calibre1"></a>originally developed by John Resig, creator of the jQuery
    JavaScript framework. It offers an implementation of the browser and DOM
    APIs on top of Rhino, Mozilla’s Java implementation of JavaScript. You can
    use the env.js library together with Rhino to run JavaScript tests on the
    command line.</p><div class="book" title="Zombie"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2930130" class="calibre12"></a>Zombie</h2></div></div></div><p class="calibre3"><a class="ulink" href="http://zombie.labnotes.org">Zombie.js</a>
      <a id="I_indexterm9_d1e8706" class="calibre1"></a><a id="I_indexterm9_d1e8713" class="calibre1"></a><a id="I_indexterm9_d1e8718" class="calibre1"></a>is a headless library designed to take advantage of the
      incredible performance and asynchronous nature of Node.js. Speed is a
      key feature: the less time you spend waiting for tests to complete, the
      more time you get to build new features and fix bugs.</p><p class="calibre3">Applications that use a lot of client-side JavaScript spend much
      of their time loading, parsing, and evaluating that JavaScript. Here,
      the sheer performance of Google’s<a id="I_indexterm9_d1e8724" class="calibre1"></a> V8 JavaScript engine <a id="I_indexterm9_d1e8730" class="calibre1"></a>helps your tests run faster.</p><p class="calibre3">Although your test suite and client-side JavaScript both run on
      the same engine, Zombie uses another feature of
      V8—<span class="calibre1"><em class="calibre4">contexts</em></span>—which keeps them separated so they do
      not mix the same global variables/state. It’s similar to the way Chrome
      opens each tab in its own process.</p><p class="calibre3">Another benefit of contexts is being able to run multiple tests in
      parallel, each using its own <code class="literal">Browser</code>
      object. One test might be checking the DOM content while another test is
      waiting for a page request to come back, cutting down the time it takes
      to complete the entire test suite. You’ll need to use an asynchronous
      test framework, such as the excellent <a class="ulink" href="http://vowsjs.org">Vows.js</a><a id="I_indexterm9_d1e8746" class="calibre1"></a>, and pay attention to which tests must run in parallel
      and which must run in sequence.</p><p class="calibre3">Zombie.js provides a <code class="literal">Browser</code>
      object that works much like a real web browser: it maintains state
      between pages (cookies, history, web storage) and provides access to the
      current window (and through it the loaded document). In addition, it
      provides you with methods for manipulating the current window, acting
      like a user (visiting pages, filling forms, clicking prompts, etc.) and
      inspecting the window contents (using XPath or CSS selectors).</p><p class="calibre3">For example, to fill in the username and password, submit a form
      and then test the contents of the title element:</p><pre class="screen">// Fill email, password, and submit form.
browser.
  fill("email", "zombie@underworld.dead").
  fill("password", "eat-the-living").
  pressButton("Sign Me Up!", function(err, browser) {
   // Form submitted, new page loaded.
   assert.equal(browser.text("title"), "Welcome to Brains Depot");
  });</pre><p class="calibre3">This example is incomplete. Obviously, you’ll need to require the
      Zombie.js library, create a new <code class="literal">Browser</code>, and load the
      page before you can interact with it. You also want to take care of that
      err argument.</p><p class="calibre3">Just like a web browser, Zombie.js is asynchronous in nature: your
      code doesn’t block waiting for a page to load, an event to fire, or a
      timer to timeout. Instead, you can either register listeners for events
      such as <span class="calibre1"><em class="calibre4">loaded</em></span> and <span class="calibre1"><em class="calibre4">error</em></span>, or
      pass a callback.</p><p class="calibre3">By convention, when you pass Zombie a callback, it will use it one
      of two ways. If the action was successful, it will pass null and some
      other value, most often a reference to the <code class="literal">Browser</code>
      object. If the action failed, it will pass a reference to the
      <code class="literal">Error</code> object. So, make sure to check the first
      argument to determine whether your request completed successfully, and
      whether there’s anything interesting in the remaining arguments.</p><p class="calibre3">This convention is common to Node.js and many libraries written
      for it, including the aforementioned Vows.js test framework. Vows.js
      also uses callbacks, which it expects to be called with one argument
      that is error or null; if that argument is null, a second argument is
      passed along to the test case.</p><p class="calibre3">Here, for example, is a test case that uses Zombie.js and Vows.js.
      It visits a web page and looks for elements with the class
      <span class="calibre1"><em class="calibre4">brains</em></span> (expecting to find none):</p><pre class="screen">var zombie  = require("zombie");

vows.describe("Zombie lunch").addBatch({
  "visiting home page": {
    topic: function() {
      var browser = new zombie.Browser;
      browser.cookies("localhost").update("session_id=5678");
      browser.visit("http://localhost:3003/", this.callback);
    },
    "should find no brains": function(browser) {
      assert.isEmpty(browser.css(".brains"));
    } 
  }
});</pre><p class="calibre3">There are many other things you can do with Zombie.js. For
      example, you can save the browser state (cookies, history, web storage,
      etc.) after running one test and use that state to run other tests (to
      start each test from the state of “new session and user logged
      in”).</p><p class="calibre3">You can also fire DOM events—e.g., to simulate a mouse click—or
      respond to confirmation prompts and alerts. You can view the history of
      requests and responses, similar to the Resources tab in WebKit’s Web
      Inspector. Although Zombie runs on Node.js, it can make HTTP requests to
      any web server, so you can certainly use it to test your Ruby or Python
      application.</p></div><div class="book" title="Ichabod"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2930388" class="calibre12"></a>Ichabod</h2></div></div></div><p class="calibre3"><a id="I_indexterm9_d1e8798" class="calibre1"></a><a id="I_indexterm9_d1e8805" class="calibre1"></a><a id="I_indexterm9_d1e8810" class="calibre1"></a><a id="I_indexterm9_d1e8813" class="calibre1"></a>The imaginatively named <a class="ulink" href="http://github.com/maccman/ichabod">Ichabod</a> library is
      another alternative for running tests headlessly, and it is a great
      solution if you’re after simplicity and speed.</p><p class="calibre3">The advantage to Ichabod is that, rather than an emulation of the
      DOM and parser engine, it uses WebKit—the browser engine behind Safari
      and Chrome. However, Ichabod works only on OS X, as it requires MacRuby
      and the OS X WebView APIs.</p><p class="calibre3">Installation is pretty straightforward. First, install
      MacRuby,<a id="I_indexterm9_d1e8826" class="calibre1"></a> either off the project’s <a class="ulink" href="http://www.macruby.org">site</a> or with <a class="ulink" href="http://rvm.beginrescueend.com/interpreters/macruby/">rvm</a>.
      Then, install the Ichabod gem:</p><pre class="screen">$ macgem install ichabod</pre><p class="calibre3">Ichabod currently supports running Jasmine or QUnit tests,
      although additional libraries will be supported soon. Simply pass the
      test’s endpoint to the <code class="literal">ichabod</code>
      executable:</p><pre class="screen">$ ichabod --jasmine http://path/to/jasmine/specs.html
$ ichabod --qunit http://path/to/qunit/tests.html</pre><p class="calibre3">The tests don’t have to be hosted—you can also pass a local
      path:</p><pre class="screen">$ ichabod --jasmine ./tests/index.html
    ...
    Finished in 0.393 seconds
    1 test, 5 assertions, 0 failures</pre><p class="calibre3">Ichabod will load up all your tests and run them in a GUI-less
      version of WebKit, straight from the command line.<a id="I_indexterm9_d1e8851" class="calibre1"></a><a id="I_indexterm9_d1e8852" class="calibre1"></a></p></div></div></div>

{% endraw %}

