---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch04s02.html
next: OEBPS/ch04s04.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="State Machines"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect14_d1e4450" class="calibre1"></a>State Machines</h1></div></div></div><p class="calibre3"><a id="I_indexterm4_d1e4454" class="calibre1"></a><a id="I_indexterm4_d1e4459" class="calibre1"></a>State machines—or to use their proper term, <span class="calibre1"><em class="calibre4">Finite
    State Machines</em></span> (FSMs)<a id="I_indexterm4_d1e4466" class="calibre1"></a><a id="I_indexterm4_d1e4469" class="calibre1"></a>—are a great way to program UIs.<a id="I_indexterm4_d1e4473" class="calibre1"></a> Using state machines, you can easily manage multiple
    controllers, showing and hiding views as necessary. So, what exactly is a
    state machine? At its core, a state machine consists of two things: states
    and transitions. It has only one active state, but it has a multitude of
    passive states. When the active state switches, transitions between the
    states are called.</p><p class="calibre3">How does this work in practice? Well, consider having a few
    application views that need to be displayed independently—say, a view for
    showing contacts and a view for editing contacts. These two views need to
    be displayed exclusively—when one is shown, the other view needs to be
    hidden. This is a perfect scenario to introduce a state machine because it
    will ensure that only one view is active at any given time. Indeed, if we
    want to add additional views, such as a settings view, using a state
    machine makes this trivial.</p><p class="calibre3">Let’s flesh out a practical example that will give you a good idea
    of how state machines can be implemented. The example is simple and
    doesn’t cater to different transition types, but it is sufficient for our
    needs. First, we’re going to create an <code class="literal">Events</code> object that will use jQuery’s event API
    (as discussed in <a class="ulink" href="ch02.html" title="Chapter 2. Events and Observing">Chapter 2</a>) to add the ability
    to bind and trigger events on our state machine:</p><pre class="screen">var Events = {
  bind: function(){
    if ( !this.o ) this.o = $({});
    this.o.bind.apply(this.o, arguments);
  },

  trigger: function(){
    if ( !this.o ) this.o = $({});
    this.o.trigger.apply(this.o, arguments);
  }
};</pre><p class="calibre3">The <code class="literal">Events</code> object is essentially
    extending jQuery’s existing event support outside the DOM so that we can
    use it in our own library. Now let’s set about creating the <code class="literal">StateMachine</code> class, which will have one main
    function, <code class="literal">add(</code><code class="literal">)</code>:</p><pre class="screen">var StateMachine = function(){};
StateMachine.fn  = StateMachine.prototype;

// Add event binding/triggering
$.extend(StateMachine.fn, Events);

StateMachine.fn.add = function(controller){
  this.bind("change", function(e, current){
    if (controller == current)
      controller.activate();
    else
      controller.deactivate();
  });

  controller.active = $.proxy(function(){
    this.trigger("change", controller);
  }, this);
};</pre><p class="calibre3">The state machine’s <code class="literal">add()</code>
    function adds the passed controller to the list of states and creates an
    <code class="literal">active()</code> function. When <code class="literal">active()</code> is called, the active state will
    transition to the controller. The state machine will call <code class="literal">activate()</code> on the active controller and <code class="literal">deactivate()</code> on all the other controllers. We
    can see how this works by creating two example controllers, adding them to
    the state machine, and then activating one of them:</p><pre class="screen">var con1 = {
  activate:   function(){ /* ... */ },
  deactivate: function(){ /* ... */ }
};

var con2 = {
  activate:   function(){ /* ... */ },
  deactivate: function(){ /* ... */ }
};

// Create a new StateMachine and add states
var sm = new StateMachine;
sm.add(con1);
sm.add(con2);

// Activate first state
con1.active();</pre><p class="calibre3">The state machine’s <code class="literal">add()</code>
    function works by creating a callback for the <span class="calibre1"><em class="calibre4">change</em></span>
    event, calling the <code class="literal">activate()</code><a id="I_indexterm4_d1e4532" class="calibre1"></a> or <code class="literal">deactivate()</code><a id="I_indexterm4_d1e4540" class="calibre1"></a><a id="I_indexterm4_d1e4543" class="calibre1"></a> function, depending on which is appropriate. Although the
    state machine gives us an <code class="literal">active()</code>
    function, we can also change the state by manually triggering the
    <span class="calibre1"><em class="calibre4">change</em></span> event:<a id="I_indexterm4_d1e4556" class="calibre1"></a><a id="I_indexterm4_d1e4561" class="calibre1"></a></p><pre class="screen">sm.trigger("change", con2);</pre><p class="calibre3">Inside our controller’s <code class="literal">activate()</code> function, we can set up and display
    its view, adding and showing elements. Likewise, inside the <code class="literal">deactivate()</code> function, we can tear down anything
    that is hiding the view. CSS classes offer a good way of hiding and
    showing views. Simply add a class—say, <code class="literal">.active</code>—when the view is active, and remove it
    upon deactivation:</p><pre class="screen">var con1 = {
  activate: function(){
    $("#con1").addClass("active");
  },
  deactivate: function(){ 
    $("#con1").removeClass("active");
  }
};

var con2 = {
  activate: function(){
    $("#con2").addClass("active");
  },
  deactivate: function(){ 
    $("#con2").removeClass("active");
  }
};</pre><p class="calibre3">Then, in your stylesheets, make sure that the views have a <code class="literal">.active</code> class; otherwise, they’re hidden:</p><pre class="screen">#con1, #con2 { display: none; }
#con1.active, #con2.active { display: block; }</pre><p class="calibre3">You can see the full examples in
    <span class="calibre1"><em class="calibre4">assets/ch04/state_machine.html</em></span>.</p></div></div>

{% endraw %}

