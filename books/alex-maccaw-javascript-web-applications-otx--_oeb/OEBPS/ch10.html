---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch09s10.html
next: OEBPS/ch10s02.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre7"></div><div class="book" title="Chapter 10. Deploying"><div class="book"><div class="book"><div class="book"><div class="calibre7"></div><h1 class="title1"><a id="deploying" class="calibre1"></a>Chapter 10. Deploying</h1></div></div></div><p class="calibre3"><a id="index-122M728WT2G" class="calibre1"></a>Deploying your web application properly is just as important
  as actually developing it; there’s no point in building the next Facebook if
  it loads too slowly for people to actually use it. Users want your site to
  be as reliable and fast as possible, with good uptime. Deploying JavaScript
  and HTML files sounds straightforward—they’re static assets after all—but
  there’s actually a fair amount to it. This is an often neglected part to web
  application building.</p><p class="calibre3">Luckily, there are a few tried-and-tested techniques that should apply
  to all JavaScript applications, and indeed serving any kind of static
  assets. If you follow the recommendations below, you should be well on your
  way to delivering speedy web apps.</p><div class="book" title="Performance"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect110_d1e9591" class="calibre1"></a>Performance</h1></div></div></div><p class="calibre3"><a id="I_indexterm10_d1e9595" class="calibre1"></a><a id="I_indexterm10_d1e9600" class="calibre1"></a>One of the simplest ways of increasing performance is also
    the most obvious: minimize the amount of HTTP requests.<a id="I_indexterm10_d1e9606" class="calibre1"></a> Every HTTP request contains a lot of header information, as
    well as the TCP overhead. Keeping separate connections to an absolute
    minimum will ensure pages load faster for users. This clearly extends to
    the amount of data the server needs to transfer. Keeping a page and its
    assets’ file size low will decrease any network time—the real bottleneck
    to any application on the Web.</p><p class="calibre3">Concatenating scripts into a single script and combining CSS into a
    single stylesheet will reduce the amount of HTTP connections needed to
    render the page. You can do this upon deployment or at runtime. If it’s
    the latter, make sure any files generated are cached in production.</p><p class="calibre3">Use CSS sprites <a id="I_indexterm10_d1e9614" class="calibre1"></a>to combine images into one comprehensive image. Then, use
    the CSS <code class="literal">background-image</code> and <code class="literal">background-position</code> properties to display the
    relevant images in your page. You just have to scope the background
    position coordinates to cover the desired image.</p><p class="calibre3">Avoiding redirects also keeps the number of HTTP requests to a
    minimum. You may think these are fairly uncommon, but one of the most
    frequent redirect scenarios occurs when a trailing slash (<span class="calibre1"><strong class="calibre18">/</strong></span>) is missing from a URL that should otherwise
    have one. For example, going to <span class="calibre1"><em class="calibre4">http://facebook.com</em></span>
    currently redirects you to <span class="calibre1"><em class="calibre4">http://facebook.com/</em></span>. If
    you’re using Apache, you can fix this by using Alias or
    mod_rewrite.</p><p class="calibre3">It’s also important to understand how your browser <a id="I_indexterm10_d1e9637" class="calibre1"></a>downloads resources. To speed up page rendering, modern
    browsers download required resources in parallel. However, the page can’t
    start rendering until all the stylesheets and scripts have finished
    downloading. Some browsers go even further, blocking all other downloads
    while any JavaScript files are being processed.</p><p class="calibre3">However, most scripts <a id="I_indexterm10_d1e9645" class="calibre1"></a>need to access the DOM and add things like event handlers,
    which are executed after the page loads. In other words, the browser is
    needlessly restricting the page rendering until everything’s finished
    downloading, decreasing performance. You can solve this by setting the
    <code class="literal">defer</code> attribute on scripts, letting the
    browser know the script won’t need to manipulate the DOM until after the
    page has loaded:</p><pre class="screen">&lt;script src="foo.js" type="text/javascript" charset="utf-8" defer&gt;&lt;/script&gt;</pre><p class="calibre3">Scripts with the <code class="literal">defer</code> attribute
    <a id="I_indexterm10_d1e9659" class="calibre1"></a><a id="I_indexterm10_d1e9662" class="calibre1"></a>set to “defer” will be downloaded in parallel with other
    resources and won’t prevent page rendering. HTML5 has also introduced a
    new mode of script downloading and execution called <code class="literal">async</code>. By setting the <code class="literal">async</code> attribute,<a id="I_indexterm10_d1e9674" class="calibre1"></a><a id="I_indexterm10_d1e9678" class="calibre1"></a> the script will be executed at the first opportunity after
    it’s finished downloading. This means it’s possible (and likely) that
    async scripts are not executed in the order in which they occur in the
    page, leaving an opportunity for dependency errors. If the script doesn’t
    have any dependencies, though, async is a useful tool. Google
    Analytics,<a id="I_indexterm10_d1e9684" class="calibre1"></a> for example, takes advantage of it by default:</p><pre class="screen">&lt;script src="http://www.google-analytics.com/ga.js" async&gt;&lt;/script&gt;</pre></div></div></div>

{% endraw %}

