---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch11s06.html
next: OEBPS/ch12s02.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre7"></div><div class="book" title="Chapter 12. The Backbone Library"><div class="book"><div class="book"><div class="book"><div class="calibre7"></div><h1 class="title1"><a id="libraries---backbone" class="calibre1"></a>Chapter 12. The Backbone Library</h1></div></div></div><p class="calibre3"><a id="index-452P227UO8J" class="calibre1"></a><a id="index-866W001MC5I" class="calibre1"></a>Backbone is an excellent library for building JavaScript
  applications. Its beauty is in its simplicity; the library is very
  lightweight, giving you a great deal of flexibility while covering all the
  basics. As with the rest of this book, MVC is the name of the game, and that
  pattern runs right through the core of Backbone. The library gives you
  models, controllers, and views—the building blocks for your
  application.</p><p class="calibre3">How is Backbone different from other frameworks, such as SproutCore or
  Cappuccino? Well, the main difference is Backbone’s lightweight nature.
  SproutCore <a id="I_indexterm12_d1e11804" class="calibre1"></a>and Cappuccino <a id="I_indexterm12_d1e11808" class="calibre1"></a>provide rich UI widgets and vast core libraries, and they
  determine the structure of your HTML for you. Both frameworks measure in the
  hundreds of kilobytes when packed and gzipped, as well as many megabytes of
  JavaScript, CSS, and images when loaded in the browser. By comparison,
  Backbone measures just 4 KB, providing purely the core concepts of models,
  events, collections, views, controllers, and persistence.</p><p class="calibre3">Backbone’s only hard dependency is <a class="ulink" href="http://documentcloud.github.com/underscore">underscore.js</a><a id="I_indexterm12_d1e11816" class="calibre1"></a><a id="I_indexterm12_d1e11819" class="calibre1"></a>, a library full of useful utilities and general-purpose
  JavaScript functions. Underscore provides more than 60 functions that deal
  with—among other things—array manipulation, function binding, JavaScript
  templating, and deep-equality testing. It’s definitely worth checking out
  Underscore’s API, <a id="I_indexterm12_d1e11825" class="calibre1"></a>especially if you’re doing a lot of work with arrays. Other
  than Underscore, you can safely use jQuery or Zepto.js<a id="I_indexterm12_d1e11831" class="calibre1"></a> to help Backbone with view functionality.</p><p class="calibre3">Although it’s well documented, Backbone can be a little overwhelming
  when you first get into it. The aim of this chapter is to rectify that
  situation, giving you an in-depth and practical introduction to the library.
  The first few sections will be an overview of Backbone’s components, and
  then we’ll finish with a practical application. Feel free to skip straight
  to the end if you want to see Backbone in action.</p><div class="book" title="Models"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect112_d1e11837" class="calibre1"></a>Models</h1></div></div></div><p class="calibre3"><a id="I_indexterm12_d1e11841" class="calibre1"></a><a id="I_indexterm12_d1e11846" class="calibre1"></a>Let’s start with probably the most key component to MVC:
    models. Models are where your application’s data is kept. Think of models
    as a fancy abstraction upon the <span class="calibre1">application’s</span> raw data, adding utility
    functions and events. You can create Backbone models by calling the
    <code class="literal">extend()</code> function <a id="I_indexterm12_d1e11858" class="calibre1"></a><a id="I_indexterm12_d1e11861" class="calibre1"></a>on <code class="literal">Backbone.Model</code>:</p><pre class="screen">var User = Backbone.Model.extend({
  initialize: function() {
    // ...
  }
});</pre><p class="calibre3">The first argument to <code class="literal">extend()</code>
    takes an object that becomes the instance properties of the model. The
    second argument is an optional class property hash. You can call <code class="literal">extend()</code> multiple times to generate subclasses
    of models, which inherit all their parents’ class and instance
    properties:</p><pre class="screen">var User = Backbone.Model.extend({
  // Instance properties
  instanceProperty: "foo"
}, {
  // Class properties
  classProperty: "bar"
});

assertEqual( User.instanceProperty, "foo" );
assertEqual( User.prototype.classProperty, "bar" );</pre><p class="calibre3">When a model is instantiated, the model’s <code class="literal">initialize()</code> instance function <a id="I_indexterm12_d1e11887" class="calibre1"></a><a id="I_indexterm12_d1e11890" class="calibre1"></a>is called with any instantiation arguments. Behind the
    scenes, Backbone models are constructor functions, so you can instantiate
    a new instance by using the <code class="literal">new</code>
    keyword:</p><pre class="screen">var User = Backbone.Model.extend({
  initialize: function(name) {
    this.set({name: name});
  }
});

var user = new User("Leo McGarry");
assertEqual( user.get("name"), "Leo McGarry");</pre><div class="book" title="Models and Attributes"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2938274" class="calibre12"></a>Models and Attributes</h2></div></div></div><p class="calibre3"><a id="I_indexterm12_d1e11905" class="calibre1"></a>Use the <code class="literal">set()</code><a id="I_indexterm12_d1e11913" class="calibre1"></a><a id="I_indexterm12_d1e11916" class="calibre1"></a> and <code class="literal">get()</code> functions <a id="I_indexterm12_d1e11925" class="calibre1"></a><a id="I_indexterm12_d1e11928" class="calibre1"></a>for setting and retrieving an instances’
      attributes:</p><pre class="screen">var user = new User();
user.set({name: "Donna Moss"})

assertEqual( user.get("name"), "Donna Moss" );
assertEqual( user.attributes, {name: "Donna Moss"} );</pre><p class="calibre3"><code class="literal">set(attrs, [options])</code> takes a
      hash of attributes to apply to the instance, and <code class="literal">get(attr)</code> takes a single string argument—the
      name of the attribute—returning <span class="calibre1">its
      value</span>. The instance keeps track of its current attributes with
      a local hash called <code class="literal">attributes</code>. You
      shouldn’t manipulate this directly; as with the <code class="literal">get()</code> and <code class="literal">set()</code> functions, make sure the appropriate
      validation and events are invoked.</p><p class="calibre3">You can validate an instance’s attributes <a id="I_indexterm12_d1e11957" class="calibre1"></a>by using the <code class="literal">validate()</code>
      function.<a id="I_indexterm12_d1e11966" class="calibre1"></a><a id="I_indexterm12_d1e11969" class="calibre1"></a> By default, this is left undefined, but you can override
      it to add any custom validation logic:</p><pre class="screen">var User = Backbone.Model.extend({      
  validate: function(atts){
    if (!atts.email || atts.email.length &lt; 3) {
      return "email must be at least 3 chars";
    }
  }
});</pre><p class="calibre3">If the model and attributes are valid, don’t return anything from
      <code class="literal">validate()</code>; if the attributes are
      invalid, you can either return a string describing the error or an
      <code class="literal">Error</code> instance. If validation fails,
      the <code class="literal">set()</code> and <code class="literal">save()</code> functions will not continue and an
      <span class="calibre1"><em class="calibre4">error</em></span> event will be triggered. You can bind to the
      <em class="calibre4">error</em> event,<a id="I_indexterm12_d1e11998" class="calibre1"></a><a id="I_indexterm12_d1e12001" class="calibre1"></a> ensuring that you’ll be notified when any validation
      fails:</p><pre class="screen">var user = new User;

user.bind("error", function(model, error) {
  // Handle error
});

user.set({email: "ga"});

// Or add an error handler onto the specific set
user.set({"email": "ga"}, {error: function(model, error){
  // ...
}});</pre><p class="calibre3">Specify default attributes with a <code class="literal">default</code> hash.<a id="I_indexterm12_d1e12014" class="calibre1"></a> When creating an instance of the model, any unspecified
      attributes will be set to their default value:</p><pre class="screen">var Chat = Backbone.Model.extend({
  defaults: {
    from: "anonymous"
  }
});

assertEqual( (new Chat).get("from"), "anonymous" );</pre></div></div></div></div>

{% endraw %}

