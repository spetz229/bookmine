---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch01s05.html
next: OEBPS/ch01s07.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Adding Methods to Our Class Library"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect11_d1e965" class="calibre1"></a>Adding Methods to Our Class Library</h1></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e969" class="calibre1"></a><a id="I_indexterm1_d1e974" class="calibre1"></a><a id="I_indexterm1_d1e979" class="calibre1"></a>Currently, our class library includes functionality for
    instantiating and initializing instances. Adding properties <a id="I_indexterm1_d1e985" class="calibre1"></a>to classes is the same as adding properties to constructor
    functions.</p><p class="calibre3">Properties set directly on the class will be equivalent to static
    members:</p><pre class="screen">var Person = new Class;

// Static functions are added directly on the class
Person.find = function(id){ /* ... */ };

// And now we can call them directly
var person = Person.find(1);</pre><p class="calibre3">And properties set on the class’ prototype are also available on
    instances:</p><pre class="screen">var Person = new Class;

// Instance functions are on the prototype
Person.prototype.save = function(){ /* ... */ };

// And now we can call them on instances
var person = new Person;
person.save();</pre><p class="calibre3">However, in my opinion, that syntax is a little convoluted,
    impractical, and repetitive. It’s difficult to see, at a glance, a list of
    your class’ static and instance properties. Instead, let’s create a
    different way of adding properties to our classes using two functions,
    <code class="literal">extend()</code><a id="I_indexterm1_d1e1003" class="calibre1"></a><a id="I_indexterm1_d1e1006" class="calibre1"></a> and <code class="literal">include()</code><a id="I_indexterm1_d1e1014" class="calibre1"></a><a id="I_indexterm1_d1e1017" class="calibre1"></a>:</p><pre class="screen">var Class = function(){
  var klass = function(){
    this.init.apply(this, arguments);
  };

  klass.prototype.init  = function(){};

  // Shortcut to access prototype
  klass.fn = klass.prototype;

  // Shortcut to access class
  klass.fn.parent = klass;

  // Adding class properties
  klass.extend = function(obj){
    var extended = obj.extended;
    for(var i in obj){
      klass[i] = obj[i];
    }
    if (extended) extended(klass)
  };

  // Adding instance properties
  klass.include = function(obj){
    var included = obj.included;
    for(var i in obj){
      klass.fn[i] = obj[i];
    }
    if (included) included(klass)
  };

  return klass;
};</pre><p class="calibre3">In the improved class library above, we’re adding an <code class="literal">extend()</code> function to generated classes, which
    accepts an object. The object’s properties are iterated through and copied
    directly onto the class:</p><pre class="screen">var Person = new Class;

Person.extend({
  find:   function(id) { /* ... */ },
  exists: functions(id) { /* ... */ }
});

var person = Person.find(1);</pre><p class="calibre3">The <code class="literal">include()</code> function works in
    exactly the same way, except properties are copied onto the class’
    prototype, rather than directly onto the class. In other words, the
    properties are on the class’ instance, rather than statically on the
    class.</p><pre class="screen">var Person = new Class;

Person.include({
  save:    function(id) { /* ... */ },
  destroy: functions(id) { /* ... */ }
});

var person = new Person;
person.save();</pre><p class="calibre3">We’re also implementing support for <code class="literal">extended</code> and <code class="literal">included</code> callbacks.<a id="I_indexterm1_d1e1048" class="calibre1"></a> If these properties are present on the passed object,
    they’ll be invoked:</p><pre class="screen">Person.extend({
  extended: function(klass) {
    console.log(klass, " was extended!");
  }
});</pre><p class="calibre3">If you’ve used classes in Ruby, this should all look very familiar.
    The beauty of this approach is that we’ve now got support for modules.
    Modules are reusable pieces of code, and they can be used as an
    alternative to inheritance for sharing common properties among
    classes.</p><pre class="screen">var ORMModule = {
  save: function(){
    // Shared function
  }
};

var Person = new Class;
var Asset  = new Class;

Person.include(ORMModule);
Asset.include(ORMModule);</pre></div></div>

{% endraw %}

