---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch03.html
next: OEBPS/ch03s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Building an ORM"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect13_d1e2639" class="calibre1"></a>Building an ORM</h1></div></div></div><p class="calibre3"><a id="index-180T574IR2A" class="calibre1"></a><a id="index-676J158GQ2N" class="calibre1"></a>Object-relational mappers, or ORMs, are typically used in
    languages other than JavaScript. However, they’re a very useful technique
    for data management as well as a great way of using models in your
    JavaScript application. With an ORM, for example, you can tie up a model
    with a remote server—any changes to model instances will send background
    Ajax requests to the server. Or, you could tie up a model instance with an
    HTML element—any changes to the instance will be reflected in the view.
    I’ll elaborate on those examples later, but for now, let’s look at
    creating a custom ORM.</p><p class="calibre3">Essentially, an ORM is just an object layer wrapping some data.
    Typically, ORMs are used to abstract SQL databases, but in our case, the
    ORM will just be abstracting JavaScript data types. The advantage of this
    extra layer is that we can enhance the basic data with more functionality
    by adding our own custom functions and properties. This lets us add things
    like validation, observers, persistence, and server callbacks while still
    being able to reuse a lot of code.</p><div class="book" title="Prototypal Inheritance"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2914906" class="calibre12"></a>Prototypal Inheritance</h2></div></div></div><p class="calibre3"><a id="I_indexterm3_d1e2658" class="calibre1"></a><a id="I_indexterm3_d1e2663" class="calibre1"></a><a id="I_indexterm3_d1e2668" class="calibre1"></a>We’re going to use
      <code class="literal">Object.create()</code><a id="I_indexterm3_d1e2676" class="calibre1"></a><a id="I_indexterm3_d1e2679" class="calibre1"></a> to construct our ORM, which is a little different from
      the class-based examples we covered in <a class="ulink" href="ch01.html" title="Chapter 1. MVC and Classes">Chapter 1</a>.
      This will allow us to use <span class="calibre1">prototype</span>-based inheritance, rather than
      using constructor functions and the <code class="literal">new</code> <span class="calibre1">keyword</span>.</p><p class="calibre3"><code class="literal">Object.create()</code> takes one
      argument, a prototype object, and returns a new object with the
      specified prototype object. In other words, you give it an object, and
      it returns a new one, inheriting from the one you specified.</p><p class="calibre3"><code class="literal">Object.create()</code> was recently
      added to ECMAScript, 5th Edition, so it isn’t implemented in some
      browsers, such as IE. However, this doesn’t pose a problem since we can
      easily add support if needed:</p><pre class="screen">if (typeof Object.create !== "function")
    Object.create = function(o) {
      function F() {}
      F.prototype = o;
      return new F();
    };</pre><p class="calibre3">The example above was taken from Douglas Crockford’s article on
      <a class="ulink" href="http://javascript.crockford.com/prototypal.html">Prototypal
      Inheritance</a>. Check it out if you want a more in-depth
      explanation behind JavaScript prototypes and inheritance.</p><p class="calibre3">We’re going to create a <code class="literal">Model</code>
      object, which will be in charge of creating new models and
      instances:</p><pre class="screen">var Model = {
  inherited: function(){},
  created: function(){},

  prototype: {
    init: function(){}
  },

  create: function(){
    var object = Object.create(this);
    object.parent = this;
    object.prototype = object.fn = Object.create(this.prototype);

    object.created();
    this.inherited(object);
    return object;
  },

  init: function(){
    var instance = Object.create(this.prototype);
    instance.parent = this;
    instance.init.apply(instance, arguments);
    return instance;
  }
};</pre><p class="calibre3">If you’re unfamiliar with <code class="literal">Object.create()</code>, this may look daunting, so
      let’s break it down. The <code class="literal">create()</code>
      function returns a new object, inheriting from the <code class="literal">Model</code> object; we’ll use this for creating new
      models. The <code class="literal">init()</code> function
      <a id="I_indexterm3_d1e2733" class="calibre1"></a><a id="I_indexterm3_d1e2736" class="calibre1"></a>returns a new object, inheriting from <code class="literal">Model.prototype</code>—i.e., an instance of the
      <code class="literal">Model</code> object:</p><pre class="screen">var Asset = Model.create();
var User  = Model.create();

var user = User.init();</pre></div><div class="book" title="Adding ORM Properties"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2915131" class="calibre12"></a>Adding ORM Properties</h2></div></div></div><p class="calibre3"><a id="I_indexterm3_d1e2755" class="calibre1"></a><a id="I_indexterm3_d1e2760" class="calibre1"></a>Now, if we add properties to <code class="literal">Model</code>, they’ll be available on all inherited
      models:</p><pre class="screen">// Add object properties
jQuery.extend(Model, {
  find: function(){}
});

// Add instance properties
jQuery.extend(Model.prototype, {
  init: function(atts) {
    if (atts) this.load(atts);
  },

  load: function(attributes){
    for(var name in attributes)
      this[name] = attributes[name];
  }
});</pre><p class="calibre3"><code class="literal">jQuery.extend()</code><a id="I_indexterm3_d1e2774" class="calibre1"></a> is just a shorthand way of using a <code class="literal">for</code> loop to copy over properties manually,
      which is similar to what we’re doing in the <code class="literal">load()</code> function. Now, our object and instance
      properties are propagating down to our individual models:</p><pre class="screen">assertEqual( typeof Asset.find, "function" );</pre><p class="calibre3">In fact, we’re going to be adding a lot of properties, so we might
      as well make <code class="literal">extend()</code> and <code class="literal">include()</code> part of the <code class="literal">Model</code>
      object:</p><pre class="screen">var Model = {
  /* ... snip ... */

  extend: function(o){
    var extended = o.extended;
    jQuery.extend(this, o);
    if (extended) extended(this);
  },

  include: function(o){
    var included = o.included;
    jQuery.extend(this.prototype, o);
    if (included) included(this);
  }
};

// Add object properties
Model.extend({
  find: function(){}
});

// Add instance properties
Model.include({
  init: function(atts) { /* ... */ },
  load: function(attributes){ /* ... */ }
});</pre><p class="calibre3">Now, we can create new assets and set some attributes:</p><pre class="screen">var asset = Asset.init({name: "foo.png"});</pre></div><div class="book" title="Persisting Records"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2915256" class="calibre12"></a>Persisting Records</h2></div></div></div><p class="calibre3"><a id="I_indexterm3_d1e2807" class="calibre1"></a><a id="I_indexterm3_d1e2812" class="calibre1"></a><a id="I_indexterm3_d1e2817" class="calibre1"></a>We need a way of persisting records—i.e., of saving a
      reference to created instances so we can access them later. We’ll do
      that using a <code class="literal">records</code> object, set on the
      <code class="literal">Model</code>. When we’re saving an instance, we’ll add it to
      that object; when deleting instances, we’ll remove them from the
      object:</p><pre class="screen">// An object of saved assets
Model.records = {};

Model.include({
  newRecord: true,

  create: function(){
    this.newRecord = false;
    this.parent.records[this.id] = this;
  },

  destroy: function(){
    delete this.parent.records[this.id];
  }
});</pre><p class="calibre3">What about updating an existing instance? Easy—just update the
      object reference:</p><pre class="screen">Model.include({
  update: function(){
    this.parent.records[this.id] = this;
  }
});</pre><p class="calibre3">Let’s create a convenience function to save an instance, so we
      don’t have to check to see whether the instance was saved previously, or
      whether it needs to be created:</p><pre class="screen">// Save the object to the records hash, keeping a reference to it
Model.include({
  save: function(){
    this.newRecord ? this.create() : this.update();            
  }
});</pre><p class="calibre3">And what about implementing that <code class="literal">find()</code> function,<a id="I_indexterm3_d1e2844" class="calibre1"></a><a id="I_indexterm3_d1e2847" class="calibre1"></a> so we can find assets by their ID?</p><pre class="screen">Model.extend({
  // Find by ID, or raise an exception
  find: function(id){
    return this.records[id] || throw("Unknown record");
  }
});</pre><p class="calibre3">Now that we’ve succeeded in creating a basic ORM, let’s try it
      out:<a id="I_indexterm3_d1e2857" class="calibre1"></a><a id="I_indexterm3_d1e2858" class="calibre1"></a></p><pre class="screen">var asset  = Asset.init();
asset.name = "same, same";
asset.id   = 1
asset.save();

var asset2  = Asset.init();
asset2.name = "but different";
asset2.id   = 2;
asset2.save();

assertEqual( Asset.find(1).name, "same, same" );

asset2.destroy();</pre></div></div></div>

{% endraw %}

