---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch04.html
next: OEBPS/ch04s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Adding a Bit of Context"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect14_d1e4022" class="calibre1"></a>Adding a Bit of Context</h1></div></div></div><p class="calibre3"><a id="index-204R756SE2H" class="calibre1"></a><a id="index-373H161BG8J" class="calibre1"></a>Using a local context is a useful way of structuring
    modules, especially when it comes to registering callbacks <a id="I_indexterm4_d1e4035" class="calibre1"></a><a id="I_indexterm4_d1e4040" class="calibre1"></a>to events.<a id="I_indexterm4_d1e4044" class="calibre1"></a> As it stands, the context inside our module is <span class="calibre1">global—</span><code class="literal">this</code> is equal to <code class="literal">window</code>:</p><pre class="screen">(function(){
  assertEqual( this, window );
})();</pre><p class="calibre3">If we want to scope the context,<a id="I_indexterm4_d1e4063" class="calibre1"></a> we need to start adding functions onto an object. For
    example:</p><pre class="screen">(function(){
  var mod = {};

  mod.contextFunction = function(){
    assertEqual( this, mod );
  };

  mod.contextFunction();
})();</pre><p class="calibre3">The context inside <code class="literal">contextFunction()</code> is now local to our <code class="literal">mod</code> object. We can start using <code class="literal">this</code> without worrying about creating global
    variables. To give you a better indication of how it would be used in
    practice, let’s further flesh out that example:</p><pre class="screen">(function($){

  var mod = {};

  mod.load = function(func){
    $($.proxy(func, this));
  };

  mod.load(function(){
    this.view = $("#view");
  });

  mod.assetsClick = function(e){
    // Process click
  };

  mod.load(function(){
    this.view.find(".assets").click(
      $.proxy(this.assetsClick, this)
    );
  });

})(jQuery);</pre><p class="calibre3">We’re creating a <code class="literal">load()</code> function
    <a id="I_indexterm4_d1e4089" class="calibre1"></a><a id="I_indexterm4_d1e4092" class="calibre1"></a>that takes a callback, executing it when the page has
    loaded. Notice that we’re using <code class="literal">jQuery.proxy()</code><a id="I_indexterm4_d1e4100" class="calibre1"></a> to ensure that the callback is invoked in the correct
    context.</p><p class="calibre3">Then, when the page loads, we’re adding a click handler onto an
    element, giving it a local function, <code class="literal">assetsClick()</code>, as a callback. Creating a
    controller doesn’t need to be any more complicated than that. What’s
    important is that all of the controller’s state is kept local and
    encapsulated cleanly into a module.</p><div class="book" title="Abstracting into a Library"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2918492" class="calibre12"></a>Abstracting into a Library</h2></div></div></div><p class="calibre3"><a id="I_indexterm4_d1e4113" class="calibre1"></a><a id="I_indexterm4_d1e4118" class="calibre1"></a>Let’s abstract that library out so we can reuse it with
      other modules and controllers. We’ll include the existing <code class="literal">load()</code> function and add new ones like <code class="literal">proxy()</code><a id="I_indexterm4_d1e4129" class="calibre1"></a><a id="I_indexterm4_d1e4132" class="calibre1"></a> and <code class="literal">include()</code><a id="I_indexterm4_d1e4140" class="calibre1"></a><a id="I_indexterm4_d1e4144" class="calibre1"></a>:</p><pre class="screen">(function($, exports){
  var mod = function(includes){
    if (includes) this.include(includes);
  };
  mod.fn = mod.prototype;

  mod.fn.proxy = function(func){
    return $.proxy(func, this);
  };

  mod.fn.load = function(func){
    $(this.proxy(func));
  };

  mod.fn.include = function(ob){
    $.extend(this, ob);
  };

  exports.Controller = mod;
})(jQuery, window);</pre><p class="calibre3"><code class="literal">proxy()</code> ensures that functions
      are executed in the local context, which is a useful pattern for event
      callbacks. The <code class="literal">include()</code> function is
      just a shortcut for adding properties onto the controller, saving some
      typing.</p><p class="calibre3">We’re adding our library to the <code class="literal">exports</code> object, exposing it as the global
      <code class="literal">Controller</code> variable. Inside the
      module we can instantiate a <code class="literal">Controller</code> object using its constructor
      function. Let’s go through a simple example that toggles an element’s
      class depending on whether the mouse is over the element:</p><pre class="screen">(function($, Controller){

  var mod = new Controller;

  mod.toggleClass = function(e){ 
    this.view.toggleClass("over", e.data);
  };

  mod.load(function(){
    this.view = $("#view");
    this.view.mouseover(this.proxy(this.toggleClass), true);
    this.view.mouseout(this.proxy(this.toggleClass), false);
  });

})(jQuery, Controller);</pre><p class="calibre3">When the page loads, we’re creating a <code class="literal">view</code> variable and attaching some event
      listeners. They in turn call <code class="literal">toggleClass()</code><a id="I_indexterm4_d1e4179" class="calibre1"></a> when the mouse moves over the element, toggling the
      element’s class. You can see the full example in this book’s
      accompanying files, in
      <span class="calibre1"><em class="calibre4">assets/ch04/modules.html</em></span>.</p><p class="calibre3">Granted, using context rather than local variables means there is
      probably more code to write, what with all the usage of <code class="literal">this</code>. However, the technique gives us much
      greater scope for reusing code and including mixins. For example, we
      could add a function onto every <code class="literal">Controller</code> instance by setting a property on
      its <code class="literal">prototype</code>:</p><pre class="screen">Controller.fn.unload = function(func){
  jQuery(window).bind("unload", this.proxy(func));
};</pre><p class="calibre3">Or, we could extend an individual controller by using the <code class="literal">include()</code> function we defined earlier, passing
      it an object:</p><pre class="screen">var mod = new Controller;
mod.include(StateMachine);</pre><p class="calibre3">The <code class="literal">StateMachine</code> object, in
      this example, could be reused over and over again with our other
      modules, preventing us from duplicating code and keeping things DRY
      (don’t repeat yourself).</p></div><div class="book" title="Loading Controllers After the Document"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2918731" class="calibre12"></a>Loading Controllers After the Document</h2></div></div></div><p class="calibre3"><a id="I_indexterm4_d1e4216" class="calibre1"></a><a id="I_indexterm4_d1e4221" class="calibre1"></a>As it stands, some parts of our controllers are being
      loaded before the DOM, and other parts are in callbacks to be invoked
      after the page’s document has loaded. This can be confusing because the
      controller’s logic is being executed under different states, resulting
      in a lot of document load callbacks.</p><p class="calibre3">We can solve this in one fell swoop by loading controllers
      <span class="calibre1"><em class="calibre4">after</em></span> the DOM. I personally advocate this approach
      because it ensures that you don’t need to think constantly about what
      state the page’s DOM is in when accessing elements.</p><p class="calibre3">Let’s first take advantage and clear up our library, making our
      controllers a bit cleaner. The <code class="literal">Controller</code> class doesn’t need to be a
      constructor function because the context switch needed when generating
      subcontrollers is unnecessary here:</p><pre class="screen">// Use global context, rather than the window
// object, to create global variables
var exports = this;

(function($){
  var mod = {};

  mod.create = function(includes){
    var result = function(){
      this.init.apply(this, arguments);
    };

    result.fn = result.prototype;
    result.fn.init = function(){};

    result.proxy    = function(func){ return $.proxy(func, this); };
    result.fn.proxy = result.proxy;

    result.include = function(ob){ $.extend(this.fn, ob); }; 
    result.extend  = function(ob){ $.extend(this, ob); };
    if (includes) result.include(includes)

    return result;
  };

  exports.Controller = mod;
})(jQuery);</pre><p class="calibre3">Now we can use our new <code class="literal">Controller.create()</code> function to create
      controllers, passing in an object literal of instance properties. Notice
      that the entire controller is wrapped in <code class="literal">jQuery(function(){ /* ... */ })</code>. This is an
      alias for <code class="literal">jQuery.ready()</code>, and it
      ensures that the controller is loaded only after the page’s DOM has
      fully initialized:</p><pre class="screen">jQuery(function($){
  var ToggleView = Controller.create({
    init: function(view){
      this.view = $(view);
      this.view.mouseover(this.proxy(this.toggleClass), true);
      this.view.mouseout(this.proxy(this.toggleClass), false);          
    },

    this.toggleClass: function(e){
      this.view.toggleClass("over", e.data);          
    }
  });

  // Instantiate controller, calling init()
  new ToggleView("#view");
});</pre><p class="calibre3">The other significant change we’ve made is passing in the view
      element to the controller upon instantiation, rather than hardcoding it
      inside. This is an important refinement because it means we can start
      reusing controllers with different elements, keeping code repetition to
      a minimum.</p></div><div class="book" title="Accessing Views"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2918870" class="calibre12"></a>Accessing Views</h2></div></div></div><p class="calibre3"><a id="I_indexterm4_d1e4259" class="calibre1"></a><a id="I_indexterm4_d1e4264" class="calibre1"></a>A common pattern is to have one controller per view. That
      view has an ID, so it can be passed to controllers easily. Elements
      inside the view then use classes, rather than IDs, so they don’t
      conflict with elements in other views. This pattern provides a good
      structure for a general practice, but it should not be conformed to
      rigidly.</p><p class="calibre3">So far in this chapter we’ve been accessing views by using the
      <code class="literal">jQuery()</code> selector,<a id="I_indexterm4_d1e4275" class="calibre1"></a> storing a local reference to the view inside the
      controller. Subsequent searches for elements inside the view are then
      scoped by that view reference, speeding up their lookup:</p><pre class="screen">// ...  
init: function(view){
  this.view = $(view);
  this.form = this.view.find("form");
}</pre><p class="calibre3">However, it does mean that controllers fill up with a lot of
      selectors, requiring us to query the DOM constantly. We can clean this
      up somewhat by having one place in the controller where selectors are
      mapped to variables names, like so:</p><pre class="screen">elements: {
  "form.searchForm": "searchForm",
  "form input[type=text]": "searchInput"
}</pre><p class="calibre3">This ensures that the variables <code class="literal">this.searchForm</code> and <code class="literal">this.searchInput</code> will be created on the
      controller when it’s instantiated, set to their respective elements.
      These are normal jQuery objects, so we can manipulate them as usual,
      setting event handlers and fetching attributes.</p><p class="calibre3">Let’s implement support for that <code class="literal">elements</code> mapping <a id="I_indexterm4_d1e4298" class="calibre1"></a>inside our controllers, iterating over all the selectors
      and setting local variables. We’ll do this inside our <code class="literal">init()</code> function,<a id="I_indexterm4_d1e4307" class="calibre1"></a><a id="I_indexterm4_d1e4310" class="calibre1"></a> which is called when our controller is
      instantiated:</p><pre class="screen">var exports = this;

jQuery(function($){
  exports.SearchView = Controller.create({
    // Map of selectors to local variable names
    elements: {
      "input[type=search]": "searchInput",
      "form": "searchForm"
    },

    // Called upon instantiation
    init: function(element){
      this.el = $(element);
      this.refreshElements();
      this.searchForm.submit(this.proxy(this.search));
    },

    search: function(){
      console.log("Searching:", this.searchInput.val());
    },

    // Private

    $: function(selector){
      // An `el` property is required, and scopes the query
      return $(selector, this.el);
    },

    // Set up the local variables
    refreshElements: function(){
      for (var key in this.elements) {
        this[this.elements[key]] = this.$(key);
      }
    }
  });

  new SearchView("#users");
});</pre><p class="calibre3"><code class="literal">refreshElements()</code> expects every
      controller to have a current element property, <code class="literal">el</code>, which will scope any selectors. Once
      <code class="literal">refreshElements()</code> is called, the
      <code class="literal">this.searchForm</code> and <code class="literal">this.searchInput</code> properties will be set on the
      controller and are subsequently available for event binding and DOM
      manipulation.</p><p class="calibre3">You can see a full example of this in this book’s accompanying
      files, in <span class="calibre1"><em class="calibre4">assets/ch04/views.html</em></span>.</p></div><div class="book" title="Delegating Events"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2919080" class="calibre12"></a>Delegating Events</h2></div></div></div><p class="calibre3"><a id="I_indexterm4_d1e4343" class="calibre1"></a><a id="I_indexterm4_d1e4348" class="calibre1"></a><a id="I_indexterm4_d1e4353" class="calibre1"></a><a id="I_indexterm4_d1e4358" class="calibre1"></a>We can also take a stab at cleaning up all that event
      binding and proxying by having an <code class="literal">events</code> object that
      maps event types and selectors to callbacks. This is going to be very
      similar to the <code class="literal">elements</code> object, but
      instead will take the following form:</p><pre class="screen">events: {
  "submit form": "submit"
}</pre><p class="calibre3">Let’s go ahead and add that to our <code class="literal">SearchView</code> controller. Like <code class="literal">refreshElements()</code>, we’ll have a <code class="literal">delegateEvents()</code> function that will be called
      when the controller is instantiated. This will parse the controller’s
      <code class="literal">events</code> object, attaching event
      callbacks. In our <code class="literal">SearchView</code> example,
      we want the <code class="literal">search()</code> function to be
      invoked whenever the view’s <span class="calibre1"><code class="literal">&lt;form /&gt;</code></span> is submitted:</p><pre class="screen">var exports = this;

jQuery(function($){
  exports.SearchView = Controller.create({
    // Map all the event names, 
    // selectors, and callbacks
    events: {
      "submit form": "search"
    },

    init: function(){
      // ...
      this.delegateEvents();
    },

    search: function(e){ /* ... */ },

    // Private

    // Split on the first space
    eventSplitter: /^(\w+)\s*(.*)$/,

    delegateEvents: function(){
      for (var key in this.events) {
        var methodName = this.events[key];
        var method     = this.proxy(this[methodName]);

        var match      = key.match(this.eventSplitter);
        var eventName  = match[1], selector = match[2];

        if (selector === '') {
          this.el.bind(eventName, method);
        } else {
          this.el.delegate(selector, eventName, method);
        }
      }
    }
  });</pre><p class="calibre3">Notice we’re using the <code class="literal">delegate()</code> function <a id="I_indexterm4_d1e4404" class="calibre1"></a><a id="I_indexterm4_d1e4407" class="calibre1"></a>inside <code class="literal">delegateEvents()</code>, as well as the <code class="literal">bind()</code> function.<a id="I_indexterm4_d1e4419" class="calibre1"></a><a id="I_indexterm4_d1e4423" class="calibre1"></a> If the event selector isn’t provided, the event will be
      placed straight on <code class="literal">el</code>. Otherwise, the
      event will be <a class="ulink" href="http://api.jquery.com/delegate">delegated</a>, and it will be
      triggered if the event type is fired on a child matching the selector.
      The advantage of delegation is that it often reduces the amount of event
      listeners required—i.e., <span class="calibre1">listeners</span>
      don’t have to be placed on every element selected because events are
      caught dynamically when they bubble up.</p><p class="calibre3">We can push all those controller enhancements upstream to our
      <code class="literal">Controller</code> library so they can be
      reused in every controller. Here’s the finished example; you can find
      the full controller library in
      <span class="calibre1"><em class="calibre4">assets/ch04/finished_controller.html</em></span>:<a id="I_indexterm4_d1e4446" class="calibre1"></a><a id="I_indexterm4_d1e4447" class="calibre1"></a></p><pre class="screen">  var exports = this;

  jQuery(function($){
    exports.SearchView = Controller.create({
      elements: {
        "input[type=search]": "searchInput",
        "form": "searchForm"
      },

      events: {
        "submit form": "search"
      },

      init: function(){ /* ... */ },

      search: function(){
        alert("Searching: " + this.searchInput.val());
        return false;
      },
    });

    new SearchView({el: "#users"});
  });</pre></div></div></div>

{% endraw %}

