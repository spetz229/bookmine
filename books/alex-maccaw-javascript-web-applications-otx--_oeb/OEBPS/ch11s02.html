---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch11.html
next: OEBPS/ch11s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Classes"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect111_d1e10176" class="calibre1"></a>Classes</h1></div></div></div><p class="calibre3"><a id="index-423G214GK4K" class="calibre1"></a><a id="index-010J467DQ5R" class="calibre1"></a>Pretty much every object in Spine is encapsulated in a
    class. However, Spine’s classes are constructed using <code class="literal">Object.create()</code><a id="I_indexterm11_d1e10193" class="calibre1"></a><a id="I_indexterm11_d1e10196" class="calibre1"></a> and pure prototypal inheritance, as covered in <a class="ulink" href="ch03.html" title="Chapter 3. Models and Data">Chapter 3</a>, which is different from how most class
    abstractions are constructed.</p><p class="calibre3">To create a new class, call <code class="literal">Spine.Class.create([instanceProperties,
    classProperties])</code>, passing an optional set of instance and class
    properties:</p><pre class="screen">var User = Spine.Class.create({
  name: "Caroline"
});</pre><p class="calibre3">In the example above, instances of <code class="literal">User</code> now have a default name property. Behind
    the scenes, <code class="literal">create()</code> is creating a new
    object whose prototype is set to <code class="literal">Spine.Class</code> —i.e., <span class="calibre1">it’s inheriting from it. If you want to create
    subsequent subclasses, simply call <code class="literal">create</code></span><span class="calibre1"><code class="literal">()</code><a id="I_indexterm11_d1e10229" class="calibre1"></a><a id="I_indexterm11_d1e10232" class="calibre1"></a> on their parent class:</span></p><pre class="screen">var Friend = User.create();</pre><p class="calibre3"><code class="literal">Friend</code> is now a subclass of
    <code class="literal">User</code> and will inherit all of its
    properties:</p><pre class="screen">assertEqual( Friend.prototype.name, "Caroline" );</pre><div class="book" title="Instantiation"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2934207" class="calibre12"></a>Instantiation</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10253" class="calibre1"></a><a id="I_indexterm11_d1e10260" class="calibre1"></a>Because we’re using pure prototypal objects and
      inheritance instead of constructor functions, we can’t use the <code class="literal">new</code> keyword for instantiating instances.
      Rather, Spine uses the <code class="literal">init()</code>
      function:<a id="I_indexterm11_d1e10272" class="calibre1"></a><a id="I_indexterm11_d1e10277" class="calibre1"></a></p><pre class="screen">var user = User.init();
assertEqual( user.name,  "Caroline" );

user.name = "Trish";
assertEqual( user.name, "Trish" );</pre><p class="calibre3">Any arguments passed to <code class="literal">init()</code>
      will be sent to the instances initializer function, <code class="literal">init()</code>:</p><pre class="screen">var User = Spine.Class.create({
  init: function(name){
    this.name = name;
  }
});

var user = User.init("Martina");
assertEqual( user.name, "Martina" );</pre></div><div class="book" title="Extending Classes"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2934299" class="calibre12"></a>Extending Classes</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10296" class="calibre1"></a><span class="calibre1">As well as setting class and
      instance properties during creation, you can use <code class="literal">include</code></span><span class="calibre1"><code class="literal">()</code><a id="I_indexterm11_d1e10310" class="calibre1"></a><a id="I_indexterm11_d1e10313" class="calibre1"></a> and <code class="literal">extend()</code><a id="I_indexterm11_d1e10321" class="calibre1"></a><a id="I_indexterm11_d1e10324" class="calibre1"></a>, passing in an object literal:</span></p><pre class="screen">User.include({
  // Instance properties
});

User.extend({
  // Class properties
});</pre><p class="calibre3"><code class="literal">include()</code> and <code class="literal">extend()</code> pave the way for modules, which are
      reusable pieces of code that you can include multiple times:</p><pre class="screen">var ORM = {
  extended: function(){ 
    // invoked when extended
    //   this === User
  },
  find:  function(){ /* ... */ },
  first: function(){ /* ... */ }
};

User.extend( ORM );</pre><p class="calibre3">You can receive a callback <a id="I_indexterm11_d1e10343" class="calibre1"></a>when a module is included or extended. In the example
      above, the <code class="literal">extended</code> function will be
      invoked when <code class="literal">User.extend()</code><a id="I_indexterm11_d1e10354" class="calibre1"></a> is called with a context of <code class="literal">User</code>. Likewise, if a module has an <code class="literal">included</code> property, it will be invoked when the
      module is included inside a class.</p><p class="calibre3">Because we’re using prototypal-based inheritance, any properties
      we add onto classes will be reflected dynamically across subclasses at
      runtime:</p><pre class="screen">var Friend = User.create();

User.include({
  email: "info@eribium.org"
});

assertEqual( Friend.init().email, "info@eribium.org" );</pre><p class="calibre3">Properties <a id="I_indexterm11_d1e10370" class="calibre1"></a>in subclasses can be overridden without affecting the
      parent class. However, modifications to objects in subclasses, such as
      arrays, will be reflected across the whole inheritance tree. If you want
      an object to be specific to a class or instance, you’ll need <span class="calibre1">to create it when the class or instance is first
      initialized. You can do this in a <code class="literal">created</code></span><span class="calibre1"><code class="literal">()</code>
      function,<a id="I_indexterm11_d1e10384" class="calibre1"></a><a id="I_indexterm11_d1e10387" class="calibre1"></a> which Spine will call when the class is first set up or
      instantiated:</span></p><pre class="screen">// We want the records array to be specific to the class
var User = Spine.Class.create({
  // Called on instantiation
  init: function(){
    this.attributes = {};
  }
}, {
  // Called when the class is created
  created: function(){
    this.records = [];
  }
});</pre></div><div class="book" title="Context"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2934544" class="calibre12"></a>Context</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10399" class="calibre1"></a>Context changes are rife within JavaScript programs, so
      <code class="literal">Spine.Class</code> includes some utility
      methods for controlling scope. To demonstrate the problem, take this
      example:</p><pre class="screen">var Controller = Spine.Class.create({
  init: function(){
    // Add event listener
    $("#destroy").click(this.destroy);
  },

  destroy: function(){
    // This destroy function is called with the wrong context,
    // so any references to `this` will cause problems
    // The following assertion will fail:
    assertEqual( this, Controller.fn );
  }
});</pre><p class="calibre3">In the example above, when the event is invoked, the <code class="literal">destroy()</code> function <a id="I_indexterm11_d1e10417" class="calibre1"></a><a id="I_indexterm11_d1e10420" class="calibre1"></a>will be called with the context of the element <code class="literal">#destroy</code>, rather than the Controller. To deal
      with this, you can proxy the context, forcing it to be a particular one
      you specify. Spine gives you the <code class="literal">proxy()</code> function <a id="I_indexterm11_d1e10432" class="calibre1"></a><a id="I_indexterm11_d1e10436" class="calibre1"></a>to do that:</p><pre class="screen">var Controller = Spine.Class.create({
  init: function(){
    $("#destroy").click(this.proxy(this.destroy));
  },

  destroy: function(){ }
});</pre><p class="calibre3">If you find you’re constantly proxying a function, you may want to
      rewrite it to always include a proxy. Spine includes a <code class="literal">proxyAll()</code> function <a id="I_indexterm11_d1e10449" class="calibre1"></a><a id="I_indexterm11_d1e10452" class="calibre1"></a>to do just that:</p><pre class="screen">var Controller = Spine.Class.create({
  init: function(){
    this.proxyAll("destroy", "render")
    $("#destroy").click(this.destroy);
  },

  // Functions are now always called with the correct context
  destroy: function(){ },
  render:  function(){ }
});</pre><p class="calibre3"><code class="literal">proxyAll()</code> takes multiple
      function names, and when invoked, it will rewrite them, proxying the
      functions with the current scope. This will ensure that <code class="literal">destroy()</code> or <code class="literal">render()</code> will always be executed in the local
      context.<a id="I_indexterm11_d1e10470" class="calibre1"></a><a id="I_indexterm11_d1e10471" class="calibre1"></a></p></div></div></div>

{% endraw %}

