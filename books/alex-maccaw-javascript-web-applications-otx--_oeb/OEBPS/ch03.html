---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch02s10.html
next: OEBPS/ch03s02.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre7"></div><div class="book" title="Chapter 3. Models and Data"><div class="book"><div class="book"><div class="book"><div class="calibre7"></div><h1 class="title1"><a id="models-data" class="calibre1"></a>Chapter 3. Models and Data</h1></div></div></div><p class="calibre3"><a id="index-783H645TO5V" class="calibre1"></a>One of the challenges with moving state to the client side is
  data management. Traditionally, you could fetch data directly from the
  database during the page request, interoperating the result directly into
  the page. However, data management in stateful JavaScript applications is a
  completely different process. There’s no request/response model, and you
  don’t have access to server-side variables. Instead, data is fetched
  remotely and stored temporarily on the client side.</p><p class="calibre3">Although making this transition can be a hassle, there are a few
  advantages. For example, client-side data access is practically
  instantaneous, as you’re just fetching it from memory. This can make a real
  difference to your application’s interface; any interaction with the
  application gives immediate feedback, often dramatically improving the
  user’s experience.</p><p class="calibre3">How you architect data storage on the client side requires some
  thought. This is an <span class="calibre1">area riddled</span> with
  pitfalls and potential traps, often tripping up less-experienced
  developers—especially as their applications get larger. In this chapter,
  we’ll cover how best to make that transition, and I’ll give you some
  recommended patterns and practices.</p><div class="book" title="MVC and Namespacing"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect13_d1e2538" class="calibre1"></a>MVC and Namespacing</h1></div></div></div><p class="calibre3"><a id="I_indexterm3_d1e2542" class="calibre1"></a><a id="I_indexterm3_d1e2547" class="calibre1"></a><a id="I_indexterm3_d1e2552" class="calibre1"></a>Ensuring that there’s a clear separation between your
    application’s views, state, and data is crucial to keeping its
    architecture uncluttered and sustainable. With the MVC pattern, data
    management happens in models (the “M” of MVC). Models should be decoupled
    from views and controllers. Any logic associated with data manipulation
    and behavior should reside in models and be namespaced properly.</p><p class="calibre3">In JavaScript, you can namespace functions <a id="I_indexterm3_d1e2560" class="calibre1"></a>and variables <a id="I_indexterm3_d1e2566" class="calibre1"></a>by making them properties of an object. For
    example:<a id="I_indexterm3_d1e2572" class="calibre1"></a></p><pre class="screen">var User = {
  records: [ /* ... */ ]
};</pre><p class="calibre3">The array of users is namespaced properly under <code class="literal">User.records</code>. Functions associated with users
    can also be namespaced under the <code class="literal">User</code>
    model. For example, we can have a <code class="literal">fetchRemote()</code> function <a id="I_indexterm3_d1e2590" class="calibre1"></a><a id="I_indexterm3_d1e2593" class="calibre1"></a>for fetching user data from a server:</p><pre class="screen">var User = {
  records: [],
  fetchRemote: function(){ /* ... */ }
};</pre><p class="calibre3">Keeping all of a model’s properties under a namespace ensures that
    you don’t get any conflicts and that it’s MVC-compliant. It also prevents
    your code from spiraling down into a tangled mess of functions and
    callbacks.</p><p class="calibre3">You can take namespacing a step further and keep any functions
    specific to user instances on the actual user objects. Let’s say we had a
    <code class="literal">destroy()</code> function for user records; it
    refers to specific users, so it should be on <code class="literal">User</code> instances:</p><pre class="screen">var user = new User;
user.destroy()</pre><p class="calibre3">To achieve that, we need to make <code class="literal">User</code> a class, rather than a plain object:</p><pre class="screen">var User = function(atts){
  this.attributes = atts || {};
};

User.prototype.destroy = function(){
  /* ... */
};</pre><p class="calibre3">Any functions and variables that don’t relate to specific users can
    be properties directly on the <code class="literal">User</code>
    object:</p><pre class="screen">User.fetchRemote = function(){
  /* ... */
};</pre><p class="calibre3">For more information about namespacing, visit Peter Michaux’s blog,
    where he’s <span class="calibre1">written</span> an <a class="ulink" href="http://michaux.ca/articles/javascript-namespacing">excellent
    article</a> on the <span class="calibre1">subject</span>.</p></div></div></div>

{% endraw %}

