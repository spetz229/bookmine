---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch13s03.html
next: OEBPS/ch13s05.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Using Client-Side Templates in the View"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect113_d1e14313" class="calibre1"></a>Using Client-Side Templates in the View</h1></div></div></div><p class="calibre3"><a id="index-751I618BO8B" class="calibre1"></a><a id="index-400R021IE4I" class="calibre1"></a><a id="index-556K733PM4S" class="calibre1"></a>JavaScriptMVC’s views are really just client-side templates,
    which take data and return a string. Typically, the strings are HTML
    intended to be inserted into the DOM.</p><p class="calibre3"><code class="literal">$.View</code> is a templating interface <a id="I_indexterm13_d1e14335" class="calibre1"></a>that uses templates to take care of complexities. It
    offers:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Convenient and uniform syntax</p></li><li class="listitem"><p class="calibre3">Template loading from HTML elements or external files</p></li><li class="listitem"><p class="calibre3">Synchronous or asynchronous template loading</p></li><li class="listitem"><p class="calibre3">Template preloading</p></li><li class="listitem"><p class="calibre3">Caching of processed templates</p></li><li class="listitem"><p class="calibre3">Bundling of processed templates in production builds</p></li><li class="listitem"><p class="calibre3"><code class="literal">$.Deferred </code>support</p></li></ul></div><p class="calibre3">JavaScriptMVC comes prepackaged with four different template
    engines:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">EJS</p></li><li class="listitem"><p class="calibre3">JAML</p></li><li class="listitem"><p class="calibre3">Micro</p></li><li class="listitem"><p class="calibre3">Tmpl</p></li></ul></div><p class="calibre3">This tutorial uses EJS templates, but the following techniques will
    work with any template engine (with minor syntax differences).</p><div class="book" title="Basic Use"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2943980" class="calibre12"></a>Basic Use</h2></div></div></div><p class="calibre3"><a id="I_indexterm13_d1e14386" class="calibre1"></a><a id="I_indexterm13_d1e14393" class="calibre1"></a>When using views, you almost always want to insert the
      results of a rendered template into the page.
      <code class="literal">jQuery.View</code> overwrites the jQuery modifiers, so using
      a view is as easy as:</p><pre class="screen">$("#foo").html('mytemplate.ejs',{message: 'hello world'})</pre><p class="calibre3">This code:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre3">Loads the template in the file
          <em class="calibre4">mytemplate.ejs</em>. It might look like:</p><pre class="screen">&lt;h2&gt;&lt;%= message %&gt;&lt;/h2&gt;</pre></li><li class="listitem"><p class="calibre3">Renders it with <code class="literal">{message: ‘hello world'}</code>,
          resulting in:</p><pre class="screen">&lt;h2&gt;hello world&lt;/h2&gt;</pre></li><li class="listitem"><p class="calibre3">Inserts the result into the <code class="literal">foo</code> element,
          which might look like:</p><pre class="screen">&lt;div id='foo'&gt;&lt;h2&gt;hello world&lt;/h2&gt;&lt;/div&gt;</pre></li></ol></div></div><div class="book" title="jQuery Modifiers"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2944081" class="calibre12"></a>jQuery Modifiers</h2></div></div></div><p class="calibre3"><a id="I_indexterm13_d1e14436" class="calibre1"></a><a id="I_indexterm13_d1e14443" class="calibre1"></a>You can use a template with the following jQuery modifier
      methods:</p><pre class="screen">$('#bar').after('temp.ejs',{});
$('#bar').append('temp.ejs',{});
$('#bar').before('temp.ejs',{});
$('#bar').html('temp.ejs',{});
$('#bar').prepend('temp.ejs',{});
$('#bar').replaceWith('temp.ejs',{});
$('#bar').text('temp.ejs',{});</pre></div><div class="book" title="Loading from a Script Tag"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2944123" class="calibre12"></a>Loading from a Script Tag</h2></div></div></div><p class="calibre3"><a id="I_indexterm13_d1e14455" class="calibre1"></a><a id="I_indexterm13_d1e14462" class="calibre1"></a><a id="I_indexterm13_d1e14467" class="calibre1"></a>View can load from script tags or from files. To load from
      a script tag, create a script tag with a <code class="literal">type</code>
      attribute set to the template type (<code class="literal">text/ejs</code>), and an <code class="literal">id</code> to
      label the template:</p><pre class="screen">&lt;script type='text/ejs' id='recipesEJS'&gt;
&lt;% for(var i=0; i &lt; recipes.length; i++){ %&gt;
  &lt;li&gt;&lt;%=recipes[i].name %&gt;&lt;/li&gt;
&lt;%} %&gt;
&lt;/script&gt;</pre><p class="calibre3">Render with this template, like so:</p><pre class="screen">$("#foo").html('recipesEJS', recipeData)</pre><p class="calibre3">Notice that we passed the <code class="literal">id</code> of the element we
      want to render.</p></div><div class="book" title="$.View and Subtemplates"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2944210" class="calibre12"></a>$.View and Subtemplates</h2></div></div></div><p class="calibre3"><a id="I_indexterm13_d1e14498" class="calibre1"></a><a id="I_indexterm13_d1e14505" class="calibre1"></a>Sometimes you simply want the rendered string. In this
      case, you can use <code class="literal">$.View(TEMPLATE , data
      )</code> directly. Pass <code class="literal">$.View</code> the path to the
      template, as well as the data you want to render:</p><pre class="screen">var html = $.View("template/items.ejs", items );</pre><p class="calibre3">The most common use case is subtemplates. It’s common practice to
      separate out an individual item’s template from the list template
      (<em class="calibre4">items.ejs</em>). We’ll make <code class="literal">template/items.ejs</code> render a
      <code class="literal">&lt;&gt;</code> for each item, but use the template in
      <code class="literal">template/item.ejs</code> for the content of
      each item:</p><pre class="screen">&lt;% for( var i = 0; i &lt; this.length; i++){ %&gt;
  &lt;li&gt;
    &lt;%= $.View("template/item.ejs", this[i]);  
  &lt;/li&gt;
&lt; % } %&gt;</pre><p class="calibre3"><code class="literal">this</code> refers to the data passed
      to the template. In the case of <code class="literal">template/items.ejs</code>, <code class="literal">this</code> is the array of items. In <code class="literal">template/item.ejs</code>, it will be the individual
      item.</p></div><div class="book" title="Deferreds"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2944327" class="calibre12"></a>Deferreds</h2></div></div></div><p class="calibre3"><a id="I_indexterm13_d1e14552" class="calibre1"></a><a id="I_indexterm13_d1e14559" class="calibre1"></a><a id="I_indexterm13_d1e14564" class="calibre1"></a>It’s extremely common behavior to make an Ajax request and
      use a template to <span class="calibre1">render the</span>
      result. Using the <code class="literal">Task</code> model from the previous
      <code class="literal">$.Model</code> section, we could render tasks like:</p><pre class="screen">Task.findAll({}, function(tasks){
  $('#tasks').html("views/tasks.ejs" , tasks )
})</pre><p class="calibre3"><code class="literal">$.View</code> supports deferred
      (<em class="calibre4">http://api.jquery.com/category/deferred-object/</em>)
      allows very powerful, terse, and high-performance syntax. If a deferred
      is found in the render <span class="calibre1">data passed</span>
      to <code class="literal">$.View</code> or the jQuery modifiers,
      <code class="literal">$.View</code> will load the template asynchronously and wait
      until all deferreds and the template are loaded before rendering the
      template.</p><p class="calibre3">The model methods <code class="literal">findAll</code>,
      <code class="literal">findOne</code>, <code class="literal">save</code>, and <code class="literal">destroy</code> return deferreds. This allows us to
      rewrite the rendering of tasks into one line:</p><pre class="screen">$('#tasks').html("views/tasks.ejs" , Task.findAll() )</pre><p class="calibre3">This also works with multiple deferreds:</p><pre class="screen">$('#app').html("views/app.ejs" , {
  tasks: Task.findAll(),
  users: User.findAll()
})</pre></div><div class="book" title="Packaging, Preloading, and Performance"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2944468" class="calibre12"></a>Packaging, Preloading, and Performance</h2></div></div></div><p class="calibre3"><a id="I_indexterm13_d1e14619" class="calibre1"></a><a id="I_indexterm13_d1e14626" class="calibre1"></a><a id="I_indexterm13_d1e14631" class="calibre1"></a><a id="I_indexterm13_d1e14634" class="calibre1"></a>By default, <code class="literal">$.View</code> loads templates
      synchronously because it expects that you are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Putting templates in script tags</p></li><li class="listitem"><p class="calibre3">Packaging templates with your JavaScript build</p></li><li class="listitem"><p class="calibre3">Preloading templates</p></li></ul></div><p class="calibre3">JavaScriptMVC does not recommend putting templates <a id="I_indexterm13_d1e14655" class="calibre1"></a><a id="I_indexterm13_d1e14660" class="calibre1"></a>in script tags. Script tag templates make it hard to reuse
      templates across different JavaScript applications. They can also reduce
      load performance if your app doesn’t need the templates
      immediately.</p><p class="calibre3">JavaScriptMVC recommends initially packaging used templates with
      your application’s JavaScript, and then preloading templates that will
      be used later.</p><p class="calibre3">StealJS, JavaScriptMVC’s build system, can process and package
      templates, adding them to a minified production build. Simply point
      <code class="literal">steal.views(PATH, ...)</code> to your
      template:</p><pre class="screen">steal.views('tasks.ejs','task.ejs');</pre><p class="calibre3">Later, when <code class="literal">$.View</code> looks for that template, it
      will use a cached copy, saving an extra Ajax request.</p><p class="calibre3">For templates that are not used immediately, preload and cache
      them with <code class="literal">jQuery.get</code><a id="I_indexterm13_d1e14684" class="calibre1"></a>. Simply give the URL to the template and provide a
      <code class="literal">dataType</code> of <code class="literal">'view'</code> (it’s best to
      do this a short time after the initial page has loaded):<a id="I_indexterm13_d1e14694" class="calibre1"></a><a id="I_indexterm13_d1e14695" class="calibre1"></a><a id="I_indexterm13_d1e14696" class="calibre1"></a></p><pre class="screen">$(window).load(function(){
  setTimeout(function(){
    $.get('users.ejs',function(){},'view');
    $.get('user.ejs',function(){},'view');
  },500)
})</pre></div></div></div>

{% endraw %}

