---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch11s03.html
next: OEBPS/ch11s05.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Models"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect111_d1e10531" class="calibre1"></a>Models</h1></div></div></div><p class="calibre3"><a id="index-520I504GA8F" class="calibre1"></a><a id="index-156U107KQ4N" class="calibre1"></a>If you take a peek at Spine’s <a class="ulink" href="https://github.com/maccman/spine/blob/master/spine.js">source
    code</a>, you’ll see that the vast majority of it deals with models,
    and rightly <span class="calibre1">so—models</span> are the
    central part of any MVC application. Models deal with storing and
    manipulating your application’s data, and Spine simplifies this by
    providing a full ORM.</p><p class="calibre3">Rather than use the <code class="literal">create()</code>
    function <a id="I_indexterm11_d1e10557" class="calibre1"></a><a id="I_indexterm11_d1e10560" class="calibre1"></a>to make a new model, which is already reserved, use <code class="literal">Spine.Model.setup(name, attrs)</code>, passing in the
    model name and an array of attribute names:</p><pre class="screen">// Create the Task model.
var Task = Spine.Model.setup("Task", ["name", "done"]);</pre><p class="calibre3">Use <code class="literal">include()</code><a id="I_indexterm11_d1e10575" class="calibre1"></a><a id="I_indexterm11_d1e10578" class="calibre1"></a> and <code class="literal">extend()</code><a id="I_indexterm11_d1e10586" class="calibre1"></a><a id="I_indexterm11_d1e10589" class="calibre1"></a> to add instance and class properties:</p><pre class="screen">Task.extend({  
  // Return all done tasks.
  done: function(){ /* ... */ }
});

Task.include({
  // Default name
  name: "Empty...",
  done: false,

  toggle: function(){ 
    this.done = !this.done;
  }
});</pre><p class="calibre3">When instantiating a record, you can pass an optional object
    containing the record’s initial properties:</p><pre class="screen">var task = Task.init({name: "Walk the dog"});
assertEqual( task.name, "Walk the dog" );</pre><p class="calibre3">Setting and retrieving attributes is the same as setting and getting
    properties on a normal object. In addition, the <code class="literal">attributes()</code> function returns an object literal
    containing all the record’s attributes:</p><pre class="screen">var task = Task.init();
task.name = "Read the paper";
assertEqual( task.attributes(), {name: "Read the paper"} );</pre><p class="calibre3">Saving new or existing records is as simple as calling the <code class="literal">save()</code> function.<a id="I_indexterm11_d1e10613" class="calibre1"></a><a id="I_indexterm11_d1e10616" class="calibre1"></a> When saving a record, an ID will be generated if it doesn’t
    already exist; then, the record will be persisted locally in
    memory:</p><pre class="screen">var task = Task.init({name: "Finish book"});
task.save();

task.id //=&gt; "44E1DB33-2455-4728-AEA2-ECBD724B5E7B"</pre><p class="calibre3">Records can be retrieved using the model’s <code class="literal">find()</code> function,<a id="I_indexterm11_d1e10630" class="calibre1"></a><a id="I_indexterm11_d1e10633" class="calibre1"></a> passing in the record’s ID:</p><pre class="screen">var task = Task.find("44E1DB33-2455-4728-AEA2-ECBD724B5E7B");
assertEqual( task.name, "Finish book" );</pre><p class="calibre3">If no record exists for the given ID, an exception will be raised.
    You can check whether a record exists without fear of an exception using
    the <code class="literal">exists()</code> function:<a id="I_indexterm11_d1e10646" class="calibre1"></a><a id="I_indexterm11_d1e10651" class="calibre1"></a></p><pre class="screen">var taskExists = Task.exists("44E1DB33-2455-4728-AEA2-ECBD724B5E7B");
assert( taskExists );</pre><p class="calibre3">You can remove a record from the local cache by using the <code class="literal">destroy()</code> function:<a id="I_indexterm11_d1e10661" class="calibre1"></a><a id="I_indexterm11_d1e10666" class="calibre1"></a></p><pre class="screen">var task = Task.create({name: "Thanks for all the fish"});

assert( task.exists() );
task.destroy();
assertEqual( task.exists(), false );</pre><div class="book" title="Fetching Records"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2935199" class="calibre12"></a>Fetching Records</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10675" class="calibre1"></a><a id="I_indexterm11_d1e10682" class="calibre1"></a>Retrieving records by ID is only one way of fetching them.
      Typically, it’s useful to iterate through all the records or to return a
      filtered subset. Spine lets you do this using <code class="literal">all()</code>, <code class="literal">select()</code>, and <code class="literal">each()</code>:</p><pre class="screen">// Return all tasks
Task.all(); //=&gt; [Object]

// Return all tasks with a false done attribute
var pending = Task.select(function(task){ return !task.done });

// Invoke a callback for each task
Task.each(function(task){ /* ... */ });</pre><p class="calibre3">In addition, Spine provides a few helpers for finding records by
      attribute:</p><pre class="screen">// Finds first task with the specified attribute value
Task.findByAttribute(name, value);    //=&gt; Object

// Finds all tasks with the specified attribute value
Task.findAllByAttribute(name, value); //=&gt; [Object]</pre></div><div class="book" title="Model Events"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2935286" class="calibre12"></a>Model Events</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10707" class="calibre1"></a><a id="I_indexterm11_d1e10714" class="calibre1"></a>You can bind to model events to get callbacks <a id="I_indexterm11_d1e10720" class="calibre1"></a>when records change:</p><pre class="screen">Task.bind("save", function(record){
  console.log(record.name, "was saved!");
});</pre><p class="calibre3">If a record is involved, it will be passed to the event callback.
      You can bind a listener to the model to receive global callbacks for
      every record, or you can bind a listener to a specific record:</p><pre class="screen">Task.first().bind("save", function(){
  console.log(this.name, "was saved!")
});

Task.first().updateAttributes({name: "Tea with the Queen"});</pre><p class="calibre3">Although you can obviously create custom events using <code class="literal">trigger()</code>, the following are available:</p><div class="book"><dl class="book"><dt class="calibre8"><span class="calibre1">save</span></dt><dd class="calibre9"><p class="calibre3">Record was saved (either created/updated)</p></dd><dt class="calibre8"><span class="calibre1">update</span></dt><dd class="calibre9"><p class="calibre3">Record was updated</p></dd><dt class="calibre8"><span class="calibre1">create</span></dt><dd class="calibre9"><p class="calibre3">Record was created</p></dd><dt class="calibre8"><span class="calibre1">destroy</span></dt><dd class="calibre9"><p class="calibre3">Record was destroyed</p></dd><dt class="calibre8"><span class="calibre1">change</span></dt><dd class="calibre9"><p class="calibre3">Any of the above; record was
            created/updated/destroyed</p></dd><dt class="calibre8"><span class="calibre1">refresh</span></dt><dd class="calibre9"><p class="calibre3">All records invalidated and replaced</p></dd><dt class="calibre8"><span class="calibre1">error</span></dt><dd class="calibre9"><p class="calibre3">Validation failed</p></dd></dl></div><p class="calibre3">You’ll find that model events are crucial when creating your
      application, especially when it comes to binding models up to the
      view.</p></div><div class="book" title="Validation"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2935414" class="calibre12"></a>Validation</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10786" class="calibre1"></a><a id="I_indexterm11_d1e10793" class="calibre1"></a>Validation is achieved in the simplest possible way, by
      overriding the model instance’s <code class="literal">validate()</code> function. <code class="literal">validate()</code> is called whenever the record is
      saved. If <code class="literal">validate()</code> returns
      anything, the validation fails. Otherwise, the save continues
      unhindered, persisting the record to local memory:</p><pre class="screen">Task.include({
  validate: function(){
    if ( !this.name ) return "Name required";
  }
});</pre><p class="calibre3">If validation fails, you should return a string from <code class="literal">validate()</code> with an explanation. Use this
      message to notify the user of what went wrong and how to correct
      it:</p><pre class="screen">Task.bind("error", function(record, msg){
  // Very basic error notification
  alert("Task didn't save: " + msg);
});</pre><p class="calibre3">The model’s <span class="calibre1"><em class="calibre4">error</em></span> event <a id="I_indexterm11_d1e10820" class="calibre1"></a><a id="I_indexterm11_d1e10823" class="calibre1"></a>will be invoked whenever validation fails. Callbacks will
      be passed the invalid record and error message.</p></div><div class="book" title="Persistence"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2935515" class="calibre12"></a>Persistence</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e10833" class="calibre1"></a><a id="I_indexterm11_d1e10840" class="calibre1"></a>Spine’s records are always persisted in memory, but you
      have a choice of storage backends, such as HTML5’s Local Storage or
      Ajax.</p><p class="calibre3">Using Local Storage is trivial. Just include the
      <span class="calibre1"><em class="calibre4">spine.model.local.js</em></span> JavaScript file, and extend
      your model with <code class="literal">Spine.Model.Local</code>:</p><pre class="screen">// Save with local storage
Task.extend(Spine.Model.Local);
Task.fetch();</pre><p class="calibre3">The records won’t be retrieved automatically from the browser’s
      local storage, so you’ll need to call <code class="literal">fetch()</code> to populate your model with
      preexisting data. This is typically done after everything else in your
      application has been initialized. Once the model has been populated with
      new data, the <span class="calibre1"><em class="calibre4">refresh</em></span> event will be
      triggered:</p><pre class="screen">Task.bind("refresh", function(){
  // New tasks!
  renderTemplate(Task.all());
});</pre><p class="calibre3">Using Ajax persistence is similar; just include the
      <span class="calibre1"><em class="calibre4">spine.model.ajax.js</em></span> script and extend your model
      with <code class="literal">Spine.Model.Ajax</code>:</p><pre class="screen">// Save to server
Task.extend(Spine.Model.Ajax);</pre><p class="calibre3">By default, Spine detects the model name and uses some basic
      pluralization to generate a URL. So, for the example above, the <code class="literal">Task</code> model’s URL would be <code class="literal">/tasks</code>. You can override this default behavior
      by providing your own URL property on the class:</p><pre class="screen">// Add a custom URL
Task.extend({
  url: "/tasks"
});

// Fetch new tasks from the server
Task.fetch();</pre><p class="calibre3">As soon as <code class="literal">Task.fetch()</code><a id="I_indexterm11_d1e10890" class="calibre1"></a> is called, Spine will make an Ajax GET request to
      <code class="literal">/tasks</code>, expecting a JSON response
      containing an array of tasks. If the server returns a successful
      response, the records will be loaded and the
      <span class="calibre1"><em class="calibre4">refresh</em></span> event triggered.</p><p class="calibre3">Spine will send Ajax requests to the server whenever you create,
      update, or destroy a record, keeping the two in sync. The library
      expects your server to be structured in a RESTful way so it works
      seamlessly, although you can obviously override this to suit a custom
      setup. Spine expects these endpoints to exist:</p><pre class="screen">read    → GET    /collection
create  → POST   /collection
update  → PUT    /collection/id
destroy → DELETE /collection/id</pre><p class="calibre3">After a record has been created client side, Spine will send off
      an HTTP POST to your server, including a JSON representation of the
      record. Let’s create a <code class="literal">Task</code> with a
      name of <code class="literal">"Buy eggs"</code>; this is the
      request that would be sent to the server:</p><pre class="screen">POST /tasks HTTP/1.0
Host: localhost:3000
Origin: http://localhost:3000
Content-Length: 66
Content-Type: application/json

{"id": "44E1DB33-2455-4728-AEA2-ECBD724B5E7B", "name": "Buy eggs"}</pre><p class="calibre3">Likewise, destroying a record will trigger a DELETE request to the
      server, and updating a record will trigger a PUT request. For PUT and
      DELETE requests, the record’s ID is referenced inside the URL:</p><pre class="screen">PUT /tasks/44E1DB33-2455-4728-AEA2-ECBD724B5E7B HTTP/1.0
Host: localhost:3000
Origin: http://localhost:3000
Content-Length: 71
Content-Type: application/json

{"id": "44E1DB33-2455-4728-AEA2-ECBD724B5E7B", "name": "Buy more eggs"}</pre><p class="calibre3">Spine has a different take on Ajax <a id="I_indexterm11_d1e10921" class="calibre1"></a>syncing than most other libraries. It sends a request to
      the server after the record has been saved client side, so the client is
      never waiting for a response. This means your client is totally
      decoupled from your server— i.e., it doesn’t need a server to be present
      in order to function.</p><p class="calibre3">Having a decoupled server offers three major advantages. First,
      your interface is fast and nonblocking, so users are never waiting to
      interact with your application. The second is that it simplifies your
      code—you don’t need to plan for a record that may be displayed in the
      user interface but isn’t editable due to a pending server response.
      Third, it makes it much easier to add offline support, if that’s ever
      required.</p><p class="calibre3">What about server-side validation?<a id="I_indexterm11_d1e10931" class="calibre1"></a> Spine assumes you’ll do all necessary validation client
      side. The only time a server should respond with an error is if there’s
      been an exception (a problem with your code), which should only happen
      in exceptional circumstances.</p><p class="calibre3">When the server returns an unsuccessful response, an
      <span class="calibre1"><em class="calibre4">ajaxError</em></span> event <a id="I_indexterm11_d1e10940" class="calibre1"></a><a id="I_indexterm11_d1e10943" class="calibre1"></a>will be fired on the model, including the record, an
      <code class="literal">XMLHttpRequest</code> object, Ajax settings, and the thrown
      error:<a id="I_indexterm11_d1e10952" class="calibre1"></a><a id="I_indexterm11_d1e10953" class="calibre1"></a></p><pre class="screen">Task.bind("ajaxError", function(record, xhr, settings, error){
  // Invalid response
});</pre></div></div></div>

{% endraw %}

