---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch07s07.html
next: OEBPS/ch07s09.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Uploading Files"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect17_d1e7039" class="calibre1"></a>Uploading Files</h1></div></div></div><p class="calibre3"><a id="index-462G226LM0W" class="calibre1"></a><a id="index-810S025OF7F" class="calibre1"></a>Part of the <a class="ulink" href="http://www.w3.org/TR/XMLHttpRequest2">XMLHttpRequest Level 2
    specification</a> was the ability to upload files. File uploads have
    long been a painful experience for users. Once they’ve browsed and
    selected a file, the page reloads and they have to wait for ages while it
    uploads, with no indication of progress or feedback—quite the usability
    nightmare. Luckily for us, XHR 2 solves this problem. It allows us to
    upload files in the background, and it even gives us progress events so
    that we can provide the user with a real-time progress bar. It’s generally
    well supported by the major browsers:<a id="I_indexterm7_d1e7055" class="calibre1"></a></p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Safari &gt;= 5.0</p></li><li class="listitem"><p class="calibre3">Firefox &gt;= 4.0</p></li><li class="listitem"><p class="calibre3">Chrome &gt;= 7.0</p></li><li class="listitem"><p class="calibre3">IE: no support</p></li><li class="listitem"><p class="calibre3">Opera: no support</p></li></ul></div><p class="calibre3">File uploads can be done via the existing XMLHttpRequest
    API,<a id="I_indexterm7_d1e7078" class="calibre1"></a><a id="I_indexterm7_d1e7081" class="calibre1"></a> using the <code class="literal">send()</code>
    function,<a id="I_indexterm7_d1e7090" class="calibre1"></a><a id="I_indexterm7_d1e7093" class="calibre1"></a> or alternatively by using a <code class="literal">FormData</code> instance.<a id="I_indexterm7_d1e7103" class="calibre1"></a> A <code class="literal">FormData</code> instance just
    represents the contents of a form in an easy-to-manipulate interface. You
    can build a <code class="literal">FormData</code> object from
    scratch, or by passing in an existing <code class="literal">form</code> element when instantiating the
    object:</p><pre class="screen">var formData = new FormData($("form")[0]);

// You can add form data as strings
formData.append("stringKey", "stringData");

// And even add File objects
formData.append("fileKey", file);</pre><p class="calibre3"><span class="calibre1">Once you’ve finished with the
    <code class="literal">FormData</code>, you can POST it to your server using
    <code class="literal">XMLHttp</code></span><span class="calibre1"><span class="calibre1"><code class="literal">Request</code>. If you’re using jQuery
    for Ajax requests, you’ll need to set the <code class="literal">process</code></span><code class="literal">Data</code> </span>option to false so that jQuery
    doesn’t try to serialize the supplied data. Don’t set the <code class="literal">Content-Type</code> header because the browser will set
    it automatically to <code class="literal">multipart/form-data</code>, along with a multipart
    boundary:</p><pre class="screen">jQuery.ajax({
  data: formData,
  processData: false,
  url: "http://example.com",
  type: "POST"
})</pre><p class="calibre3">The alternative to using <code class="literal">FormData</code>
    is to pass the file directly to the XHR object’s <code class="literal">send()</code> function:</p><pre class="screen">var req = new XMLHttpRequest();
req.open("POST", "http://example.com", true);
req.send(file);</pre><p class="calibre3">Or, with jQuery’s Ajax API, you can upload files like this:</p><pre class="screen">$.ajax({
  url: "http://example.com",
  type: "POST",
  success: function(){ /* ... */ },
  processData: false,
  data: file
});</pre><p class="calibre3">It’s worth noting that this upload is a bit different from the
    traditional <code class="literal">multipart/form-data</code> one.
    Usually, information about the file, such as the name, would be included
    in the upload. Not so in this case—the upload is pure file data. To pass
    information about the file, we can set custom headers, such as <code class="literal">X-File-Name</code>. Our servers can read these headers
    and process the file properly:</p><pre class="screen">$.ajax({
  url: "http://example.com",
  type: "POST",
  success: function(){ /* ... */ },
  processData: false,
  contentType: "multipart/form-data",

  beforeSend: function(xhr, settings){
    xhr.setRequestHeader("Cache-Control", "no-cache");
    xhr.setRequestHeader("X-File-Name", file.fileName);
    xhr.setRequestHeader("X-File-Size", file.fileSize);
  },

  data: file
});</pre><p class="calibre3">Unfortunately, many servers will have trouble receiving the upload
    because pure data is a more unfamiliar format than multipart or
    URL-encoded form parameters. Using this method, you may have to parse the
    request manually. For this reason, I advocate using <code class="literal">FormData</code> objects, and sending the upload
    serialized as a <code class="literal">multipart/form-data</code>
    request. In the <span class="calibre1"><em class="calibre4">assets/ch07</em></span> folder, you’ll find
    <span class="calibre1"><em class="calibre4">jquery.upload.js</em></span><a id="I_indexterm7_d1e7183" class="calibre1"></a><a id="I_indexterm7_d1e7186" class="calibre1"></a>, a jQuery plug-in that abstracts file uploading into a
    simple <code class="literal">$.upload(url, file)</code>
    interface.</p><div class="book" title="Ajax Progress"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2926149" class="calibre12"></a>Ajax Progress</h2></div></div></div><p class="calibre3"><a id="I_indexterm7_d1e7200" class="calibre1"></a><a id="I_indexterm7_d1e7205" class="calibre1"></a><a id="I_indexterm7_d1e7210" class="calibre1"></a>The XHR Level 2 specification adds support for
      <span class="calibre1"><em class="calibre4">progress</em></span> events, both for download and upload
      requests. This allows for a real-time file upload progress bar, giving
      users an estimated duration before the upload is complete.</p><p class="calibre3">To listen to the progress event on the download request, add it
      directly on the XHR instance:</p><pre class="screen">var req = new XMLHttpRequest();

req.addEventListener("progress", updateProgress, false);
req.addEventListener("load", transferComplete, false);
req.open();</pre><p class="calibre3">For the upload progress event, add it to the <code class="literal">upload</code> attribute of the XHR instance:</p><pre class="screen">var req = new XMLHttpRequest();

req.upload.addEventListener("progress", updateProgress, false);
req.upload.addEventListener("load", transferComplete, false);
req.open();</pre><p class="calibre3">The <span class="calibre1"><em class="calibre4">load</em></span> event <a id="I_indexterm7_d1e7235" class="calibre1"></a><a id="I_indexterm7_d1e7238" class="calibre1"></a>will fire once the upload request has completed, but
      before the server has issued a response. We can add it to jQuery because
      the XHR object and settings are passed to the
      <code class="literal">beforeSend</code> callback. The full example, including
      custom headers, looks like this:</p><pre class="screen">$.ajax({
  url: "http://example.com",
  type: "POST",
  success: function(){ /* ... */ },
  processData: false,
  dataType: "multipart/form-data",

  beforeSend: function(xhr, settings){
    var upload = xhr.upload;

    if (settings.progress)
      upload.addEventListener("progress", settings.progress, false);

    if (settings.load)
      upload.addEventListener("load", settings.load, false);

    var fd = new FormData;

    for (var key in settings.data)
      fd.append(key, settings.data[key]);

    settings.data = fd;
  },

  data: file
});</pre><p class="calibre3">The <span class="calibre1"><em class="calibre4">progress</em></span> event <a id="I_indexterm7_d1e7254" class="calibre1"></a><a id="I_indexterm7_d1e7259" class="calibre1"></a>contains the <code class="literal">position</code>
      of the upload (that is, how many bytes have uploaded) and the <code class="literal">total</code> (the size of the upload request in
      bytes). You can use these two properties to calculate a progress
      percentage:</p><pre class="screen">var progress = function(event){
  var percentage = Math.round((event.position / event.total) * 100);
  // Set progress bar
}</pre><p class="calibre3">In fact, the event has a timestamp, so if you record the time you
      started the upload, you can create a rudimentary estimated time of
      completion (ETA):</p><pre class="screen">var startStamp = new Date();
var progress = function(e){
  var lapsed = startStamp - e.timeStamp;
  var eta    = lapsed * e.total / e.position - lapsed;
};</pre><p class="calibre3">However, this estimation is unlikely to be accurate with smaller
      (and therefore quicker) uploads. In my opinion, it’s only worth showing
      an ETA if the upload will take longer than four minutes or so. A
      percentage bar is usually sufficient, as it gives users a clear and
      visual indication of how much longer an upload will take.<a id="I_indexterm7_d1e7280" class="calibre1"></a><a id="I_indexterm7_d1e7281" class="calibre1"></a></p></div></div></div>

{% endraw %}

