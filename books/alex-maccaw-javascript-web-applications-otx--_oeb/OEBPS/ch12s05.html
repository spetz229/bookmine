---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch12s04.html
next: OEBPS/ch12s06.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Syncing with the Server"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect112_d1e12632" class="calibre1"></a>Syncing with the Server</h1></div></div></div><p class="calibre3"><a id="index-254J838NU5K" class="calibre1"></a><a id="index-880K428JJ1R" class="calibre1"></a><a id="index-046P180NB3J" class="calibre1"></a>By default, whenever you save a model, Backbone will notify
    your server with an Ajax request, using either the jQuery or Zepto.js
    library. Backbone achieves this by calling <code class="literal">Backbone.sync()</code><a id="I_indexterm12_d1e12652" class="calibre1"></a><a id="I_indexterm12_d1e12655" class="calibre1"></a> before a model is created, updated, or deleted. Backbone
    will then send off a RESTful JSON request to your server which, if
    successful, will update the model client side.</p><p class="calibre3">To take advantage of this, you need to define a <code class="literal">url</code> instance property <a id="I_indexterm12_d1e12666" class="calibre1"></a><a id="I_indexterm12_d1e12669" class="calibre1"></a>on your model and have a RESTfully compliant server.
    Backbone will take care of the rest:</p><pre class="screen">var User = Backbone.Model.extend({
  url: '/users'
});</pre><p class="calibre3">The <code class="literal">url</code> property can either be a
    string or a function that returns a string. The path can be relative or
    absolute, but it must return the model’s endpoint.</p><p class="calibre3">Backbone maps create, read, update, and delete (CRUD) actions into
    the following methods:</p><pre class="screen">create → POST   /collection
read   → GET    /collection[/id]
update → PUT    /collection/id
delete → DELETE /collection/id</pre><p class="calibre3">For example, if you were creating a <code class="literal">User</code> instance, Backbone would send off a POST
    request to <code class="literal">/users</code>. Similarly, updating
    a <code class="literal">User</code> instance would send off a PUT
    request to the endpoint <code class="literal">/users/id</code>,
    where <code class="literal">id</code> is the model’s identifier.
    Backbone expects you to return a JSON hash of the instance’s attributes in
    response to POST, PUT, and GET requests, which will be used to update the
    instance.</p><p class="calibre3">To save a model to the server, call the model’s <code class="literal">save([attrs], [options])</code> function, optionally
    passing in a hash of attributes and request options. If the model has an
    <code class="literal">id</code>, it is assumed to exist on the
    server side, and <code class="literal">save()</code> sends will be a
    PUT (update) request. Otherwise, <code class="literal">save()</code>
    will send a POST (create) request:</p><pre class="screen">var user = new User();
user.set({name: "Bernard"});

user.save(null, {success: function(){
  // user saved successfully
}});</pre><p class="calibre3">All calls to <code class="literal">save()</code><a id="I_indexterm12_d1e12723" class="calibre1"></a><a id="I_indexterm12_d1e12726" class="calibre1"></a> are asynchronous, but you can listen to the Ajax request
    callbacks by passing the <code class="literal">success</code> and
    <code class="literal">failure</code> options. In fact, if Backbone
    is using jQuery, any options passed to <code class="literal">save()</code> will also be passed to <code class="literal">$.ajax()</code>. In other words, you can use any of
    jQuery’s <a class="ulink" href="http://api.jquery.com/jQuery.ajax">Ajax
    options</a>, such as <code class="literal">timeout</code>, when
    saving models.</p><p class="calibre3">If the server returns an error and the save fails, an
    <span class="calibre1"><em class="calibre4">error</em></span> event will be triggered on the model. If it
    succeeds, the model will be updated with the server’s response:</p><pre class="screen">var user = new User();

user.bind("error", function(e){
  // The server returns an error!
});

user.save({email: "Invalid email"});</pre><p class="calibre3">You can refresh a model by using the <code class="literal">fetch()</code> function,<a id="I_indexterm12_d1e12764" class="calibre1"></a><a id="I_indexterm12_d1e12767" class="calibre1"></a> which will request the model’s attributes from the server
    (via a GET request). A <span class="calibre1"><em class="calibre4">change</em></span> event <a id="I_indexterm12_d1e12776" class="calibre1"></a><a id="I_indexterm12_d1e12779" class="calibre1"></a>will trigger if the remote representation of the model
    differs from its current attributes:</p><pre class="screen">var user = Users.get(1);
user.fetch();</pre><div class="book" title="Populating Collections"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2940314" class="calibre12"></a>Populating Collections</h2></div></div></div><p class="calibre3"><a id="I_indexterm12_d1e12791" class="calibre1"></a><a id="I_indexterm12_d1e12796" class="calibre1"></a>So, we’ve covered creating and updating models, but what
      about fetching them from the server in the first place? This is where
      Backbone collections come in, requesting remote models and storing them
      locally. Like models, you should add a <code class="literal">url</code> property to the collection to specify its
      endpoint. If a <code class="literal">url</code> isn’t provided,
      Backbone will fall back to the associated model’s <code class="literal">url</code>:</p><pre class="screen">var Followers = Backbone.Collection.extend({
  model: User,
  url: "/followers"
});

Followers.fetch();</pre><p class="calibre3">The collection’s <code class="literal">fetch()</code>
      function will send off a GET request to the server—in this case, to
      <code class="literal">/followers</code>—retrieving the remote
      models. When the model data returns from the server, the collection will
      refresh, triggering a <span class="calibre1"><em class="calibre4">refresh</em></span> event.<a id="I_indexterm12_d1e12824" class="calibre1"></a><a id="I_indexterm12_d1e12829" class="calibre1"></a></p><p class="calibre3">You can refresh collections manually with the <code class="literal">refresh()</code> function,<a id="I_indexterm12_d1e12837" class="calibre1"></a><a id="I_indexterm12_d1e12840" class="calibre1"></a> passing in an array of model objects. This comes in
      really handy when you’re first setting up the page. Rather than firing
      off another GET request on page load, you can prepopulate collection
      data by passing in a JSON object inline via <code class="literal">refresh()</code>. For example, here’s how it would
      look using Rails:</p><pre class="screen">&lt;script type="text/javascript"&gt;
  Followers.refresh(&lt;%= @users.to_json %&gt;);
&lt;/script&gt;</pre></div><div class="book" title="On the Server Side"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2940474" class="calibre12"></a>On the Server Side</h2></div></div></div><p class="calibre3">As mentioned previously, your server needs to implement a number
      of RESTful endpoints in order to integrate seamlessly with
      Backbone:</p><pre class="screen">create → POST   /collection
read   → GET    /collection
read   → GET    /collection/id
update → PUT    /collection/id
delete → DELETE /collection/id</pre><p class="calibre3">Backbone will serialize models into JSON before sending them. Our
      <code class="literal">User</code> model would look like
      this:</p><pre class="screen">{"name": "Yasmine"}</pre><p class="calibre3">Notice that the data isn’t prefixed by the current model,
      something that can especially trip up Rails developers. I’m going to go
      through some of the specifics of integrating Rails with Backbone, so if
      you’re not using the framework, feel free to skip to the next
      section.</p><p class="calibre3">Inside your CRUD methods, you should be using the plain,
      unprefixed parameters. For example, here’s how our Rails controller’s
      <code class="literal">update</code> method could work:</p><pre class="screen">def update
  user = User.find(params[:id])
  user.update_attributes!(params)
  render :json =&gt; user
end</pre><p class="calibre3"><span class="calibre1">Obviously, you should be securing your model from
      malicious input by <a class="ulink" href="http://guides.rubyonrails.org/security.html#mass-assignment">whitelisting
      <span class="calibre1">attributes</span></a><span class="calibre1">
      </span></span><span class="calibre1"><span class="calibre1"><span class="calibre1">using the <code class="literal">attr</code></span></span><span class="calibre1"><code class="literal">_</code></span></span><code class="literal">accessible</code> method, but that’s beyond the scope
      of this book. Every controller method, except for <code class="literal">destroy</code>, should return a JSON representation
      of the record.<a id="I_indexterm12_d1e12898" class="calibre1"></a><a id="I_indexterm12_d1e12903" class="calibre1"></a></p><p class="calibre3">Serializing attributes to JSON is also an issue because, by
      default, Rails prefixes any record data with the model, like
      this:</p><pre class="screen">{"user": {"name": "Daniela"}}</pre><p class="calibre3">Unfortunately, Backbone won’t be able to parse that object
      correctly. You need to ensure Rails doesn’t include the model name
      inside JSON serializations of records by creating an initializer
      file:</p><pre class="screen"># config/initializers/json.rb
ActiveRecord::Base.include_root_in_json = false</pre></div><div class="book" title="Custom Behavior"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2940621" class="calibre12"></a>Custom Behavior</h2></div></div></div><p class="calibre3"><code class="literal">Backbone.sync()</code><a id="I_indexterm12_d1e12923" class="calibre1"></a><a id="I_indexterm12_d1e12926" class="calibre1"></a> is the function Backbone calls every time it attempts to
      read or save a model to the server. You can override its default
      behavior (sending an Ajax request) in order to use a different
      persistence strategy, such as WebSockets, XML transport, or Local
      Storage. For example, let’s replace <code class="literal">Backbone.sync()</code> with a no-op function that
      just logs the arguments with which its called:</p><pre class="screen">Backbone.sync = function(method, model, options) {
  console.log(method, model, options);
  options.success(model);
};</pre><p class="calibre3">As you can see, <code class="literal">Backbone.sync()</code>
      gets passed a <code class="literal">method</code>, <code class="literal">model</code>, and <code class="literal">options</code>, which have the following
      properties:</p><div class="book"><dl class="book"><dt class="calibre8"><span class="calibre1"><code class="literal">method</code></span></dt><dd class="calibre9"><p class="calibre3">The CRUD method (<code class="literal">create</code>,
            <code class="literal">read</code>, <code class="literal">update</code>, or
            <code class="literal">delete</code>)</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">model</code></span></dt><dd class="calibre9"><p class="calibre3">The model to be saved (or collection to be read)</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">options</code></span></dt><dd class="calibre9"><p class="calibre3">The request options, including success and failure
            callbacks</p></dd></dl></div><p class="calibre3">The only thing <a id="I_indexterm12_d1e12987" class="calibre1"></a>Backbone expects you to do is invoke either the <code class="literal">options.success()</code><a id="I_indexterm12_d1e12995" class="calibre1"></a> or <code class="literal">options.error()</code>
      callback.<a id="I_indexterm12_d1e13002" class="calibre1"></a></p><p class="calibre3">It’s also possible to override the sync function per model or
      collection, rather than globally:</p><pre class="screen">Todo.prototype.sync = function(method, model, options){ /* ... */ };</pre><p class="calibre3">A good example of a custom <code class="literal">Backbone.sync()</code> function is in the <a class="ulink" href="https://github.com/jeromegn/Backbone.localStorage">local storage
      adapter</a><a id="I_indexterm12_d1e13016" class="calibre1"></a>. Including the adapter and setting the <code class="literal">localStorage</code> option on the relevant models or
      collections enables Backbone to <span class="calibre1">use
      HTML5</span> <code class="literal">localStorage</code>, rather
      than a backend server. As you can see in the example below, <code class="literal">Backbone.sync()</code> CRUDs the <code class="literal">store</code> object, depending on the method, and
      finally calls <code class="literal">options.success()</code> with
      the appropriate model:<a id="I_indexterm12_d1e13041" class="calibre1"></a><a id="I_indexterm12_d1e13042" class="calibre1"></a><a id="I_indexterm12_d1e13043" class="calibre1"></a></p><pre class="screen">// Save all of the todo items under the "todos" localStorage namespace.
Todos.prototype.localStorage = new Store("todos");

// Override Backbone.sync() to use a delegate to the model or collection's
// localStorage property, which should be an instance of Store.
Backbone.sync = function(method, model, options) {

  var resp;
  var store = model.localStorage || model.collection.localStorage;

  switch (method) {
    case "read":    resp = model.id ? store.find(model) : store.findAll(); break;
    case "create":  resp = store.create(model);                            break;
    case "update":  resp = store.update(model);                            break;
    case "delete":  resp = store.destroy(model);                           break;
  }

  if (resp) {
    options.success(resp);
  } else {
    options.error("Record not found");
  }
};</pre></div></div></div>

{% endraw %}

