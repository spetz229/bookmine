---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch08.html
next: OEBPS/ch08s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="WebSockets"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect18_d1e7424" class="calibre1"></a>WebSockets</h1></div></div></div><p class="calibre3"><a class="ulink" href="http://dev.w3.org/html5/websockets">WebSockets</a>
    <a id="index-314K650VP4E" class="calibre1"></a><a id="index-715J286RS0E" class="calibre1"></a>are part of the <a class="ulink" href="http://www.w3.org/TR/html5">HTML5 specification</a>, <a id="I_indexterm8_d1e7443" class="calibre1"></a>providing bidirectional, full-duplex sockets over TCP. This
    means that servers can push data to clients without developers resorting
    to long polling or browser plug-ins, which is quite an improvement.
    Although a number of browsers have implemented support, <a class="ulink" href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76">the
    protocol</a> is still in flux due to security issues. However, that
    shouldn’t put you off; the teething problems will soon get ironed out and
    the spec will be finalized. In the meantime, browsers that don’t support
    WebSockets can fall back to legacy methods like Comet or polling.</p><p class="calibre3">WebSockets have significant advantages over previous server push
    transports because they are full-duplex, aren’t over HTTP, and persist
    once opened. The real drawback to Comet was the overhead of HTTP—every
    request also had a full set of HTTP headers. Then there was the overhead
    of multiple extraneous TCP handshakes, which was significant at high
    levels of requests.</p><p class="calibre3">With WebSockets, once a handshake is completed between client and
    server, messages can be sent back and forth without the overhead of HTTP
    headers. This greatly reduces bandwidth usage, thus improving performance.
    Since there is an open connection, servers can reliably push updates to
    clients as soon as new data becomes available (no polling is required). In
    addition, the connection is duplex, so clients can also send messages back
    to the server, again without the overhead of HTTP.</p><p class="calibre3">This is what Google’s Ian Hickson, the HTML5 specification lead,
    said about WebSockets:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre17">Reducing kilobytes of data to 2 bytes...and reducing latency from
      150ms to 50ms is far more than marginal. In fact, these two factors
      alone are enough to make WebSockets seriously interesting to
      Google.</p></blockquote></div><p class="calibre3">So, let’s look at WebSocket support in the browsers:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Chrome &gt;= 4</p></li><li class="listitem"><p class="calibre3">Safari &gt;= 5</p></li><li class="listitem"><p class="calibre3">iOS &gt;= 4.2</p></li><li class="listitem"><p class="calibre3">Firefox &gt;= 4*</p></li><li class="listitem"><p class="calibre3">Opera &gt;= 11*</p></li></ul></div><p class="calibre3">Although Firefox and Opera have WebSocket implementations, it’s
    currently disabled due to recent security scares. This will all get sorted
    out though, probably by the time this book goes to print. In the meantime,
    you can gracefully degrade with older technologies like Comet and Adobe
    Flash. IE support is nowhere on the map at the moment, and it probably
    won’t be added until after IE9.</p><p class="calibre3">Detecting support for WebSockets is very straightforward:</p><pre class="screen">var supported = ("WebSocket" in window);
if (supported) alert("WebSockets are supported");</pre><p class="calibre3">From a browser perspective, the WebSocket API <a id="I_indexterm8_d1e7488" class="calibre1"></a>is clear and logical. You instantiate a new socket using the
    <code class="literal">WebSocket</code> class<a id="I_indexterm8_d1e7497" class="calibre1"></a>, passing the socket server endpoint—in this case,
    <code class="literal">ws://example.com</code>:</p><pre class="screen">var socket = new WebSocket("ws://example.com");</pre><p class="calibre3">Then, we can add some event listeners to the socket:</p><pre class="screen">// The connection has connected
socket.onopen = function(){ /* ... */ }

// The connection has some new data
socket.onmessage = function(data){ /* ... */ }

// The connection has closed
socket.onclose = function(){ /* ... */ }</pre><p class="calibre3">When the server sends some data,
    <span class="calibre1"><em class="calibre4">onmessage</em></span><a id="I_indexterm8_d1e7516" class="calibre1"></a> will be called. Clients, in turn, can call the <code class="literal">send()</code> function <a id="I_indexterm8_d1e7523" class="calibre1"></a><a id="I_indexterm8_d1e7526" class="calibre1"></a>to transmit data back to the server. Clearly, we should call
    that only after the socket has connected and the
    <span class="calibre1"><em class="calibre4">onopen</em></span> event <a id="I_indexterm8_d1e7536" class="calibre1"></a><a id="I_indexterm8_d1e7539" class="calibre1"></a>has fired:</p><pre class="screen">socket.onmessage = function(msg){
  console.log("New data - ", msg);
};

socket.onopen = function(){
  socket.send("Why, hello there").
};</pre><p class="calibre3">When sending and receiving messages,<a id="I_indexterm8_d1e7549" class="calibre1"></a> only strings are supported. However, it’s simple enough to
    serialize and deserialize the message strings into JSON, creating your own
    protocol:</p><pre class="screen">var rpc = {
  test: function(arg1, arg2) { /* ... */ }
};

socket.onmessage = function(data){
  // Parse JSON
  var msg = JSON.parse(data);

  // Invoke RPC function
  rpc[msg.method].apply(rpc, msg.args);
};</pre><p class="calibre3">Above, we’ve created a remote procedure call (RPC) script.<a id="I_indexterm8_d1e7557" class="calibre1"></a> Our server can send some simple JSON, like the following,
    to invoke functions on the client side:</p><pre class="screen">{"method": "test", "args": [1, 2]}</pre><p class="calibre3">Notice we’re restricting invocation to the <code class="literal">rpc</code> object. This is important for security
    reasons—we don’t want to expose clients to hackers by evaluating arbitrary
    JavaScript.</p><p class="calibre3">To terminate the connection, just call the <code class="literal">close()</code> function:</p><pre class="screen">var socket = new WebSocket("ws://localhost:8000/server");</pre><p class="calibre3">You’ll notice when instantiating a WebSocket that we’re using the
    WebSocket scheme, <code class="literal">ws://</code>, rather than
    <code class="literal">http://</code>. WebSockets also allow encrypted connections
    via TLS using the <code class="literal">wss://</code> schema. By default, WebSockets
    will use port 80 for nonencrypted connections and port 443 for encrypted
    ones. You can override this by providing a custom port in the URL. Keep in
    mind that not all ports are available to clients; firewalls may block the
    more uncommon ones.</p><p class="calibre3">At this stage, you may be thinking, “I can’t possibly use this in
    production—the <span class="calibre1">standard’s</span> a moving
    target and there’s no IE support.” Well, those are valid concerns, but
    luckily there’s a solution. <a class="ulink" href="https://github.com/gimite/web-socket-js">Web-socket-js</a><a id="I_indexterm8_d1e7594" class="calibre1"></a> is a WebSocket implementation powered by Adobe Flash. You
    can use this library to provide legacy browsers a WebSocket fallback to
    Flash, a plug-in that’s almost ubiquitously available. It mirrors the
    WebSocket API exactly, so when WebSockets have better penetration, you'll
    only need to remove the library—not change the code.</p><p class="calibre3">Although the client-side API is fairly straightforward, things
    aren’t quite so simple server side. The WebSocket protocol has been
    through several incompatible iterations: drafts <a class="ulink" href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75">75</a>
    and <a class="ulink" href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76">76</a>.
    Servers need to take account of both drafts by detecting the type of
    handshake clients use.</p><p class="calibre3">WebSockets work by first performing an HTTP “upgrade” request to
    your server. If your server has WebSocket support, it will perform the
    WebSocket handshake and a connection will be initiated. Included in the
    upgrade request is information about the origin domain (where the request
    is coming from). Clients can make WebSocket connections to any domain—it’s
    the server that decides which clients can connect, often by using a
    whitelist of allowed domains.</p><p class="calibre3">From conception, WebSockets were designed to work well with
    firewalls <a id="I_indexterm8_d1e7610" class="calibre1"></a>and proxies,<a id="I_indexterm8_d1e7614" class="calibre1"></a> using popular ports and HTTP headers for the initial
    connection. However, things rarely work out so simply in the wild Web.
    Some proxies change the WebSockets upgrade headers, breaking them. Others
    don’t allow long-lived connections and will time out after a while. In
    fact, the most recent update to the protocol draft (version 76)
    unintentionally broke compatibility with reverse-proxies and gateways.
    There are a few steps you can take to give your WebSockets the best chance
    of success:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Use secured WebSocket connections (wss). Proxies won’t meddle
        with encrypted connections, and you get the added advantage that the
        data is safe from eavesdroppers.</p></li><li class="listitem"><p class="calibre3">Use a TCP load balancer in front of your WebSocket servers,
        rather than an HTTP one. Consider an HTTP balancer only if it actively
        advertises WebSocket support.</p></li><li class="listitem"><p class="calibre3">Don’t assume that if a browser has WebSocket support, it will
        work. Instead, time out connections if they aren’t established
        quickly, gracefully degrading to a different transport like Comet or
        polling.</p></li></ul></div><p class="calibre3">So, what server options are there? Luckily, there is a multitude of
    implementations in languages like Ruby, Python, and Java. Make sure any
    implementation supports at least draft 76 of the protocol, as this is most
    common in clients.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Node.js</p><p class="calibre3">—<a class="ulink" href="http://github.com/miksago/node-websocket-server">node-Websocket-server</a></p><p class="calibre3">—<a class="ulink" href="http://socket.io">Socket.IO</a></p></li><li class="listitem"><p class="calibre3">Ruby</p><p class="calibre3">—<a class="ulink" href="http://github.com/igrigorik/em-websocket">EventMachine</a></p><p class="calibre3">—<a class="ulink" href="https://github.com/lifo/cramp">Cramp</a></p><p class="calibre3">—<a class="ulink" href="http://rainbows.rubyforge.org/sunshowers/">Sunshowers</a></p></li><li class="listitem"><p class="calibre3">Python</p><p class="calibre3">—<a class="ulink" href="http://github.com/rlotun/txWebSocket">Twisted</a></p><p class="calibre3">—<a class="ulink" href="http://code.google.com/p/pywebsocket">Apache
        module</a></p></li><li class="listitem"><p class="calibre3">PHP</p><p class="calibre3">—<a class="ulink" href="https://github.com/nicokaiser/php-websocket">php-Websocket</a></p></li><li class="listitem"><p class="calibre3">Java</p><p class="calibre3">—<a class="ulink" href="http://www.eclipse.org/jetty">Jetty</a></p></li><li class="listitem"><p class="calibre3">Google Go</p><p class="calibre3">—<a class="ulink" href="http://code.google.com/p/go">native</a></p></li></ul></div><div class="book" title="Node.js and Socket.IO"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2927480" class="calibre12"></a>Node.js and Socket.IO</h2></div></div></div><p class="calibre3"><a class="ulink" href="http://nodejs.org">Node.js</a><a id="I_indexterm8_d1e7697" class="calibre1"></a> is the newest kid on the block, but one of the most
      exciting. Node.js is an evented JavaScript server, powered by Google’s
      <a class="ulink" href="http://code.google.com/p/v8">V8 JS engine</a>. As such,
      it’s incredibly fast and is great for services that have a large number
      of connected clients, like a WebSocket server.</p><p class="calibre3"><a class="ulink" href="http://socket.io">Socket.IO</a><a id="I_indexterm8_d1e7707" class="calibre1"></a> is a Node.js library for WebSockets. What’s interesting,
      though, is that it goes far beyond that. Here’s a blurb from its
      site:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre17">Socket.IO aims to make real-time apps possible in every browser
        and mobile device, blurring the differences between the different
        transport mechanisms.</p></blockquote></div><p class="calibre3">Socket.IO will try and use WebSockets if they’re supported, but it
      will fall back to other transports if necessary. The list of supported
      transports is very comprehensive and offers a lot of browser
      compatibility.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">WebSocket</p></li><li class="listitem"><p class="calibre3">Adobe Flash Socket</p></li><li class="listitem"><p class="calibre3">ActiveX HTMLFile (IE)</p></li><li class="listitem"><p class="calibre3">XHR with multipart encoding</p></li><li class="listitem"><p class="calibre3">XHR with long-polling</p></li><li class="listitem"><p class="calibre3">JSONP polling (for cross-domain)</p></li></ul></div><p class="calibre3">Socket.IO’s browser support is brilliant. Server push can be
      notoriously difficult to implement, but the Socket.IO team has gone
      through all that pain for you, ensuring compatibility with most
      browsers. As such, it works in the following browsers:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Safari &gt;= 4</p></li><li class="listitem"><p class="calibre3">Chrome &gt;= 5</p></li><li class="listitem"><p class="calibre3">IE &gt;= 6</p></li><li class="listitem"><p class="calibre3">iOS</p></li><li class="listitem"><p class="calibre3">Firefox &gt;= 3</p></li><li class="listitem"><p class="calibre3">Opera &gt;= 10.61</p></li></ul></div><p class="calibre3">Although the server side to Socket.IO was initially written for
      Node.js, there are now implementations in other languages, like <a class="ulink" href="http://github.com/markjeee/Socket.IO-rack">Ruby (Rack)</a>,
      <a class="ulink" href="https://github.com/MrJoes/tornadio">Python
      (Tornado)</a>, <a class="ulink" href="http://code.google.com/p/socketio-java">Java</a>, and <a class="ulink" href="http://github.com/madari/go-socket.io">Google Go</a>.</p><p class="calibre3">A quick look at the API will demonstrate how simple and
      straightforward it is. The client-side API looks very similar to the
      WebSocket one:</p><pre class="screen">var socket = new io.Socket(); 

socket.on("connect", function(){ 
  socket.send('hi!'); 
});

socket.on("message", function(data){ 
  alert(data);
});

socket.on("disconnect", function(){});</pre><p class="calibre3">Behind the scenes, Socket.IO will work out the best transport to
      use. As written in its <em class="calibre4">readme</em> file, Socket.IO is
      “making creating real-time apps that work everywhere a snap.”</p><p class="calibre3">If you’re looking for something a bit higher level than Socket.IO,
      you may be interested in <a class="ulink" href="https://github.com/maccman/juggernaut">Juggernaut</a>, which
      builds upon it. Juggernaut has a channel interface: clients can
      subscribe to channels and servers can publish to them, i.e.—the <a class="ulink" href="http://en.wikipedia.org/wiki/PubSub">PubSub</a> pattern. The
      library can manage scaling, publishing to specific clients, TLS, and
      more.</p><p class="calibre3">If you need hosted solutions, look no further than <a class="ulink" href="http://pusherapp.com">Pusher</a><a id="I_indexterm8_d1e7792" class="calibre1"></a>. Pusher lets you leave behind the hassle of managing your
      own server so that you can concentrate on the fun part: developing web
      applications. For clients, it is as simple as including a JavaScript
      file in the page and subscribing to a channel. When it comes to
      publishing messages, it’s just a case of sending an HTTP request to
      their <a class="ulink" href="http://pusherapp.com/docs">REST API</a>.<a id="I_indexterm8_d1e7799" class="calibre1"></a><a id="I_indexterm8_d1e7800" class="calibre1"></a></p></div></div></div>

{% endraw %}

