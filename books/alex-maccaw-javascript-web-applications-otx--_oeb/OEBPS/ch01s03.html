---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch01s02.html
next: OEBPS/ch01s04.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="What Is MVC?"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect11_d1e567" class="calibre1"></a>What Is MVC?</h1></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e571" class="calibre1"></a>MVC is a design pattern that breaks an application into
    three parts: the data (Model), the presentation layer (View), and the user
    interaction layer (Controller). In other words, the event flow goes like
    this:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre3">The user interacts with the application.</p></li><li class="listitem"><p class="calibre3">The controller’s event handlers trigger.</p></li><li class="listitem"><p class="calibre3">The controller requests data from the model, giving it to the
        view.</p></li><li class="listitem"><p class="calibre3">The view presents the data to the user.</p></li></ol></div><p class="calibre3">Or, to give a real example, <a class="ulink" href="ch01s03.html#fig_1_1" title="Figure 1-1. Sending a new chat message from Holla">Figure 1-1</a> shows how
    sending a new chat message would work with Holla.</p><div class="book"><div class="figure"><a id="fig_1_1" class="calibre1"></a><div class="book"><div class="book"><a id="I_mediaobject1_d1e597" class="calibre1"></a><img src="httpatomoreillycomsourceoreillyimages885478.png" alt="Holla" class="calibre5"/></div></div><p class="title4">Figure 1-1. Sending a new chat message from Holla</p></div></div><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre3">The user submits a new chat message.</p></li><li class="listitem"><p class="calibre3">The controller’s event handlers trigger.</p></li><li class="listitem"><p class="calibre3">The controller creates a new Chat Model record.</p></li><li class="listitem"><p class="calibre3">The controller then updates the view.</p></li><li class="listitem"><p class="calibre3">The user sees his new chat message in chat log.</p></li></ol></div><p class="calibre3">The MVC architectural pattern can even be implemented without
    libraries or frameworks. The key is to divide up the responsibilities of
    the MVC components into clearly defined sections of code, keeping them
    decoupled. This allows for independent development, testing, and
    maintenance of each component.</p><p class="calibre3">Let’s explore the components of MVC in detail.</p><div class="book" title="The Model"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2863052" class="calibre12"></a>The Model</h2></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e629" class="calibre1"></a>The model is where all the application’s data objects are
      stored. For example, we might have a User Model that contains a list of
      users, their attributes, and any logic associated specifically with that
      model.</p><p class="calibre3">A model doesn’t know anything about views or controllers. The only
      thing a model should contain is data<a id="I_indexterm1_d1e637" class="calibre1"></a> and the logic associated directly with that data. Any
      event handling code, view templates, or logic not specific to that model
      should be kept well clear of it. You know an application’s MVC
      architecture is violated when you start seeing view code in the models.
      Models should be completely decoupled from the rest of your
      application.</p><p class="calibre3">When controllers fetch data from servers or create new records,
      they wrap them in model instances. This means that our data is object
      oriented, and any functions or logic defined on the model can be called
      directly on the data.</p><p class="calibre3">So, rather than this:</p><pre class="screen">var user = users["foo"];
destroyUser(user);</pre><p class="calibre3">We can do something like this:</p><pre class="screen">var user = User.find("foo");
user.destroy();</pre><p class="calibre3">The first example is not namespaced or object oriented. If we have
      another <code class="literal">destroyUser()</code> function
      defined in our application, the two will conflict. Global variables and
      functions <a id="I_indexterm1_d1e659" class="calibre1"></a><a id="I_indexterm1_d1e662" class="calibre1"></a><a id="I_indexterm1_d1e667" class="calibre1"></a>should always be kept to an absolute minimum. In the
      second example, the <code class="literal">destroy()</code>
      function <a id="I_indexterm1_d1e676" class="calibre1"></a><a id="I_indexterm1_d1e679" class="calibre1"></a>is namespaced behind User instances, as are all the stored
      records. This is ideal, since we’re keeping global variables to a
      minimum, exposing fewer areas to potential conflicts. The code is
      cleaner and can take advantage of inheritance so functions like <code class="literal">destroy()</code> don’t have be defined separately on
      every model.</p><p class="calibre3">Models are explored in much more depth in <a class="ulink" href="ch03.html" title="Chapter 3. Models and Data">Chapter 3</a>, which covers topics such as loading in data
      from servers and creating object-relational mappers (ORMs).</p></div><div class="book" title="The View"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2863100" class="calibre12"></a>The View</h2></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e697" class="calibre1"></a>The view layer is what’s presented to the user and is what
      she interacts with. In a JavaScript application, the view would be made
      up mostly of HTML, CSS, and JavaScript templates.<a id="I_indexterm1_d1e703" class="calibre1"></a> Apart from simple conditional statements in templates,
      the views shouldn’t contain any logic.</p><p class="calibre3">In fact, like models, views should also be decoupled from the rest
      of the application. Views shouldn’t know anything about controllers and
      models—they should be independent. Mixing up views with logic is one of
      the surest paths to disaster.</p><p class="calibre3">That isn’t to say MVC doesn’t allow for presentational logic—as
      long as it’s not defined inside views. Presentational logic resides in
      what are called <span class="calibre1"><em class="calibre4">helpers</em></span><a id="I_indexterm1_d1e715" class="calibre1"></a>: scripts solely for small utility functions related to
      the view.</p><p class="calibre3">The example below, which includes logic inside views, is something
      you shouldn’t do:</p><pre class="screen">// template.html
&lt;div&gt;
  &lt;script&gt;
    function formatDate(date) {
      /* ... */
    };
  &lt;/script&gt;
  ${ formatDate(this.date) }
&lt;/div&gt;</pre><p class="calibre3">In the code above, we’re inserting the <code class="literal">formatDate()</code> function directly into the view,
      which violates MVC, resulting in an unmaintainable mess of tag soup. By
      separating out presentational logic into helpers, as with the example
      below, we’re avoiding that problem and keeping our application’s
      structure MVC-compliant.</p><pre class="screen">// helper.js
var helper = {};
helper.formatDate = function(){ /* ... */ };

// template.html
&lt;div&gt;
  ${ helper.formatDate(this.date) }
&lt;/div&gt;</pre><p class="calibre3">In addition, all presentational logic is namespaced under the
      <code class="literal">helper</code> variable, preventing conflicts
      and keeping the code clean and extendable.</p><p class="calibre3">Don’t worry too much about specifics regarding views and
      templates—we cover them extensively in <a class="ulink" href="ch05.html" title="Chapter 5. Views and Templating">Chapter 5</a>. The aim of this section is to familiarize
      you with how views relate to the MVC architectural pattern.</p></div><div class="book" title="The Controller"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2895610" class="calibre12"></a>The Controller</h2></div></div></div><p class="calibre3"><a id="I_indexterm1_d1e745" class="calibre1"></a>Controllers are the glue between models and views.
      Controllers receive events <a id="I_indexterm1_d1e751" class="calibre1"></a>and input from views, process them (perhaps involving
      models), and update the views accordingly. The controller will add event
      listeners to views when the page loads, such as those detecting when
      forms are submitted or buttons are clicked. Then, when the user
      interacts with your application, the events trigger actions inside the
      controllers.</p><p class="calibre3">You don’t need any special libraries or frameworks to implement
      controllers; here’s an example using plain old jQuery:</p><pre class="screen">var Controller = {};

// Use a anonymous function to enscapulate scope
(Controller.users = function($){

  var nameClick = function(){
    /* ... */
  };

  // Attach event listeners on page load
  $(function(){
    $("#view .name").click(nameClick);
  });

})(jQuery);</pre><p class="calibre3">We’re creating a <code class="literal">users</code>
      Controller that is namespaced under the <code class="literal">Controller</code> variable. Then, we’re using an
      anonymous function to encapsulate scope, preventing variable pollution
      of the global scope. When the page loads, we’re adding a
      <span class="calibre1"><em class="calibre4">click</em></span> event listener to a view element.</p><p class="calibre3">As you can see, controllers don’t require a library or framework.
      However, to comply with MVC’s architectural requirements, they must be
      separated from Models and Views. Controllers and states are covered in
      more detail in <a class="ulink" href="ch04.html" title="Chapter 4. Controllers and State">Chapter 4</a>.</p></div></div></div>

{% endraw %}

