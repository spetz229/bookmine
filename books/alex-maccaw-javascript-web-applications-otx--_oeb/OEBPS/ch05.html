---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch04s04.html
next: OEBPS/ch05s02.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre7"></div><div class="book" title="Chapter 5. Views and Templating"><div class="book"><div class="book"><div class="book"><div class="calibre7"></div><h1 class="title1"><a id="views-templating" class="calibre1"></a>Chapter 5. Views and Templating</h1></div></div></div><p class="calibre3">Views are the interface to your application; they’re what the end user
  actually interacts with and sees. In our case, views are logicless HTML
  fragments managed by the application’s controllers, which deal with event
  handlers and interpolating data. This is where it can be quite tempting to
  break the MVC abstraction by including logic directly into your views. Don’t
  succumb to that temptation! You’ll end up with senseless spaghetti
  code.</p><p class="calibre3">One of the biggest architectural changes you’ll have to make when
  moving server-side applications <a id="I_indexterm5_d1e5002" class="calibre1"></a>to the client side is with views. Traditionally, you could
  just interpolate server-side data with HTML fragments, creating new pages.
  However, views in JavaScript applications are somewhat different.</p><p class="calibre3">First, you have to transfer any data needed for the view to the client
  because you don’t have access to server-side variables. This is generally
  done with an Ajax call, returning a JSON object, which is then loaded by
  your application’s models. You shouldn’t be prerendering any HTML <a id="I_indexterm5_d1e5008" class="calibre1"></a><a id="I_indexterm5_d1e5011" class="calibre1"></a>on the server side, but rather delegating all of that to the
  client. This will ensure that your client-side application isn’t reliant on
  the server for rendering views, keeping its interface snappy.</p><p class="calibre3">You then load that data into your views, either by creating the DOM
  elements dynamically with JavaScript or by using templates. I’ll elaborate
  on those two options below.</p><div class="book" title="Dynamically Rendering Views"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect15_d1e5019" class="calibre1"></a>Dynamically Rendering Views</h1></div></div></div><p class="calibre3"><a id="I_indexterm5_d1e5023" class="calibre1"></a><a id="I_indexterm5_d1e5028" class="calibre1"></a><a id="I_indexterm5_d1e5031" class="calibre1"></a>One way to create views is pragmatically via JavaScript. You
    can create DOM elements <a id="I_indexterm5_d1e5037" class="calibre1"></a><a id="I_indexterm5_d1e5042" class="calibre1"></a>using <code class="literal">document.createElement()</code><a id="I_indexterm5_d1e5050" class="calibre1"></a>, setting their contents and appending them to the page.
    When it’s time to redraw the view, just empty the view and repeat the
    process:</p><pre class="screen">var views = document.getElementById("views");
views.innerHTML = ""; // Empty the element

var container = document.createElement("div");
container.id = "user";

var name = document.createElement("span");
name.innerHTML = data.name;

container.appendChild(name);
views.appendChild(container);</pre><p class="calibre3">Or, for a more succinct API with jQuery:</p><pre class="screen">$("#views").empty();

var container = $("&lt;div /&gt;").attr({id: "user"});
var name      = $("&lt;span /&gt;").text(data.name);

$("#views").append(container.append(name));</pre><p class="calibre3">I’d only advocate this if the view you need to render is very small,
    perhaps just a couple of elements. Placing view elements in your
    controllers or states compromises the application’s MVC
    architecture.</p><p class="calibre3">Instead of creating the elements from scratch, I advise including
    the static HTML in the page—hiding and showing it when necessary. This
    will keep any view-specific code in your controllers to an absolute
    minimum, and you can just update the element’s contents when
    necessary.</p><p class="calibre3">For example, let’s create an HTML fragment that will serve as our
    view:</p><pre class="screen">&lt;div id="views"&gt;
  &lt;div class="groups"&gt; ... &lt;/div&gt;
  &lt;div class="user"&gt;
    &lt;span&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre><p class="calibre3">Now, we can use jQuery selectors to update the view and to toggle
    the display of the various elements:</p><pre class="screen">$("#views div").hide();

var container = $("#views .user");
container.find("span").text(data.name);
container.show();</pre><p class="calibre3">This method is preferable to generating the elements because it
    keeps the view and controller as separate as possible.</p></div></div></div>

{% endraw %}

