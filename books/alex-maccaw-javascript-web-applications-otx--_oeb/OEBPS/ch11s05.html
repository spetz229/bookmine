---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch11s04.html
next: OEBPS/ch11s06.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Controllers"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect111_d1e10956" class="calibre1"></a>Controllers</h1></div></div></div><p class="calibre3"><a id="index-805C231NJ8S" class="calibre1"></a><a id="index-730I441MW4A" class="calibre1"></a>Controllers are the last component to Spine, and they
    provide the glue that will tie the rest of your application together.
    Controllers generally add event handlers to DOM elements and models,
    render templates, and keep the view and models in sync. To create a Spine
    controller, you need to subclass <code class="literal">Spine.Controller</code> by calling <code class="literal">create()</code><a id="I_indexterm11_d1e10976" class="calibre1"></a><a id="I_indexterm11_d1e10979" class="calibre1"></a>:</p><pre class="screen">jQuery(function(){
  window.Tasks = Spine.Controller.create({
    // Controller properties
  });
});</pre><p class="calibre3">It’s recommended to load controllers only after the rest of the page
    has loaded, so you don’t have to deal with different page states. In all
    the Spine examples, you’ll notice each controller is contained inside a
    call to <code class="literal">jQuery()</code>. This ensures that the
    controller will be created only when the document’s ready.</p><p class="calibre3">In Spine, the convention is to give controllers camel-cased plural
    names—usually, the plural of the model with which they’re associated. Most
    controllers just have instance properties, as they’re used after
    instantiation only. Instantiating controllers is the same as instantiating
    any other class, by calling <code class="literal">init()</code><a id="I_indexterm11_d1e10996" class="calibre1"></a><a id="I_indexterm11_d1e10999" class="calibre1"></a>:</p><pre class="screen">var tasks = Tasks.init();</pre><p class="calibre3">Controllers always have a DOM element <a id="I_indexterm11_d1e11009" class="calibre1"></a>associated with them, which can be accessed through the
    <code class="literal">el</code> property.<a id="I_indexterm11_d1e11018" class="calibre1"></a><a id="I_indexterm11_d1e11021" class="calibre1"></a> You can optionally pass this through on instantiation;
    otherwise, the controller will generate a default <code class="literal">div</code> element:</p><pre class="screen">var tasks = Tasks.init({el: $("#tasks")});
assertEqual( tasks.el.attr("id"), "tasks" );</pre><p class="calibre3">This element can be used internally to append templates and render
    views:</p><pre class="screen">window.Tasks = Spine.Controller.create({
  init: function(){
    this.el.html("Some rendered text");
  }
});

var tasks = Tasks.init();
$("body").append(tasks.el);</pre><p class="calibre3">In fact, any arguments you pass to <code class="literal">init()</code> will be set as properties on the
    controller. For example:</p><pre class="screen">var tasks = Tasks.init({item: Task.first()});
assertEqual( Task.first(), tasks.item );</pre><div class="book" title="Proxying"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936058" class="calibre12"></a>Proxying</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11049" class="calibre1"></a><a id="I_indexterm11_d1e11056" class="calibre1"></a>You’ll notice in the previous examples that we’re wrapping
      all event callbacks <a id="I_indexterm11_d1e11062" class="calibre1"></a><a id="I_indexterm11_d1e11067" class="calibre1"></a>with <code class="literal">this.proxy()</code><a id="I_indexterm11_d1e11075" class="calibre1"></a> to ensure that they always run in the correct context.
      Because this is such a common pattern, Spine provides a shortcut,
      <code class="literal">proxied</code><a id="I_indexterm11_d1e11081" class="calibre1"></a>. Onto your controller, simply add a <code class="literal">proxied</code> property containing an array of
      function names that should always be executed in the context of the
      controller:</p><pre class="screen">// Equivalent to using proxyAll
var Tasks = Spine.Controller.create({
  proxied: ["render", "addAll"],

  render: function(){ /* ... */ },
  addAll: function(){ /* ... */ }
});</pre><p class="calibre3">Now you can pass callbacks like <code class="literal">render()</code> to event listeners without being
      concerned about execution context. Those functions will always be
      invoked in the correct context.</p></div><div class="book" title="Elements"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936169" class="calibre12"></a>Elements</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11100" class="calibre1"></a><a id="I_indexterm11_d1e11107" class="calibre1"></a>It’s often useful to access elements inside your
      controller as local properties. Spine provides a shortcut for this:
      <code class="literal">elements</code>. Just add the <code class="literal">elements</code> property on your controller,
      containing an object of selectors to names. In the example below,
      <code class="literal">this.input</code><a id="I_indexterm11_d1e11121" class="calibre1"></a> refers to the element selected by <code class="literal">form input[type=text]</code>. All selections are done
      in the context of the controller’s element (<code class="literal">el</code>), not the whole page:</p><pre class="screen">// The `input` instance variable
var Tasks = Spine.Controller.create({
  elements: {
    "form input[type=text]": "input"
  },

  init: function(){
    // this.input refers to the form's input
    console.log( this.input.val() );
  }
});</pre><p class="calibre3">Keep in mind, though, that if you replace the HTML of the
      controller’s element (<code class="literal">el</code>), you’ll
      need to call <code class="literal">refreshElements()</code><a id="I_indexterm11_d1e11141" class="calibre1"></a> to refresh all the element’s references.</p></div><div class="book" title="Delegating Events"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936279" class="calibre12"></a>Delegating Events</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11149" class="calibre1"></a><a id="I_indexterm11_d1e11156" class="calibre1"></a>Spine’s <code class="literal">events</code> property<a id="I_indexterm11_d1e11165" class="calibre1"></a> gives you an easy way to add event listeners in bulk.
      Behind the scenes, Spine takes advantage of event bubbling,<a id="I_indexterm11_d1e11171" class="calibre1"></a> so only one event listener is added onto the controller’s
      element (<code class="literal">el</code>). Like the <code class="literal">events</code> property, all event delegation is
      scoped by <code class="literal">el</code>.</p><p class="calibre3">Events take the form of <code class="literal">{"eventName
      selector": "callback"}</code>. The selector is optional and, if it
      isn’t provided, the event will be placed straight on <code class="literal">el</code>. Otherwise, the event will be <a class="ulink" href="http://api.jquery.com/delegate">delegated</a>, and it will be
      triggered if the event type is fired on a child matching the selector.
      This happens dynamically, so it doesn’t matter whether the contents of
      <code class="literal">el</code> change:</p><pre class="screen">var Tasks = Spine.Controller.create({
  events: {
    "keydown form input[type=text]": "keydown"
  },

  keydown: function(e){ /* ... */ }
});</pre><p class="calibre3">In the example above, whenever the input matching the selector
      receives a <span class="calibre1"><em class="calibre4">keydown</em></span> event,<a id="I_indexterm11_d1e11206" class="calibre1"></a><a id="I_indexterm11_d1e11209" class="calibre1"></a> the controller’s <code class="literal">keydown</code> callback is executed. Spine makes sure
      that it’s executed with the correct context, so you don’t need to worry
      about proxying event callbacks in this case.</p><p class="calibre3">The <code class="literal">event</code> object<a id="I_indexterm11_d1e11223" class="calibre1"></a> is passed along to the callback, which is useful in this
      example because we can tell which key was pressed. Additionally, the
      element in question can be retrieved from the event’s <code class="literal">target</code> property.</p></div><div class="book" title="Controller Events"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936465" class="calibre12"></a>Controller Events</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11236" class="calibre1"></a><a id="I_indexterm11_d1e11243" class="calibre1"></a>As well as event delegation, Spine’s controllers support
      custom events. By default,<a id="I_indexterm11_d1e11249" class="calibre1"></a> controllers are extending with <code class="literal">Spine.Events</code><a id="I_indexterm11_d1e11257" class="calibre1"></a>, meaning they have all the event functionality that
      entails, like <code class="literal">bind()</code> and <code class="literal">trigger()</code>. You can use this to ensure that
      your controllers are decoupled from each other, or as part of the
      controller’s internal structure:</p><pre class="screen">var Sidebar = Spine.Controller.create({
  events: {
    "click [data-name]": this.click
  },

  init: function(){
    this.bind("change", this.change);
  },

  change: function(name){ /* ... */ },

  click: function(e){
    this.trigger("change", $(e.target).attr("data-name"));
  }

  // ...
});

var sidebar = Sidebar.init({el: $("#sidebar")});
sidebar.bind("change", function(name){
  console.log("Sidebar changed:", name);
})</pre><p class="calibre3">In the example above, other controllers can bind to <code class="literal">Sidebar</code>’s <span class="calibre1"><em class="calibre4">change</em></span> event or
      even trigger it. As we explored in <a class="ulink" href="ch02.html" title="Chapter 2. Events and Observing">Chapter 2</a>,
      custom events can be a great way of structuring applications internally,
      even if they’re never used externally.</p></div><div class="book" title="Global Events"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936574" class="calibre12"></a>Global Events</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11283" class="calibre1"></a><a id="I_indexterm11_d1e11290" class="calibre1"></a>Spine lets you bind to and trigger events on a global
      basis. This is a form of PubSub,<a id="I_indexterm11_d1e11296" class="calibre1"></a> and it lets controllers communicate without even knowing
      about one another, ensuring they’re properly decoupled. This is achieved
      by having a global object, <code class="literal">Spine.App</code><a id="I_indexterm11_d1e11304" class="calibre1"></a>, which anything can bind to or trigger events on:</p><pre class="screen">var Sidebar = Spine.Controller.create({
  proxied: ["change"],

  init: function(){
    this.App.bind("change", this.change);
  },

  change: function(name){ /* ... */ }
});</pre><p class="calibre3">Spine’s controllers aliased <code class="literal">Spine.App</code> to a shortened <code class="literal">this.App</code><a id="I_indexterm11_d1e11317" class="calibre1"></a>, saving you a bit of typing. You can see in the example
      above that the <code class="literal">Sidebar</code> controller is
      binding to the global event <span class="calibre1"><em class="calibre4">change</em></span>. Other
      controllers or scripts can then trigger this event, passing any required
      data:</p><pre class="screen">Spine.App.trigger("change", "messages");</pre></div><div class="book" title="The Render Pattern"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936683" class="calibre12"></a>The Render Pattern</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11333" class="calibre1"></a><a id="I_indexterm11_d1e11340" class="calibre1"></a>Now that we’ve covered all the main options available in
      controllers, let’s look at some typical use cases.</p><p class="calibre3">The <em class="calibre4">render pattern</em> is a really useful way of
      binding models and views. When the controller is instantiated, it adds
      an event listener to the relevant model, invoking a callback when the
      model is refreshed or changed. The callback will update <code class="literal">el</code>, usually by replacing its contents with a
      rendered template:</p><pre class="screen">var Tasks = Spine.Controller.create({
  init: function(){
    Task.bind("refresh change", this.proxy(this.render));
  },

  template: function(items){ 
    return($("#tasksTemplate").tmpl(items));
  },

  render: function(){
    this.el.html(this.template(Task.all()));
  }
});</pre><p class="calibre3">This simple but blunt method for data binding updates every
      element whenever a single record is changed. This is fine for
      uncomplicated and small lists, but you may find you need more control
      over individual elements, such as adding event handlers to items. This
      is where the <span class="calibre1"><em class="calibre4">element pattern</em></span> comes in.</p></div><div class="book" title="The Element Pattern"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2936752" class="calibre12"></a>The Element Pattern</h2></div></div></div><p class="calibre3"><a id="I_indexterm11_d1e11363" class="calibre1"></a><a id="I_indexterm11_d1e11370" class="calibre1"></a>The element pattern essentially gives you the same
      functionality as the render pattern, but with a lot more control. It
      consists of two controllers: one that controls a collection of items,
      and one that deals with each individual item. Let’s dive right into the
      code to give you a good indication of how it works:</p><pre class="screen">var TasksItem = Spine.Controller.create({
  // Delegate the click event to a local handler
  events: {
    "click": "click"
  },

  // Ensure functions have the correct context
  proxied: ["render", "remove"],

  // Bind events to the record
  init: function(){
    this.item.bind("update", this.render);
    this.item.bind("destroy", this.remove);
  },

  // Render an element
  render: function(item){
    if (item) this.item = item;

    this.el.html(this.template(this.item));
    return this;
  },

  // Use a template, in this case via jQuery.tmpl.js
  template: function(items){ 
    return($("#tasksTemplate").tmpl(items));
  },

  // Called after an element is destroyed
  remove: function(){
    this.el.remove();
  },

  // We have fine control over events, and 
  // easy access to the record too
  click: function(){ /* ... */ }
});

var Tasks = Spine.Controller.create({
  proxied: ["addAll", "addOne"],

  init: function(){
    Task.bind("refresh", this.addAll);
    Task.bind("create",  this.addOne);
  },

  addOne: function(item){
    var task = TasksItem.init({item: item});
    this.el.append(task.render().el);
  },

  addAll: function(){
    Task.each(this.addOne);
  }
});</pre><p class="calibre3">In the example above, <code class="literal">Tasks</code> has
      responsibility for adding records when they’re initially created, and
      <code class="literal">TasksItem</code> takes responsibility for
      the record’s <em class="calibre4">update</em> and
      <em class="calibre4">destroy</em> events, rerendering the record when
      necessary. Although it’s more complicated, this gives us some advantages
      over the previous render pattern.</p><p class="calibre3">For one thing, it’s more efficient—the list doesn’t need to be
      redrawn whenever a single element changes. Furthermore, we now have a
      lot more control over individual items. We can place event handlers, as
      demonstrated with the <code class="literal">click</code> callback,
      and manage rendering on an item-by-item basis.<a id="I_indexterm11_d1e11395" class="calibre1"></a><a id="I_indexterm11_d1e11396" class="calibre1"></a></p></div></div></div>

{% endraw %}

