---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch05s02.html
next: OEBPS/ch06.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Binding"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect15_d1e5361" class="calibre1"></a>Binding</h1></div></div></div><p class="calibre3">Binding is where you start to see the real benefits of view
    rendering on the client side. Essentially, binding hooks together a view
    element and a JavaScript object (usually a model). When the JavaScript
    object changes, the view automatically updates to reflect the newly
    modified object. In other words, once you’ve got your views and models
    bound together, the views will rerender automatically when the
    application’s models are updated.<a id="I_indexterm5_d1e5366" class="calibre1"></a></p><p class="calibre3">Binding is a really big deal. It means your controllers don’t have
    to deal with updating views when changing records, because it all happens
    automatically in the background. Structuring your application using
    binders also paves the way for real-time applications, which we’ll cover
    in depth in <a class="ulink" href="ch08.html" title="Chapter 8. The Real-Time Web">Chapter 8</a>.</p><p class="calibre3">So, in order to bind JavaScript objects and views, we need to get a
    callback that instructs the view to update when an object’s property
    changes. The trouble is that JavaScript doesn’t provide a native method
    for doing that. The language doesn’t have any <code class="literal">method_missing</code> functionality like in Ruby or
    Python, and it isn’t yet possible to emulate the behavior using JavaScript
    <a class="ulink" href="http://ejohn.org/blog/javascript-getters-and-setters">getters
    and setters</a>. However, because JavaScript is a very dynamic
    language, we can roll our own <code class="literal">change</code> callback:</p><pre class="screen">var addChange = function(ob){
  ob.change = function(callback){
    if (callback) {
      if ( !this._change ) this._change = [];
      this._change.push(callback);
    } else {
      if ( !this._change ) return;
      for (var i=0; i &lt; this._change.length; i++)
        this._change[i].apply(this);
    }
  };    
};</pre><p class="calibre3">The <code class="literal">addChange()</code> function
    <a id="I_indexterm5_d1e5391" class="calibre1"></a><a id="I_indexterm5_d1e5394" class="calibre1"></a>adds a <code class="literal">change()</code> function
    onto any object it’s passed. The <code class="literal">change()</code> function works exactly the same as the
    <span class="calibre1"><em class="calibre4">change</em></span> event in jQuery. You can add callbacks by
    invoking <code class="literal">change()</code> with a function, or
    trigger the event by calling <code class="literal">change()</code>
    without any arguments. Let’s see it in practice:</p><pre class="screen">var object = {};
object.name = "Foo";

addChange(object);

object.change(function(){
  console.log("Changed!", this);
  // Potentially update view
});

object.change();

object.name = "Bar";
object.change();</pre><p class="calibre3">So, you see we’ve added a <code class="literal">change()</code> callback to the object, allowing us to
    bind and trigger <span class="calibre1"><em class="calibre4">change</em></span> events.</p><div class="book" title="Binding Up Models"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2921853" class="calibre12"></a>Binding Up Models</h2></div></div></div><p class="calibre3"><a id="I_indexterm5_d1e5430" class="calibre1"></a>Now let’s take that binding example a step further and
      apply it to models. Whenever a model record is created, updated, or
      destroyed, we’ll trigger a <span class="calibre1"><em class="calibre4">change</em></span> event,<a id="I_indexterm5_d1e5439" class="calibre1"></a><a id="I_indexterm5_d1e5442" class="calibre1"></a> rerendering the view. In the example below, we’re
      creating a basic <code class="literal">User</code> class, setting
      up event binding and triggering, and finally listening to the
      <span class="calibre1"><em class="calibre4">change</em></span> event, rerendering the view whenever it’s
      triggered:</p><pre class="screen">&lt;script&gt;      
  var User = function(name){
    this.name = name;
  };

  User.records = []

  User.bind = function(ev, callback) {
    var calls = this._callbacks || (this._callbacks = {});
    (this._callbacks[ev] || (this._callbacks[ev] = [])).push(callback);
  };

  User.trigger = function(ev) {
    var list, calls, i, l;
    if (!(calls = this._callbacks)) return this;
    if (!(list  = this._callbacks[ev])) return this;
    jQuery.each(list, function(){ this() })
  };

  User.create = function(name){
    this.records.push(new this(name));
    this.trigger("change")
  };

  jQuery(function($){
    User.bind("change", function(){       
      var template = $("#userTmpl").tmpl(User.records);

      $("#users").empty();        
      $("#users").append(template);
    });
  }):
&lt;/script&gt;

&lt;script id="userTmpl" type="text/x-jquery-tmpl"&gt;
  &lt;li&gt;${name}&lt;/li&gt;
&lt;/script&gt;

&lt;ul id="users"&gt;
&lt;/ul&gt;</pre><p class="calibre3">Now, whenever we alter <code class="literal">User</code>’s
      records, the <code class="literal">User</code> model’s
      <span class="calibre1"><em class="calibre4">change</em></span> event will be triggered, invoking our
      templating callback and redrawing the list of users. This is pretty
      useful, as we can go about creating and updating users without having to
      worry about updating the view, which will happen automatically. For
      example, let’s create a new <code class="literal">User</code>:</p><pre class="screen">User.create("Sam Seaborn");</pre><p class="calibre3">The <code class="literal">User</code>’s
      <span class="calibre1"><em class="calibre4">change</em></span> event will be invoked and our template will
      rerender, automatically updating the view and showing our new user. You
      can see the full model-binding <span class="calibre1">example</span> in
      <span class="calibre1"><em class="calibre4">assets/ch05/model.html</em></span>.</p></div></div></div>

{% endraw %}

