---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch10.html
next: OEBPS/ch10s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Caching"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect110_d1e9690" class="calibre1"></a>Caching</h1></div></div></div><p class="calibre3"><a id="I_indexterm10_d1e9694" class="calibre1"></a><a id="I_indexterm10_d1e9697" class="calibre1"></a>If it weren’t for caching, the Web would collapse under
    network traffic. Caching stores recently requested resources locally so
    subsequent requests can serve them up from the disk, rather than
    downloading them again. It’s important to explicitly tell browsers what
    you want cached. Some browsers like Chrome will make their own default
    <a id="I_indexterm10_d1e9703" class="calibre1"></a>decisions, but you shouldn’t rely on that.</p><p class="calibre3">For static resources, make the cache “never” expire by adding a far
    future <code class="literal">Expires</code> header.<a id="I_indexterm10_d1e9714" class="calibre1"></a> This will ensure that the browser only ever downloads the
    resource once, and it should then be set on all static components,
    including scripts, stylesheets, and images.</p><pre class="screen">Expires: Thu, 20 March 2015 00:00:00 GMT</pre><p class="calibre3">You should set the expiry date in the far future relative to the
    current date. The example above tells the browser the cache won’t be stale
    until March 20th, 2015. <span class="calibre1">If you’re <span class="calibre1">using the</span> Apache web server, you can set a
    relative expiration date easily using <code class="literal">Expires</code></span><span class="calibre1"><code class="literal">Default</code>:</span><a id="I_indexterm10_d1e9733" class="calibre1"></a><a id="I_indexterm10_d1e9736" class="calibre1"></a></p><pre class="screen">ExpiresDefault "access plus 5 years"</pre><p class="calibre3">But what if you want to expire the resource before that time? A
    useful technique is to append the file’s modified time (or mtime)
    <a id="I_indexterm10_d1e9743" class="calibre1"></a>as a query parameter on URLs referencing it. Rails, for
    example, does this by default. Then, whenever the file is modified, the
    resource’s URL will change, clearing out the cache.</p><pre class="screen">&lt;link rel="stylesheet" href="master.css?1296085785" type="text/css"&gt;</pre><p class="calibre3">HTTP 1.1. introduced a new class of headers, <code class="literal">Cache-Control</code><a id="I_indexterm10_d1e9753" class="calibre1"></a>, to give developers more advanced caching and to address
    the limitations of <code class="literal">Expires</code>. The
    <code class="literal">Cache-Control</code> control header can take a
    number of options, separated by commas:</p><pre class="screen">Cache-Control: max-age=3600, must-revalidate</pre><p class="calibre3">To see the full list of options, visit the <a class="ulink" href="http://www.ietf.org/rfc/rfc2616.txt">specification</a>. The ones
    you’re likely to use now are listed below:</p><div class="book"><dl class="book"><dt class="calibre8"><span class="calibre1"><code class="literal">max-age</code></span></dt><dd class="calibre9"><p class="calibre3">Specifies the maximum amount of time, in seconds, that a
          resource will be considered fresh. Unlike
          <code class="literal">Expires</code>, which is absolute, this directive is
          relative to the time of the request.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">public</code></span></dt><dd class="calibre9"><p class="calibre3">Marks resources as cacheable. By default, if resources are
          served over SSL or if HTTP authentication is used, caching is turned
          off.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">no-store</code></span></dt><dd class="calibre9"><p class="calibre3">Turns off caching completely, which is something you’ll want
          to do for dynamic content only.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">must-revalidate</code></span></dt><dd class="calibre9"><p class="calibre3">Tells caches they must obey any information you give them
          regarding resource freshness. Under certain conditions, HTTP allows
          caches to serve stale resources according to their own rules. By
          specifying this header, you’re telling the cache that you want it to
          strictly follow your rules.</p></dd></dl></div><p class="calibre3">Adding a <code class="literal">Last-Modified</code> header
    <a id="I_indexterm10_d1e9808" class="calibre1"></a>to the served resource can also help caching. With
    subsequent requests to the resource, browsers can specify the <code class="literal">If-Modified-Since</code> header,<a id="I_indexterm10_d1e9815" class="calibre1"></a> which contains a timestamp. If the resource hasn’t been
    modified since the last request, the server can just return a 304 (not
    modified) status. The browser still has to make the request, but the
    server doesn’t have to include the resource in its response, saving
    network time and bandwidth:</p><pre class="screen"># Request
GET /example.gif HTTP/1.1
Host:www.example.com
If-Modified-Since:Thu, 29 Apr 2010 12:09:05 GMT

# Response
HTTP/1.1 200 OK
Date: Thu, 20 March 2009 00:00:00 GMT
Server: Apache/1.3.3 (Unix)
Cache-Control: max-age=3600, must-revalidate
Expires: Fri, 30 Oct 1998 14:19:41 GMT
Last-Modified: Mon, 17 March 2009 00:00:00 GMT
Content-Length: 1040
Content-Type: text/html</pre><p class="calibre3">There is an alternative to <code class="literal">Last-Modified</code>: ETags. Comparing ETags <a id="I_indexterm10_d1e9826" class="calibre1"></a>is like comparing the hashes of two files; if the ETags are
    different, the cache is stale and must be revalidated. This works in a
    similar way to the <code class="literal">Last-Modified</code>
    header. The server will attach an ETag to a resource with an <code class="literal">ETag</code> header, and a client will check ETags with
    an <code class="literal">If-None-Match</code> header:<a id="I_indexterm10_d1e9840" class="calibre1"></a></p><pre class="screen"> # Request
 GET /example.gif HTTP/1.1
 Host:www.example.com
 If-Modified-Since:Thu, 29 Apr 2010 12:09:05 GMT
 If-None-Match:"48ef9-14a1-4855efe32ba40"

 # Response
 HTTP/1.1 304 Not Modified</pre><p class="calibre3">ETags are typically constructed with attributes specific to the
    server—i.e., two separate servers will give different ETags for the same
    resource. With clusters becoming more and more common, this is a real
    issue. Personally, I advise you to stick with <span class="calibre1"><strong class="calibre18"><span class="calibre1"><em class="calibre4"><code class="literal2">Last-Modified</code></em></span></strong></span>
    and turn off ETags altogether.</p></div></div>

{% endraw %}

