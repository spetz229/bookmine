---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch06.html
next: OEBPS/ch06s03.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Module Loaders"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect16_d1e5666" class="calibre1"></a>Module Loaders</h1></div></div></div><p class="calibre3"><a id="I_indexterm6_d1e5670" class="calibre1"></a><a id="I_indexterm6_d1e5675" class="calibre1"></a><a id="I_indexterm6_d1e5680" class="calibre1"></a>To use CommonJS modules on the client side, we need to use a
    module loader library. There is a variety of options, each with its own
    strengths and weaknesses. I’ll cover the most popular ones and you can
    choose which one best suits your needs.</p><p class="calibre3">The CommonJS module format is still in flux, with various proposals
    under review. As it stands, there’s no officially blessed transport
    format, which unfortunately complicates things. The two main module
    implementations in the wild are <a class="ulink" href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">Transport
    C</a> and <a class="ulink" href="http://wiki.commonjs.org/wiki/Modules/Transport/D">Transport
    D</a>. If you use any of the wrapping tools mentioned in the sections
    below, you’ll have to make sure it generates wrapped modules in a format
    your loader supports. Fortunately, many module loaders also <span class="calibre1">come with</span> compatible wrapping tools, or they
    specify supported ones in their <span class="calibre1">documentation</span>.</p><div class="book" title="Yabble"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2922620" class="calibre12"></a>Yabble</h2></div></div></div><p class="calibre3"><a class="ulink" href="https://github.com/jbrantly/yabble">Yabble</a><a id="I_indexterm6_d1e5706" class="calibre1"></a> is an excellent and lightweight module loader. You can
      configure Yabble to either request modules with XHR or to use script
      tags. The advantage to fetching modules with XHR is that they don’t need
      wrapping in the transport format. However, the disadvantage is that
      modules have to be executed using <code class="literal">eval()</code>, making debugging more difficult.
      Additionally, there are cross-domain issues, especially if you’re using
      a CDN. Ideally, you should only use the XHR option for quick and dirty
      development, certainly not in production:</p><pre class="screen">&lt;script src="https://github.com/jbrantly/yabble/raw/master/lib/yabble.js"&gt; &lt;/script&gt;
&lt;script&gt;
  require.setModuleRoot("javascripts");

  // We can use script tags if the modules 
  // are wrapped in the transport format
  require.useScriptTags();

  require.ensure(["application"], function(require) {
    // Application is loaded
  });
&lt;/script&gt;</pre><p class="calibre3">The above example will fetch our wrapped
      <code class="literal">application</code> module and then load its dependencies,
      <span class="calibre1"><em class="calibre4">utils.js</em></span>, before running the module. We can load
      modules using the <code class="literal">require()</code>
      function:<a id="I_indexterm6_d1e5726" class="calibre1"></a><a id="I_indexterm6_d1e5727" class="calibre1"></a></p><pre class="screen">&lt;script&gt;
  require.ensure(["application", "utils"], function(require) {
    var utils = require("utils");
    assertEqual( utils.per( 50, 200 ), 25 );
  });
&lt;/script&gt;</pre><p class="calibre3">Although <code class="literal">utils</code> is required twice—once by the
      inline <code class="literal">require.ensure()</code> function, and
      once by the <code class="literal">application</code> module—our script is clever
      enough to fetch the module <span class="calibre1">only
      once</span>. Make sure any dependencies your module needs are listed
      in the transport wrapping.</p></div><div class="book" title="RequireJS"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2922762" class="calibre12"></a>RequireJS</h2></div></div></div><p class="calibre3"><a id="I_indexterm6_d1e5748" class="calibre1"></a>A great alternative to Yabble is <a class="ulink" href="http://requirejs.org">RequireJS</a>, one of the most popular
      loaders. RequireJS has a slightly different take on loading modules—it
      follows the <a class="ulink" href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">Asynchronous
      Module Definition</a> format,<a id="I_indexterm6_d1e5758" class="calibre1"></a> or AMD. The main difference you need to be concerned with
      is that the API evaluates dependencies eagerly, rather than lazily. In
      practice, RequireJS is completely compatible with CommonJS modules,
      requiring only different wrapping transport.</p><p class="calibre3">To load JavaScript files, just pass their paths to the <code class="literal">require</code><code class="literal">()</code> function,
      specifying a callback that will be invoked when the dependencies are all
      loaded:</p><pre class="screen">&lt;script&gt;
  require(["lib/application", "lib/utils"], function(application, utils) {
    // Loaded!
  });      
&lt;/script&gt;</pre><p class="calibre3">As you can see in the example above, the <code class="literal">application</code> and <code class="literal">utils</code> modules are passed as arguments to the
      callback; they don’t have to be fetched with the <code class="literal">require()</code> function.</p><p class="calibre3">It’s not just modules that you can require—RequireJS also supports
      ordinary JavaScript libraries as dependencies, specifically jQuery and
      Dojo. Other libraries will work, but they won’t be passed correctly as
      arguments to the required callback. However, any library that has
      dependencies is required to use the module format:</p><pre class="screen">require(["lib/jquery.js"], function($) {
  // jQuery loaded
  $("#el").show();
});</pre><p class="calibre3">Paths given to <code class="literal">require()</code> are
      relative to the current file or module, unless they begin with a
      <code class="literal">/</code>. To help with optimization,
      RequireJS encourages you to place your initial script loader in a
      separate file. The library even provides shorthand to do this: the
      <code class="literal">data-main</code> attribute:</p><pre class="screen">&lt;script data-main="lib/application" src="lib/require.js"&gt;&lt;/script&gt;</pre><p class="calibre3">Setting the <code class="literal">data-main</code> attribute
      instructs RequireJS to treat the script tag like a <code class="literal">require()</code> call and load the attribute’s value.
      In this case, it would load the <span class="calibre1">lib/application.js</span> script, which would in turn load
      the rest of our application:</p><pre class="screen">// Inside lib/application.js
require(["jquery", "models/asset", "models/user"], function($, Asset, User) {
    //...
});</pre><p class="calibre3">So, we’ve covered requiring modules, but what about actually
      defining them? Well, as stated previously, RequireJS uses a slightly
      different syntax for modules. Rather than using <code class="literal">require.define()</code>, just use the plain <code class="literal">define()</code> function. As long as modules are in
      different files, they don’t need explicit naming. Dependencies come
      first, as an array of strings, and then comes a callback function
      containing the actual module. As in the RequireJS <code class="literal">require()</code> function, dependencies are passed as
      arguments to the callback function:</p><pre class="screen">define(["underscore", "./utils"], function(_, Utils) {
  return({
    size: 10
  })
});</pre><p class="calibre3">By default, there’s no <code class="literal">exports</code> variable. To
      expose variables from inside the module, just return data from the
      function. The benefit to RequireJS modules is that they’re already
      wrapped up, so you don’t have to worry about transport formats for the
      browser. However, the caveat to this API is that it’s not compatible
      with CommonJS modules—i.e., you couldn’t share modules between Node.js
      and the browser. All is not lost, though; RequireJS has a compatibility
      layer for CommonJS modules—just wrap your existing modules with the
      <code class="literal">define()</code> function:<a id="I_indexterm6_d1e5834" class="calibre1"></a><a id="I_indexterm6_d1e5839" class="calibre1"></a></p><pre class="screen">define(function(require, exports) {
  var mod = require("./relative/name");

  exports.value = "exposed";
});</pre><p class="calibre3">The arguments to the callbacks need to be exactly as shown
      above—i.e., <code class="literal">require</code> and <code class="literal">exports</code>. Your modules can then carry on using
      those variables as usual, without any alterations.</p></div></div></div>

{% endraw %}

