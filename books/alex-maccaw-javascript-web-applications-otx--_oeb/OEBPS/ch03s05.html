---
layout: page
title: "JavaScript Web Applications"
prev: OEBPS/ch03s04.html
next: OEBPS/ch03s06.html
book_path: books/alex-maccaw-javascript-web-applications-otx--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Loading in Data"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_sect13_d1e2997" class="calibre1"></a>Loading in Data</h1></div></div></div><p class="calibre3"><a id="index-835P882PT7H" class="calibre1"></a><a id="index-243S815AA0E" class="calibre1"></a>Unless your web application is entirely restricted to the
    browser, you’ll need to load in remote data from a server. Typically, a
    subset of data is loaded when the application starts, and more data is
    loaded after the interaction. Depending on the type of application and the
    amount of data, you may be able to load everything you need on the initial
    page load. This is ideal, so users never have to wait for more data to be
    loaded. However, this isn’t feasible for a lot of applications because
    there’s too much data to fit comfortably in a browser’s memory.</p><p class="calibre3">Preloading data <a id="I_indexterm3_d1e3014" class="calibre1"></a>is crucial to making your application feel slick and fast to
    your users, keeping any waiting time to a minimum. However, there’s a fine
    line between preloading data that’s actually accessed and loading
    redundant data that’s never used. You need to predict what sort of data
    your users will want (or use metrics once your application is
    live).</p><p class="calibre3">If you’re displaying a paginated list, why not preload the next page
    so transitions are instant? Or, even better, just display a long list and
    automatically load and insert data as the list is scrolled (the infinite
    scroll pattern). The less latency a user feels, the better.</p><p class="calibre3">When you do fetch new data, make sure the UI isn’t blocked. Display
    some sort of loading indicator, but make sure the interface is still
    usable. There should be very few scenarios, if any, that require blocking
    the UI.</p><p class="calibre3">Data can be present inline in the initial page or loaded with
    separate HTTP requests through Ajax or JSONP. Personally, I would
    recommend the latter two technologies, as including a lot of data inline
    increases the page size, whereas parallel requests load faster. AJAX and
    JSON also let you cache the HTML page, rather than dynamically render it
    for every request.</p><div class="book" title="Including Data Inline"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2915892" class="calibre12"></a>Including Data Inline</h2></div></div></div><p class="calibre3"><a id="I_indexterm3_d1e3030" class="calibre1"></a><a id="I_indexterm3_d1e3037" class="calibre1"></a><a id="I_indexterm3_d1e3044" class="calibre1"></a><a id="I_indexterm3_d1e3047" class="calibre1"></a>I don’t really advocate this approach for the reasons I
      outlined in the previous paragraph, but it can be useful in specific
      situations, especially for loading in a very small amount of data. This
      technique has the advantage of being really simple to implement.</p><p class="calibre3">All you need to do is render a JSON object<a id="I_indexterm3_d1e3057" class="calibre1"></a><a id="I_indexterm3_d1e3060" class="calibre1"></a> directly into the page. For example, here’s how you’d do
      it with Ruby on Rails:</p><pre class="screen">&lt;script type="text/javascript"&gt;
  var User = {};
  User.records = &lt;%= raw @users.to_json %&gt;;
&lt;/script&gt;</pre><p class="calibre3">We’re using ERB tags to output a JSON interpretation of the user
      data. The <code class="literal">raw</code> method <a id="I_indexterm3_d1e3073" class="calibre1"></a>is simply to stop the JSON from being escaped. When the
      page is rendered, the resulting HTML looks like this:</p><pre class="screen">&lt;script type="text/javascript"&gt;
  var User = {};
  User.records = [{"first_name": "Alex"}];
&lt;/script&gt;</pre><p class="calibre3">JavaScript can just evaluate the JSON as-is because it has the
      same structure as a JavaScript object.</p></div><div class="book" title="Loading Data with Ajax"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2916020" class="calibre12"></a>Loading Data with Ajax</h2></div></div></div><p class="calibre3"><a id="index-625E462UF7T" class="calibre1"></a><a id="index-047D446JM0H" class="calibre1"></a><a id="index-265P701BF2B" class="calibre1"></a><a id="I_indexterm3_d1e3104" class="calibre1"></a>This is probably the first method of loading remote data
      that springs to mind when you hear background requests, and for good
      reason: it’s tried, tested, and supported in all modern browsers. That’s
      not to say that Ajax is without its drawbacks—its unstandardized history
      has resulted in an inconsistent API and, due to browser security,
      <span class="calibre1">loading</span> data from different
      domains is tricky.</p><p class="calibre3">If you need a short primer on Ajax and the
      <code class="literal">XMLHttpRequest</code> class,<a id="I_indexterm3_d1e3121" class="calibre1"></a><a id="I_indexterm3_d1e3124" class="calibre1"></a> read “Getting Started,” a <a class="ulink" href="https://developer.mozilla.org/en/Ajax/Getting_Started">Mozilla
      Developer article</a>. In all likelihood, though, you’ll end up
      using a library like jQuery that abstracts Ajax’s API, massaging out the
      differences among browsers. For that reason, we’ll cover jQuery’s API
      here, rather than the raw <code class="literal">XMLHttpRequest</code>
      class.</p><p class="calibre3">jQuery’s Ajax API consists of one low-level function, <code class="literal">jQuery.ajax()</code><a id="I_indexterm3_d1e3140" class="calibre1"></a><a id="I_indexterm3_d1e3143" class="calibre1"></a>, and several higher-<span class="calibre1">level
      abstractions of it, reducing the amount of code you need to write.
      <code class="literal">jQuery</code></span><span class="calibre1"><code class="literal">.ajax()</code> takes a
      hash of settings for request parameters, content type, and
      callbacks,</span> among others. As soon as you call the function, the
      request is asynchronously sent in the background.</p><div class="book"><dl class="book"><dt class="calibre8"><span class="calibre1"><code class="literal">url</code></span></dt><dd class="calibre9"><p class="calibre3">The request url. The default is the current page.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">success</code></span></dt><dd class="calibre9"><p class="calibre3">A function to be called if the request succeeds. Any data
            returned from the server is passed as a parameter.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">contentType</code></span></dt><dd class="calibre9"><p class="calibre3">Sets the <code class="literal">Content-Type</code> header of the
            request. If the request contains data, the default is <code class="literal">application/x-www-form-urlencoded</code>, which
            is fine for most use cases.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">data</code></span></dt><dd class="calibre9"><p class="calibre3">The data to be sent to the server. If it’s not already a
            string, jQuery will serialize and URL-encode it.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">type</code></span></dt><dd class="calibre9"><p class="calibre3">The HTTP method to use: <code class="literal">GET</code>, <code class="literal">POST</code>, or <code class="literal">DELETE</code>. The default is <code class="literal">GET</code>.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">dataType</code></span></dt><dd class="calibre9"><p class="calibre3">The type of data you’re expecting back from the server.
            jQuery needs to know this so it knows what to do with the result.
            If you don’t specify a <code class="literal">dataType</code>, jQuery will do
            some intelligent guessing based on the MIME type of the response.
            Supported values are:</p><div class="book"><dl class="book"><dt class="calibre8"><span class="calibre1"><code class="literal">text</code></span></dt><dd class="calibre9"><p class="calibre3">Plain-text response; no processing is needed.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">script</code></span></dt><dd class="calibre9"><p class="calibre3">jQuery evaluates the response as JavaScript.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">json</code></span></dt><dd class="calibre9"><p class="calibre3">jQuery evaluates the response as JSON, using a
                    strict parser.</p></dd><dt class="calibre8"><span class="calibre1"><code class="literal">jsonp</code></span></dt><dd class="calibre9"><p class="calibre3">For JSONP requests, which we’ll cover in detail
                    later.</p></dd></dl></div></dd></dl></div><p class="calibre3">For example, let’s do a simple Ajax request, which alerts whatever
      data returned by the server:</p><pre class="screen">jQuery.ajax({
  url: "/ajax/endpoint",
  type: "GET",
  success: function(data) {
    alert(data);
  }
});</pre><p class="calibre3">However, all those options are a bit verbose. Luckily, jQuery has
      a few shortcuts. <code class="literal">jQuery.get()</code> takes a
      URL and optional data and callback:</p><pre class="screen">jQuery.get("/ajax/endpoint", function(data){
  $(".ajaxResult").text(data);
});</pre><p class="calibre3">Or, if we want to send a few query parameters with the <code class="literal">GET</code> request:</p><pre class="screen">jQuery.get("/ajax/endpoint", {foo: "bar"}, function(data){
  /* ... */
});</pre><p class="calibre3">If we’re expecting JSON back from the server, we need to call
      <code class="literal">jQuery.getJSON()</code> instead, which sets
      the request’s <code class="literal">dataType</code> option to
      <code class="literal">"json"</code>:</p><pre class="screen">jQuery.getJSON("/json/endpoint", function(json){
  /* ... */
});</pre><p class="calibre3">Likewise, there’s a <code class="literal">jQuery.post()</code> function, which also takes a
      URL, data, and callback:</p><pre class="screen">jQuery.post("/users", {first_name: "Alex"}, function(result){
  /* Ajax POST was a success */
});</pre><p class="calibre3">If you want to use other HTTP methods—<code class="literal">DELETE</code>, <code class="literal">HEAD</code>, and <code class="literal">OPTIONS</code>—you’ll have to use the lower-level
      <code class="literal">jQuery.ajax()</code> function.</p><p class="calibre3">That was a brief overview of jQuery’s Ajax API, but if you need
      more information, read the <a class="ulink" href="http://api.jquery.com/category/ajax">full
      documentation</a>.</p><p class="calibre3">A limitation of Ajax is the <span class="calibre1"><em class="calibre4">same origin
      policy</em></span><a id="I_indexterm3_d1e3313" class="calibre1"></a>, which restricts requests <a id="I_indexterm3_d1e3317" class="calibre1"></a>to the same domain,<a id="I_indexterm3_d1e3323" class="calibre1"></a> subdomain, and port as the address of the page from which
      they’re made. There’s a good reason for this: whenever an Ajax request
      is sent, all that domain’s cookie information is sent along with the
      request. That means, to the remote server, the request appears to be
      from a logged-in user. Without the same origin policy, an attacker could
      potentially fetch all your emails from Gmail, update your Facebook
      status, or direct message your followers on Twitter—quite a security
      flaw.</p><p class="calibre3">However, while the same origin policy is integral to the security
      of the Web, it’s also somewhat inconvenient for developers trying to
      access legitimate remote resources. Other technologies like Adobe Flash
      and Java have implemented workarounds to the problem with cross-domain
      policy files, and now Ajax is catching up with a standard called <a class="ulink" href="http://www.w3.org/TR/access-control"><span class="calibre1">CORS</span></a>, or cross-origin resource
      sharing.<a id="I_indexterm3_d1e3335" class="calibre1"></a></p><p class="calibre3">CORS lets you break out of the same origin policy, giving you
      access to authorized remote servers. The specification is well supported
      by the major browsers,<a id="I_indexterm3_d1e3340" class="calibre1"></a> so unless you’re using IE6, you should be fine.</p><p class="calibre3">CORS support by browser:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">IE &gt;= 8 (with caveats)</p></li><li class="listitem"><p class="calibre3">Firefox &gt;= 3</p></li><li class="listitem"><p class="calibre3">Safari: full support</p></li><li class="listitem"><p class="calibre3">Chrome: full support</p></li><li class="listitem"><p class="calibre3">Opera: no support</p></li></ul></div><p class="calibre3">Using CORS is trivially easy. If you want to authorize access to
      your server, just add a few lines to the HTTP header of returned
      responses:</p><pre class="screen">Access-Control-Allow-Origin: example.com
Access-Control-Request-Method: GET,POST</pre><p class="calibre3">The above header will authorize cross-origin GET and POST requests
      from <span class="calibre1"><em class="calibre4">example.com</em></span>. You should separate multiple
      values with commas, as with the <code class="literal">GET,POST</code> values above. To allow access from
      additional domains, just list them comma-separated in the <code class="literal">Access-Control-Allow-Origin</code> header.<a id="I_indexterm3_d1e3380" class="calibre1"></a> Or, to give any domain access, just set the origin header
      to an asterisk (<code class="literal">*</code>).</p><p class="calibre3">Some browsers, like Safari, will first make an OPTIONS request to
      check whether the request is allowed. Firefox, on the other hand, will
      make the request and just raise a security exception if the CORS headers
      aren’t set. You’ll need to take account of this different behavior
      server side.</p><p class="calibre3">You can even authorize custom request headers using the <code class="literal">Access-Control-Request-Headers</code>
      header:<a id="I_indexterm3_d1e3394" class="calibre1"></a></p><pre class="screen">Access-Control-Request-Headers: Authorization</pre><p class="calibre3">This means that clients can add custom headers to Ajax requests,
      such as signing the request with OAuth:</p><pre class="screen">var req = new XMLHttpRequest();  
req.open("POST", "/endpoint", true);  
req.setRequestHeader("Authorization", oauth_signature);</pre><p class="calibre3">Unfortunately, while CORS works with versions of Internet Explorer
      8 and higher, Microsoft chose to ignore the spec and the <a class="ulink" href="http://lists.w3.org/Archives/Public/public-webapps/2008AprJun/0168.html">working
      group</a>. Microsoft created its own object, <a class="ulink" href="http://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx"><code class="literal">XDomainRequest</code></a>,
      which is to be used instead of <code class="literal">XMLHttpRequest</code> for cross-domain requests.
      While <span class="calibre1">its interface</span> is similar to
      <code class="literal">XMLHttpRequest</code>’s, it has a number of
      <a class="ulink" href="http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx">restrictions
      and limitations</a>. For example, only GET and POST methods work, no
      authentication or custom headers are supported, and finally, the
      kicker—only the “Content-Type: text/plain” is supported. If you’re
      prepared to work around those restrictions, then—with the correct
      <code class="literal">Access-Control</code> headers—you can get CORS <span class="calibre1">working</span> in IE.<a id="I_indexterm3_d1e3431" class="calibre1"></a><a id="I_indexterm3_d1e3434" class="calibre1"></a><a id="I_indexterm3_d1e3435" class="calibre1"></a><a id="I_indexterm3_d1e3436" class="calibre1"></a></p></div><div class="book" title="JSONP"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2916842" class="calibre12"></a>JSONP</h2></div></div></div><p class="calibre3"><a class="ulink" href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp">JSONP</a><a id="I_indexterm3_d1e3443" class="calibre1"></a><a id="I_indexterm3_d1e3450" class="calibre1"></a><a id="I_indexterm3_d1e3457" class="calibre1"></a><a id="I_indexterm3_d1e3464" class="calibre1"></a>, or JSON with padding, was created before CORS was
      standardized, and is another way of fetching data from remote servers.
      The idea is that you have a script tag that points to a JSON endpoint
      where returned data is wrapped in a function invocation. Script tags
      aren’t subject to any cross-domain limitations, and this technique is
      supported in practically every browser.</p><p class="calibre3">So, here we have a script tag that points to our remote
      server:</p><pre class="screen">&lt;script src="http://example.com/data.json"&gt; &lt;/script&gt;</pre><p class="calibre3">Then the endpoint, <span class="calibre1"><em class="calibre4">data.json</em></span>, returns a JSON
      object wrapped in a function invocation:</p><pre class="screen">jsonCallback({"data": "foo"})</pre><p class="calibre3">We then define a globally accessible function. Once the script has
      loaded, this function will be called:</p><pre class="screen">window.jsonCallback = function(result){
  // Do stuff with the result
}</pre><p class="calibre3">As it is, this is a fairly convoluted process. Luckily, jQuery
      wraps it in a succinct API:</p><pre class="screen">jQuery.getJSON("http://example.com/data.json?callback=?", function(result){
  // Do stuff with the result
});</pre><p class="calibre3">jQuery replaces the last question mark in the above URL with a
      random name of a temporary function it creates. Your server needs to
      read the <code class="literal">callback</code> parameter and use
      that as the name of the returned wrapping function.</p></div><div class="book" title="Security with Cross-Domain Requests"><div class="book"><div class="book"><div class="book"><h2 class="title3"><a id="id2916961" class="calibre12"></a>Security with Cross-Domain Requests</h2></div></div></div><p class="calibre3"><a id="I_indexterm3_d1e3496" class="calibre1"></a><a id="I_indexterm3_d1e3503" class="calibre1"></a><a id="I_indexterm3_d1e3510" class="calibre1"></a><a id="I_indexterm3_d1e3517" class="calibre1"></a><a id="I_indexterm3_d1e3520" class="calibre1"></a><a id="I_indexterm3_d1e3523" class="calibre1"></a>If you’re opening up your server to cross-origin requests
      or JSONP from any domain, you’ve got to really think about security.
      Usually the cross-origin domain policy stops an attacker from calling,
      say, Twitter’s API, and fetching your personal data. CORS and JSONP
      change all of that. As with a normal Ajax request, all your session
      cookies are passed with the request, so you’ll be logged into Twitter’s
      API. Any potential attackers have full control over your account;
      security considerations are therefore <span class="calibre1">paramount</span>.</p><p class="calibre3">With this in mind, here are some key points to take into account
      when using CORS/JSONP if you’re not controlling which domains can access
      your API:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre3">Don’t reveal any sensitive information, such as email
          addresses.</p></li><li class="listitem"><p class="calibre3">Don’t allow any actions (like a Twitter “follow”).</p></li></ul></div><p class="calibre3">Or, alternatively, to mitigate those security issues, just have a
      whitelist of domains <a id="I_indexterm3_d1e3543" class="calibre1"></a><a id="I_indexterm3_d1e3548" class="calibre1"></a>that can connect, or you can use OAuth authentication
      exclusively.<a id="I_indexterm3_d1e3554" class="calibre1"></a><a id="I_indexterm3_d1e3555" class="calibre1"></a></p></div></div></div>

{% endraw %}

