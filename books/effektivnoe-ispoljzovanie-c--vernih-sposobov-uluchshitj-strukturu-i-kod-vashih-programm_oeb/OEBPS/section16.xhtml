---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section15.xhtml
next: OEBPS/section17.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <p class="calibre2">Замечательное свойство модификатора const состоит в том, что он накладывает определенное семантическое ограничение: данный объект не должен модифицироваться, – и компилятор будет проводить это ограничение в жизнь. const позволяет указать компилятору и программистам, что определенная величина должна оставаться неизменной. Во всех подобных случаях вы должны обозначить это явным образом, призывая себе на помощь компилятор и гарантируя тем самым, что ограничение не будет нарушено.</p>
      <p class="calibre2">Ключевое слово const удивительно многосторонне. Вне классов вы можете использовать его для определения констант в глобальной области или в пространстве имен (см. правило 2), а также для статических объектов (внутри файла, функции или блока). Внутри классов допустимо применять его как для статических, так и для нестатических данных-членов. Для указателей можно специфицировать, должен ли быть константным сам указатель, данные, на которые он указывает, либо и то, и другое (или ни то, ни другое):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">char greeting[] = “Hello”;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char *p = greeting; // неконстантный указатель,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// неконстантные данные</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const char *p = greeting; // неконстантный указатель,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// константные данные</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char * const p = greeting; // константный указатель,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// неконстантные данные</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const char * const p = greeting; // константный указатель,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// константные данные</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот синтаксис не так страшен, как может показаться. Если слово const появляется слева от звездочки, константным является то, на что указывает указатель; если справа, то сам указатель является константным. Наконец, если же слово const появляется с обеих сторон, то константно и то, и другое.</p>
      <p class="calibre2">Когда то, на что указывается, – константа, некоторые программисты ставят const перед идентификатором типа. Другие – после идентификатора типа, но перед звездочкой. Семантической разницы здесь нет, поэтому следующие функции принимают параметр одного и того же типа:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void f1(const Widget *pw); // f1 принимает указатель на</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// константный объект Widget</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void f1(Widget const *pw); // то же самое делает f2</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку в реальном коде встречаются обе формы, следует привыкать и к той, и к другой.</p>
      <p class="calibre2">Итераторы STL смоделированы на основе указателей, поэтому iterator ведет себя почти как указатель T*. Объявление const-итератора подобно объявлению const-указателя (то есть записи T* const): итератор не может начать указывать на что-то другое, но то, на что он указывает, может быть модифицировано. Если вы хотите иметь итератор, который указывал бы на нечто, что запрещено модифицировать (то есть STL-аналог указателя const T*), то вам понадобится константный итератор:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::vector&lt;int&gt; vec;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const std::vector&lt;int&gt;::iterator iter = // iter работает как T* const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">vec.begin();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">*iter = 10; // Ok, изменяется то, на что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// указывает iter</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++iter; // ошибка! iter константный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::vector&lt;int&gt;::const_iterator citer = // citer работает как const T*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">vec.begin();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">*citer = 10; // ошибка! *citer константный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++citer; // нормально, citer изменяется</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Некоторые из наиболее интересных применений const связаны с объявлениями функций. В этом случае const может относиться к возвращаемому функцией значению, к отдельным параметрам, а для функций-членов – еще и к функции в целом.</p>
      <p class="calibre2">Если указать в объявлении функции, что она возвращает константное значение, то можно уменьшить количество ошибок в клиентских программах, не снижая уровня безопасности и эффективности. Например, рассмотрим объявление функции operator* для рациональных чисел, введенное в правиле 24:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Rational {…}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Многие программисты удивятся, впервые увидев такое объявление. Почему результат функции operator* должен быть константным объектом? Потому что в противном случае пользователь получил бы возможность делать вещи, которые иначе как надругательством над здравым смыслом не назовешь:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Rational a, b, c;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">…</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">(a*b)=c; // присваивание произведению a*b!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Я не знаю, с какой стати программисту пришло бы в голову присваивать значение произведению двух чисел, но могу точно сказать, что иногда такое может случиться по недосмотру. Достаточно простой опечатки (при условии, что тип может быть преобразован к bool):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">if (a*b = c)... // имелось в виду сравнение!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Такой код был бы совершенно некорректным, если бы a и b имели встроенный тип. Одним из критериев качества пользовательских типов является совместимость со встроенными (см. также правило 18), а возможность присваивания значения результату произведения двух объектов представляется мне весьма далекой от совместимости. Если же объявить, что operator* возвращает константное значение, то такая ситуация станет невозможной. Вот почему Так Следует Поступать.</p>
      <p class="calibre2">В отношении аргументов с модификатором const трудно сказать что-то новое; они ведут себя как локальные константные const-объекты. Всюду, где возможно, добавляйте этот модификатор. Если модифицировать аргумент или локальный объект нет необходимости, объявите его как const. Вам всего-то придется набрать шесть символов, зато это предотвратит досадные ошибки типа «хотел напечатать ==, а нечаянно напечатал =» (к чему это приводит, мы только что видели).</p>
    </div>
  </div>

{% endraw %}

