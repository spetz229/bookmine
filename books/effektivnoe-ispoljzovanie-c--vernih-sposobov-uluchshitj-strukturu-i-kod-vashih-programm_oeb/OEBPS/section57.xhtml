---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section56.xhtml
next: OEBPS/section58.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 32: Используйте открытое наследование для моделирования отношения «является»</h2>
      </div>
      <p class="calibre2">Вильям Демент (William Dement) в своей книге «Кто-то должен бодрствовать, пока остальные спят» (W. H. Freeman and Company, 1974) рассказывает о том, как он пытался донести до студентов наиболее важные идеи своего курса. Утверждается, говорил он своей группе, что средний британский школьник помнит из уроков истории лишь то, что битва при Хастингсе произошла в 1066 году. Даже если ученик почти ничего не запомнил из курса истории, подчеркивает Демент, 1066 год остается в его памяти. Демент пытался внушить слушателям несколько основных идей, в частности ту любопытную истину, что снотворное вызывает бессонницу. Он призывал своих студентов запомнить ряд ключевых фактов, даже если забудется все, что обсуждалось на протяжении курса, и в течение семестра возвращался к нескольким фундаментальным заповедям.</p>
      <p class="calibre2">Последним на заключительном экзамене был вопрос: «Напишите, какой факт из тех, что обсуждались на лекциях, вы запомните на всю жизнь». Проверяя работы, Демент был ошеломлен. Почти все упомянули 1066 год.</p>
      <p class="calibre2">Теперь я с трепетом хочу провозгласить, что самое важное правило в объектно-ориентированном программировании на C++ звучит так: открытое наследование означает «является». Твердо запомните это.</p>
      <p class="calibre2">Если вы пишете класс D (derived – «производный») открыто наследует классу B («base» – «базовый»), то тем самым сообщаете компилятору C++ (а заодно и людям, читающим ваш код), что каждый объект типа D является также объектом типа B, но <em class="calibre5">не наоборот.</em> Вы говорите, что B представляет собой более общую концепцию, чем D, а D – более конкретную концепцию, чем B. Вы утверждаете, что везде, где может быть использован объект B, можно использовать также объект D, потому что D является объектом типа B. С другой стороны, если вам нужен объект типа D, то объект B не подойдет, поскольку каждый D «является разновидностью» B, но не наоборот.</p>
      <p class="calibre2">Такой интерпретации открытого наследования придерживается C++. Рассмотрим следующий пример:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Person {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Student: public Person {...};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Здравый смысл и опыт подсказывают нам, что каждый студент – человек, но не каждый человек – студент. Именно такую связь подразумевает данная иерархия. Мы ожидаем, что всякое утверждение, справедливое для человека – например, что у него есть дата рождения, – справедливо и для студента, но не все, что верно для студента – например, что он учится в каком-то определенном институте, – верно для человека в общем случае.</p>
      <p class="calibre2">Применительно к C++ это выглядит следующим образом: любая функция, которая принимает аргумент типа Person (или указатель на Person, или ссылку на Person), примет объект типа Student (или указатель на Student, или ссылку на Student):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void eat(const Person&amp; p); // все люди могут есть</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void study(const Student&amp; s); // только студент учится</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Person p; // p – человек</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Student s; // s – студент</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">eat(p); // правильно, p есть человек</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">eat(s); // правильно, s – это студент,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// и студент также является человеком</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">study(s); // правильно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">study(p); // ошибка! p – не студент</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Все сказанное верно только для <em class="calibre5">открытого</em> наследования. C++ будет вести себя так, как описано выше, только в случае, если Student открыто наследует Person. Закрытое наследование означает нечто совсем иное (см. правило 39), а смысл защищенного наследования ускользает от меня по сей день.</p>
      <p class="calibre2">Идея тождества открытого наследования и понятия «является» кажется достаточно очевидной, но иногда интуиция нас подводит. Рассмотрим следующий пример: пингвин – это птица, птицы умеют летать. Если вы по наивности попытаетесь выразить это на C++, то вот что получится:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(); // птицы умеют летать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Penguin: public Bird { // пингвины – птицы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Неожиданно мы столкнулись с затруднением. Утверждается, что пингвины могут летать, что, как известно, неверно. В чем тут дело?</p>
      <p class="calibre2">В данном случае нас подвела неточность разговорного языка. Когда мы говорим, что птицы умеют летать, то не имеем в виду, что <em class="calibre5">все</em> птицы летают, а только то, что обычно они обладают такой способностью. Если бы мы выбирали формулировки поточнее, то вспомнили бы, что существует несколько видов нелетающих птиц, и пришли к следующей иерархии, которая значительно лучше моделирует реальность:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // функция fly не объявлена</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class FlyingBird: public Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Penguin: public Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // функция fly не объявлена</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Данная иерархия гораздо точнее отражает реальность, чем первоначальная.</p>
      <p class="calibre2">Но и теперь еще не все закончено с «птичьими делами», потому что для некоторых приложений может и не быть необходимости делать различие между летающими и нелетающими птицами. Так, если ваше приложение в основном имеет дело с клювами и крыльями и никак не отражает способность пернатых летать, вполне сойдет и исходная иерархия. Это наблюдение, сообственно, является лишь подтверждением того, что не существует идеального проекта, который подходил бы для всех видов программных систем. Выбор проекта зависит от того, что система должна делать – как сейчас, так и в будущем. Если ваше приложение никак не связано с полетами и не предполагается, что оно будет связано с ними в дальнейшем, то вполне можно не принимать во внимание различий между летающими и нелетающими птицами. На самом деле даже лучше не проводить таких различий, потому что его нет в мире, который вы пытаетесь моделировать. Существует другая школа, иначе относящаяся к рассматриваемой проблеме. Она предлагает переопределить для пингвинов функцию fly() так, чтобы во время исполнения она возвращала ошибку:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void error(const std::string&amp; msg); // определено в другом месте</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Penguin: public Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly() {error(“Попытка заставить пингвина летать!”);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Важно понимать, что это здесь имеется в виду не совсем то, что вам могло показаться. Мы не говорим: «Пингвины не могут летать», а лишь сообщаем: «Пингвины могут летать, но с их стороны было бы ошибкой это делать».</p>
      <p class="calibre2">В чем разница? Во времени обнаружения ошибки. Утверждение «пингвины не могут летать» может быть поддержано на уровне компилятора, а соответствие утверждения «попытка полета ошибочна для пингвинов» реальному положению дел может быть обнаружено во время выполнения программы.</p>
      <p class="calibre2">Чтобы обозначить ограничение «пингвины не могут летать – и точка», следует убедиться, что для объектов Penguin функция fly() не определена:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // функция fly не объявлена</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Penguin: public Bird {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // функция fly не объявлена</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если теперь вы попробуете заставить пингвина взлететь, компилятор сделает вам выговор за нарушение правил:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Penguin p;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">p.fly(); // ошибка!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это сильно отличается от поведения, которое получается, если применить подход, генерирующий ошибку времени исполнения. Ведь в таком случае компилятор ничего не может сказать о вызове p.fly(). В правиле 18 объясняется, что хороший интерфейс предотвращает компиляцию неверного кода, поэтому лучше выбрать проект, который отвергает попытки пингвинов полетать во время компиляции, а не во время исполнения.</p>
      <p class="calibre2">Возможно, вы решите, что вам недостает интуиции орнитолога, но вполне можете положиться на свои познания в элементарной геометрии, не так ли? Тогда ответьте на следующий простой вопрос: должен ли класс Square (квадрат) открыто наследовать классу Rectangle (прямоугольник)?</p>
      <div class="sectionimage">
        <img alt="" src="images/i_002.png" class="calibre8"/>
      </div>
      <p class="calibre2">«Конечно! – скажете вы. – Каждый знает, что квадрат – это прямоугольник, а обратное утверждение в общем случае неверно». Что ж, правильно, по крайней мере, для школы. Но мы ведь решаем задачи посложнее школьных.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void setHeight(int newHeight);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void setWidth(int newWidth);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual int height() const; // возвращают текущие значения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual int width() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void makeBigger(Rectangle&amp; r) // функция увеличивает площадь r</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int oldHeight = r.height();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">r.setWidth(r.width() + 10); // увеличить ширину r на 10</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">assert(r.height() == oldHeight); // убедиться, что высота r</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // не изменилась</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Ясно, что утверждение assert никогда не должно нарушаться. Функция make-Bigger изменяет только ширину r. Высота остается постоянной.</p>
      <p class="calibre2">Теперь рассмотрим код, который посредством открытого наследования позволяет рассматривать квадрат как частный случай прямоугольника:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Square: public Rectangle {…};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Square s;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">assert(s.width() == s.height()); // должно быть справедливо для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// всех квадратов</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">makeBigger(s); // из-за наследования, s является</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// Rectangle, поэтому мы можем</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// увеличить его площадь</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">assert(s.width() == s.height()); // По-прежнему должно быть справедливо</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// для всех квадратов</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как и в предыдущем примере, что второе утверждение также никогда не должно быть нарушено. По определению, ширина квадрата равна его высоте.</p>
      <p class="calibre2">Но теперь перед нами встает проблема. Как примирить следующие утверждения?</p>
      <p class="calibre2">• Перед вызовом makeBigger высота s равна ширине.</p>
      <p class="calibre2">• Внутри makeBigger ширина s изменяется, а высота – нет.</p>
      <p class="calibre2">• После возврата из makeBigger высота s снова равна ширине (отметим, что s передается по ссылке, поэтому makeBigger модифицирует именно s, а не его копию).</p>
      <p class="calibre2">Так что же?</p>
      <p class="calibre2">Добро пожаловать в удивительный мир открытого наследования, где интуиция, приобретенная вами в других областях знания, включая математику, иногда оказывается плохим помощником. Основная трудность в данном случае заключается в том, что некоторые утверждения, справедливые для прямоугольника (его ширина может быть изменена независимо от высоты), не выполняются для квадрата (его ширина и высота должны быть одинаковы). Но открытое наследование предполагает, что все, что применимо к объектам базового класса, – <em class="calibre5">все!</em> – также применимо и к объектам производных классов. В ситуации с прямоугольниками и квадратами (а также в аналогичных случаях, включая множества и списки из правила 38), утверждение этого условия не выполняется, поэтому использование открытого наследования для моделирования здесь некорректно. Компилятор, конечно, этого не запрещает, но, как мы только что видели, не существует гарантий, что такой код будет вести себя должным образом. Любому программисту должно быть известно (некоторые знают это лучше других): если код компилируется, то это еще не значит, что он будет работать.</p>
      <p class="calibre2">Все же не стоит беспокоиться, что приобретенная вами за многие годы разработки программного обеспечения интуиция окажется бесполезной при переходе к объектно-ориентированному программированию. Все ваши знания по-прежнему актуальны, но теперь, когда вы добавили к своему арсеналу наследование, вам придется дополнить свою интуицию новым пониманием, позволяющим создавать приложения с использованием наследования. Со временем идея наследования Penguin от Bird или Square от Rectangle будет казаться вам столь же забавной, как функция объемом в несколько страниц. Такое решение <em class="calibre5">может</em> оказаться правильным, но это маловероятно.</p>
      <p class="calibre2">Отношение «является» – не единственное, возможное между классами. Два других, достаточно распространенных отношения – это «содержит» и «реализован посредством». Они рассматриваются в правилах 38 и 39. Очень часто при проектировании на C++ весь проект идет вкривь и вкось из-за того, что эти взаимосвязи моделируются отношением «является». Поэтому вы должны быть уверены, что понимаете различия между этими отношениями и знаете, каким образом их лучше всего моделировать в C++.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Открытое наследование означает «является». Все, что применимо к базовому классу, должно быть применимо также и производным от него, потому что каждый объект производного класса является также объектом базового класса.</p>
    </div>
  </div>

{% endraw %}

