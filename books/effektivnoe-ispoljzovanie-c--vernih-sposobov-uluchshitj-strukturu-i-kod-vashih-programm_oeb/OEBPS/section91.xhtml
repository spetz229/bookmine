---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section90.xhtml
next: OEBPS/section92.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 54: Ознакомьтесь со стандартной библиотекой, включая TR1</h2>
      </div>
      <p class="calibre2">Стандарт C++ (документ, описывающий язык и его библиотеку) был ратифицирован в 1998 году. В 2003 году были внесены небольшие изменения, исправляющие ошибки. Комитет по стандартизации, однако, продолжает работать, и появление «Версии 2.0» стандарта C++ ожидается примерно в 2008 году. Неопределенность относительно точной даты объясняет, почему обычно при ссылке на следующую версию C++ говорят «С++0х» (версию C++ 200х-го года).</p>
      <p class="calibre2">Предположительно, C++0x будет описывать некоторые интересные дополнения к самому языку, но большая часть новой функциональности C++ будет иметь вид добавлений к стандартной библиотеке. Мы уже знаем кое-что из того, что появится в библиотеке, потому что это специфицировано в документе, известном под названием TR1 («Technical Report 1»), созданном рабочей группой по библиотеке C++. Комитет по стандартизации сохраняет за собой право модифицировать описанную в TR1 функциональность, прежде чем она будет включена в официальный стандарт C++0x, но существенные изменения маловероятны. С практической точки зрения, TR1 возвещает начало новой редакции C++, которую можно было бы назвать стандартом C++ 1.1. Нельзя быть эффективно работающим программистом C++, не будучи знакомым с функциональностью, описанной в TR1, потому что она полезна для библиотек и приложений почти любого типа.</p>
      <p class="calibre2">Прежде чем дать краткий обзор того, что включено в TR1, стоит вспомнить основные части стандартной библиотеки C++, специфицированные в C++98:</p>
      <p class="calibre2">• <strong class="calibre4">Стандартная библиотека шаблонов (STL),</strong> включающая контейнеры (vector, string, map и т. п.); итераторы; алгоритмы (find, sort, transform и т. п.); функциональные объекты (less, greater и т. п.) и различные адаптеры контейнеров и функциональных объектов (stack, priority_queue, mem_fun, not1 и т. п.).</p>
      <p class="calibre2">• <strong class="calibre4">Потоки ввода-вывода (iostreams),</strong> включая поддержку определенной пользователем буферизации, интернационализацию ввода-вывода и предопределенные объекты – cin, cout, cerr и clog.</p>
      <p class="calibre2">• <strong class="calibre4">Поддержка интернационализации,</strong> включая возможность иметь несколько активных локалей. Типы наподобие wchar_t (обычно 16-битные char) и wstring (строки, состоящие из wchar_t), облегчающие работу с кодировкой Unicode.</p>
      <p class="calibre2">• <strong class="calibre4">Поддержка численных методов,</strong> включая шаблоны для комплексных чисел (complex) и массивы чистых значений (valarray).</p>
      <p class="calibre2">• <strong class="calibre4">Иерархия исключений,</strong> включая базовый класс exception, производные от него – logic_error и runtime_error, а также разнообразные классы, наследующие этим.</p>
      <p class="calibre2">• <strong class="calibre4">Стандартная библиотека C89.</strong> Все, что есть в стандартной библиотеке C 1989 года, есть и в C++.</p>
      <p class="calibre2">Если что-то из перечисленного вам незнакомо, я советую найти время и исправить ситуацию, обратившись к вашему любимому руководству по C++.</p>
      <p class="calibre2">TR1 специфицирует 14 новых компонентов библиотеки. Все они находятся в пространстве имен std, точнее, во вложенном пространстве tr1. Таким образом, полное наименование компонента TR1 shared_ptr (см. ниже) – std::tr1::shared_ptr. В этой книге я иногда пропускаю std::, когда говорю о компонентах стандартной библиотеки, но всегда указываю префикс tr1::.</p>
      <p class="calibre2">В настоящей книге были приведены примеры следующих компонентов TR1:</p>
      <p class="calibre2">• <strong class="calibre4">«Интеллектуальные» указатели</strong> tr1::shared_ptr и tr1::weak_ptr. tr1::shared_ptr работает как встроенный указатель, но отслеживает, сколько экземпляров tr1::shared_ptr указывает на объект. Этот прием называется <em class="calibre5">подсчет ссылок</em> (reference counting). Когда уничтожается последний такой указатель (то есть счетчик ссылок на объект становится равным 0), объект автоматически удаляется. Это удобно для предотвращения утечек памяти в ациклических структурах данных, но если два или более объектов содержат ссылающиеся друг на друга указатели tr1::shared_ptr, которые образуют цикл, то счетчики ссылок могут оставаться положительными, даже если все внешние указатели на объекты, образующие цикл, будут уничтожены (то есть группа объектов в целом недостижима). В такой ситуации и наступает очередь «слабых указателей» tr1::weak_ptr. Смысл их в том, чтобы выступать в роли указателей, создающих циклы в структурах данных, основанных на применении tr1::shared_ptr, которые в противном случае были бы ацикличны. Указатели tr1::weak_ptr не участвуют в подсчете ссылок. Когда разрушается последний указатель tr1::shared_ptr на объект, то объект удаляется, даже если на него продолжает указывать какой-нибудь tr1::weak_ptr. Однако такие указатели tr1::weak_ptr автоматически помечаются как недействительные.</p>
      <p class="calibre2">tr1::shared_ptr, может быть, наиболее полезный компонент TR1. Я многократно прибегал к нему в этой книге, в том числе в правиле 13, где объяснял, почему это так важно. (К сожалению, в книге не нашлось места для tr1::weak_ptr.)</p>
      <p class="calibre2">• <strong class="calibre4">tr1::function</strong> дает возможность представить любую <em class="calibre5">вызываемую сущность</em> (то есть любую функцию или функциональный объект), чья сигнатура совместима с целевой сигнатурой. Если мы хотим обеспечить возможность регистрации функций обратного вызова, которые принимают параметр int и возвращают string, то можем сделать следующее:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void registerCallback(std::string func(int)); // типом параметра</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// является функция</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// принимающая int и</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// возвращающая string</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Имя параметра – func – необязательно, поэтому registerCallback может быть объявлена и так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void registerCallback(std::string (int)); // то же, что выше; имя</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// параметра опущено</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Отметим, что «std::string (int)» – это сигнатура функции. tr1::function позволяет сделать функцию registerCallback намного более гибкой за счет того, что ее аргументом может быть любая вызываемая сущность, которая принимает параметр int или <em class="calibre5">нечто преобразуемое в int</em> и возвращает string или <em class="calibre5">нечто преобразуемое в string.</em> tr1::function принимает в качестве шаблонного параметра сигнатуру целевой функции:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void registerCallback(std::tr1::function&lt;std::string (int)&gt; func);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// параметр func – это любая вызываемая</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// сущность с сигнатурой, совместимой</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// с “std::string (int)”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Гибкость такого рода удивительно удобна. Я постарался продемонстрировать ее в правиле 35.</p>
      <p class="calibre2">• <strong class="calibre4">tr1::bind</strong> делает все, на что способны адаптеры-связыватели STL bind1st и bind2nd, плюс многое другое. В отличие от связывателей, существовавших до TR1, tr1::bind может работать как с константными, так и с неконстантными функциями-членами. Допускаются также параметры, передаваемые по ссылке. Кроме того, в отличие от старых связывателей, tr1::bind не нуждается в помощи со стороны при работе с указателями на функции, поэтому обращаться к ptr_fun, mem_fun или mem_fun_ref перед вызовом tr1::bind больше нет нужды. Проще говоря, tr1::bind – это связыватель второго поколения, которое существенно лучше своих предшественников. Пример использования я привел в правиле 35.</p>
      <p class="calibre2">Прочие компоненты TR1 я разделил на две группы. Первая группа представляет довольно дискретную, самостоятельную функциональность:</p>
      <p class="calibre2">• <strong class="calibre4">Хэш-таблицы</strong> используются для реализации контейнеров, подобных set, multiset, map и multimap. Интерфейсы новых контейнеров смоделированы на основе соответствующего компонента из предыдущей версии библиотеки. Наиболее удивительны в хэш-таблицах TR1 имена: tr1::unordered_set, tr1::unordered_multiset, tr1::unordered_map, tr1::unordered_multimap. Они отражают тот факт, что в отличие от set, multiset, map или multimap, элементы кэшированных контейнеров TR1 никак не упорядочены.</p>
      <p class="calibre2">• <strong class="calibre4">Регулярные выражения,</strong> включая возможность поиска и замены в строках, перебора соответствий и т. п.</p>
      <p class="calibre2">• <strong class="calibre4">Кортежи (tuples)</strong> – изящные обобщения шаблона pair, уже имеющегося в стандартной библиотеке. Если объект типа pair может содержать только два объекта, то объект tr1::tuple может служить вместилищем для произвольного числа других объектов. Эмигранты из стран Python и Eiffel, возрадуйтесь! Теперь в C++ появилась горсть и вашей родной земли.</p>
      <p class="calibre2">• <strong class="calibre4">tr1::array</strong> – по существу, «STL-изированный» массив, то есть массив, поддерживающий такие функции-члены, как begin и end. Размер tr1::array фиксируется при компиляции; этот объект не использует динамической памяти.</p>
      <p class="calibre2">• <strong class="calibre4">tr1::mem_fn</strong> – синтаксически унифицированный способ адаптации указателей на функции-члены. Как tr1::bind обобщает связыватели bind1st и bind2nd из библиотеки C++98, так и tr1::mem_fn расширяет возможности mem_fn и mem_fn_ref.</p>
      <p class="calibre2">• <strong class="calibre4">tr1::reference_wrapper</strong> – средство, предназначенное для того, чтобы придать ссылкам большее сходство с объектами. В частности, это дает возможность создавать контейнеры, которые ведут себя так, будто содержат ссылки (в действительности контейнер может содержать только объекты или указатели).</p>
      <p class="calibre2">• <strong class="calibre4">Генератор случайных чисел</strong> – средство, намного превосходящее функцию rand, которую C++ унаследовал от стандартной библиотеки C.</p>
      <p class="calibre2">• <strong class="calibre4">Специальные математические функции,</strong> включая полиномы Лагерра, функции Бесселя, полные эллиптические интегралы и многое другое.</p>
      <p class="calibre2">• <strong class="calibre4">Расширения, совместимые с C99,</strong> – набор функций и шаблонов, предназначенных для включения в C++ многих новых средств из библиотеки C99.</p>
      <p class="calibre2">Второй набор компонентов TR1 обеспечивает поддержку более изощренной техники программирования с применением шаблонов, включая и метапрограммирование шаблонов (см. правило 48):</p>
      <p class="calibre2">• <strong class="calibre4">Характеристики типов (type traits)</strong> – набор классов для предоставления информации о типах во время компиляции (см. правило 47). По данному типу T классы-характеристики TR1 могут узнать, является ли он встроенным, обладает ли виртуальным деструктором, представляет ли пустой класс (см. правило 39), может ли быть неявно преобразован в некоторый другой тип U и многое другое. Классы-характеристики TR1 также могут также определить правильное выравнивание для данного типа, что очень важно при написании специализированных функций распределения памяти (см. правило 50).</p>
      <p class="calibre2">
        <strong class="calibre4">• tr1::result_of</strong> – шаблон, позволяющий вывести тип значения, возвращаемого функцией. При написании шаблонов часто важно иметь возможность ссылаться на тип объекта, возвращаемого при вызове функции (шаблона), но этот тип может сложным образом зависеть от типов параметров. tr1::result_of упрощает определение возвращаемого типа значения, возвращаемого функцией… tr1::result_of используется и во многих местах в самой библиотеке TR1.</p>
      <p class="calibre2">Несмотря на то что некоторые части TR1 (в частности, tr1::bind и tr1::mem_fn) обобщают ранее существовавшие компоненты, все же TR1 содержит и немало совсем новых возможностей. Ни один из компонентов TR1 не заменяет существующих, поэтому унаследованный код будет продолжать работать.</p>
      <p class="calibre2">Отчет TR1 сам по себе – всего лишь документ<a id="n_4_back" href="section99.xhtml#n_4" class="calibre6">[4]</a>. Чтобы воспользоваться преимуществами описанной в нем функциональности, необходим доступ к ее реализации. Рано или поздно код будет поставляться вместе с компиляторами, но в 2005 году, когда писалась настоящая книга, вероятно, не все включенное в TR1 вошло в состав имеющейся у вас реализации стандартной библиотеки. К счастью, нужные компоненты можно найти и в других местах: 10 из 14 компонентов TR1 основаны на библиотеках, доступных на сайте Boost (см. правило 55), поэтому это отличный источник TR1-подобной функциональности. Я говорю «TR1-подобной», потому что хотя значительная часть того, что описано в TR1, и базируется на библиотеках Boost, есть некоторые моменты, в которых нынешние версии Boost не вполне соответствуют спецификации TR1. Возможно, когда вы будете читать эту главу, Boost не только будет предоставлять полностью соответствующую TR1 реализацию, но также и те четыре компонента, которые вошли в TR1 независимо.</p>
      <p class="calibre2">Если вы предпочитаете применять TR1-подобные библиотеки Boost в качестве временной меры, до тех пор, пока вместе с компиляторами не начнут поставляться собственные реализации TR1, возможно, вам придется применить трюк с пространствами имен. Все компоненты Boost находятся в пространстве имен boost, тогда как компоненты TR1 должны находиться в пространстве std::tr1. Вы можете указать компилятору, чтобы он воспринимал ссылки на пространство std::tr1 как на boost. Вот как это делается:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">namespace std {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">namespace tr1 = ::boost; // std::tr1 – псевдоним для пространства boost</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Технически такое поведение считается неопределенным, потому что, как объяснено в правиле 25, запрещается добавлять что-либо в пространство имен std. На практике, однако, возникновение проблем маловероятно. Когда ваш компилятор предоставит собственную реализацию TR1, вам нужно будет только удалить показанный выше псевдоним пространства имен. Код, ссылающийся на std::tr1, останется правильным.</p>
      <p class="calibre2">Возможно, наиболее важная часть TR1, которая не базируется на библиотеках Boost, – это хэш-таблицы. Но хэш-таблицы доступны уже много лет из нескольких источников под именами hash_set, hash_multiset, hash_map и hash_ multimap. Есть неплохой шанс, что библиотеки, поставляемые с вашим компилятором, уже содержат эти шаблоны. Если нет, попросите вашу любимую поисковую машину найти эти имена (как и их аналоги в TR1). Наверняка вы найдете несколько источников – как коммерческих, так и открытых.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Основная функциональность стандартной библиотеки C++ состоит из STL, потоков iostream и локалей. Также включена стандартная библиотека C99.</p>
      <p class="calibre2">• TR1 добавляет поддержку «интеллектуальных» указателей (например, tr1::shared_ptr), обобщенных указателей на функции (tr1::function), кэшированных контейнеров, регулярных выражений и еще 10 компонентов.</p>
      <p class="calibre2">• Отчет TR1 сам по себе – всего лишь спецификация. Чтобы воспользоваться преимуществами TR1, понадобится реализация. Одним из источников реализаций компонентов TR1 является проект Boost.</p>
    </div>
  </div>

{% endraw %}

