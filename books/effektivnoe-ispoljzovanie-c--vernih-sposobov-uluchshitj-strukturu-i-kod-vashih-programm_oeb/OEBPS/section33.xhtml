---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section32.xhtml
next: OEBPS/section34.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 14: Тщательно продумывайте поведение при копировании классов, управляющих ресурсами</h2>
      </div>
      <p class="calibre2">В правиле 13 изложена идея <em class="calibre5">Получение Ресурса Есть Инициализация</em> (Resource Acquisition Is Initialization – RAII), лежащая в основе создания управляющих ресурсами классов. Было также показано, как эта идея воплощается в классах auto_ptr и tr1::shared_ptr для управления динамически выделяемой из кучи памятью. Но не все ресурсы имеют дело с «кучей», и для них интеллектуальные указатели вроде auto_ptr и tr1::shared_ptr обычно не подходят. Время от времени вы будете сталкиваться со случаями, когда понадобится создать собственный класс для управления ресурсами.</p>
      <p class="calibre2">Например, предположим, что вы используете написанный на языке C интерфейс для работы с мьютексами – объектами типа Mutex, в котором есть функции lock и unlock:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void lock(Mutex *pm); // захватить мьютекс, на который указывает pm</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void unlock(Mutex *pm); // освободить семафор</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Чтобы гарантировать, что вы не забудете освободить ранее захваченный Mutex, можно создать управляющий класс. Базовая структура такого класса продиктована принципом RAII, согласно которому ресурс захватывается во время конструирования объекта и освобождается при его уничтожении:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Lock {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit Lock(Mutex *pm)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">: mutexPtr(pm)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{lock(mutexPtr);} // захват ресурса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~Lock() {unlock(mutexPtr);} // освобождение ресурса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Mutex *mutexPtr;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Клиенты используют класс Lock, как того требует идиома RAII:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Mutex m; // определить мьютекс, который вам нужно использовать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // создать блок для определения критической секции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Lock ml(&amp;m); // захватить мьютекс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // выполнить операции критической секции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // автоматически освободить мьютекс в конце блока</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Все прекрасно, но что случится, если скопировать объект Lock?</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Lock ml1(&amp;m); // захват m</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Lock ml2(ml1); // копирование m1 в m2 – что должно произойти?</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это частный пример общего вопроса, с которым сталкивается каждый разработчик классов RAII: что должно происходить при копировании RAII-объекта? В большинстве случаев выбирается один из двух вариантов:</p>
      <p class="calibre2">
        <strong class="calibre4">• Запрет копирования.</strong> Во многих случаях не имеет смысла разрешать копирование объектов RAII. Вероятно, это справедливо для класса вроде Lock, потому что редко нужно иметь копии примитивов синхронизации (каковым является мьютекс). Когда копирование RAII-объектов не имеет смысла, вы должны запретить его. Правило 6 объясняет, как это сделать: объявите копирующие операции закрытыми. Для класса Lock это может выглядеть так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">сlass Lock: private Uncopyable { // запрет копирования –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // см. правило 6</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">• <strong class="calibre4">Подсчет ссылок на ресурс.</strong> Иногда желательно удерживать ресурс до тех пор, пока не будет уничтожен последний объект, который его использует. В этом случае при копировании RAII-объекта нужно увеличивать счетчик числа объектов, ссылающихся на ресурс. Так реализовано «копирование» в классе tr1::shared_ptr.</p>
      <p class="calibre2">Часто RAII-классы реализуют копирование с подсчетом ссылок путем включения члена типа tr1::shared_ptr&lt;Mutex&gt;. К сожалению, поведение по умолчанию tr1::shared_ptr заключается в том, что он удаляет то, на что указывает, когда значение счетчика ссылок достигает нуля, а это не то, что нам нужно. Когда мы работаем с Mutex, нам нужно просто разблокировать его, а не выполнять delete.</p>
      <p class="calibre2">К счастью, tr1::shared_ptr позволяет задать «чистильщика» – функцию или функциональный объект, который должен быть вызван, когда счетчик ссылок достигает нуля (эта функциональность не предусмотрена для auto_ptr, который <em class="calibre5">всегда</em> удаляет указатель). Функция-чистильщик – это необязательный второй параметр конструктора tr1::shared_ptr, поэтому код должен выглядеть так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Lock {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit Lock(Mutex *pm) // инициализировать shared_ptr объектом</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">: mutexPtr(pm, unlock) // Mutex, на который он будет</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// указывать, функцией unlock</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // в качестве чистильщика</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">lock(mutexPtr.get());</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr; // использовать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // shared_ptr вместо</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// простого указателя</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Отметим, что в этом примере в классе Lock больше нет деструктора. Просто в нем отпала необходимость. В правиле 5 объясняется, что деструктор класса (независимо от того, сгенерирован он компилятором или определен пользователем) автоматически вызывает деструкторы нестатических данных-членов класса. В нашем примере это mutexPtr. Но деструктор mutexPtr автоматически вызовет функцию-чистильщик tr1::shared_ptr (в данном случае unlock), когда счетчик ссылок на мьютекс достигнет нуля. (Пользователи, которые будут знакомиться с исходным текстом класса, вероятно, будут благодарны за комментарии, указывающие, что вы не забыли о деструкторе, а просто положились на поведение по умолчанию деструктора, сгенерированного компилятором.)</p>
      <p class="calibre2">• <strong class="calibre4">Копирование управляемого ресурса.</strong> Иногда допустимо иметь столько копий ресурса, сколько вам нужно, и единственная причина использования класса, управляющего ресурсами, – гарантировать, что каждая копия ресурса будет освобождена по окончании работы с ней. В этом случае копирование управляющего ресурсом объекта означает также копирование самого ресурса, который в него «обернут». То есть копирование управляющего ресурсом объекта выполняет «глубокое копирование». Некоторые реализации стандартного класса string включают указатели на память из «кучи», где хранятся символы, входящие в строку. Объект такого класса содержит указатель на память из «кучи». Когда объект string копируется, то копируется и указатель, и память, на которую он указывает. Здесь мы снова встречаемся с «глубоким копированием».</p>
      <p class="calibre2">
        <strong class="calibre4">• Передача владения управляемым ресурсом.</strong> Иногда нужно гарантировать, что только один RAII-объект ссылается на ресурс, и при копировании такого объекта RAII владение ресурсом передается объекту-копии. Как объясняется в правиле 13, это означает копирование с применением auto_ptr.</p>
      <p class="calibre2">Копирующие функции (конструктор копирования и оператор присваивания) могут быть сгенерированы компилятором, но если сгенерированные версии не делают того, что вам нужно (правило 5 объясняет поведение по умолчанию), придется написать их самостоятельно. Иногда имеет смысл поддерживать обобщенные версии этих функций. Такой подход описан в правиле 45.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Копирование RAII-объектов влечет за собой копирование ресурсов, которыми они управляют, поэтому поведение ресурса при копировании определяет поведение RAII-объекта.</p>
      <p class="calibre2">• Обычно при реализации RAII-классов применяется одна из двух схем: запрет копирования или подсчет ссылок, но возможны и другие варианты.</p>
    </div>
  </div>

{% endraw %}

