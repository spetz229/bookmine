---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section31.xhtml
next: OEBPS/section33.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 13: Используйте объекты для управления ресурсами</h2>
      </div>
      <p class="calibre2">Предположим, что мы работаем с библиотекой, моделирующей инвестиции (то есть акции, облигации и т. п.), и классы, представляющие разные виды инвестиций, наследуются от корневого класса Investment:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Investment {...} // корневой класс иерархии</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// типов инвестиций</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Предположим далее, что библиотека предоставляет объекты, описывающие конкретные инвестиции, с помощью фабричной функции (см. правило 7):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Investment *createInvestment(); // возвращает указатель на динамически</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// распределенный объект в иерархии</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// Investment: вызвавший клиент обязан</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// удалить его (параметры для простоты</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// опущены)</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как следует из комментария, пользователь, вызвавший createlnvestment, отвечает за удаление объекта, возвращенного этой функцией, по окончании его использования. Рассмотрим теперь функцию f, которая это делает:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void f()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Investment *pInv = createInvestment(); // вызвать фабричную функцию</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // использовать pInv</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete pInv; // освободить память, занятую</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // объектом</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Выглядит хорошо, но есть несколько случаев, когда f не удастся удалить объект инвестиций, полученный от createlnvestment. Где-нибудь внутри непоказанной части функции может встретиться предложение return. Если такой возврат будет выполнен, то управление никогда не достигнет оператора delete. Похожая ситуация может случиться, если вызов createlnvestment и delete поместить в в цикл, и этот цикл будет прерван в результате выполнения goto или continue. И наконец, некоторые предложения внутри части, обозначенной «…», могут возбудить исключение. И в этом случае управление не дойдет до оператора delete. Независимо от того, почему delete будет пропущен, мы потеряем не только память, выделенную для объекта Investment, но и все ресурсы, которые он захватил.</p>
      <p class="calibre2">Конечно, тщательное программирование может предотвратить ошибки подобного рода, но подумайте о том, как может измениться код со временем. При сопровождении программы кто-то может добавить предложение return или continue, не вполне понимая последствий своих действий для стратегии управления ресурсами, реализованной в данной функции. Хуже того, часть «…» функции f может вызвать функцию, которая никогда не возбуждала исключений, но начнет это делать после некоторого «усовершенствования». То есть полагаться на то, что f всегда доберется до своего оператора delete, просто нельзя.</p>
      <p class="calibre2">Чтобы обеспечить освобождение ресурса, возвращенного createlnvestment, нам нужно инкапсулировать ресурс внутри объекта, чей деструктор автоматически освободит его, когда управление покинет функцию f. Фактически это половина идеи дела: заключая ресурс в объект, мы можем положиться на автоматический вызов деструкторов C++, чтобы гарантировать их освобождение. (Вторую половину мы обсудим чуть ниже.)</p>
      <p class="calibre2">Многие ресурсы динамически выделяются из «кучи», используются внутри одного блока или функции и должны быть освобождены, когда управление покидает этот блок или функцию. Для таких ситуаций предназначен класс стандартной библиотеки auto_ptr. Класс auto_ptr описывает объект, подобный указателю (интеллектуальный указатель), чей деструктор автоматически вызывает delete для того, на что он указывает. Вот как использовать auto_ptr для предотвращения потенциальной опасности утечки ресурсов в нашей функции f:</p>
      <p class="calibre2">
        <code class="calibre7">void f()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); // вызов фабричной</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// функции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // использование pInv как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // автоматическое удаление pInv</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// деструктором auto_ptr</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот простой пример демонстрирует два наиболее существенных аспекта применения объектов для управления ресурсами:</p>
      <p class="calibre2">
        <strong class="calibre4">• Ресурс захватывается и сразу преобразуется объект, управлящий им. </strong>В приведенном примере ресурс, возвращенный функцией createInvestment, используется для инициализации auto_ptr, который будет им управлять. Фактически идею использования объектов для управления ресурсами часто называют <em class="calibre5">Получение Ресурса Есть Инициализация</em> (Resource Acquisition Is Initialization – RAII), поскольку нередко приходится получать ресурс и инициализировать объект управления ресурсом в одном и том же предложении. Иногда полученные ресурсы присваиваются управляющему объекту вместо инициализации, но в любом случае каждый ресурс сразу после получения преобразуется в управляющий им объект.</p>
      <p class="calibre2">• <strong class="calibre4">Управляющие ресурсами объекты используют свои деструкторы для гарантии освобождения ресурсов.</strong> Поскольку деструктор вызывается автоматически при уничтожении объекта (например, когда объект выходит из области действия), ресурсы корректно освобождаются независимо от того, как управление покидает блок. Ситуация осложняется, когда в ходе освобождения ресурса может возникнуть исключение, но эта тема обсуждается в правиле 8, поэтому сейчас мы о ней говорить не будем.</p>
      <p class="calibre2">Так как деструктор auto_ptr автоматически удаляет то, на что указывает, важно, чтобы ни в какой момент времени не существовало более одного auto_ptr, указывающего на один и тот же объект. Если такое случается, то объект будет удален более одного раза, что обязательно приведет к неопределенному поведению. Чтобы предотвратить такие проблемы, объекты auto_ptr обладают необычным свойством: при копировании (посредством копирующих конструкторов или операторов присваивания) внутренний указатель в старом объекте становится равным нулю, а новый объект получает ресурс в свое монопольное владение!</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::auto_ptr&lt;Investment&gt; // pInv1 указывает на объект,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv1(createInvestment()); // возвращенный createInvestment()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // pInv2 теперь указывает на объект,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// а pInv1 равен null</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv1 = pInv2; // теперь pInv1 указывает на объект,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// а pInv2 равно null</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это странное поведение при копировании плюс лежащее в его основе требование о том, что ни на какой ресурс, управляемый auto_ptr, не должен указывать более чем один auto_ptr, означает, что auto_ptr – не всегда является наилучшим способом управления динамически выделяемыми ресурсами. Например, STL-контейнеры требуют, чтобы их содержимое при копировании вело себя «нормально», поэтому помещать в них объекты auto_ptr нельзя.</p>
      <p class="calibre2">Альтернатива auto_ptr – это <em class="calibre5">интеллектуальные указатели с подсчетом ссылок (reference-counting smart pointer – RCSP).</em> RCSP – это интеллектуальный указатель, который отслеживает, сколько объектов указывают на определенный ресурс, и автоматически удаляет ресурс, когда никто на него не ссылается. Следовательно, RCSP ведет себя подобно сборщику мусора. Но, в отличие от сборщика мусора, RCSP не может разорвать циклические ссылки (когда два неиспользуемых объекта указывают друг на друга).</p>
      <p class="calibre2">Класс tr1::shared_prt из библиотеки TR1 (см. правило 54) – это типичный пример RCSP, поэтому вы можете написать:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void f()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv(createStatement()); // вызвать фабричную функцию</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // использовать pInv как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // автоматически удалить pInv</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// деструктором shared_ptr</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот код выглядит почти так же, как и использующий auto_ptr, но shared_ptr при копировании ведет себя гораздо более естественно:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void f()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; // pInv1 указывает на объект,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv1(createStatement()); // возвращенный createInvestment</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; // теперь оба объекта pInv1 и pInv2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv2(pInv1); // указывают на объект</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv1 = pInv2; // ничего не изменилось</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // pInv1 и pInv2 уничтожены, а объект,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// на который они указывали,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// автоматически удален</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку копирование объектов tr1::shared_ptr работает «как ожидается», то они могут быть использованы в качестве элементов STL-контейнеров, а также в других случаях, когда непривычное поведение auto_ptr нежелательно.</p>
      <p class="calibre2">Однако не заблуждайтесь. Это правило посвящено не auto_ptr и tr1::shared_ptr, или любым другим типам интеллектуальных указателей. Здесь мы говорим о важности использования объектов для управления ресурсами. auto_ptr и tr1::shared_ptr – всего лишь примеры объектов, которые делают это. (Более подробно о tr1::shared_ptr читайте в правилах 14, 18 и 54.)</p>
      <p class="calibre2">И auto_ptr, и tr1::shared_ptr в своих деструкторах используют оператор delete, а не delete[]. (Разница между ними описана в правиле 16.) Это значит, что нельзя применять auto_ptr и tr1::shared_ptr к динамически выделенным массивам, хотя, как это ни прискорбно, следующий код скомпилируется:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::auto_ptr&lt;std::string&gt; // плохая идея! Будет</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">aps(new std::string[10]); // использована не та форма</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// оператора delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;int&gt; spi(new int[1024]); // та же проблема</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Вас может удивить, что не предусмотрено ничего подобного auto_ptr или tr1::shared_ptr для работы с динамически выделенными массивами – ни в C++, ни даже в TR1. Это объясняется тем, что такие массивы почти всегда можно заменить векторами или строками (vector и string). Если вы все-таки считаете, что было бы неплохо иметь auto_ptr и tr1::shared_ptr для массивов, обратите внимание на библиотеку Boost (см. правило 55). Там вы найдете классы boost::scoped_array и boost::shared_array, которые предоставляют нужное вам поведение.</p>
      <p class="calibre2">Излагаемые здесь правила по использованию объектов для управления ресурсами предполагают, что если вы освобождаете ресурсы вручную (например, применяя delete помимо того, который содержится в деструкторе управляющего ресурсами класса), то поступаете неправильно. Готовые классы для управления ресурсами – вроде auto_ptr и tr1::shared_ptr – часто облегчают выполнение советов из настоящего правила, но иногда приходится иметь дело с ресурсами, для которых поведение этих классов неадекватно. В таких случаях вам придется разработать собственные классы управления ресурсами. Это не так уж трудно сделать, но нужно принять во внимание некоторые соображения (см. правила 14 и 15).</p>
      <p class="calibre2">И в качестве завершающего комментария я должен сказать, что возврат из функции createInvestment обычного указателя – это путь к утечкам ресурсов, потому что после обращения к ней очень просто забыть вызвать delete для этого указателя. (Даже если используются auto_ptr или tr1::shared_ptr для выполнения delete, нужно не забыть «обернуть» возвращенное значение интеллектуальным указателем.) Чтобы решить эту проблему, нам придется изменить интерфейс createInvestment, и это станет темой правила 18.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Чтобы предотвратить утечку ресурсов, используйте объекты RAII, которые захватывают ресурсы в своих конструкторах и освобождают в деструкторах.</p>
      <p class="calibre2">• Два часто используемых класса RAII – это tr1::shared_ptr и auto_ptr. Обычно лучше остановить выбор на классе tr1::shared_ptr, потому что его поведение при копировании соответствует интуитивным ожиданиям. Что касается auto_ptr, то после копирования он уже не указывает ни на какой объект.</p>
    </div>
  </div>

{% endraw %}

