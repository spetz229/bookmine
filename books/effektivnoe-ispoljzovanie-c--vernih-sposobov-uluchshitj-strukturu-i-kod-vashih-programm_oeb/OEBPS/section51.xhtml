---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section50.xhtml
next: OEBPS/section52.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 28: Избегайте возвращения «дескрипторов» внутренних данных</h2>
      </div>
      <p class="calibre2">Представим, что вы работаете над приложением, имеющим дело с прямоугольниками. Каждый прямоугольник может быть представлен своим левым верхним углом и правым нижним. Чтобы объект Rectangle оставался компактным, вы можете решить, что описание определяющих его точек следует вынести из Rectangle во вспомогательную структуру:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Point { // класс, представляющий точки</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point(int x, int y);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void setX(int newVal);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void setY(int newVal);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">struct RectData { // точки, определяющие Rectangle</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point ulhc; // ulhc – верхний левый угол</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point lrhc; // lrhc – нижний правый угол</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;RectData&gt; pData; // см. в правиле 13</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // информацию о tr1::shared_ptr</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку пользователям класса Rectangle понадобится определять его координаты, то класс предоставляет функции upperLeft и lowerRight. Однако Point – это определенный пользователем тип, поэтому, помня о том, что передача таких типов по ссылке обычно более эффективна, чем передача по значению (см. правило 20), эти функции возвращают ссылки на внутренние объекты Point:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point&amp; upperLeft() const { return pData-&gt;ulhc;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point&amp; lowerRight() const { return pData-&gt;lrhc;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Такой вариант откомпилируется, но он неправильный! Фактически он внутренне противоречив. С одной стороны, upperLeft и lowerRight объявлены как константные функции-члены, поскольку они предназначены только для того, чтобы предоставить клиенту способ получить информацию о точках Rectangle, не давая ему возможности модифицировать объект Rectangle (см. правило 3). С другой стороны, обе функции возвращают ссылки на закрытые внутренние данные – ссылки, которые пользователь может затем использовать для модификации этих внутренних данных! Например:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Point coord1(0, 0);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point coord2(100,100);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rectangle rec(coord1, coord2); // rec – константный прямоугольник</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// от (0, 0) до (100, 100)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">rec.upperLeft().setX(50); // теперь rec лежит между</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// (50, 0) и (100, 100)!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Обратите внимание, что пользователь функции upperLeft может использовать возвращенную ссылку на один из данных-членов внутреннего объекта Point для модификации этого члена. Но ведь ожидается, что rec – константа!</p>
      <p class="calibre2">Из этого примера следует извлечь два урока. Первый – член данных инкапсулирован лишь настолько, насколько доступна функция, возвращающая ссылку на него. В данном случае хотя ulhc и lrhc объявлены закрытыми, но на самом деле они открыты, потому что на них возвращают ссылки открытые функции upperLeft и lowerRight. Второй урок в том, что если константная функция-член возвращает ссылку на данные, ассоциированные с объектом, но хранящиеся вне самого объекта, то код, вызывающий эту функцию, может модифицировать данные. (Все это последствия ограничений побитовой константности – см. правило 3.)</p>
      <p class="calibre2">Такой результат получился, когда мы использовали функции-члены, возвращающие ссылки, но если они возвращают указатели или итераторы, проблема остается, и причины те же. Ссылки, указатели и итераторы – все это «дескрипторы» (handles), и возвращение такого «дескриптора» внутренних данных объекта – прямой путь к нарушению принципов инкапсуляции. Как мы только что видели, это может привести к тому, что константные функции-члены позволят модифицировать состояние объекта.</p>
      <p class="calibre2">Обычно, говоря о внутреннем устройстве объекта, мы имеем в виду его данные-члены, но функции-члены, к которым нет открытого доступа (то есть объявленные в секции private или protected), также являются частью внутреннего устройства. Поэтому возвращать их «дескрипторы» тоже не следует. Иными словами, нельзя, чтобы функция-член возвращала указатель на менее доступную функцию-член. В противном случае реальный уровень доступа будет определять более доступная функция, потому что клиенты смогут получить указатель на менее доступную функцию и вызвать ее через такой указатель.</p>
      <p class="calibre2">Впрочем, функции, которые возвращают указатели на функции-члены, встречаются нечасто, поэтому вернемся к классу Rectangle и его функциям-членам upperLeft и lowerRight. Обе проблемы, которые мы идентифицировали для этих функций, могут быть исключены простым применением квалификатора const к их возвращаемому типу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Point&amp; upperLeft() const { return pData-&gt;ulhc;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Point&amp; lowerRight() const { return pData-&gt;lrhc;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В результате такого изменения пользователи смогут читать объекты Point, определяющие прямоугольник, но не смогут изменять их. Это значит, что объявление константными функций upperLeft и lowerRight больше не является ложью, так как они более не позволяют клиентам модифицировать состояние объекта. Что касается проблемы инкапсуляции, то мы с самого начала намеревались дать клиентам возможность видеть объекты Point, определяющие Rectangle, поэтому в данном случае ослабление инкапсуляции намеренное. К тому же это лишь <em class="calibre5">частичное</em> ослабление: рассматриваемые функции дают только доступ для чтения. Доступ для записи по-прежнему запрещен.</p>
      <p class="calibre2">Но даже и так upperLeft и lowerRight по-прежнему возвращают «дескрипторы» внутренних данных объекта, и это может вызвать проблемы иного свойства. В частности, возможно появление «висячих дескрипторов» (dangling handles), то есть дескрипторов, ссылающихся на части уже не существующих объектов. Наиболее типичный источник таких исчезнувших объектов – значения, возвращаемые функциями. Например, рассмотрим функцию, которая возвращает ограничивающий прямоугольник объекта GUI:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class GUIObject {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rectangle // возвращает прямоугольник по значению;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">boundBox(const GUIObject&amp; obj); // см. в правиле 3, почему const</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь посмотрим, как пользователь может применить эту функцию:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">GUIObject *pgo; // pgo указывает на некий объект</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // GUIObject</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Point *pUpperLeft = // получить указатель на верхний левый</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">&amp;(boundingBox(*pgo).upperLeft()); // угол его рамки</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Вызов boundingBox вернет новый временный объект Rectangle. Этот объект не имеет имени, поэтому назовем его <em class="calibre5">temp.</em> Затем вызывается функция-член <em class="calibre5">upperLeft</em> объекта <em class="calibre5">temp,</em> и этот вызов возвращает ссылку на внутренние данные <em class="calibre5">temp,</em> в данном случае на один из объектов Point. В результате pUpperLeft указывает на этот объект Point. До сих пор все шло хорошо, но мы еще не закончили, поскольку в конце предложения возвращенное boundingBox значение – <em class="calibre5">temp</em> – будет разрушено, а это приведет к разрушению объектов Point, принадлежавших <em class="calibre5">temp.</em> То есть pUpperLeft теперь указывает на объект, который более не существует. Указатель PUpperLeft становится «висячим» уже в конце предложения, где он создан!</p>
      <p class="calibre2">Вот почему опасна любая функция, которая возвращает «дескриптор» внутренних данных объекта. При этом не важно, является ли «дескриптор» ссылкой, указателем или итератором. Не важно, что она квалифицирована const. Не важно, что сама функция-член, возвращающая «дескриптор», является константной. Имеет значение лишь тот факт, что «дескриптор» возвращен, поскольку возникает опасность, что он «переживет» объект, с которым связан.</p>
      <p class="calibre2">Это не значит, что <em class="calibre5">никогда</em> не следует писать функции-члены, возвращающие дескрипторы. Иногда это бывает необходимо. Например, operator[] позволяет вам обращаться к отдельному элементу строки или вектора, и работает он, возвращая ссылку на данные в контейнере (см. правило 3), которые уничтожаются вместе с контейнером. Но все же такие функции – скорее исключение, чем правило.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Избегайте возвращать «дескрипторы» (ссылки, указатели, итераторы) внутренних данных объекта. Это повышает степень инкапсуляции, помогает константным функциям-членам быть константными и минимизирует вероятность появления «висячих дескрипторов».</p>
    </div>
  </div>

{% endraw %}

