---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section64.xhtml
next: OEBPS/section66.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">«Классический» паттерн «Стратегия»</h2>
      </div>
      <p class="calibre2">Если вас больше интересуют паттерны проектирования, чем собственно язык C++, то более традиционный подход к реализации паттерна «Стратегия» состоит в том, чтобы сделать функцию вычисления жизненной силы виртуальной функцией-членом в классах, принадлежащих отдельной иерархии. Эта иерархия может выглядеть примерно так:</p>
      <div class="sectionimage">
        <img alt="" src="images/i_007.png" class="calibre8"/>
      </div>
      <p class="calibre2">Если вы не знакомы с нотацией UML, поясню: здесь говорится, что GameCharacter – корень иерархии, в которой EvilBadGay и EyeCandyCharacter являются производными классами; HealthCalcFunc – корень иерархии, в которой производными классами являются SlowHealthLooser и FastHealthLooser; и каждый объект типа GameCharacter содержит указатель на объект из иерархии HealthCalcFunc. А вот как структурируется соответствующий код:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class GameCharacter; // опережающее объявление</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class HealthCalcFunc {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual int calc(const GameCharacter&amp; gc) const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{...}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HealthCalcFunc defaultHealthCalc;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class GameCharacter {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit GameCharacter(HealhCalcFunc *phfc = &amp;defaultHealthCalc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:pHealtCalc(pfhc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int healthValue() const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return pHealthCalc-&gt;calc(*this);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HealhCalcFunc * pHealtCalc;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот подход привлекателен тем, что программисты, знакомые со «стандартной» реализацией паттерна «Стратегия», сразу видят, что к чему. К тому же он предоставляет возможность модифицировать существующий алгоритм вычисления жизненной силы путем добавления производных классов в иерархию HealthCalcFunc.</p>
    </div>
  </div>

{% endraw %}

