---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section63.xhtml
next: OEBPS/section65.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Реализация паттерна «Стратегия» посредством класса tr::function</h2>
      </div>
      <p class="calibre2">Если вы привыкли к шаблонам и их применению для построения неявных интерфейсов (см. правило 41), то применение указателей на функции покажется вам не слишком гибким решением. Почему вообще для вычисления жизненной силы нужно обязательно использовать функцию, а не что-то <em class="calibre5">ведущее себя</em> как функция (например, функциональный объект)? Если от функции никуда не деться, то почему не сделать ее членом класса? И почему функция должна возвращать int, а не объект, который можно <em class="calibre5">преобразовать</em> в int?</p>
      <p class="calibre2">Эти ограничения исчезают, если вместо указателя на функцию (подобную healthFunc) воспользоваться объектом типа tr::function. Как объясняется в правиле 54, такой объект может содержать любую <em class="calibre5">вызываемую сущность</em> (указатель на функцию, функциональный объект либо указатель на функцию-член), чья сигнатура совместима с ожидаемой. Вот пример такого подхода, на этот раз с использованием tr1::function:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class GameCharacter; // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int defaultHealthCalc(const GameCharacter&amp; gc); // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class GameCharacter {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// HealthCalcFunction – это любая вызываемая сущность, которой можно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// передать в качестве параметра нечто, совместимое с GameCharacter,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// и которая возвращает нечто, совместимое с int; подробности см. ниже</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">: healthFunc(hcf)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int healthValue() const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return healthFunc(*this);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HealthCalcFunc healthFunc;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как видите, HealthCalcFunc – это typedef, описывающий конкретизацию шаблона tr1::function. А значит, он работает как обобщенный указатель на функцию. Посмотрим внимательнее, как определен тип HealthCalcFunc:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::function&lt;int (const GameCharacter&amp;)&gt;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Здесь я выделил «целевую сигнатуру» данной конкретизации tr1::function. Словами ее можно описать так: «функция, принимающая ссылку на объект типа const GameCharacter и возвращающая int». Объект типа HealthCalcFunc может содержать любую вызываемую сущность, чья сигнатура совместима с заданной. Быть совместимой в данном случае означает, что параметр можно неявно преобразовать в const GameCharacter&amp;, а тип возвращаемого значения неявно конвертируется в int.</p>
      <p class="calibre2">Если сравнить с предыдущим вариантом дизайна (где GameCharacter включал в себя указатель на функцию), то вы не обнаружите почти никаких отличий. Единственная разница в том, что GameCharacter теперь содержит объект типа tr1::function – <em class="calibre5">обобщенный</em> указатель на функцию. Это изменение так незначительно, что я назвал бы его несущественным, если бы не то обстоятельство, что теперь пользователь получает ошеломляющую гибкость в спецификации функций, вычисляющих жизненную силу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">short calcHealth(const gameCharacter&amp;); // функция вычисления</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// жизненной силы;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// она возвращает не int</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">stuct HealthCalculator { // класс функциональных</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int operator()(const GameCharacter&amp;) const // объектов, вычисляющих</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{...} // жизненную силу</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class GameLevel {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">float health(const GameCharacter&amp;) const; // функция-член для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // вычисления жизненной</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // силы; возвращает не int</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class EvilBadGay: public GameCharacter { // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class EyeCandyCharacter: public GameCharacter { // другой тип персонажей;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // предполагается такой же</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // конструктор как</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// у EvilBadGay</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">EvilBadGay ebg1(calcHealh); // персонаж использует</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// функцию вычисления</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// жизненной силы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">EyeCandyCharacter ecc1(HealthCalculator()); // персонаж использует</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// функциональный объект</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вычисления жизненной</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// силы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">GameLevel currentLevel;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">EvilBadGay ebg2( // персонаж использует</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::bind(&amp;GameLevel::health, // функцию-член для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">currentLevel, // вычисления жизненной</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">_1) // силы; подробности</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">); // см. ниже</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Лично я поражаюсь тому, какие удивительные вещи позволяет делать шаблон tr1::function. Если вы не разделяете моих чувств, то не исключено, что просто не понимаете, для чего используется tr1::bind в определении ebg2. Позвольте мне объяснить.</p>
      <p class="calibre2">Мы хотим сказать, что для вычисления жизненной силы персонажа ebg2 следует использовать функцию-член класса GameLevel. Но из объявления GameLevel::health следует, что она должна принимать один параметр (ссылку на GameCharacter), а на самом деле она принимает два, потому что имеется еще неявный параметр типа GameLevel – тот, на который внутри нее указывает this. Все функции вычисления жизненной силы принимают лишь один параметр: ссылку на персонажа GameCharacter, чья жизненная сила вычисляется. Если мы используем функцию GameLevel::health, то должны каким-то образом «адаптировать» ее, чтобы вместо двух параметров (GameCharacter и GameLevel) она принимала только один (GameCharacter). В этом примере мы хотим для вычисления здоровья ebg2 в качестве параметра типа GameLevel всегда использовать объект currentLevel, поэтому «привязываем» его как первый параметр при вызове GameLevel::health. Именно в этом и заключается смысл вызова tr1::bind: указать, что функция вычисления жизненной силы персонажа ebg2 должна в качестве объекта типа GameLevel использовать currentLevel.</p>
      <p class="calibre2">Я пропускаю целый ряд подробностей, к примеру: почему «_1» означает «использовать currentLevel в качестве объекта GameLevel при вызове GameLevel::health для ebg2». Эти детали не столь сложны, к тому же они не имеют прямого отношения к основной идее, которую я хочу продемонстрировать, а именно: используя tr1::function вместо указателя на функцию, мы позволяем пользователям применять <em class="calibre5">любую совместимую вызываемую сущность</em> для вычислении жизненной силы персонажа. Впечатляет, не правда ли?</p>
    </div>
  </div>

{% endraw %}

