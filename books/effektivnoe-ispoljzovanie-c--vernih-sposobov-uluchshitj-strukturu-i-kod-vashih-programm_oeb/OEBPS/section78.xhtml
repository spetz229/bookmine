---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section77.xhtml
next: OEBPS/section79.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 45: Разрабатывайте шаблоны функций-членов так, чтобы они принимали «все совместимые типы»</h2>
      </div>
      <p class="calibre2">
        <em class="calibre5">Интеллектуальные указатели</em> – это объекты, которые ведут себя во многом подобно обычным указателям, но добавляют функциональность, которую последние не предоставляют. Например, в правиле 13 объясняется, как можно использовать стандартные классы auto_ptr и tr1::shared_ptr для автоматического удаления динамически выделенных ресурсов в нужное время. Итераторы STL-контейнеров почти всегда являются интеллектуальными указателями. Понятно, что от обычного указателя нельзя ожидать, что он будет сдвигаться на следующий узел связанного списка в результате выполнения операции «++», но итератор списка list::iterator работает именно так.</p>
      <p class="calibre2">Для чего обычные указатели хороши – так это для поддержки неявных преобразований типов. Указатели на объекты производных классов неявно преобразуются в указатели на объекты базовых классов, указатели на неконстантные объекты – в указатели на константные и т. п. Например, рассмотрим некоторые преобразования, которые могут происходить в трехуровневой иерархии:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Top {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Middle: public Top {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Bottom: public Middle {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Top *pt1 = new Middle; // преобразует Middle* в Top*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Top *pt2 = new Bottom; // преобразует Middle* в Bottom*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Const Top *pct2 = pt1; // преобразует Top* в const Top*</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Эмулировать такие преобразования с помощью определяемых пользователем «интеллектуальных» указателей не просто. Для этого нужно, чтобы компилировался такой код:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class SmartPtr {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit SmartPtr(T *realPtr); // интеллектуальные указатели обычно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // инициализируются встроенными</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // указателями</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr&lt;Top&gt; pt1 = // преобразует SmartPtr&lt;Middle&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr&lt;Middle&gt;(new Middle); // в SmartPtr&lt;Top&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr&lt;Top&gt; pt2 = // преобразует SmartPtr&lt;Bottom&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr&lt;Bottom&gt;(new Bottom); // SmartPtr&lt;Top&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr&lt;const Top&gt; pct2 = pt1;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Разные конкретизации одного шаблона не связаны каким-либо отношением, поэтому компилятор считает, что SmartPtr&lt;Middle&gt; и SmartPtr&lt;Top&gt; – совершенно разные классы, не более связанные друг с другом, чем, например, vector&lt;float&gt; и Widget. Чтобы можно было осуществлять преобразования между разными классами SmartPtr, необходимо явно написать соответствующий код. В приведенном выше примере каждое предложение создает новый объект интеллектуального указателя, поэтому для начала сосредоточимся на написании конструкторов, которые будут вести себя так, как нам нужно. Ключевое наблюдение состоит в том, что невозможно написать сразу все необходимые конструкторы. В приведенной иерархии мы можем сконструировать SmartPtr&lt;Top&gt; из SmartPtr&lt;Middle&gt; или SmartPtr&lt;Bottom&gt;, но если в будущем иерархия будет расширена, то придется добавить возможность конструирования объектов SmartPtr&lt;Top&gt; из других типов интеллектуальных указателей. Например, если мы позже добавим такой класс:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class BelowBottom: public Bottom {...};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то нужно будет поддержать создание объектов SmartPtr&lt;Top&gt; из SmartPtr&lt;Below-Bottom&gt;, и, очевидно, не хотелось бы ради этого модифицировать шаблон SmartPtr.</p>
      <p class="calibre2">В принципе, нам может понадобиться неограниченное число конструкторов. Поскольку шаблон может быть конкретизирован для генерации неограниченного числа функций, похоже, что нам нужен не <em class="calibre5">конструктор-функция</em> для SmartPtr, а <em class="calibre5">конструктор-шаблон.</em> Это пример <em class="calibre5">шаблона функции-члена</em> (часто называемого <em class="calibre5">шаблонного члена),</em> то есть шаблона, генерирующего функции-члены класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class SmartPtr {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename U&gt; // шаблонный член</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr(const SmartPtr&lt;U&gt;&amp; other); // для «обобщенного</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // конструктора копирования»</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Здесь говорится, что для каждой пары типов T и U класс SmartPtr&lt;T&gt; может быть создан из SmartPtr&lt;U&gt;, потому что SmartPtr&lt;T&gt; имеет конструктор, принимающий параметр типа SmartPtr&lt;U&gt;. Подобные конструкторы, создающие один объект из другого, тип которого является другой конкретизацией того же шаблона (например, SmartPtr&lt;T&gt; из SmartPtr&lt;U&gt;), иногда называют <em class="calibre5">обобщенными конструкторами копирования.</em></p>
      <p class="calibre2">Обобщенный конструктор копирования в приведенном выше примере не объявлен с модификатором explicit. И это сделано намеренно. Преобразования типов между встроенными типами указателей (например, из указателя на производный класс к указателю на базовый класс) происходят неявно и не требуют приведения, поэтому разумно и для интеллектуальных указателей эмулировать такое поведение. Именно поэтому и не указано слово explicit в объявлении обобщенного конструктора шаблона.</p>
      <p class="calibre2">Будучи объявлен описанным выше образом, обобщенный конструктор копирования для SmartPtr предоставляет больше, чем нам нужно. Да, мы хотим иметь возможность создавать SmartPtr&lt;Top&gt; из SmartPtr&lt;Bottom&gt;, но вовсе не просили создавать SmartPtr&lt;Bottom&gt; из SmartPtr&lt;Top&gt;, потому что это противоречит смыслу открытого наследования (см. правило 32). Мы также не хотим создавать SmartPtr&lt;int&gt; из SmartPtr&lt;double&gt;, потому что не существует неявного преобразования int* в double*. Каким-то образом мы должны сузить многообразие функций-членов, которые способен генерировать этот шаблон.</p>
      <p class="calibre2">Предполагая, что SmartPtr написан по образцу auto_ptr и tr1::shared_ptr, то есть предоставляет функцию-член get, которая возвращает копию встроенного указателя, хранящегося в объекте «интеллектуального» указателя (см. правило 15), мы можем воспользоваться реализацией шаблонного конструктора, чтобы ограничить набор преобразований:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class SmartPtr {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename U&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">SmartPtr(const SmartPtr&lt;U&gt;&amp; other) // инициировать этот хранимый</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:heldPtr(other.get()) {...} // указатель указателем, хранящимся</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в другом объекте</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">T *get() const { return heldPtr;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private: // встроенный указатель,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">T *heldPtr; // хранящийся в «интеллектуальном»</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Мы используем список инициализации членов, чтобы инициализировать член данных SmartPtr&lt;T&gt; типа T* указателем типа U*, который хранится в Smart-Ptr&lt;U&gt;. Этот код откомпилируется только тогда, когда существует неявное преобразование указателя U* в T*, а это как раз то, что нам нужно. Итак, SmartPtr&lt;T&gt; теперь имеет обобщенный копирующий конструктор, который компилируется только тогда, когда ему передается параметр совместимого типа.</p>
      <p class="calibre2">Использование шаблонных функций-членов не ограничивается конструкторами. Еще одно полезное применение таких функций – поддержка присваивания. Например, класс shared_ptr из TR1 (см. правило 13) поддерживает конструирование из всех совместимых встроенных указателей, tr1::shared_ptr, auto_ptr и tr1::weak_ptr (см. правило 54), а также наличие в правой части оператора присваивания объекта любого из этих типов, кроме tr1::weak_ptr. Ниже приведен фрагмент спецификации TR1 для tr1::shared_ptr; обратите внимание, что при объявлении параметров шаблона используется ключевое слов class, а не typename. Как объясняется в правиле 42, в данном контексте они означают одно и то же.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class T&gt; class shared_ptr {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // конструирует из</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit shared_ptr(Y *p); // любого совместимого</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // встроенного указателя,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">shared_ptr(shared_ptr&lt;Y&gt; const&amp; r); // shared_ptr,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // weak_ptr или</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit shared_ptr(weak_ptr&lt;Y&gt; const&amp; r); // auto_ptr</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit shared_ptr(auto_ptr&lt;Y&gt;&amp; r);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // присваивает</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r); // любой</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // совместимый</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit shared_ptr&amp; operator=(auto_ptr&lt;Y&gt; const&amp; r); // shared_ptr или</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // auto_ptr</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Все эти конструкторы объявлены как explicit, за исключением обобщенного конструктора копирования. Это значит, что неявные преобразования от одного типа shared_ptr к другому допускаются, но <em class="calibre5">неявные</em> преобразования от встроенного указателя или другого «интеллектуального» указателя не допускаются. <em class="calibre5">(Явные</em> преобразования – например, с помощью приведения типов – разрешены). Также интересно отметить, что при передаче объекта auto_ptr конструктору tr1::shared_ptr и оператору присваивания параметр указывается без модификатора const, тогда как передаваемые параметры типа tr1::shared_ptr и tr1::weak_ptr константны. Это следствие того факта, что в отличие от других классов объекты auto_ptr модифицируются при копировании (см. правило 13).</p>
      <p class="calibre2">Шаблонные функции-члены – чудесная вещь, но они не отменяют основных правил языка. В правиле 5 объясняется, что две из четырех функций-членов, которые компиляторы могут генерировать автоматически, – это конструктор копирования и оператор присваивания. В классе tr1::shared_ptr объявлен обобщенный конструктор копирования, и ясно, что в случае совпадения типов T и Y конкретизация обобщенного конструктора копирования может быть сведена к созданию «обычного» конструктора копирования. Поэтому возникает вопрос, что будет делать компилятор в случае, когда один объект tr1::shared_ptr конструируется из другого объекта того же типа: генерировать обычный конструктор копирования для tr1::shared_ptr или конкретизировать обобщенный конструктор копирования из шаблона?</p>
      <p class="calibre2">Как я сказал, шаблонные члены не отменяют основных правил языка, а из этих правил следует, что если конструктор копирования нужен, а вы не объявляете его, то он будет сгенерирован автоматически. Объявление в классе обобщенного конструктора копирования (шаблонного члена) не предотвращает генерацию компилятором обычного конструктора копирования. Поэтому если вы хотите полностью контролировать все аспекты конструирования путем копирования, то должны объявить как обобщенный конструктор копирования, так и обычный. То же касается присваивания. Приведем фрагмент определения класса tr1::shared_ptr, который иллюстрирует это положение:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class T&gt; class shared_ptr {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">shared_ptr(shared_ptr const&amp; r); // конструктор копирования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // обобщенный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">shared_ptr(shared_ptr&lt;Y&gt; const&amp; r); // конструктор копирования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">shared_ptr&amp; operator=(shared_ptr const&amp; r); // оператор присваивания</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;class Y&gt; // обобщенный оператор</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r); // присваивания</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Используйте шаблонные функции-члены для генерации функций, принимающих все совместимые типы.</p>
      <p class="calibre2">• Если вы объявляете шаблоны обобщенных конструкторов копирования или обобщенного оператора присваивания, то по-прежнему должны объявить обычный конструктор копирования и оператор присваивания.</p>
    </div>
  </div>

{% endraw %}

