---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section16.xhtml
next: OEBPS/section18.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Константные функции-члены</h2>
      </div>
      <p class="calibre2">Назначение модификатора const в объявлении функций-членов – определить, какие из них можно вызывать для константных объектов. Такие функции-члены важны по двум причинам. Во-первых, они облегчают понимание интерфейса класса, ведь полезно сразу видеть, какие функции могут модифицировать объект, а какие нет. Во-вторых, они обеспечивают возможность работать с константными объектами. Это очень важно для написания эффективного кода, потому что, как объясняется в правиле 20, один из основных способов повысить производительность программ на C++ – передавать объекты по ссылке на константу. Но эта техника будет работать только в случае, когда функции-члены для манипулирования константными объектами объявлены с модификатором const.</p>
      <p class="calibre2">Многие упускают из виду, что функции, отличающиеся только наличием const в объявлении, могут быть перегружены. Это, однако, важное свойство C++. Рассмотрим класс, представляющий блок текста:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class TextBlock {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const char&amp; operator[](std::size_t position) const // operator[] для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{return text[position];} // константных объектов</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char&amp; operator[](std::size_t position) // operator[] для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{return text[position];} // неконстантных объектов</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string text;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Функцию operator[] в классе TextBlock можно использовать следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">TextBlock tb(“Hello”);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Std::cout &lt;&lt; tb[0]; // вызов неконстантного</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// оператора TextBlock::operator[]</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const TextBlock ctb(“World”);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Std::cout &lt;&lt; ctb[0]; // вызов константного</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// оператора TextBlock::operator[]</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Кстати, константные объекты чаще всего встречаются в реальных программах в результате передачи по указателю или ссылке на константу. Приведенный выше пример ctb является довольно искусственным. Но вот вам более реалистичный:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void print(const TextBlock&amp; ctb) // в этой функции ctb – ссылка</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// на константный объект</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; ctb[0]; // вызов const TextBlock::operator[]</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Перегружая operator[] и создавая различные версии с разными возвращаемыми типами, вы можете по-разному обрабатывать константные и неконстантные объекты TextBlock:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; tb[0]; // нормально – читается</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// неконстантный TextBlock</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">tb[0] = ‘x’; // нормально – пишется</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// неконстантный TextBlock</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; ctb[0]; // нормально – читается</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// константный TextBlock</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ctb[0] = ‘x’; // ошибка! – запись</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// константного TextBlock</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Отметим, что ошибка здесь связана только с типом значения, возвращаемого operator[]; сам вызов operator[] проходит нормально. Причина ошибки – в попытке присвоить значение объекту типа const char&amp;, потому что это именно такой тип возвращается константной версией operator[].</p>
      <p class="calibre2">Отметим также, что тип, возвращаемый неконстантной версией operator[], – это ссылка на char, а не сам char. Если бы operator[] возвращал просто char, то следующее предложение не скомпилировалось бы:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">tb[0] = ‘x’;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это объясняется тем, что возвращаемое функцией значение встроенного типа модифицировать некорректно. Даже если бы это было допустимо, тот факт, что C++ возвращает объекты по значению (см. правило 20), означал бы следующее: модифицировалась <em class="calibre5">копия</em> tb.text[0], а не само значение tb.text[0]. Вряд ли это то, чего вы ожидаете.</p>
      <p class="calibre2">Давайте немного передохнем и пофилософствуем. Что означает для функции-члена быть константной? Существует два широко распространенных понятия: <em class="calibre5">побитовая константность</em> (также известная как <em class="calibre5">физическая константность)</em> и <em class="calibre5">логическая константность.</em></p>
      <p class="calibre2">Сторонники побитовой константности полагают, что функция-член константна тогда и только тогда, когда она не модифицирует никакие данные-члены объекта (за исключением статических), то есть не модифицирует ни одного бита внутри объекта. Определение побитовой константности хорошо тем, что ее нарушение легко обнаружить: компилятор просто ищет присваивания членам класса. Фактически, побитовая константность – это константность, определенная в C++: функция-член с модификатором const не может модифицировать нестатические данные-члены объекта, для которого она вызвана.</p>
      <p class="calibre2">К сожалению, многие функции-члены, которые ведут себя далеко не константно, проходят побитовый тест. В частности, функция-член, которая модифицирует то, на что указывает указатель, часто не ведет себя как константная. Но если объекту принадлежит только указатель, то функция формально является побитово константной, и компилятор не станет возражать. Это может привести к неожиданному поведению. Например, предположим, что есть класс подобный Text-Block, где данные хранятся в строках типа char * вместо string, поскольку это необходимо для передачи в функции, написанные на языке C, который не понимает, что такое объекты типа string.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class CtextBlock {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char&amp; operator[](std::size_t position) const // неудачное (но побитово</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return pText[position]} // константное)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// объявление operator[]</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char *pText;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этом классе функция operator[] (неправильно!) объявлена как константная функция-член, хотя она возвращает ссылку на внутренние данные объекта (эта тема обсуждается в правиле 28). Оставим это пока в стороне и отметим, что реализация operator[] никак не модифицирует pText. В результате компилятор спокойно сгенерирует код для функции operator[]. Ведь она действительно является побитово константной, а это все, что компилятор может проверить. Но посмотрите, что происходит:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const CtextBlock cctb(“Hello”); // объявление константного объекта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char &amp;pc = &amp;cctb[0]; // вызов const operator[] для получения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// указателя на данные cctb</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">*pc = ‘j’; // cctb теперь имеет значение “Jello”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Несомненно, есть что-то некорректное в том, что вы создаете константный объект с определенным значением, вызываете для него только константную функцию-член и тем не менее изменяете его значение!</p>
      <p class="calibre2">Это приводит нас к понятию логической константности. Сторонники этой философии утверждают, что функции-члены с const могут модифицировать некоторые биты вызвавшего их объекта, но только так, чтобы пользователь не мог этого обнаружить. Например, ваш класс CTextBlock мог бы кэшировать длину текстового блока при каждом запросе:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Class CtextBlock {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t length() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char *pText;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t textLength; // последнее вычисленное значение длины</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// текстового блока</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool lengthIsValid; // корректна ли длина в данный момент</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t CtextBlock::length() const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(!lengthIsValid) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">textLength = std::strlen(pText); // ошибка! Нельзя присваивать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">lengthIsValid = true; // значение textLength и</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // lengthIsValid в константной</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// функции-члене</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return textLength;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Эта реализация length(), конечно же, не является побитово константной, поскольку может модифицировать значения членов textLength и lengthlsValid. Но в то же время со стороны кажется, что константности объектов CTextBlock это не угрожает. Однако компилятор не согласен. Он настаивает на побитовой константности. Что делать?</p>
      <p class="calibre2">Решение простое: используйте модификатор mutable. Он освобождает нестатические данные-члены от ограничений побитовой константности:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Class CtextBlock {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t length() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">char *pText;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">mutable std::size_t textLength; // Эти данные-члены всегда могут быть</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">mutable bool lengthIsValid; // модифицированы, даже в константных</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // функциях-членах</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t CtextBlock::length() const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(!lengthIsValid) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">textLength = std::strlen(pText); // теперь порядок</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">lengthIsValid = true; // здесь то же</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return textLength;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
    </div>
  </div>

{% endraw %}

