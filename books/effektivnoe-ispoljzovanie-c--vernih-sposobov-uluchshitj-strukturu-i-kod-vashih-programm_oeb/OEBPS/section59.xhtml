---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section58.xhtml
next: OEBPS/section60.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 34: Различайте наследование интерфейса и наследование реализации</h2>
      </div>
      <p class="calibre2">Внешне простая идея открытого наследования при ближайшем рассмотрении оказывается состоящей из двух различных частей: наследования интерфейса функций и наследования их реализации. Различие между этими двумя видами наследования соответствует различию между объявлениями и определениями функций, обсуждавшемуся во введении к этой книге.</p>
      <p class="calibre2">При разработке классов иногда требуется, чтобы производные классы наследовали только интерфейс (объявления) функций-членов. В других случаях необходимо, чтобы производные классы наследовали и интерфейс, и реализацию функций, но могли переопределять унаследованную реализацию. А иногда вам может понадобиться использование наследования интерфейса и реализации, но без возможности что-либо переопределять.</p>
      <p class="calibre2">Чтобы лучше почувствовать различия между этими вариантами, рассмотрим иерархию классов для представления геометрических фигур в графическом приложении:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw() const = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void error(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int objectID() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle: public Shape {…};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Ellipse: public Shape {…};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Shape – это абстрактный класс; таковым его делает чисто виртуальная функция draw. В результате пользователи не могут создавать объекты класса Shape, а лишь классов, производных от него. Несмотря на это, Shape оказывает сильное влияние на все открыто наследующие ему классы по следующей причине:</p>
      <p class="calibre2">
        <em class="calibre5">• Интерфейс</em> функций-членов <em class="calibre5">наследуется всегда.</em> Как объясняется в правиле 32, открытое наследование означает «является», поэтому все, что верно для базового класса, также верно и для производных от него. Поэтому если функция применима к классу, она остается применимой и для подклассов.</p>
      <p class="calibre2">В классе Shape объявлены три функции. Первая, draw, выводит текущий объект на дисплей, подразумеваемый по умолчанию. Вторая, error, вызывается функциями-членами, если необходимо сообщить об ошибке. Третья, objectID, возвращает уникальный целочисленный идентификатор текущего объекта. Каждая из трех функций объявлена по-разному: draw – как чисто виртуальная; error – как просто виртуальная; а objectID – как невиртуальная функция. Каковы практические последствия этих различий?</p>
      <p class="calibre2">Рассмотрим первую чисто виртуальную функцию draw:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw() const = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Две наиболее заметные характеристики чисто виртуальных функций – они <em class="calibre5">должны</em> быть заново объявлены в любом конкретном наследующем их классе, и в абстрактном классе они обычно не определяются. Сопоставьте эти два свойства, и вы придете к пониманию следующего обстоятельства:</p>
      <p class="calibre2">• Цель объявления чисто виртуальной функции состоит в том, чтобы производные классы наследовали <em class="calibre5">только ее интерфейс.</em></p>
      <p class="calibre2">Это в полной мере относится к функции Shape::draw, поскольку наиболее разумное требование ко всем объектам класса Shape заключается в том, что они должны быть отображены на дисплее, но Shape не может обеспечить разумной реализации этой функции по умолчанию. Алгоритм рисования эллипса очень сильно отличается от алгоритма рисования прямоугольника. Объявление Shape::draw можно интерпретировать как следующее сообщение разработчикам конкретных подклассов: «Вы должны обеспечить наличие функции draw, но у меня нет ни малейшего представления, как вы это собираетесь сделать».</p>
      <p class="calibre2">Между прочим, дать определение чисто виртуальной функции <em class="calibre5">возможно.</em> Иными словами, вы можете предоставить реализацию для Shape::draw, и С++ будет ее компилировать, но единственный способ вызвать – квалифицировать имя функции названием класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Shape *ps = new Shape; // ошибка! Shape – абстрактный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Shape *ps1 = new Rectangle; // правильно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ps1-&gt;draw(); // вызов Rectangle::draw</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Shape *ps2 = new Ellipse; // правильно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Ps2-&gt;draw(); // вызов Ellipse::draw</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ps1-&gt;Shape::draw(); // вызов Shape::draw</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ps2-&gt;Shape::draw(); // вызов Shape::draw</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Кроме перспективы блеснуть перед приятелями-программистами во время вечеринки, знание этой особенности вряд ли даст вам что-то ценное. Тем не менее, как вы увидите ниже, возможность определения чисто виртуальной функции может быть использована в качестве механизма обеспечения более безопасной реализации по умолчанию обычных виртуальных функций.</p>
      <p class="calibre2">Ситуация с обычными виртуальными функциями несколько отличается от ситуации с чисто виртуальными функциями. Как всегда, производные классы наследуют интерфейс функции, но обычные виртуальные функции традиционно обеспечивают реализацию, которую подклассы могут переопределить. Если вы на минуту задумаетесь над этим, то поймете, что:</p>
      <p class="calibre2">• Цель объявлений обычной виртуальной функции – наследовать в производных классах <em class="calibre5">как интерфейс, так и ее реализацию по умолчанию.</em></p>
      <p class="calibre2">Рассмотрим функцию Shape::error:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void error(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Интерфейс говорит о том, что каждый класс должен поддерживать функцию, которую необходимо вызывать при возникновении ошибки, но каждый класс волен обрабатывать ошибки наиболее подходящим для себя образом. Если класс не предполагает производить специальные действия, он может просто положиться на обработку ошибок по умолчанию, которую предоставляет класс Shape. То есть объявление Shape::error говорит разработчикам производных классов: «Вы должны поддерживать функцию error, но если не хотите писать свою собственную, то можете рассчитывать просто использовать версию по умолчанию из класса Shape».</p>
      <p class="calibre2">Оказывается, иногда может быть опасно использовать обычные виртуальные функции, которые обеспечивают как интерфейс функции, так и ее реализацию по умолчанию. Для того чтобы понять, почему имеется такая вероятность, рассмотрим иерархию самолетов в компании XYZ Airlines. XYZ располагает самолетами только двух типов: модель A и модель B, и оба летают одинаково. В связи с этим разработчики XYZ проектирует такую иерархию:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Airport {…}; // представляет аэропорты</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void Airplane::fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">код по умолчанию, описывающий полет самолета</em>
        </code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">в заданный пункт назначения – destination</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ModelA: public Airplane {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ModelB: public Airplane {...};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Чтобы выразить тот факт, что все самолеты должны поддерживать функцию fly, и для того чтобы засвидетельствовать, что для разных моделей, в принципе, могут потребоваться различные реализации fly, функция Airplane::fly объявлена виртуальной. При этом во избежание написания идентичного кода в классах ModelA и ModelB в качестве стандартного поведения используется тело функции Airplane::fly, которую наследуют как ModelA, так и ModelB.</p>
      <p class="calibre2">Это классический пример объектно-ориентированного проектирования. Два класса имеют общее свойство (способ реализации fly), поэтому оно реализуется в базовом классе и наследуется обоими подклассами. Благодаря этому проект явным образом выделяет общие свойства, что позволяет избежать дублирования, благоприятствует проведению будущих модернизаций и упрощает долгосрочную эксплуатацию – иными словами, обеспечивает все, за что так ценится объектно-ориентированная технология. Программисты компании XYZ Airlines могут собой гордиться.</p>
      <p class="calibre2">А теперь предположим, что дела XYZ идут в гору, и компания решает приобрести новый самолет модели C. Эта модель отличается от моделей A и B, в частности, тем, что летает по-другому.</p>
      <p class="calibre2">Программисты компании XYZ добавляют в иерархию класс ModelC, но в спешке забывают переопределить функцию fly:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class ModelB: public Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // функция fly не объявлена</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В своем коде потом они пишут что-то вроде этого:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Airport PDX(...); // PDX – аэропорт возле моего дома</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Airplane *pa = new ModelC;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pa-&gt;fly(PDX); // вызывается Airplane::fly!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Назревает катастрофа: делается попытка отправить в полет объект ModelC, как если бы он принадлежал одному из классов ModelA или ModelB. Такой образ действия вряд ли может внушить доверие пассажирам.</p>
      <p class="calibre2">Проблема здесь заключается не в том, что Airplane::fly ведет себя определенным образом по умолчанию, а в том, что такое наследование допускает неявное применение этой функции для ModelC. К счастью, легко можно предложить подклассам поведение по умолчанию, но не предоставлять его, если они сами об этом не попросят. Трюк состоит в том, чтобы разделить <em class="calibre5">интерфейс</em> виртуальной функции и ее <em class="calibre5">реализацию</em> по умолчанию. Вот один из способов добиться этого:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination) = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">protected:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void defaultFly(const Airport&amp; destination);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void Airplane::defaultFly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">код по умолчанию, описывающий полет самолета в заданный пункт назначения</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Обратите внимание, что функция Airplane::fly преобразовна в чисто виртуальную. Она предоставляет интерфейс для полета. В классе Airplane присутствует и реализация по умолчанию, но теперь она представлена в форме независимой функции defaultFly. Классы, подобные ModelA и ModelB, которые хотят использовать поведение по умолчанию, просто выполняют встроенный вызов defaultFly внутри fly (см. также правило 30 о взаимодействии встраивания и виртуальных функций):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class ModelA: public Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ defaultFly(destination};}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ModelB: public Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ defaultFly(destination};}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь для класса ModelC возможность случайно унаследовать некорректную реализацию fly исключена, поскольку чисто виртуальная функция в Airplane вынуждает ModelC создавать свою собственную версию fly.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class ModelC: public Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void ModelC::fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">код, описывающий полет самолета ModelC в заданный пункт назначения</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Эта схема не обеспечивает «защиту от дурака» (программисты все же могут создать себе проблемы копированием/вставкой), но она более надежна, чем исходная. Что же касается функции Airplane::defaultFly, то она объявлена защищенной, поскольку действительно является деталью реализации класса Airplane и производных от него. Пассажиры теперь должны беспокоиться только о том, чтобы улететь, а не о том, как происходит полет.</p>
      <p class="calibre2">Важно также то, что Airplane::defaultFly объявлена как невиртуальная функция. Это связано с тем, что никакой подкласс не должен ее переопределять – обстоятельство, которому посвящено правило 36. Если бы defaultFly была виртуальной, перед вами снова встала бы та же самая проблема: что, если некоторые подклассы забудут переопределить defaultFly должным образом?</p>
      <p class="calibre2">Иногда высказываются возражения против идеи разделения функций на обеспечивающие интерфейс и реализацию по умолчанию, такие, например, как fly и defaultFly. Прежде всего, отмечают противники этой идеи, это засоряет пространство имен класса близкими названиями функций. Все же они соглашаются с тем, что интерфейс и реализация по умолчанию должны быть разделены. Как разрешить кажущееся противоречие? Для этого используется тот факт, что производные классы должны переопределять чисто виртуальные функции и при необходимости предоставлять свои собственные реализации. Вот как можно было бы использовать возможность определения чисто виртуальных функций в иерархии Airplane:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination) = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void Airplane::fly(const Airport&amp; destination) // реализация чисто</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // виртуальной функции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">код по умолчанию, описывающий полет</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">самолета в заданный пункт назначения</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ModelA: pubic Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ Airplane::fly(destination);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ModelB: pubic Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ Airplane::fly(destination);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ModelC: pubic Airplane {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void fly(const Airport&amp; destination);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void ModelC::fly(const Airport&amp; destination)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">код, описывающий полет самолета ModelC в заданный пункт назначения</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это практически такой же подход, как и прежде, за исключением того, что тело чисто виртуальной функции Airplane::fly заменяет собой независимую функцию Airplane::defaultFly. По существу, fly разбита на две основные составляющие. Объявление задает интерфейс (который <em class="calibre5">должен</em> быть использован в производных классах), а определение задает поведение по умолчанию (которое <em class="calibre5">может</em> использоваться производным классом, но только по явному требованию). Однако, производя слияние fly и defaultFly, мы теряем возможность задать для этих функций разные уровни доступа: код, который должен быть защищенным (функция defaultFly), становится открытым (потому что теперь он находится внутри fly).</p>
      <p class="calibre2">И наконец, пришла очередь невиртуальной функции класса Shape – objectID:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int objectID() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Когда функция-член объявлена невиртуальной, не предполагается, что она будет вести себя иначе в производных классах. В действительности невиртуальные функции-члены выражают <em class="calibre5">инвариант относительно специализации,</em> поскольку определяют поведение, которое должно сохраняться независимо от того, как специализируются производные классы. Справедливо следующее:</p>
      <p class="calibre2">• Цель объявления невиртуальной функции – заставить производные классы наследовать как ее <em class="calibre5">интерфейс, так и обязательную реализацию.</em></p>
      <p class="calibre2">Вы можете представлять себе объявление Shape::objectID как утверждение: «Каждый объект Shape имеет функцию, которая дает идентификатор объекта, и этот идентификатор всегда вычисляется одним и тем же способом. Этот способ задается определением функции Shape::objectID, и никакой производный класс не должен его изменять». Поскольку невиртуальная функция определяет инвариант относительно специализации, ее не следует переопределять в производных классах (см. правило 36).</p>
      <p class="calibre2">Разница в объявлениях чисто виртуальных, просто виртуальных и невиртуальных функций позволяет точно указать, что, по вашему замыслу, должны наследовать производные классы: только интерфейс, интерфейс и реализацию по умолчанию либо интерфейс и обязательную реализацию соответственно. Поскольку эти типы объявлений обозначают принципиально разные вещи, следует тщательно подходить к выбору подходящего варианта при объявлянии функции-члена. При этом вы должны избегать двух ошибок, чаще всего совершаемых неопытными проектировщиками классов.</p>
      <p class="calibre2">Первая ошибка – объявление всех функций невиртуальными. Это не оставляет возможности для маневров в производных классах; при этом больше всего проблем вызывают невиртуальные деструкторы (см. правило 7). Конечно, нет ничего плохого в проектировании классов, которые не предполагается использовать в качестве базовых. В этом случае вполне уместен набор из одних только невиртуальных функций-членов. Однако очень часто такие классы объявляются либо из-за незнания различий между виртуальными и невиртуальными функциями, либо в результате необоснованного беспокойства по поводу потери производительности при использовании виртуальных функций. Факт остается фактом: практически любой класс, который должен использоваться как базовый, будет содержать виртуальные функции (см. правило 7).</p>
      <p class="calibre2">Если вы обеспокоены тем, во что обходится использование виртуальных функций, позвольте мне напомнить вам эмпирическое правило «80–20» (см. также правило 30), которое утверждает, что в типичной программе 80 % времени исполнения затрачивается на 20 % кода. Это правило крайне важно, потому что оно означает, что в среднем 80 % ваших функций могут быть виртуальными, не оказывая ощутимого влияния на общую производительность программы. Прежде чем начать беспокоиться о том, можете ли вы позволить себе использование виртуальных функций, убедитесь, что вы имеете дело с теми 20 % программы, для которых ваше решение окажет существенное влияние на производительность.</p>
      <p class="calibre2">Другая распространенная ошибка – объявление <em class="calibre5">всех</em> функций виртуальными. Иногда это правильно, о чем свидетельствуют, например, интерфейсные классы (см. правило 31). Однако данное решение может также навести на мысль, что у разработчика нет ясного понимания задачи. Некоторые функции не должны переопределяться в производных классах, и в таком случае необходимо недвусмысленно указать на это, объявляя функции невиртуальными. Не имеет смысла делать вид, что ваш класс годится на все случаи жизни, стоит лишь переопределить его функции. Если вы видите необходимость в инвариантности относительно специализации, не бойтесь это признать!</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Наследование интерфейса отличается от наследования реализации. При открытом наследовании производные классы всегда наследуют интерфейсы базовых классов.</p>
      <p class="calibre2">• Чисто виртуальные функции означают, что наследуется только интерфейс.</p>
      <p class="calibre2">• Обычные виртуальные функции означают, что наследуются интерфейс и реализация по умолчанию.</p>
      <p class="calibre2">• Невиртуальные функции означают, что наследуются интерфейс и обязательная реализация.</p>
    </div>
  </div>

{% endraw %}

