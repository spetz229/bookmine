---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section34.xhtml
next: OEBPS/section36.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 16: Используйте одинаковые формы new и delete</h2>
      </div>
      <p class="calibre2">Что неправильно в следующем фрагменте?</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::string *stringArray = new std::string[100];</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete stringArray;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">На первый взгляд, все в полном порядке – использованию new соответствует применение delete, но кое-что здесь совершенно неверно. Поведение программы непредсказуемо. По меньшей мере, 99 из 100 объектов string, на которые указывает stringArray, вероятно, не будут корректно уничтожены, потому что их деструкторы, скорее всего, так и не вызваны.</p>
      <p class="calibre2">При использовании <em class="calibre5">выражения new</em> (когда объект создается динамически путем вызова оператора <em class="calibre5">new)</em> происходят два события. Во-первых, выделяется память (посредством функции operator new, см. правила 49 и 51). Во-вторых, для этой памяти вызывается один или несколько конструкторов. При вызове delete также происходят два события: вызывается один или несколько деструкторов, а затем память возвращается системе (посредством функции operator delete, см. правило 51). Важный вопрос, возникающий в связи с использованием delete, заключается в следующем: <em class="calibre5">сколько</em> объектов следует удалить из памяти? Ответ на него и определяет, сколько деструкторов нужно будет вызвать.</p>
      <p class="calibre2">В действительности вопрос гораздо проще: является ли удаляемый указатель указателем на один объект или на массив объектов? Это критичный вопрос, поскольку схема распределения памяти для отдельных объектов существенно отличается от схемы выделения памяти для массивов. В частности, при выделении памяти для массива обычно запоминается его размер, чтобы оператор delete знал, сколько деструкторов вызывать. В памяти, выделенной для отдельного объекта, такая информация не хранится. Различные схемы распределения памяти изображены на рисунке ниже (n – размер массива):</p>
      <div class="sectionimage">
        <img alt="" src="images/i_001.png" class="calibre8"/>
      </div>
      <p class="calibre2">Конечно, это только пример. От компилятора не требуется реализовывать схему именно таким образом, хотя многие так и делают.</p>
      <p class="calibre2">Когда вы используете оператор delete для указателя, как он может узнать, что где-то имеется информация о размере массива? Только от вас. Если после delete стоят квадратные скобки, то предполагается, что указатель указывает на массив. В противном случае компилятор считает, что это указатель на отдельный объект:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::string *stringPtr1 = new std::string;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string *stringPtr2 = new std::string[100];</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete stringPtr1;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete[]stringPtr2;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Что произойдет, если использовать форму «[]» с stringPtr1? Результат не определен, но вряд ли он будет приятным. В предположении, что память организована, как в приведенной выше схеме, delete сначала прочитает размер массива, а затем будет вызывать деструкторы, не обращая внимания на тот факт, что память, с которой он работает, не только не является массивом, но даже не содержит объектов того типа, для которых должны быть вызваны деструкторы.</p>
      <p class="calibre2">Что случится, если вы не используете форму «[]» для stringPtr2? Неизвестно, но можно предположить, что будет вызван только один деструктор, хотя нужно было вызвать несколько. Более того, это не определено даже для встроенных типов, подобных int, несмотря на то что у них нет деструкторов.</p>
      <p class="calibre2">Правило простое: если вы используете [] в выражении new, то должны использовать [] и в соответствующем выражении delete. Если вы не используете [] в new, то не надо использовать его в соответствующем выражении delete.</p>
      <p class="calibre2">Это правило особенно важно помнить при написании классов, содержащих указатели на динамически распределенную память, в которых есть несколько конструкторов, поскольку в этом случае вы должны использовать одинаковую форму new во всех конструкторах для инициализации членов-указателей. Если этого не сделать, то как узнать, какую форму delete применить в деструкторе?</p>
      <p class="calibre2">Данное правило для тех, кто часто прибегает к использованию typedef, поскольку из него следует, что автор typedef должен документировать, какую форму delete применять для удаления объектов типа, описываемого typedef. Рассмотрим пример:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">typedef std::string AddressLines[5]; // адрес человека состоит из 4 строк,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// каждая из которых имеет тип string</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку AddressLines – массив, то следующему применению new</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::string *pal = new AddressLines; // отметим, что “new AddressLines”</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вернет string *, как и</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// выражение “new string[4]”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">должна соответствовать форма delete для массивов:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">delete pal; // не определено!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete[] pal; // правильно</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Чтобы избежать путаницы, старайтесь не примененять typedef для определения типов массивов. Это просто, потому что стандартная библиотека C++ (см. правило 54) включает шаблонные классы string и vector, позволяющие практически полностью избавиться от динамических массивов. Так, в примере выше AddressLines можно было бы определить как вектор строк: vector&lt;string&gt;.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Если вы используете [] в выражении new, то должны применять [] и в соответствующем выражении delete. Если вы не используете квадратные скобки [] в выражении new, то не должны использовать их и в соответствующем выражении delete.</p>
    </div>
  </div>

{% endraw %}

