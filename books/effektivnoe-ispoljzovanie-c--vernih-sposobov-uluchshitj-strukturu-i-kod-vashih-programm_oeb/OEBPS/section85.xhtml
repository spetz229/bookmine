---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section84.xhtml
next: OEBPS/section86.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 50: Когда имеет смысл заменять new и delete</h2>
      </div>
      <p class="calibre2">Вернемся к основам. Прежде всего зачем кому-то может понадобиться подменять предлагаемые компилятором версии operator new и operator delete? Существуют, по крайней мере, три распространенные причины.</p>
      <p class="calibre2">• <strong class="calibre4">Чтобы обнаруживать ошибки применения.</strong> Если не освобождать (с помощью оператора delete) память, выделенную оператором new, это приведет к утечкам памяти. Вызов delete более одного раза для одного и того же участка памяти, выделенного new, приведет к неопределенному поведению программы. Если оператор new будет вести список выделенных адресов, а оператор delete удалять адреса освобожденных областей из списка, то такие ошибки легко обнаружить. Аналогично различные ошибки в программе могут приводить к записи за концом выделенного блока (переполнению буфера) либо с адреса, предшествующего началу выделенного блока. Специализированная версия оператора new может запрашивать блоки большего размера и в неиспользуемое место до и после области, доступной пользователям, записывать некоторую комбинацию битов («сигнатуры»). При этом оператор delete может проверять наличие такой сигнатуры. Если ее нет, значит, память была затерта, и оператор delete может запротоколировать этот факт вместе со значением указателя, для которого это обнаружилось.</p>
      <p class="calibre2">• <strong class="calibre4">Чтобы повысить эффективность.</strong> Версии операторов new и delete, поставляемые вместе с компилятором, универсальны. Они должны быть приемлемы как для долго работающих программ (например, Web-серверов), так и для программ, работающих менее одной секунды. Они должны уметь обрабатывать серии запросов на выделение больших блоков памяти, малых блоков, а также смеси тех и других. Они должны адаптироваться к широкому диапазону вариантов использования – от динамического выделения нескольких блоков большого размера, которые существуют на протяжении всего времени работы программы, до выделения и освобождения памяти для большого количества мелких объектов с малым временем жизни. Они должны предотвращать фрагментацию «кучи», ибо если этого не делать, то в конце концов будет невозможно удовлетворить запрос на выделение большого блока памяти, даже если суммарно такой объем имеется, но разнесен по множеству мелких участков.</p>
      <p class="calibre2">Учитывая все требования, предъявляемые к менеджерам памяти, неудивительно, что поставляемые с компиляторами операторы new и delete придерживаются усредненной стратегии. Они работают достаточно хорошо для всех, но оптимально – ни для кого. Если вы хорошо представляете, как динамическая память используется в вашей программе, вы сможете написать собственные версии операторов new и delete, превосходящие по эффективности стандартные. Под «превосходством» я подразумеваю, что они работают быстрее (иногда на много порядков) и требуют меньше памяти (до 50 %). Для некоторых, но отнюдь не для всех, приложений замена поставляемых new и delete собственными версиями – простой способ ощутимого повышения производительности.</p>
      <p class="calibre2">• <strong class="calibre4">Чтобы собирать статистику использования.</strong> Прежде чем перейти к написанию собственных new и delete, благоразумно собрать информацию о том, как ваша программа использует динамическую память. Как распределены выделяемые блоки по размерам? Как распределяется их время жизни? Порядок выделения и освобождения в основном следует принципу FIFO («первым вошел – первым вышел») или же LIFO («последним вошел – первым вышел»)? Или никакой закономерности не наблюдается? Изменяется ли характер использования памяти со временем, то есть существует ли разница в порядке выделения-освобождения памяти между разными стадиями исполнения? Какой максимальный объем динамически выделенной памяти используется в каждый момент времени?</p>
      <p class="calibre2">По существу, написание пользовательских версий new и delete – довольно простая задача. Например, рассмотрим вкратце, как можно реализовать глобальный оператор new с контролем записи за границами выделенного блока. Правда, в нем есть множество дефектов, но пока не будем обращать на них внимания.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">static const int signature = 0xDEADBEEF;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typedef unsigned char Byte;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в этом коде есть несколько дефектов – см. ниже</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void *operator new(std:size_t size) throw(std::bad_alloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using namespace std;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">size_t realSize=size+2*sizeof(int); // увеличить размер запрошенного</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// блока, чтобы можно было разместить</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// сигнатуры</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void *pMem = malloc(realSize); // вызвать malloc для получения памяти</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(!pMem) throw(bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// записать сигнатуру в первое и последнее слово выделенного блока</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">*(static_cast&lt;int&gt;pMem)) = signature;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">*(reinterpret_cast&lt;int*&gt;(static_cast&lt;Byte*&gt;(pMem)+realSize-sizeof(int))) =</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">signature;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вернуть указатель на память сразу за начальной сигнатурой</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return static_cast&lt;Byte*&gt;(pMem)+sizeof(int);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Большинство недостатков этой версии оператора new связаны с тем, что он не вполне соответствует соглашениям C++ относительно функций с таким именем. Например, в правиле 51 объясняется, что все операторы new должны включать цикл вызова функции-обработчика new, чего этот вариант не делает. Этому соглашению посвящено правило 51, поэтому сейчас я хочу сосредоточиться на более тонком моменте: <em class="calibre5">выравнивании.</em></p>
      <p class="calibre2">Многие компьютерные архитектуры требуют, чтобы данные конкретных типов были размещены в памяти по вполне определенным адресам. Например, архитектура может требовать, чтобы указатели размещались по адресам, кратным четырем (то есть были выровнены на границу четырехбайтового слова), а данные типа double начинались с адреса, кратного восьми. Если не придерживаться этого соглашения, то возможны аппаратные ошибки во время исполнения. Другие архитектуры более терпимы, хотя и могут демонстрировать более высокую производительность, если удовлетворены требования выравнивания. Например, на архитектуре Intel x86 значения типа double могут быть выровнены по границе любого байта, но доступ к ним будет значительно быстрее, если они выровнены по восьмибайтовым границам.</p>
      <p class="calibre2">Выравнивание важно, потому что C++ требует, чтобы все указатели, возвращаемые оператором new, были выровнены для <em class="calibre5">любого</em> типа данных. Функция malloc подчиняется этим же требованиям, поэтому использование указателя, возвращенного malloc, безопасно. Но в приведенном выше операторе new мы не возвращаем указатель, полученный от malloc, а возвращаем <em class="calibre5">указатель, смещенный от</em> возвращенного malloc <em class="calibre5">на размер int.</em> Нет никаких гарантий, что это безопасно! Если клиент вызовет оператор new, чтобы получить память, достаточную для размещения double (либо если мы напишем оператор new[] для выделения памяти под массив значений типа double), а потом запустим программу на машине, где int занимает 4 байта, а значения double должны быть выровнены по границам восьмибайтовых блоков, то, скорее всего, вернем неправильно выровненный указатель. Это может вызвать аварийную остановку программы. Или же просто замедлить ее работу. В любом случае, это совсем не то, что мы хотели.</p>
      <p class="calibre2">Внимание к подобным деталям отличает менеджеры памяти профессионального качества от тех, что делают на скорую руку программисты, вынужденные отвлекаться на другие задачи. Написать собственный менеджер памяти, который почти работает, достаточно просто. Написать такой, который работает <em class="calibre5">хорошо,</em> намного сложнее. Вообще говоря, я не рекомендую заниматься этим делом, если только нет настоятельной потребности.</p>
      <p class="calibre2">Во многих случаях ее нет. Некоторые компиляторы имеют переключатели, позволяющие отлаживать и протоколировать работу функций управления памятью. Поверхностное знакомство с документацией по вашему компилятору может исключить необходимость в написании собственных версий new и delete. На многих платформах доступны коммерческие продукты, позволяющие заменить функции управления памятью, поставляемые с компиляторами. Чтобы воспользоваться их расширенной функциональностью и (предположительно) повышенной производительностью, придется лишь заново компоновать программу (ну и, само собой, заплатить).</p>
      <p class="calibre2">Другой вариант – менеджеры памяти с открытым кодом. Они есть для многих платформ, поэтому можете скачать и попробовать. Один из таких распределителей памяти с открытым кодом – библиотека Pool из проекта Boost (см. правило 55). Библиотека Pool предлагает распределители памяти, оптимизированные для использования в одной из наиболее часто встречающихся ситуаций, где может быть оказаться полезным нестандартный менеджер памяти: распределение памяти для большого количества мелких объектов. Во многих книгах по C++, включая и ранние редакции этой, приводится код высокопроизводительного распределителя памяти для мелких объектов, но часто опускаются такие «скучные» детали, как переносимость, соглашения о выравнивании, безопасность относительно потоков и т. п. В реальные библиотеки включен гораздо более устойчивый код. Даже если вы решите написать собственные new и delete, знакомство версий с открытым кодом, вероятно, даст вам понимание тех деталей, которые отличают «почти работающие» системы от действительно работающих. Выравнивание – одна из таких деталей. Стоило бы отметить, что в отчет TR1 (см. правило 54) включена поддержка для выявления требований выравнивания, специфичных для конкретного типа.</p>
      <p class="calibre2">Тема настоящего правила – вопрос о том, когда имеет смысл подменять версии new и delete по умолчанию – на глобальном уровне или на уровне класса. Теперь мы можем ответить на этот вопрос более подробно.</p>
      <p class="calibre2">
        <strong class="calibre4">• Чтобы обнаруживать ошибки использования</strong> (как было сказано выше).</p>
      <p class="calibre2">
        <strong class="calibre4">• Чтобы собирать статистику об использовании динамически распределенной памяти</strong> (также было сказано выше).</p>
      <p class="calibre2">
        <strong class="calibre4">• Для ускорения процесса распределения и освобождения памяти.</strong> Распределители общего назначения часто (хотя и не всегда) работают намного медленнее, чем оптимизированные версии, особенно если последние специально разработаны для объектов определенного типа. Специфичные для класса распределители являются примерами выделения блоков фиксированного размера, вроде тех, что представляет библиотека Pool из проекта Boost. Если ваше приложение однопоточное, но менеджер памяти, поставляемый с компилятором, по умолчанию потокобезопасный, то вы можете получить заметный рост производительности, написав менеджер памяти для однопоточных приложений. Конечно, прежде чем решить, что нужно переписывать операторы new и delete для повышения скорости, убедитесь с помощью профилирования, что эти функции действительно являются узким местом.</p>
      <p class="calibre2">
        <strong class="calibre4">• Чтобы уменьшить накладные расходы, характерные для стандартного менеджера памяти.</strong> Менеджеры памяти общего назначения часто (хотя не всегда) не только медленнее оптимизированных версий, но и потребляют больше памяти. Это происходит из-за того, что с каждым выделенным блоком связаны некоторые накладные расходы. Распределители, оптимизированные для мелких объектов (как, например, Pool), позволяют почти избавиться от этих расходов.</p>
      <p class="calibre2">
        <strong class="calibre4">• Чтобы компенсировать субоптимальное выравнивание в распределителях по умолчанию.</strong> Как я уже упоминал, самый быстрый доступ к значениям double на архитектуре x86 получается тогда, когда они выровнены по восьмибайтным границам. К сожалению, операторы new, поставляемые с некоторыми компиляторами, не гарантируют восьмибайтового выравнивания при динамическом выделении double. В этих случаях замена оператора new по умолчанию на специальный, который гарантирует такое выравнивание, может дать заметный рост производительности программы.</p>
      <p class="calibre2">
        <strong class="calibre4">• Чтобы сгруппировать взаимосвязанные объекты друг с другом.</strong> Если вы знаете, что определенные структуры данных обычно используются вместе, и хотите минимизировать частоту ошибок из-за отсутствия страницы в физической памяти при работе с такими данными, то, возможно, имеет смысл создать отдельную кучу для подобных структур, чтобы они были собраны вместе, или на столь небольшом числе страниц, насколько возможно. Версии операторов new и delete с размещением (см. правило 52) могут обеспечить такую группировку.</p>
      <p class="calibre2">
        <strong class="calibre4">• Чтобы получить нестандартное поведение.</strong> Иногда может понадобиться, чтобы операторы new и delete делали нечто, чего поставляемые с компилятором версии делать не умеют. Например, вам нужно распределять и освобождать блоки памяти в разделяемой памяти, но для операций с такой памятью у вас только программный интерфейс C. Написание специальных версий new и delete (возможно, с размещением – см. правило 52) позволит вам обернуть C API в классы C++. Вы также можете написать специальный оператор delete, который заполняет освобождаемую память нулями, чтобы повысить степень защиты данных в приложении.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Есть много причин для написания специальных версий new и delete, включая повышение производительности, отладку ошибок при работе с кучей, а также сбор информации об использовании памяти.</p>
    </div>
  </div>

{% endraw %}

