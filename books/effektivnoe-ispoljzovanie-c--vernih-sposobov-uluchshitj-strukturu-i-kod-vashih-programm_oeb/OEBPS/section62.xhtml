---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section61.xhtml
next: OEBPS/section63.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Реализация паттерна««Шаблонный метод» с помощью идиомы невиртуального интерфейса</h2>
      </div>
      <p class="calibre2">Начнем с интересной концепции, которая утверждает, что виртуальные функции почти всегда должны быть закрытыми. Сторонники этой школы предполагают, что правильно было бы оставить функцию-член healthValue открытой, но сделать ее невиртуальной и заставить вызывать закрытую виртуальную функцию, которая и выполнит реальную работу. Назовем эту функцию doHealthValue:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class GameCharacter {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int healthValue() const // производные классы не переопределяют</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // эту функцию, см. правило 36</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // выполнить предварительные действия –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// см. ниже</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int retVal = doHealthValue(); // выполнить реальную работу</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // выполнить завершающие действия –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// см. ниже</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return retVal;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual int doHealthValue() const // производные классы могут</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // переопределить эту функцию</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // алгоритм по умолчанию для вычисления</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // жизненной силы персонажа</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этом коде (и ниже в данном правиле) я привожу тела функций в определениях классов. Как следует из правила 30, тем самым они неявно объявляются встроенными. Я поступаю так лишь для того, чтобы смысл кода было проще понять. Описываемый подход к проектированию никак не зависит от того, будут ли функции встроенными или нет.</p>
      <p class="calibre2">Основная идея этого подхода – дать возможность клиентам вызывать закрытые виртуальные функции опосредованно, через открытые невиртуальные функции-члены – известен под названием <em class="calibre5">идиома невиртуального интерфейса (non-virtual interface idiom – NVI).</em> Это частный случай более общего паттерна проектирования, называемого «Шаблонный метод» (Template Method) (к сожалению, он не имеет никакого отношения к шаблонам C++). Я называю невиртуальную функцию (healthValue) <em class="calibre5">оберткой (wrapper)</em> виртуальной функции.</p>
      <p class="calibre2">Преимущество идиомы NVI таится в коде, скрытом за комментариями «выполнить предварительные действия» и «выполнить завершающие действия». Подразумевается, что некоторый код гарантированно будет выполнен перед вызовом виртуальной функции, выполняющей реальную работу, и после возврата из нее. Таким образом, обертка настроит контекст перед вызовом виртуальной функции создания, а после возврата произведет очистку. Например, «предварительные действия» могут заключаться в захвате мьютекса, записи в протокол, проверке инвариантов класса и выполнении предусловий и т. п. В состав «завершающих действий» могут входить освобождение мьютекса, проверка постусловий функции, повторная проверка инвариантов класса и т. п. Будет затруднительно проделать все это, если вы позволите клиентам вызывать виртуальную функцию непосредственно.</p>
      <p class="calibre2">Возможно, вас поразила следующая странность: идиома NVI предполагает, что производные классы-наследники переопределяют закрытые виртуальные функции, которых они и вызывать-то не могут! Но здесь нет противоречия. Переопределяя виртуальную функцию, мы говорим, <em class="calibre5">как</em> должно быть выполнено некоторое действие. Вызов же виртуальной функции определяет момент, <em class="calibre5">когда</em> это действие выполняется. Одно от другого не зависит. Идиома NVI позволяет производным классам переопределить виртуальную функцию и, стало быть, управлять тем, <em class="calibre5">как</em> реализована некоторая функциональность. Базовый же класс оставляет за собой право определять, <em class="calibre5">когда</em> должна быть вызвана функция. Поначалу это может показаться странным, но то, что C++ разрешает в производных классах переопределять закрытые виртуальные функции, вполне разумно.</p>
      <p class="calibre2">Идиома NVI не требует, чтобы виртуальные функции обязательно были закрытыми. В некоторых иерархиях классов ожидается, что виртуальная функция, переопределенная в производном классе, будем вызывать одноименную функцию из базового класса (как в примере из правила 27). Чтобы такие вызовы были возможны, виртуальная функция должна быть защищенной, а не закрытой. Иногда она даже может быть открытой (как, например, деструкторы в полиморфных базовых классах – см. правило 7), но к этому случаю идиома NVI уже неприменима.</p>
    </div>
  </div>

{% endraw %}

