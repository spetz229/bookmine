---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section67.xhtml
next: OEBPS/section69.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 37: Никогда не переопределяйте наследуемое значение аргумента функции по умолчанию</h2>
      </div>
      <p class="calibre2">Давайте с самого начала упростим обсуждение. Есть только два типа функций, которые можно наследовать: виртуальные и невиртуальные. Но переопределять наследуемые невиртуальные функции в любом случае ошибочно (см. правило 36), поэтому мы вполне можем ограничить наше обсуждение случаем наследования <em class="calibre5">виртуальной</em> функции со значением аргумента по умолчанию.</p>
      <p class="calibre2">В этих обстоятельствах мотивировка настоящего правила становится достаточно очевидной: виртуальные функции связываются динамически, а значения аргументов по умолчанию – статически.</p>
      <p class="calibre2">Что это значит? Вы говорите, что уже позабыли, в чем заключается разница между статическим и динамическим связыванием? (Кстати, статическое связывание называют еще <em class="calibre5">ранним связыванием,</em> а динамическое – <em class="calibre5">поздним.)</em> Что ж, давайте освежим вашу память.</p>
      <p class="calibre2">
        <em class="calibre5">Статический тип</em> объекта – это тип, объявленный вами в тексте программы. Рассмотрим следующую иерархию классов:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// классы для представления геометрических фигур</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">enum ShapeColor { Red, Green, Blue };</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// все фигуры должны предоставлять функцию для рисования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw(ShapeColor color = Red) const = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle: public Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// заметьте, другое значение параметра по умолчанию – плохо!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw(ShapeColor color = Green) const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Circle: public Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw(ShapeColor color) const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Графически это можно представить так:</p>
      <div class="sectionimage">
        <img alt="" src="images/i_008.png" class="calibre8"/>
      </div>
      <p class="calibre2">Теперь рассмотрим следующие указатели:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Shape *ps; // статический тип – Shape*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Shape *pc = new Circle; // статический тип – Shape*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Shape *pr = new Rectangle; // статический тип – Shape*</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этом примере ps, pc и pr объявлены как указатели на Shape, так что для всех них он и будет выступать в роли статического типа. Отметим, что не совершенно безразлично, на что они указывают <em class="calibre5">в действительности,</em> – независимо от этого они имеют статический тип Shape*.</p>
      <p class="calibre2">
        <em class="calibre5">Динамический тип</em> объекта определяется типом того объекта, на который он ссылается в данный момент. Иными словами, динамический тип определяет поведение объекта. В приведенном выше примере динамический тип pc – это Circle*, а динамический тип pr – Recangle*. Что касается ps, то он не имеет динамического типа, потому что не указывает ни на какой объект (пока).</p>
      <p class="calibre2">Динамические типы, как следует из их названия, могут изменяться в процессе работы программы, обычно вследствие присваивания:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">ps = pc; // динамический тип ps теперь Circle*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ps = pr; // динамический тип ps теперь Rectangle*</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Виртуальные функции <em class="calibre5">связываются динамически,</em> то есть динамический тип вызывающего объекта определяет, какая конкретная функция вызывается:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">pc-&gt;draw(Shape::Red); // вызывается Circle::draw(Shape::Red)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pr-&gt;draw(Shape::Red); // вызывается Rectangle::draw(Shape::Red)</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Я знаю, что все это давно известно, и вы, несомненно, разбираетесь в виртуальных функциях. Самое интересное начинается, когда мы подходим к виртуальным функциям с аргументами, принимающими значения по умолчанию, поскольку, как я уже сказал, виртуальные функции связываются динамически, а аргументы по умолчанию – статически. Следовательно, вы можете прийти к тому, что будете вызывать виртуальную функцию, определенную в <em class="calibre5">производном классе,</em> но при этом использовать аргументы по умолчанию, заданные в <em class="calibre5">базовом классе:</em></p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">pr-&gt;draw(); // вызывается Rectangle::draw(Shape::Red)!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этом случае динамический тип pr – это Rectangle*, поэтому, как вы и ожидали, вызывается виртуальная функция класса Rectangle. Для функции Rectangle::draw значение аргумента по умолчанию – Green. Но поскольку статический тип pr – Shape*, то значения аргумента по умолчанию берутся из класса Shape, а не Rectangle! В результате получаем вызов, состоящий из странной, совершенно неожиданной комбинации объявлений draw из классов Shape и Rectangle.</p>
      <p class="calibre2">Тот факт, что ps, pc и pr являются указателями, не играет никакой роли. Будь они ссылками, результат остался бы таким же. Важно лишь, что draw – виртуальная функция, и значение по умолчанию одного из ее аргументов переопределено в производном классе.</p>
      <p class="calibre2">Почему C++ настаивает на таком диковинном поведении? Ответ на этот вопрос связан с эффективностью исполнения программы. Если бы значения аргументов по умолчанию связывались динамически, то компилятору пришлось бы найти способ во время исполнения определять, какое значение по умолчанию должно быть у параметра виртуальной функции, что медленнее и технически сложнее нынешнего механизма. Решение было принято в пользу скорости и простоты реализации, в результате чего вы можете пользоваться преимуществами эффективного выполнения кода программы. Но если не последуете совету, изложенному в настоящем правиле, то программа будет вести себя нелогично.</p>
      <p class="calibre2">Все это прекрасно, но посмотрите, что получится, если, пытаясь следовать этому правилу, вы включите аргументы со значениями по умолчанию в функцию-член, объявленную и в базовом, и в производном классах:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">enum ShapeColor { Red, Green, Blue };</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw(ShapeColor color = Red) const = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle: public Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void draw(ShapeColor color = Red) const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Гм, дублирование кода! Хуже того: дублирование кода с зависимостями: если значение аргумента по умолчанию изменится в Shape, придется изменить его и во всех производных классах. В противном случае дело закончится переопределением наследуемого значения по умолчанию. Что делать?</p>
      <p class="calibre2">Когда у вас возникает проблема с тем, чтобы заставить виртуальную функцию вести себя так, как вы хотите, то благоразумнее рассмотреть альтернативные решения, и в правиле 35 таких альтернатив приведено немало. Одна из них – <em class="calibre5">идиома невиртуального интерфейса</em> (NVI): определить в базовом классе открытую невиртуальную функцию, которая вызывает закрытую виртуальную функцию, переопределяемую в подклассах. В данном случае можно предложить невиртуальную функцию с аргументом по умолчанию и виртуальную функцию, которая выполняет всю реальную работу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">enum ShapeColor( Red, Green, Blue };</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void draw(ShapeColor color = Red) const // теперь – невиртуальная</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">doDraw(color); // вызов виртуальной функции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void doDraw(ShapeColor color) const = 0; // реальная работа</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // выполняется</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в этой функции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Rectangle: public Shape {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void doDraw(ShapeColor color) const // обратите внимание</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // на отсутствие у аргумента</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // значения по умолчанию</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку невиртуальные функции никогда не должны переопределяться в производных классах (см. правило 36), то ясно, что при таком подходе значение по умолчанию для параметра color функции draw всегда будет Red.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Никогда не переопределяйте наследуемые значения аргументов по умолчанию, потому что аргументы по умолчанию связываются статически, тогда как виртуальные функции – а только их и можно переопределять, – динамически.</p>
    </div>
  </div>

{% endraw %}

