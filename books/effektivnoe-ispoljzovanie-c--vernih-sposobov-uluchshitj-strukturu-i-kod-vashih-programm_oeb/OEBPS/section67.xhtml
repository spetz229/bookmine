---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section66.xhtml
next: OEBPS/section68.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 36: Никогда не переопределяйте наследуемые невиртуальные функции</h2>
      </div>
      <p class="calibre2">Предположим, я сообщаю вам, что класс D открыто наследует классу B и что в классе B определена открытая функция-член mf. Ее параметры и тип возвращаемого значения не важны, поэтому давайте просто предположим, что это void. Другими словами, я говорю следующее:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class B {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class D: public B {...};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Даже ничего не зная о B, D или mf, имея объект x типа D,</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">D x; // x – объект типа D</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">вы, наверное, удивитесь, когда код</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">B *pB = &amp;x; // получить указатель на x</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PB-&gt;mf(); // вызвать mf с помощью ука</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">поведет себя иначе, чем</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">D *pD = &amp;x; // получить указатель на x</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PD-&gt;mf(); // вызвать mf через указатель</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Ведь в обоих случаях вы вызываете функцию-член объекта x. Поскольку вы имеете дело с одной и той же функцией и одним и тем же объектом, поведение в обоих случаях должно быть одинаково, не так ли?</p>
      <p class="calibre2">Да, так должно быть, но не всегда бывает. В частности, вы получите иной результат, если mf невиртуальна, а D определяет собственную версию mf:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class D: public B {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf(); // скрывает B:mf; см. правило 33</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PB-&gt;mf(); // вызвать B::mf</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PD-&gt;mf(); // вызвать D::mf</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Причина такого «двуличного» поведения заключается в том, что невиртуальные функции, подобные B::mf и D::mf, связываются статически (см. правило 37). Это означает, что когда pB объявляется как указатель на объект тип B, невиртуальные функции, вызываемые посредством pB, – это <em class="calibre5">всегда</em> функции, определения которых даны в классе B, даже если pB, как в данном примере, указывает на объект класса, производного от B.</p>
      <p class="calibre2">С другой стороны, <em class="calibre5">виртуальные</em> функции связываются динамически (снова см. правило 37), поэтому для них не существует такой проблемы. Если бы функция mf была виртуальной, то ее вызов как посредством pB, так и посредством pD означал бы вызов D::mf, потому в <em class="calibre5">действительности</em> pB и pD указывают на объект типа D.</p>
      <p class="calibre2">В итоге, если вы пишете класс D и переопределяете невиртуальную функцию mf, наследуемую от класса B, есть вероятность, что объекты D будут вести себя совершенно непредсказуемо. В частности, любой конкретный объект D может вести себя при вызове mf либо как B, либо как D, причем определяющим фактором будет не тип самого объекта, а лишь тип указателя на него. При этом ссылки в этом отношении ведут себя ничем не лучше указателей.</p>
      <p class="calibre2">Это все, что относится к «прагматической» аргументации. Теперь, я уверен, требуется некоторое теоретическое обоснование запрета на переопределение наследуемых невиртуальных функций. С удовольствием его представлю.</p>
      <p class="calibre2">В правиле 32 объясняется, что открытое наследование всегда означает «является разновидностью», а в правиле 34 говорится, почему объявление невиртуальной функции в классе определяет инвариант относительно специализации этого класса. Если вы примените эти наблюдения к классам B и D и невиртуальной функции B: mf, то получите следующее:</p>
      <p class="calibre2">• Все, что применимо к объектам B, применимо и к объектам D, поскольку каждый объект D также является объектом B;</p>
      <p class="calibre2">• Подклассы B должны наследовать как интерфейс, так и реализацию mf, потому что mf невиртуальна в B.</p>
      <p class="calibre2">Теперь, если D переопределяет mf, возникает противоречие. Если класс D <em class="calibre5">действительно</em> должен содержать отличную от B реализацию mf и если каждый объект B, являющийся разновидностью B, <em class="calibre5">действительно</em> должен использовать реализацию mf из B, тогда неверно, что каждый объект класса D является разновидностью B. В этом случае D не должен открыто наследовать B. С другой стороны, если класс D <em class="calibre5">действительно</em> должен открыто наследовать B и если D <em class="calibre5">действительно</em> должен содержать реализацию mf, отличную от B, тогда неверно, что mf является инвариантом относительно специализации B. В этом случае mf должна быть виртуальной. И наконец, если каждый объект класса D <em class="calibre5">действительно</em> является разновидностью B и если mf – <em class="calibre5">действительно</em> инвариант относительно специализации B, тогда D, по правде говоря, не нуждается в переопределении mf и не должен пытаться это делать.</p>
      <p class="calibre2">Независимо от того, какой из аргументов применим в вашем случае, чем-то придется пожертвовать, но при любых обстоятельствах запрет на переопределение наследуемых невиртуальных функций остается в силе.</p>
      <p class="calibre2">Если при чтении этого правила у вас возникло ощущение <em class="calibre5">«дежа вю»,</em> то, наверное, вы просто вспомнили правило 7, где я объяснял, почему деструкторы в полиморфных базовых классах должны быть виртуальными. Если вы не следуете этому совету (то есть объявляете невиртуальные деструкторы в полиморфных базовых классах), то нарушаете и требование, изложенное в настоящем правиле, потому что все производные классы автоматически переопределяют унаследованную невиртуальную функцию – деструктор базового класса. Это верно даже для производных классов, в которых нет деструкторов, потому что, как объясняется в правиле 5, компилятор генерирует деструктор автоматически, если вы не определяете его сами. По существу, правило 7 – это лишь частный случай настоящего правила, хотя и заслуживает отдельного внимания и рекомендаций по применению.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Никогда не переопределяйте наследуемые невиртуальные функции.</p>
    </div>
  </div>

{% endraw %}

