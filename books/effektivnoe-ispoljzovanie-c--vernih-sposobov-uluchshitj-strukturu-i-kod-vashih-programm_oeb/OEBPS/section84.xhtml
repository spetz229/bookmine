---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section83.xhtml
next: OEBPS/section85.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 49: Разберитесь в поведении обработчика new</h2>
      </div>
      <p class="calibre2">Когда оператор new не может удовлетворить запрос на выделение памяти, он возбуждает исключение. Когда-то он возвращал нулевой указатель, и некоторые старые компиляторы все еще так и поступают. Вы можете столкнуться с таким устаревшим поведением, но я отложу его обсуждение до конца правила.</p>
      <p class="calibre2">Прежде чем возбудить исключение в ответ на невозможность удовлетворить запрос на выделение памяти, оператор new вызывает определенную пользователем функцию, называемую <em class="calibre5">обработчиком new (new-handler).</em> (На самом деле это не совсем так. Реальное поведение new несколько сложнее. Подробности описаны в правиле 51.) Чтобы задать функцию, обрабатывающую нехватку памяти, клиенты вызывают set_new_handler – стандартную библиотечную функцию, объявленную в заголовочном файле &lt;new&gt;:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">namespace std {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typedef void (*new_handler)();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">new_handler set_new_handler(new_handler p) throw();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как видите, new_handler – это typedef для указателя на функцию, которая ничего не принимает и не возвращает, а set_new_handler – функция, которая принимает и возвращает new_handler (конструкция throw() в конце объявления set_new_handler – это спецификация исключения; по существу, она сообщает, что функция не возбуждает никаких исключений, хотя на самом деле все несколько интереснее; подробности см. в правиле 29).</p>
      <p class="calibre2">Параметр set_new_handler – это указатель на функцию, которую operator new вызывает при невозможности выделить запрошенную память. Возвращаемое set_new_handler значение – указатель на функцию, которая использовалась для этой цели перед вызовом set_new_handler.</p>
      <p class="calibre2">Используется set_new_handler следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// функция, которая должна быть вызвана, если operator new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// не может выделить память</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void outOfMem()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cerr &lt;&lt; “Невозможно удовлетворить запрос на выделение памяти\n”;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::abort();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int main()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::set_new_handler(outOfMem);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int *pBigDataArray = new int[100000000L];</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если operator new не может выделить память для размещения 100 000 000 целых чисел, будет вызвана функция outOfMem, и программа завершится, выдав сообщение об ошибке. (Кстати, подумайте, что случится, если память должна быть динамически выделена во время вывода сообщения об ошибке в cerr…)</p>
      <p class="calibre2">Когда operator new не может удовлетворить запрос в памяти, он будет вызывать обработчик new до тех пор, пока он не <em class="calibre5">сумеет</em> найти достаточно памяти. Код, приводящий к повторным вызовам, показан в правиле 51, но и такого высокоуровневого описания достаточно, чтобы сделать вывод о том, что правильно спроектированная функция-обработчик new должна делать что-то одно из следующего списка:</p>
      <p class="calibre2">• <strong class="calibre4">Найти дополнительную память.</strong> В результате следующая попытка выделить память внутри operator new может завершиться успешно. Один из способов реализовать такую стратегию – выделить большой блок памяти в начале работы программы, в затем освободить его при первом вызове обработчика new.</p>
      <p class="calibre2">• <strong class="calibre4">Установить другой обработчик new.</strong> Если текущий обработчик не может выделить память, то, возможно, ему известен какой-то другой, который сможет это сделать. Если так, то текущий обработчик может установить вместо себя другой (вызвав set_new_handler). В следующий раз, когда operator new обратится к обработчику, будет вызван последний установленный. (В качестве альтернативы обработчик может изменить <em class="calibre5">собственное</em> поведение, чтобы при следующем вызове сделать что-то другое. Добиться этого можно, например, путем модификации некоторых статических, определенных в пространстве имен или глобальных данных, влияющих на его поведение.)</p>
      <p class="calibre2">• <strong class="calibre4">Убрать обработчик new,</strong> то есть передать нулевой указатель set_new_handler. Если обработчик не установлен, то operator new сразу возбудит исключение при неудачной попытке выделить память.</p>
      <p class="calibre2">• <strong class="calibre4">Возбудить исключение</strong> типа bad_alloc либо некоторого типа, унаследованного от bad_alloc. Такие исключения не перехватывает operator new, поэтому они распространяются до того места, где была запрошена память.</p>
      <p class="calibre2">• <strong class="calibre4">Не возвращать управление</strong> – обычно вызвав abort или exit.</p>
      <p class="calibre2">Эти варианты выбора обеспечивают вам достаточную гибкость в реализации функций-обработчиков new.</p>
      <p class="calibre2">Иногда обработать ошибки при выделении памяти можно и другими способами, зависящими от класса распределяемого объекта:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class X {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void outOfMemory();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Y {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void outOfMemory();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">X *p1 = new X; // если выделить память не удалось,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вызвать X::outOfMemory</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Y *p2 = new Y; // если выделить память не удалось,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вызвать Y::outOfMemory</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">С++ не поддерживает специфичных для класса обработчиков new, но он и не нуждается в них. Вы можете реализовать такое поведение самостоятельно. Для этого просто в каждом классе определяете собственную версию set_new_handler и operator new. Определенная в классе функция set_new_handler класса позволит пользователям задать обработчик new для класса (точно так же, как обычный set_new_handler устанавливает глобальный обработчик new). Принадлежащий классу operator new гарантирует, что при выделении памяти для объектов этого класса вместо глобального обработчика new будет использован тот, что определен в данном классе.</p>
      <p class="calibre2">Предположим, вы хотите обработать ошибки выделения памяти для класса Widget. Понадобится функция, которая будет вызываться, когда operator new не может выделить достаточно памяти для объекта Widget, поэтому вы объявляете статический член типа new_handler для хранения указателя на обработчик new для класса. Тогда Widget будет выглядеть примерно так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static std::new_handler set_new_handler(std::new_handler p) throw();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size) throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static std::new_handler currentHandler;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Статические члены класса должны быть определены вне самого класса (если только они не константные целые – см. правило 2), поэтому:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::new_handler Widget::currentHandler = 0; // инициализировать нулем</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в файле реализации класса</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Функция set_new_handler в классе Widget сохранит переданный ей указатель и вернет тот указатель на функцию, действовавшую ранее. Так же поступает и стандартная версия set_new_handler:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">static std::new_handler set_new_handler(std::new_handler p) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::new_handler oldHandler = currentHandler;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">currentHandler = p;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return oldHandler;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">А вот что должен делать operator new из класса Widget.</p>
      <p class="calibre2">1. Вызвать стандартный set_new_handler, указав в качестве параметра функцию-обработчик ошибок из класса Widget. В результате обработчик new из класса Widget будет установлен в качестве глобального.</p>
      <p class="calibre2">2. Вызвать глобальный operator new для реального выделения памяти. Если произойдет ошибка, глобальный operator new вызовет обработчик new, принадлежащий Widget, поскольку эта функция была установлена в качестве глобального обработчика. Если это ни к чему не приведет, то глобальный operator new возбудит исключение bad_alloc. В этом случае operator new из класса Widget должен восстановить исходный обработчик new, а затем распространить исключение. Чтобы гарантировать, что исходный обработчик всегда восстанавливается, класс Widget трактует его как ресурс и следует совету правила 13 об использовании управляющих ресурсами объектов для предотвращения утечек.</p>
      <p class="calibre2">3. Если глобальный operator new в состоянии выделить достаточно памяти для объекта Widget, то operator new класса Widget возвращает указатель на выделенную память. Деструктор объекта, самостоятельно управляющего глобальным обработчиком new, автоматически восстанавливает тот глобальный обработчик, который был установлен перед вызовом operator new класса Widget.</p>
      <p class="calibre2">Теперь посмотрим, как все это выразить на C++. Начнем с класса, управляющего ресурсами, который не содержит ничего, кроме основных операций, диктуемых идиомой RAII: захват ресурса во время конструирования объекта и освобождение при его уничтожении (см. правило 13):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class NewHandlerHolder {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit NewHandlerHolder(std::new_handler nh) // получить текущий</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:handler(nh) {} // обработчик new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~NewHandlerHolder() // освободить его</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ std::set_new_handler(handler);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::new_handler handler; // запомнить его</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">NewHandlerHolder(const NewHandlerHolder&amp;); // предотвратить</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">NewHandlerHolder&amp; // копирование</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">operator=(const NewHandlerHolder&amp;); // (см. правило 14)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это делает реализацию оператора new для Widget совсем простой:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void Widget::orerator new(std::size_td size) throw(std::bad_aloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">NewHandlerHolder // установить обработчик</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">h(std::set_new_handler(currentHandler)); // new из класса Widget</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return ::operator new(size); // выделить память или</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// возбудить исключение</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // восстановить глобальный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// обработчик new</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Пользователи класса Widget применяют эти средства следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void outOfMem(); // объявление функции, которую нужно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вызвать, если выделить память</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// для Widget не удается</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget::set_new_handler(outOfmem); // установка outOfMem в качестве</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// обработчика new для Widget</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw1 = new Widget; // если выделить память не удалось,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вызывается outOfMem</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string *ps = new std::string; // если выделить память не удалось,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// вызывается глобальный обработчик new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// (если есть)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget::set_new_handler(0); // отменяет обработчик new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw1 = new Widget; // если выделить память не удалось,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// сразу же возбуждается исключение (никакого</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// обработчика new сейчас нет)</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Код, реализующий эту схему, один и тот же (независимо от класса), поэтому разумно было бы повторно использовать его в других местах. Простой способ сделать это – создать «присоединяемый» базовый класс, то есть базовый класс, который предназначен для того, чтобы подклассы могли унаследовать одно-единственное средство, в данном случае способность устанавливать специфичный для класса обработчик new. Затем превратите базовый класс в шаблон, чтобы каждый производный класс мог получать разные копии данных.</p>
      <p class="calibre2">При таком подходе принадлежащая базовому классу часть позволяет подклассам наследовать необходимые им функции set_new_handler и operator new, а шаблонная часть гарантирует, что у каждого подкласса будет собственный член данных currentHandler. Звучит сложновато, но код выглядит обнадеживающе знакомым. Фактически единственным отличием является то, что теперь он доступен любому классу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt; // «присоединяемый» базовый класс для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class NewHandlerSupport { // поддержки специфичной для класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // функции set_new_handler</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static std::new_handler set_new_handler(std::new_handler p) throw();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size) throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // другие версии оператора new – см. правило 52</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static std::new_handler currentHandler;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::new_handler</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::new_handler oldHandler = currentHandler;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">currentHandler = p;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return oldHandler;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void *NewHandlerSupport&lt;T&gt;::operator(std::size_t size)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(std::bad_alloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">NewHandlerHolder h(std::set_new_handler(currentHandler);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return ::operator new(size);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// currentHandler в любом классе инициализируется значением null</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">С этим шаблоном класса добавление поддержки set_new_handler к Widget очень просто: Widget просто наследуется от NewHandlerSupport&lt;Widget&gt;. (Это может показаться экстравагантным, но ниже я подробно объясню, что здесь происходит.)</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget: public NewHandlerSupport&lt;Widget&gt; {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // как раньше, но без декларации</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // set_new_handler или operator new</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это все, что нужно сделать в классе Widget, чтобы предоставить специфичный для класса обработчик set_new_handler.</p>
      <p class="calibre2">Но может быть, вас беспокоит тот факт, что Widget наследует классу New-HandlerSupport&lt;Widget&gt;? Если так, то ваше беспокойство усилится, когда вы заметите, что NewHandlerSupport никогда не использует свой параметр типа T. Он не нуждается в нем. Единственное, что нам нужно, – это отдельная копия NewHandlerSupport, а точнее его статический член currentHandler для каждого класса, производного от NewHandlerSupport. Параметр шаблона T просто отличает один подкласс от другого. Механизм шаблонов автоматически генерирует копию currentHandler для каждого типа T, для которого он конкретизируется.</p>
      <p class="calibre2">А что касается того, что Widget наследует шаблонному базовому классу, который принимает Widget как параметр типа, не пугайтесь, это только поначалу кажется непривычным. На практике это очень удобная техника, имеющая собственное название, которое отражает тот факт, что никому из тех, кто видит ее в первый раз, она не кажется естественной. А называется она <em class="calibre5">курьезный рекурсивный шаблонный паттерн</em> (curious recurring template pattern – CRTP). Честное слово.</p>
      <p class="calibre2">Однажды я опубликовал статью, в которой писал, что лучше было бы это назвать ее «Сделай Это Для Меня», потому что Widget наследует NewHandler-Support&lt;Widget&gt; и как бы говорит: «Я – Widget, и я хочу наследовать классу NewHandlerSupport для Widget». Никто не станет пользоваться предложенным мной названием (даже я сам), но если думать о CRTP как о способе сказать «сделай это для меня», то вам будет проще понять смысл наследование шаблону.</p>
      <p class="calibre2">Шаблоны, подобные NewHandlerSupport, упрощают добавление специфичных для класса обработчиков new к любому классу, которому это нужно. Однако наследование присоединяемому классу приводит к множественному наследованию, и прежде чем вставать на этот путь, вам, возможно, стоит перечитать правило 40.</p>
      <p class="calibre2">До 1993 года C++ требовал, чтобы оператор new возвращал нулевой указатель, если не мог выделить нужную память. Теперь же operator new в этом случае должен возбуждать исключение bad_alloc. Но огромный объем кода на C++ был написан до того, как компиляторы стали поддерживать новую спецификацию. Комитет по стандартизации C++ не хотел отметать весь код, основанный на сравнении с null, поэтому было решено предоставить альтернативные формы operator new, обеспечивающие традиционное поведение с возвращением null при неудаче. Эти формы известны под названием «nothrow» (не возбуждающие исключений), потому что в них используются объекты nothrow (определенные в заголовке &lt;new&gt;) в точке, где используется new:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw1 = new Widget; // возбуждает bad_alloc, если</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// выделить память не удалось</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(pw1 == 0) ... // эта проверка <em class="calibre5">должна</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// завершиться неудачно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw2 = new (std::nothrow)Widget; // возвращает 0, если выделить</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// память не удалось</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(pw2 == 0) ... // эта проверка может</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// завершиться успешно</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Не возбуждающий исключений оператор new предоставляет менее надежные гарантии относительно исключений, чем кажется на первый взгляд. В выражении «new (std::nothrow)Widget» происходят две вещи. Во-первых, nothrow-версия оператора new вызывается для выделения памяти, достаточной для размещения объекта Widget. Если получить память не удалось, то оператор new возвращает нулевой указатель, как нам и хотелось. Если же память выделить удалось, то вызывается конструктор Widget, и в этой точке все гарантии заканчиваются. Конструктор Widget может делать все, что угодно. Он может сам по себе запросить с помощью new какую-то память, и если он это делает, никто не заставляет его использовать nothrow. Хотя вызов оператора new в «new (std::nothrow)Widget» не возбуждает исключений, к конструктору Widget это не относится. И если он возбудит исключение, то оно будет распространяться как обычно. Вывод? Применение nothrow new гарантирует только то, что данный operator new не возбудит исключений, но не дает никаких гарантий относительно выражения, подобного «new (std::nothrow)Widget». А потому вряд ли стоит вообще прибегать к nothrow new.</p>
      <p class="calibre2">Независимо от того, используете вы «нормальный» (возбуждающий исключения) new или же вариант nothrow, важно, чтобы вы понимали поведение обработчика new, поскольку он вызывается обеими формами.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• set_new_handler позволяет указать функцию, которая должна быть вызвана, если запрос на выделение памяти не может быть удовлетворен.</p>
      <p class="calibre2">• Полезность nothrow new ограничена, поскольку эта форма применимо только для выделения памяти; последующие вызовы конструктора могут по-прежнему возбуждать исключения.</p>
    </div>
  </div>

{% endraw %}

