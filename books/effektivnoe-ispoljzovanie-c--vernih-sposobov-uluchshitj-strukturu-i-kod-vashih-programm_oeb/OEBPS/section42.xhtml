---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section41.xhtml
next: OEBPS/section43.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 21: Не пытайтесь вернуть ссылку, когда должны вернуть объект</h2>
      </div>
      <p class="calibre2">Как только программисты осознают проблемы эффективности, связанные с передачей объектов по значению (см. правило 20), они, подобно крестоносцам, преисполняются решимости искоренить зло – передачу по значению – везде, где бы оно ни пряталось. Непреклонные в своем «святом» порыве, они с неизбежностью допускают фатальную ошибку: начинают передавать по ссылке значения несуществующих объектов. А это неправильно.</p>
      <p class="calibre2">Рассмотрим класс для представления рациональных чисел, включающий в себя дружественную функцию для перемножения двух таких чисел:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Rational {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Rational(int numerator = 0, // см. в правиле 24 – почему этот</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int denominator = 1); // конструктор не explicit</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int n, d;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">friend</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational // см. в правиле 3 -</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">operator*(const Rational&amp; lhs, // почему возвращаемый тип const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; rhs);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Ясно, что эта версия operator* возвращает результирующий объект по значению, и вы обнаружили бы непрофессиональный подход, если бы не уделили внимания вопросу о затратах на создание и удаление объекта. Вы не хотите платить за то, за что платить не должны. Отсюда вопрос: должны ли вы платить?</p>
      <p class="calibre2">Нет, если можете вернуть ссылку. Но ссылка – это просто другое <em class="calibre5">имя</em> некоторого <em class="calibre5">существующего</em> объекта. Всякий раз, сталкиваясь с объявлением ссылки, вы должны спросить себя: для чего предназначено это имя, ведь оно должно принадлежать <em class="calibre5">чему-то.</em> В случае operator*, если функция возвращает ссылку, значит, она должна вернуть ссылку на некоторый уже существующий объект Rational, который и содержит произведение двух объектов, которые следовало перемножить.</p>
      <p class="calibre2">Очевидно, нет никаких оснований полагать, что такой объект существует до вызова operator*. Например, если у вас есть</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Rational a(1, 2); // a = 1/2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Rational a(3, 5); // b = 3/5</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Rational c = a*b; // c должно равняться 3/10</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то неразумно ожидать, что уже существует то рациональное число со значением три десятых. Если operator* будет возвращать такое число, то он должен создать его самостоятельно.</p>
      <p class="calibre2">Функция может создать новый объект только двумя способами: в стеке или в куче. Создание в стеке осуществляется посредством определения локальной переменной. Используя эту стратегию, вы можете попытаться написать operator* так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; operator*(const Rational&amp; lhs, // предупреждение!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; rhs) // плохой код!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Rational result(lhs.n * rhs.h, lhs.d * rhs.d);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return result;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот подход можно отвергнуть сразу, потому что вашей целью было избежать вызова конструктора, а result должен быть создан, подобно любому другому объекту. Кроме того, эта функция порождает и более серьезную проблему, поскольку возвращает ссылку на result, но result – это локальный объект, а локальные объекты разрушаются при завершении функции, в которой они объявлены. Таким образом, эта версия operator* возвращает ссылку не на Rational, а на бывший Rational – пустой, отвратительный, гнилой скелет того, что когда-то было объектом Rational, но уже не является таковым, потому что он уничтожен. Стоит вызвать эту функцию – вы попадете в область неопределенного поведения. Запомним: любая функция, которая возвращает ссылку на локальный объект, некорректна (то же касается и функций, возвращающих указатель на локальный объект).</p>
      <p class="calibre2">А теперь давайте рассмотрим возможность конструирования объекта в «куче» с возвратом ссылки на него. Объекты в «куче» создаются посредством new. Вот как мог бы выглядеть operator* в этом случае:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; operator*(const Rational&amp; lhs, // предупреждение!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; rhs) // Опять плохой код!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Rational *result = new Rational(lhs.n * rhs.h, lhs.d * rhs.d);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return *result;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Да, вам все же придется расплачиваться за вызов конструктора, поскольку память, выделяемая new, инициализируется вызовом соответствующего конструктора, но теперь возникает новая проблема: кто выполнит delete для объекта, созданного вами с использованием new?</p>
      <p class="calibre2">Даже если вызывающая программа написана аккуратно и добросовестно, не вполне понятно, как она предотвратит утечку в следующем вполне естественном сценарии:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Rational w, x, y, z;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">w = x * y * z; // то же, что operator*(operator*(x, y), z)</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Здесь выполняется два вызова operator* в одном предложении, поэтому получаются два вызова new, которым должны соответствовать два delete. Но у пользователя operator* нет возможности это сделать, так как он не может получить указатели, скрытые за ссылками, которые возвращает функция operator*. Это гарантированная утечка ресурсов.</p>
      <p class="calibre2">Но, возможно, вы заметили, что оба подхода (на основе стека и на основе кучи) страдают от необходимости вызова конструкторов для каждого возвращаемого значения operator*. Вспомните, что исходно мы ставили себе целью вообще не вызывать конструкторы. Быть может, вы думаете, что знаете, как избежать всего, всех вызовов конструктора, кроме одного. Не исключено, что вы придумали следующую реализацию функции operator*, которая возвращает ссылку на <em class="calibre5">статический</em> объект Rational, определенный <em class="calibre5">внутри</em> функции:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; operator*(const Rational&amp; lhs, // предупреждение!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; rhs) // Код еще хуже!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static Rational result; // статический объект,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// на который возвращается ссылка</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">result = ...; // умножить lhs на rhs и поместить</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// произведение в result</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return result;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Подобно всем проектным решениям на основе статических объектов, это сразу вызывает вопросы, связанные с безопасностью относительно потоков, но есть и более очевидный недостаток. Чтобы разглядеть его, рассмотрим следующий абсолютно разумный код:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">bool operator==(const Rational&amp; lhs, // оператор == для Rational</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const Rational&amp; rhs);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Rational a, b, c, d;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if ((a*b) == (c*d)) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">действия, необходимые в случае, если два произведения равны;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} else {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">действия, необходимые в противном случае;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Догадываетесь, что не так? Выражение ((a*b) == (c*d)) будет <em class="calibre5">всегда</em> равно true независимо от значений a, b, c и d!</p>
      <p class="calibre2">Легче всего найти объяснение такому неприятному поведению, переписать проверку на равенство в эквивалентной функциональной форме:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">if(operator==(operator*(a, b), operator*(c, d)))</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Заметьте, что когда вызывается operator==, уже присутствуют два активных вызова operator*, каждый из которых будет возвращать ссылку на статический объект Rational внутри operator*. Таким образом, operator== будет сравнивать статический объект Rational, определенный в функции operator*, со значением статического объект Rational внутри той же функции. Было бы удивительно, если бы они не оказались равны всегда.</p>
      <p class="calibre2">Этого должно быть достаточно, чтобы убедить вас, что возвращение ссылки из функции, подобной operator*, – пустая трата времени, но я не настолько наивен, чтобы полагаться на везение. Кое-кто в настоящий момент думает: «Хорошо, если недостаточно одного статического объекта, то, может быть, для этого подойдет статический массив…»</p>
      <p class="calibre2">Я не снизойду до того, чтобы посвятить такой программе отдельный пример, но вкратце могу пояснить, почему даже возникновение такой идеи должно повергать вас в стыд. Во-первых, вы должны выбрать n – размер массива. Если n слишком мало, у вас может закончиться место для хранения, и вы ничего не выиграете по сравнению с вышеописанной программой. Если же n чересчур велико, вы уменьшаете производительность вашей программы, поскольку каждый объект в массиве конструируется при первом вызове функции. Это будет стоить вам n вызовов конструкторов и n вызовов деструкторов, даже если данная функция вызывается всего один раз. Если процесс повышения производительности программного обеспечения называется оптимизацией, тогда самое верное название происходящему – «пессимизация». И наконец, подумайте о том, как заносить необходимые вам значения в массив объектов и во что это обойдется. Наиболее прямой способ передачи объектов – операция присваивания, но с чем она связана? В общем случае это вызов деструктора (для уничтожения старого значения) плюс вызов конструктора (для копирования нового значения). А ваша цель – избежать вызовов конструктора и деструктора! Так что затея весьма неудачна (нет-нет: применение векторов вместо массивов не улучшит ситуацию).</p>
      <p class="calibre2">Правильный способ написания функции заключается в том, что она должна возвращать новый объект. В применении к operator* для класса Rational это означает либо следующий код, либо нечто похожее:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">inline const Rational operator*(const Rational&amp; lhs, Rational&amp; rhs)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return Rational(lhs.n*rhs.h, lhs.d*rhs.d);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Конечно, в этом случае вам придется смириться с издержками на вызов конструктора и деструктора для объектов, возвращаемых operator*, но в глобальном масштабе это небольшая цена за корректное поведение. Притом, вероятно, все не так уж страшно. Подобно всем языкам программирования, C++ позволяет разработчикам компиляторов применить оптимизацию для повышения производительности генерируемого кода, и, как оказывается, в некоторых случаях вызовы конструктора и деструктора возвращаемого operator* значения можно безопасно устранить. Когда компилятор пользуется этой возможностью (а часто он так и поступает), ваша программа продолжает делать то, чего вы от нее хотите, и даже быстрее, чем ожидалось.</p>
      <p class="calibre2">Подведем итог: когда вы выбираете между возвратом ссылки и возвращением объекта, ваша задача заключается в том, чтобы все работало правильно. О том, как сделать этот выбор менее накладным, должен заботиться разработчик компилятора.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Никогда не возвращайте указатель или ссылку на локальный объект, ссылку на объект, распределенный в «куче», либо указатель или ссылку на локальный статический объект, если есть шанс, что понадобится более, чем один экземпляр такого объекта. В правиле 4 приведен пример ситуации, когда возврат ссылки на локальный статический объект имеет смысл, по крайней мере, в однопоточных средах.</p>
    </div>
  </div>

{% endraw %}

