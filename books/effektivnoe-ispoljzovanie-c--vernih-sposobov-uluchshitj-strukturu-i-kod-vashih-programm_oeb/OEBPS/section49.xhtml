---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section48.xhtml
next: OEBPS/section50.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 26: Откладывайте определение переменных насколько возможно</h2>
      </div>
      <p class="calibre2">Всякий раз при объявлении переменной, принадлежащий типу, в котором есть конструктор или деструктор, программа тратит время на ее конструирование, когда поток управления достигнет определения переменной, и на уничтожение – при выходе переменной из области видимости. Эти накладные расходы приходится нести даже тогда, когда переменная не используется, и, разумеется, их хотелось бы избежать.</p>
      <p class="calibre2">Вероятно, вы думаете, что никогда не объявляете неиспользуемых переменных, но так ли это? Рассмотрим следующую функцию, которая возвращает зашифрованный пароль при условии, что его длина не меньше некоторого минимума. Если пароль слишком короткий, функция возбуждает исключение типа logic_error, определенное в стандартной библиотеке C++ (см. правило 54):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// эта функция объявляет переменную encrypted слишком рано</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string encryptPassword(const std::string&amp; password)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using namespace std;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">string encrypted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(password.length() &lt; MinimumPasswordLength) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw logic_error(“Слишком короткий пароль”);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // сделать все, что необходимо для помещения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// зашифрованного пароля в переменную encrypted</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return encrypted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Нельзя сказать, что объект encrypted в этой функции совсем уж не используется, но он не используется в случае, когда возбуждается исключение. Другими словами, вы платите за вызов конструктора и деструктора объекта encrypted, даже если функция encryptPassword возбуждает исключение. Так не лучше ли отложить определение переменной encrypted до того момента, когда вы будете <em class="calibre5">знать,</em> что она нужна?</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// в этой функции определение переменной encrypted отложено до момента,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// когда в ней возникает надобность</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string encryptPassword(const std::string&amp; password)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using namespace std;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(password.length() &lt; MinimumPasswordLength) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw logic_error(“Слишком короткий пароль”);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">string encrypted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // сделать все, что необходимо для помещения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// зашифрованного пароля в переменную encrypted</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return encrypted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот код все еще не настолько компактный, как мог бы быть, потому что переменная encrypted определена без начального значения. А значит, будет использован ее конструктор по умолчанию. Часто первое, что нужно сделать с объектом, – это дать ему какое-то значение, нередко посредством присваивания. В правиле 4 объяснено, почему конструирование объектов по умолчанию с последующим присваиванием значения менее эффективно, чем инициализация нужным значением с самого начала. Это относится и к данному случаю. Например, предположим, что для выполнения «трудной» части работы функция encryptPassword вызывает следующую функцию:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void encrypt(std::string&amp; s); // шифрует s по месту</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Тогда encryptPassword может быть реализована следующим образом, хотя и это еще не оптимальный способ:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// в этой функции определение переменной encrypted отложено до момента,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// когда в ней возникает надобность, но и этот вариант еще недостаточно</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// эффективен</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string encryptPassword(const std::string&amp; password)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // проверка длины</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">string encrypted; // конструктор по умолчанию</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">encrypted = password; // присваивание encrypted</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">encrypt(encrypted);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return encrypted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Еще лучше инициализировать encrypted параметром password, избежав таким образом потенциально дорогостоящего конструктора по умолчанию:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// а это оптимальный способ определения и инициализации encrypted</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string encryptPassword(const std::string&amp; password)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // проверка длины</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">string encrypted(password); // определение и инициализация</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// конструктором копирования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">encrypt(encrypted);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return encrypted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это и означает «откладывать насколько возможно» (как сказано в заголовке правила). Вы не только должны откладывать определение переменной до того момента, когда она используется, нужно еще постараться отложить определение до получения аргументов для инициализации. Поступив так, вы избегаете конструирования и разрушения ненужных объектов, а также излишних вызовов конструкторов по умолчанию. Более того, это помогает документировать назначение переменных за счет инициализации их в том контексте, в котором их значение понятно без слов.</p>
      <p class="calibre2">«А как насчет циклов?» – можете удивиться вы. Если переменная используется только внутри цикла, то что лучше: определить ее вне цикла и выполнять присваивание на каждой итерации или определить ее внутри цикла? Другими словами, какая из следующих конструкций предпочтительнее?</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// Подход A: определение вне цикла</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget w;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">for(int i=0; i&lt;n; ++i) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">w = <em class="calibre5">некоторое значение, зависящее от i;</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// Подход B: определение внутри цикла</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">for(int i=0; i&lt;n; ++i) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget w(<em class="calibre5">некоторое значение, зависящее от i</em>);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Здесь я перехожу от объекта типа string к объекту типа Widget, чтобы избежать любых предположений относительно стоимости конструирования, разрушения и присваивания.</p>
      <p class="calibre2">В терминах операций Widget накладные расходы вычисляются так:</p>
      <p class="calibre2">• Подход A: 1 конструктор + 1 деструктор + n присваиваний</p>
      <p class="calibre2">• Подход B: n конструкторов + n деструкторов</p>
      <p class="calibre2">Для классов, в которых стоимость операции присваивания меньше, чем пары конструктор-деструктор, подход A обычно более эффективен. Особенно это верно, когда значение n достаточно велико. В противном случае, возможно, подход B лучше. Более того, в случае A имя w видимо в более широкой области (включающей в себя цикл), чем в случае B, а иногда это делает программу менее понятной и удобной для сопровождения. Поэтому если (1) нет априорной информации о том, что присваивание обходится дешевле, чем пара конструктор-деструктор, и (2) речь идет о части программы, производительность которой критична, то по умолчанию рекомендуется использовать подход B.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Откладывайте определение переменных насколько возможно. Это делает программы яснее и повышает их эффективность.</p>
    </div>
  </div>

{% endraw %}

