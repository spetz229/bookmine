---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section57.xhtml
next: OEBPS/section59.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 33: Не скрывайте унаследованные имена</h2>
      </div>
      <p class="calibre2">Шекспир много размышлял об именах. Он писал: «Что в имени тебе? Роза пахнет розой, хоть розой назови ее, хоть нет». И еще писал бард: «Кто доброе мое похитит имя, несчастным сделает меня вовек…» Правильно. И это заставляет нас обратить взор на унаследованные имена в C++.</p>
      <p class="calibre2">Вообще-то эта тема относится не столько к наследованию, сколько к областям видимости. Все мы знаем, что в таком коде:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int x; // глобальная переменная</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void someFunc()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">double x; // локальная переменная</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cin &gt;&gt; x; // прочитать новое значение локальной переменной x</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">имя x в предложении считывания относится к локальной, а не к глобальной переменной, потому что имена во вложенной области видимости скрывают («затеняют») имена из внешних областей. Мы можем представить эту ситуацию визуально:</p>
      <div class="sectionimage">
        <img alt="" src="images/i_003.png" class="calibre8"/>
      </div>
      <p class="calibre2">Когда компилятор встречает имя x внутри функции someFunc, он смотрит, определено ли что-то с таким именем в локальной области видимости. Если да, то объемлющие области видимости не просматриваются. В данном случае имя x в функции someFunc принадлежит переменной типа double, а глобальная переменная с тем же именем x имеет тип int, но это несущественно. Правила сокрытия имен в C++ предназначены для одной-единственной цели: скрывать <em class="calibre5">имена.</em> Относятся ли одинаковые имена к объектам одного или разных типов, не имеет значения. В нашем примере переменная x типа double скрывает переменную x типа int.</p>
      <p class="calibre2">Вернемся к наследованию. Мы знаем, что когда находимся внутри функции-члена производного класса и ссылаемся на что-то из базового класса (например, функцию-член, typedef или член данных), компилятор сможет найти то, на что мы ссылаемся, потому что производные классы наследуют свойства, объявленные в базовых классах. Механизм основан на том, что область видимости производного класса вложена в область видимости базового класса. Например:</p>
      <div class="sectionimage">
        <img alt="" src="images/i_004.png" class="calibre8"/>
      </div>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x; </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1() = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf2();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf4();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этом примере встречаются как открытые, так и закрытые имена, как имена членов данных, так и функций-членов. Одна из функций-членов – чисто виртуальная, другая – просто виртуальная, а третья – невиртуальная. Это я к тому, что мы говорим именно об <em class="calibre5">именах,</em> а не о чем-то другом. Я мог бы включить в пример еще имена типов, например перечислений, вложенных классов и typedef. В данном контексте важно лишь то, что все это <em class="calibre5">имена.</em> Что они именуют – несущественно. В примере используется одиночное наследование, но, поняв, что происходит при одиночном наследовании, легко будет разобраться и в том, как C++ ведет себя при множественном наследовании.</p>
      <p class="calibre2">Предположим, что функция-член mf4 в производном классе реализована примерно так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void Derived::mf4()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">mf2();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Когда компилятор видит имя mf2, он должен понять, на что оно ссылается. Для этого в различных областях видимости производится поиск имени mf2. Сначала оно ищется в локальной области видимости (то есть внутри mf4), но там такого имени нет. Тогда просматривается объемлющая область видимости, то есть область видимости класса Derived. И здесь такое имя отсутствует, поэтому компилятор переходит к следующей область видимости, которой является базовый класс. И находит там нечто по имени mf2, после чего поиск завершается. Если бы mf2 не было и в классе Base, то поиск продолжился бы сначала в пространстве имен, содержащем Base, если таковое имеется, и, наконец, в глобальной области видимости.</p>
      <p class="calibre2">Данное мной описание правильно, хотя и исчерпывает всю сложность процесса поиска имен в C++. Наша цель, однако, не в том, чтобы узнать о поиске имен столько, чтобы самостоятельно написать компилятор. Достаточно будет, если мы сумеем избежать неприятных сюрпризов, а для этого изложенной информации должно хватить.</p>
      <p class="calibre2">Снова вернемся к предыдущему примеру, но на этот раз перегрузим функции mf1 и mf3, а также добавим версию mf3 в класс Derived. Как объясняется в правиле 36, перегрузка mf3 в производном классе Derived (когда наследуется невиртуальная функция) сама по себе подозрительна, но чтобы лучше разобраться с видимостью имен, закроем на это глаза.</p>
      <div class="sectionimage">
        <img alt="" src="images/i_005.png" class="calibre8"/>
      </div>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1() = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1(int);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf2();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3(double);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf4();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот код приводит к поведению, которое удивит любого программиста C++, впервые столкнувшегося с ним. Основанное на областях видимости правило сокрытия имен никуда не делось, поэтому <em class="calibre5">все</em> функции с именами mf1 и mf3 в базовом классе окажутся скрыты одноименными функциями в производном классе. С точки зрения поиска имен, Base::mf1 и Base::mf3 более не наследуются классом Derived!</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Derived d;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf1(); // правильно, вызывается Derived::mf1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf1(x); // ошибка! Derived::mf1 скрывает Base::mf1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf2(); // правильно, вызывается Base::mf2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf3(); // правильно, вызывается Derived::mf3</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf3(x); // ошибка! Derived::mf3 скрывает Base::mf3</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как видите, это касается даже тех случаев, когда функции в базовом и производном классах принимают параметры разных типов, независимо от того, идет ли речь о виртуальных или невиртуальных функциях. И точно так же, как в нашем первом примере double x внутри функции someFunc скрывает int x из глобального контекста, так и здесь функция mf3 в классе Derived скрывает функцию mf3 из класса Base, которая имеет другой тип.</p>
      <p class="calibre2">Обоснование такого поведения в том, что оно не дает нечаянно унаследовать перегруженные функции из базового класса, расположенного много выше в иерархии наследования, упрятанной в библиотеке или каркасе приложения. К сожалению, обычно вы <em class="calibre5">хотите</em> унаследовать перегруженные функции. Фактически если вы используете открытое наследование и не наследуете перегруженные функций, то нарушаете семантику отношения «является» между базовым и производным классами, которое в правиле 32 провозглашено фундаментальным принципом открытого наследования. То есть это тот случай, когда вы почти всегда хотите обойти принятое в C++ по умолчанию правило сокрытия имен.</p>
      <p class="calibre2">Это можно сделать с помощью using-объявлений:</p>
      <div class="sectionimage">
        <img alt="" src="images/i_006.png" class="calibre8"/>
      </div>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1() = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1(int);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf2();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3(double);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using Base::mf1; // обеспечить видимость всех (открытых) имен</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using Base::mf3; // mf1 и mf3 из класса Base в классе Derived</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf3();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void mf4();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь наследование будет работать, как и ожидается.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Derived d;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf1(); // по-прежнему правильно, вызывается Derived::mf1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf1(x); // теперь правильно, вызывается Base::mf1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf2(); // по-прежнему правильно, вызывается Base::mf2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf3(); // по-прежнему правильно, вызывается Derived::mf3</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf3(x); // теперь правильно, вызывается Base::mf3</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это означает, что если вы наследуете базовому классу с перегруженными функциями и хотите переопределить только некоторые из них, то должны включить using-объявление для каждого имени, иначе оно будет скрыто.</p>
      <p class="calibre2">Можно представить себе ситуацию, когда вы не хотите наследовать все функции из базовых классов. При открытом наследовании такое никогда не должно происходить, так как это противоречит смыслу отношения «является» между базовым классом и производным от него. Вот почему using-объявление находится в секции public объявления производного класса; имена, которые открыты в базовом классе, должны оставаться открытыми и в открыто унаследованном от него. Но при закрытом наследовании (см. правило 39) такое желание иногда осмыслено. Например, предположим, что класс Derived закрыто наследует классу Base, и единственная версия mfl, которую Derived хочет унаследовать, – это та, что не принимает параметров. Using-объявление в этом случае не поможет, поскольку оно делает видимыми в производном классе <em class="calibre5">все</em> унаследованные функции с заданным именем. Здесь требуется другая техника – простая перенаправляющая функция:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1() = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1(int);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: private Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void mf1() // перенаправляющая функция</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ Base::mf1();} // неявно встроена (см. правило 30)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Derived d;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Int x;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf1(); // правильно, вызывается Derived::mf1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">d.mf1(x); // ошибка! Base::mf1 скрыта</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Другое применение встроенных перенаправляющих функций – обойти дефект в тех устаревших компиляторах, которые не поддерживают using-объявления для импорта унаследованных имен в область видимости производного класса.</p>
      <p class="calibre2">Это все, что можно сказать о наследовании и сокрытии имен. Впрочем, когда наследование сочетается с шаблонами, возникает совсем другой вариант проблемы «сокрытия унаследованных имен». Все подробности, касающиеся шаблонов, см. в правиле 43.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Имена в производных классах скрывают имена из базовых классов. При открытом наследовании это всегда нежелательно.</p>
      <p class="calibre2">• Чтобы сделать скрытые имена видимыми, используйте using-объявления либо перенаправляющие функции.</p>
    </div>
  </div>

{% endraw %}

