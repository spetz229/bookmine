---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section68.xhtml
next: OEBPS/section70.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 38: Моделируйте отношение «содержит» или «реализуется посредством» с помощью композиции</h2>
      </div>
      <p class="calibre2">
        <em class="calibre5">Композиция</em> – это отношение между типами, которое возникает тогда, когда объект одного типа содержит в себе объекты других типов. Например:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Address {...}; // адрес проживания</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class PhoneNumber {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Person {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string name; // вложенный объект</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Address address; // то же</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PhoneNumber voiceNumber; // то же</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PhoneNumber faxNumber; // то же</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В данном случае объекты класса Person включают в себя объекты классов string, Address и PhoneNumber. Термин <em class="calibre5">композиция</em> имеет ряд синонимов, например: <em class="calibre5">вложение, агрегирование</em> или <em class="calibre5">встраивание.</em></p>
      <p class="calibre2">В правиле 32 объясняется, что открытое наследование означает «класс является разновидностью другого класса». У композиции тоже есть семантика, даже две: «содержит» или «реализуется посредством». Дело в том, что в своих программах вы имеете дело с двумя различными областями. Некоторые программные объекты описывают сущности из моделируемого мира: людей, автомобили, видеокадры и т. п. Такие объекты являются частью <em class="calibre5">предметной области.</em> Другие объекты возникают как часть реализации, например: буферы, мьютексы, деревья поиска и т. д. Они относятся к <em class="calibre5">области реализации,</em> свойственной для вашего приложения. Когда отношение композиции возникает между объектами из предметной области, оно имеет семантику «реализовано посредством».</p>
      <p class="calibre2">Вышеприведенный класс Person демонстрирует отношение типа «содержит». Объект Person имеет имя, адрес, номера телефона и факса. Нельзя сказать, что человек <em class="calibre5">«есть разновидность»</em> имени или что человек <em class="calibre5">«есть разновидность»</em> адреса. Можно сказать, что человек <em class="calibre5">«имеет»</em> («содержит») имя и адрес. Большинство людей не испытывают затруднений при проведении подобных различий, поэтому путаница между ролями «является» и «содержит» возникает сравнительно редко.</p>
      <p class="calibre2">Чуть сложнее провести различие между отношениями «является» и «реализуется посредством». Например, предположим, что вам нужен шаблон для классов, представляющих множества произвольных объектов, то есть наборов без дубликатов. Поскольку повторное использование – прекрасная вещь, то сразу возникает желание обратиться к шаблону set из стандартной библиотеки. В конце концов, зачем писать новый шаблон, когда есть возможность использовать уже готовый?</p>
      <p class="calibre2">К сожалению, реализации set обычно влекут за собой накладные расходы – по три указателя на элемент. Связано это с тем, что множества обычно реализованы в виде сбалансированных деревьев поиска, гарантирующих логарифмическое время поиска, вставки и удаления. Когда быстродействие важнее, чем объем занимаемой памяти, это вполне разумное решение, но конкретно для вашего приложения выясняется, что экономия памяти более существенна. Поэтому стандартный шаблон set для вас неприемлем. Похоже, нужно писать свой собственный.</p>
      <p class="calibre2">Тем не менее повторное использование – прекрасная вещь. Будучи экспертом в области структур данных, вы знаете, что среди многих вариантов реализации множеств есть и такой, который базируется на применении связанных списков. Вы также знаете, что в стандартной библиотеке C++ есть шаблон list, поэтому решаете им воспользоваться (повторно).</p>
      <p class="calibre2">В частности, вы решаете, что создаваемый вами шаблон Set должен наследовать от list. То есть Set&lt;T&gt; будет наследовать list&lt;T&gt;. В итоге в вашей реализации объект Set будет выступать как объект list. Соответственно, вы объявляете Set следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt; // <em class="calibre5">неправильный </em>способ использования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Set: public std::list&lt;T&gt; {...}; // list для определения Set</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">До сих пор все вроде бы шло хорошо, но, если присмотреться, в код вкралась ошибка. Как объясняется в правиле 32, если D является разновидностью B, то все, что верно для B, должно быть верно также и для D. Однако объект list может содержать дубликаты, поэтому если значение 3051 вставляется в list&lt;int&gt; дважды, то список будет содержать две копии 3051. Напротив, Set не может содержать дубликатов, поэтому, если значение 3051 вставляется в Set&lt;int&gt; дважды, множество будет содержать лишь одну копию данного значения. Следовательно, утверждение, что Set является разновидностью list, ложно: ведь некоторые положения, верные для объектов list, неверны для объектов Set.</p>
      <p class="calibre2">Из-за этого отношение между этими двумя классами не подходит под определение «является», открытое наследование – неправильный способ моделирования этой взаимосязи. Правильный подход основан на понимании того факта, что объект Set может быть <em class="calibre5">реализован посредством</em> объекта list:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt; // правильный способ использования list</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Set { // для определения Set</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool member(const T&amp; item) const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void insert(const T&amp; item);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void remove(const T&amp; item);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t size() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::list&lt;T&gt; rep; // представление множества</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Функции-члены класса Set могут опереться на функциональность, предоставляемую list и другими частями стандартной библиотеки, поэтому их реализацию нетрудно написать, коль скоро вам знакомы основы программирования с применением библиотеки STL:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool Set&lt;T&gt;::member(const T&amp; item) const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return std::find(rep.begin(), rel.end(), item) != rep.end();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void Set&lt;T&gt;::insert(const T&amp; item)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(!member(item)) rep.push_back(item);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void Set&lt;t&gt;::remove(const T&amp; item)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typename std::list&lt;T&gt;::iterator it = // см. в правиле 42</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::find(rep.begin(), rep.end(), item); // информацию о “typename”</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(it != rep.end()) rep.erase(it);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t Set&lt;T&gt;::size() const</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return rep.size();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Эти функции достаточно просты, чтобы стать кандидатами для встраивания, хотя перед принятием окончательного решения стоит еще раз прочитать правило 30.</p>
      <p class="calibre2">Стоит отметить, что интерфейс Set лучше отвечал бы требованиям правила 18 (проектировать интерфейсы так, чтобы их легко было использовать правильно и трудно – неправильно), если бы он следовал соглашениям, принятым для STL-контейнеров, но для этого пришлось бы добавить в класс Set столько кода, что в нем потонула бы основная идея: проиллюстрировать взаимосвязь между Set и list. Поскольку тема настоящего правила – именно эта взаимосвязь, то мы пожертвуем совместимостью с STL ради наглядности. Недостатки интерфейса Set не должны, однако, затенять тот неоспоримый факт, что отношение между классами Set и list – не «является» (как это вначале могло показаться), а «реализовано посредством».</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Семантика композиции кардинально отличается от семантики открытого наследования.</p>
      <p class="calibre2">• В предметной области композиция означает «содержит». В области реализации она означает «реализовано посредством».</p>
    </div>
  </div>

{% endraw %}

