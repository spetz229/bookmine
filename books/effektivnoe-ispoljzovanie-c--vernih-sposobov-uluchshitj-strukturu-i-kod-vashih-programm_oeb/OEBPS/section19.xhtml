---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section18.xhtml
next: OEBPS/section20.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 4: Прежде чем использовать объекты, убедитесь, что они инициализированы</h2>
      </div>
      <p class="calibre2">Отношение C++ к инициализации значений объектов может показаться странным. Например, если вы пишете:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int x;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то в некоторых контекстах переменная x будет гарантированно инициализирована нулем, а в других – нет. Если вы пишете:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Point {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x, y;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point p;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то члены-данные объекта p иногда будут инициализированы (нулями), а иногда – нет. Если вы перешли к C++ от языка, где неинициализированные объекты не могут существовать, обратите на это внимание.</p>
      <p class="calibre2">Чтение неинициализированных значений может быть причиной неопределенного поведения. На некоторых платформах такое простое действие, как доступ к неинициированному значению для чтения, может вызвать аварийную остановку программы. Но чаще вы получите случайный набор битов, который испортит внутреннее состояние объекта, в который они записываются, и в конечном итоге это приведет к необъяснимому поведению программы и длительному поиску ошибки в отладчике.</p>
      <p class="calibre2">Сформулируем правила, которые описывают, когда инициализация объекта гарантируется, а когда нет. К сожалению, эти правила достаточно сложны – на мой взгляд, слишком сложны, чтобы их стоило запоминать. Вообще, если вы работаете с C-частью C++ (см. правило 1) и инициализация может стоить определенных затрат во время исполнения, то не гарантируется, что она произойдет. Это объясняет, почему содержимое массивов (в C-части C++) не обязательно инициализируется, а содержимое вектора (из STL-части C++) инициализируется всегда.</p>
      <p class="calibre2">По-видимому, лучший способ поведения в такой неопределенной ситуации – <em class="calibre5">всегда</em> инициализировать объекты, прежде чем их использовать. Для объектов встроенных типов, не являющихся членами классов, это нужно делать вручную. Например:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int x = 0; // ручная инициализация int</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const char * text = “Строка в стиле C”; // ручная инициализация указателя</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// (см. также правило 3)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">double d; // «инициализация» чтением</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cin &gt;&gt; d; // из входного потока</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Почти во всех остальных случаях ответственность за инициализацию ложится на конструкторы. Правило простое: убедитесь, что все конструкторы инициализируют в объекте всё.</p>
      <p class="calibre2">Этому правилу легко следовать, но важно не путать присваивание с инициализацией. Рассмотрим конструктор класса, представляющего записи в адресной книге:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class PhoneNumber {…}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class ABEntry { // ABEntry = “Address Book Entry”</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ABEntry(const std::string&amp; name, const std::string&amp; address,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const std::list&lt;PhoneNumber&gt;&amp; phones);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string theName;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string theAddress;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::list&lt;PhoneNumber&gt; thePhones;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int numTimesConsulted;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ABEntry(const std::string&amp; name, const std::string&amp; address,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const std::list&lt;PhoneNumber&gt;&amp; phones)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">theName = name; // все это <em class="calibre5">присваивание</em>, а не инициализация</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">theAddress = address;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">thePhones = phones;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">numTimesConsulted = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Да, в результате порождаются объекты ABEntry со значениями, которых вы ожидаете, но это все же не лучший подход. Правила C++ оговаривают, что члены объекта инициируются <em class="calibre5">перед</em> входом в тело конструктора. То есть внутри конструктора ABEntry члены theName, theAddress и thePhones не инициализируются, а им <em class="calibre5">присваиваются</em> значения. Инициализация происходит ранее: когда автоматически вызываются их конструкторы перед входом в тело конструктора ABEntry. Это не касается numTimesConsulted, поскольку этот член относится к встроенному типу. Для него нет никаких гарантий того, что он вообще будет инициализирован перед присваиванием.</p>
      <p class="calibre2">Лучший способ написания конструктора ABEntry – использовать список инициализации членов вместо присваивания:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">ABEntry(const std::string&amp; name, const std::string&amp; address,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const std::list&lt;PhoneNumber&gt;&amp; phones)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:theName(name), // теперь это все – <em class="calibre5">инициализации</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:theAddress(address),</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">thePhones(phones),</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:numTimesConsulted(0)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{} // тело конструктора теперь пусто</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот конструктор дает тот же самый конечный результат, что и предыдущий, но часто оказывается более эффективным. Версия, основанная на присваиваниях, сначала вызывает конструкторы по умолчанию для инициализации theName, theAddress и thePhones, а затем сразу присваивает им новые значения, затирая те, что уже были присвоены в конструкторах по умолчанию. Таким образом, вся работа конструкторов по умолчанию тратится впустую. Подход со списком инициализации членов позволяет избежать этой проблемы, поскольку аргументы в списке инициализации используются в качестве аргументов конструкторов для различных членов-данных. В этом случае theName создается конструктором копирования из name, theAddress – из address, thePhones – из phones. Для большинства типов единственный вызов конструктора копирования более эффективен – иногда <em class="calibre5">намного</em> более эффективен, чем вызов конструкторов по умолчанию с последующим вызовом операторов присваивания.</p>
      <p class="calibre2">Для объектов встроенных типов вроде numTimesConsulted нет разницы по затратам между инициализацией и присваиванием, но для единообразия часто лучше инициировать все посредством списка инициализации членов. Такие списки можно применять даже тогда, когда данные-члены инициализируются конструкторами по умолчанию: просто не передавайте никаких аргументов соответствующему конструктору. Например, если у ABEntry есть конструктор, не принимающий параметров, то он может быть реализован примерно так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">ABEntry()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:theName(), // вызвать конструктор по умолчанию для theName</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:theAddress(), // сделать то же для theAddress и для thePhones;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">thePhones(), // но явно инициализировать нулем numTimesConsulted</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:numTimesConsulted(0)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку компилятор автоматически вызывает конструкторы по умолчанию для данных-членов пользовательских типов, когда для них отсутствуют инициализаторы в списке инициализации членов, некоторые программисты считают приведенный выше код избыточным. Это понятно, но, придерживаясь политики всегда перечислять все данные-члены в списках инициализации, вы избавляете себя от необходимости помнить, какие члены будут инициализированы, если их пропустить, а какие – нет. Например, поскольку numTimesConsulted относится к встроенному типу, то исключение его из списка инициализации может открыть двери неопределенному поведению.</p>
      <p class="calibre2">Иногда список инициализации просто <em class="calibre5">необходимо</em> использовать, даже для встроенных типов. Например, данные-члены, которые являются константами либо ссылками, обязаны быть инициализированы, так как они не могут получить значения посредством присваивания (см. также правило 5). Чтобы избежать необходимости помнить, когда данные-члены должны быть инициализированы в списке инициализации, а когда это не обязательно, проще делать это <em class="calibre5">всегда.</em> Иногда это обязательно, а часто – более эффективно, чем присваивание.</p>
      <p class="calibre2">Во многих классах есть несколько конструкторов, и каждый конструктор имеет свой собственный список инициализации. Если у класса много данных-членов или базовых классов, то наличие большого числа списков инициализации порождает нежелательное дублирование кода (в списках) и тоску (у программистов). В таких случаях имеет смысл опустить в списках инициализации те данные-члены, для которых присваивание работает так же, как настоящая инициализация, переместив инициализацию в одну (обычно закрытую) функцию, которую вызывают все конструкторы. Этот подход может быть особенно полезен, если начальные значения должны быть загружены из файла или базы данных. Однако, вообще говоря, инициализация членов посредством списков инициализации более предпочтительна, чем псевдоинициализация присваиванием.</p>
      <p class="calibre2">Один из аспектов C++, на который можно положиться, – это порядок, в котором инициализируются данные объектов. Этот порядок всегда один и тот же: базовые классы инициализируются раньше производных (см. также правило 12), а внутри класса члены-данные инициализируются в том порядке, в котором объявлены. Например, в классе ABEntry член theName всегда будет инициализирован первым, theAddress – вторым, thePhones – третьим, а numTimesConsulted – последним. Это верно даже в случае, если в списке инициализации членов они перечислены в другом порядке (что, к сожалению, не запрещено). Чтобы не вводить в заблуждение человека, читающего вашу программу, и во избежание ошибок непонятного происхождения, всегда перечисляйте данные-члены в списке инициализации в том порядке, в котором они объявлены в классе.</p>
      <p class="calibre2">Позаботившись о явной инициализации объектов встроенных типов, которые не являются членами классов, и обеспечив правильную инициализацию базовых классов и их данных-членов посредством списков инициализации, у вас останется только одна вещь, о чем нужно будет подумать. Речь идет о порядке инициализации нелокальных статических объектов, объявленных в разных единицах трансляции.</p>
      <p class="calibre2">Отнесемся к этой фразе со всем вниманием.</p>
      <p class="calibre2">
        <em class="calibre5">Статический объект</em> существует от момента, когда был сконструирован, и до конца работы программы. Объекты, размещенные в стеке и в «куче», к статическим не относятся. Статическими являются глобальные объекты, объекты, объявленные в области действия пространства имен, объекты, объявленные с ключевым словом static внутри классов и функций, а также в области действия отдельного файла с исходным текстом. Статические объекты, объявленные внутри функций, известны как <em class="calibre5">локальные статические объекты</em> (поскольку они локальны по отношению к функции), а все прочие называют <em class="calibre5">нелокальными статическими объектами.</em> Статические объекты автоматически уничтожаются при завершении программы, то есть при выходе из функции main() автоматически вызываются их деструкторы.</p>
      <p class="calibre2">
        <em class="calibre5">Единица трансляции (translation unit)</em> – это исходный код, который порождает отдельный объектный файл. Обычно это один исходный файл плюс все файлы, включенные в него директивой #include.</p>
      <p class="calibre2">Проблема возникает, когда есть, по крайней мере, два отдельно компилируемых исходных файла, каждый из которых содержит, по крайней мере, один нелокальный статический объект (то есть глобальный объект либо объявленный в области действия пространства имен, класса или файла). Суть ее в том, что если инициализация нелокального статического объекта происходит в одной единице трансляции, а используется он в другой, то такой объект может оказаться неинициализированным в момент использования, поскольку <em class="calibre5">относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</em></p>
      <p class="calibre2">Рассмотрим пример. Предположим, у вас есть класс FileSystem, который делает файлы из Internet неотличимыми от локальных. Поскольку ваш класс представляет мир как единую файловую систему, вы могли бы создать в глобальной области действия или в пространстве имен соответствующий ей специальный объект:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class FileSystem { // из вашей библиотеки</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t numDisks() const; // одна из многих функций-членов</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">extern FileSystem tfs; // объект для использования клиентами</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// “tfs” = “the file system”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Класс FileSystem определенно не тривиален, поэтому использование объекта theFileSystem до того, как он будет сконструирован, приведет к катастрофическим последствиям.</p>
      <p class="calibre2">Теперь предположим, что некий пользователь создает класс, описывающий каталоги файловой системы. Естественно, его класс будет использовать объект theFileSystem:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Directory { // создан пользователем</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Directory( params );</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Directory::Directory( params )</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t disks = tfs.numDisks(); // использование объекта tfs</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Далее предположим, что пользователь решает создать отдельный глобальный объект класса Directory, представляющий каталог для временных файлов:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Directory tempDir( params ); // каталог для временных файлов</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь проблема порядка инициализации становится очевидной: если объект tfs не инициализирован раньше, чем tempDir, то конструктор tempDir попытается использовать tfs до его инициализации. Но tfs и tempDir были созданы разными людьми в разное время и находятся в разных исходных файлах – это нелокальные статические объекты, определенные в разных единицах трансляции. Как вы можете быть уверены, что tfs будет инициализирован раньше, чем tempDir?</p>
      <p class="calibre2">Да никак! Еще раз повторю: <em class="calibre5">относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</em> На то есть своя причина. Определить «правильный» порядок инициализации нелокальных статических объектов трудно. Очень трудно. Неразрешимо трудно. В наиболее общем случае – при наличии многих единиц трансляции и нелокальных статических объектов, сгенерированных путем неявной конкретизации шаблонов (которые и сами могут быть результатом неявной конкретизации других шаблонов) – не только невозможно определить правильный порядок инициализации, но обычно даже не стоит искать частные случаи, когда этот порядок в принципе определить можно.</p>
      <p class="calibre2">К счастью, небольшое изменение в проекте программы позволяет полностью устранить эту проблему. Нужно лишь переместить каждый нелокальный статический объект в отдельную функцию, в которой он будет объявлен статическим. Эти функции возвращают ссылки на объекты, которые в них содержатся. Клиенты затем вызывают функции вместо непосредственного обращения к объектам. Другими словами, нелокальные статические объекты заменяются <em class="calibre5">локальными</em> статическими объектами (знакомые с паттернами проектирования легко узнают в этом описании типичную реализацию паттерна Singleton).</p>
      <p class="calibre2">Этот подход основан на том, что C++ гарантирует: локальные статические объекты инициализируются в первый раз, когда определение объекта встречается при вызове этой функции. Поэтому если вы замените прямой доступ к нелокальным статическим объектам вызовом функций, возвращающих ссылки на расположенные внутри них локальные статические объекты, то можете быть уверены, что ссылки, возвращаемые из функций, будут ссылаться на инициализированные объекты. Дополнительное преимущество заключается в том, что если вы никогда не вызываете функцию, эмулирующую нелокальный статический объект, то и не придется платить за создание и уничтожение объекта, чего не скажешь о реальных нелокальных статических объектах.</p>
      <p class="calibre2">Вот как этот прием применяется к объектам tfs и tempDir:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class FileSystem {...}; // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">FileSystem&amp; tfs() // эта функция заменяет объект tfs, она может</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // быть статической в классе FileSystem</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static FileSystem fs; // определение и инициализация локального</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// статического объекта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return fs; // возврат ссылки на него</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Directory {...}; // как раньше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Directory::Directory( <em class="calibre5">params </em>) // как раньше, но вместо ссылки на tfs</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // вызов tfs()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t disks = tfs().numDisks();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Directory&amp; tempDir() // эта функция заменяет объект tempDir,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // может быть статической в классе Directory</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static Directory td; // определение/инициализация локального</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// статического объекта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return td; // возврат ссылки на него</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Клиенты работают с этой модифицированной программой так же, как раньше, за исключением того, что вместо tfs и tempDir они теперь обращаются к tfs() и tempDir(). Иными словами, используют ссылки на объекты, возвращенные функциями, вместо использования самих объектов.</p>
      <p class="calibre2">Функции, которые в соответствии с данной схемой возвращают ссылки, всегда просты: определить и инициализировать локальный статический объект в строке 1 и вернуть его в строке 2. В связи с этим у вас может возникнуть искушение объявить их встроенными, особенно, если они часто вызываются (см. правило 30). С другой стороны, тот факт, что эти функции содержат в себе статические объекты, усложняет их применение в многопоточных системах. Но тут никуда не деться: неконстантные статические объекты любого рода – локальные или нелокальные – представляют проблему в случае наличия в программе нескольких потоков. Решить ее можно, например, вызвав самостоятельно все функции, возвращающие ссылки, на этапе запуска программы, когда еще работает только один поток. Это исключит неопределенность в ходе инициализации.</p>
      <p class="calibre2">Конечно, применимость идеи функций, возвращающих ссылки, для предотвращения проблем, связанных с порядком инициализации, зависит от того, существует ли в принципе разумный порядок инициализации ваших объектов. Если вы напишете код, в котором объект A должен быть инициализирован прежде, чем объект B, и одновременно сделаете инициализацию A зависимой от инициализации B, то вас ждут проблемы – и поделом! Если, однако, вы будете избегать таких патологических ситуаций, то описанная схема сослужит вам добрую службу, по крайней мере, в однопоточных приложениях.</p>
      <p class="calibre2">Таким образом, чтобы избежать использования объектов до их инициализации, вам следует сделать три вещи. Первое: вручную инициализировать не являющиеся членами объекты встроенных типов. Второе: использовать списки инициализации членов для всех частей объекта. И наконец, третье: обойти за счет правильного проектирования проблему негарантированного порядка инициализации нелокальных статических объектов, определенных в разных единицах трансляции.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Всегда вручную инициализировать объекты встроенных типов, поскольку C++ делает это, только не всегда.</p>
      <p class="calibre2">• В конструкторе отдавать предпочтение применению списков инициализации членов перед прямым присваиванием значений в теле конструктора. Перечисляйте данные-члены в списке инициализации в том же порядке, в каком они объявлены в классе.</p>
      <p class="calibre2">• Избегайте проблем с порядком инициализации в разных единицах трансляции, заменяя нелокальные статические объекты локальными статическими объектами.</p>
    </div>
  </div>

{% endraw %}

