---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section85.xhtml
next: OEBPS/section87.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 51: Придерживайтесь принятых соглашений при написании new и delete</h2>
      </div>
      <p class="calibre2">В правиле 50 объясняется, зачем могут понадобиться собственные версии операторов new и delete, но ничего не говорится о соглашениях, которых следует придерживаться при их написании. Следовать этим соглашениям не так уж сложно, но некоторые из них противоречат интуиции, поэтому знать о них необходимо.</p>
      <p class="calibre2">Начнем с оператора new. От отвечающего стандарту оператора new требуется, чтобы он возвращал правильное значение, вызывал обработчика new, когда запрошенную память не удается выделить (см. правило 49), и правильно обрабатывал запросы на выделения нуля байтов. Кроме того, надо принять меры к тому, чтобы нечаянно не скрыть «нормальную» форму new, хотя это в большей мере касается интерфейса класса, чем требований реализации (см. правило 52).</p>
      <p class="calibre2">Обеспечить правильность возвращаемого оператором new значения легко. Если вы можете выделить запрошенную память, то возвращаете указатель на нее. Если не можете, то следуете рекомендациям из правила 49 и возбуждаете исключение типа bad_alloc.</p>
      <p class="calibre2">Однако все не так просто, потому что оператор new пытается выделить память не один раз, и после каждой неудачи вызывает функцию-обработчик new. Предполагается, что это сможет что-то сделать для освобождения некоторого объема памяти. Только тогда, когда указатель на обработчик new равен нулю, оператор new возбуждает исключение.</p>
      <p class="calibre2">Забавно, но C++ требует, чтобы оператор new возвращал корректный указатель даже тогда, когда запрошено 0 байтов памяти. (Такое странное поведение упрощает реализацию некоторых вещей в других местах языка.) С учетом этого случая псевдокод для оператора new (нечлена класса) выглядит так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void *operator new(std::size_t size) throw(std::bad_alloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // ваш оператор new может принимать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using namespace std; // дополнительные параметры</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (size == 0) { // обработать запрос на 0 байтов,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">size = 1; // считая, что нужно выделить 1 байт</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">while(true) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">попытка выделить size байтов;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(<em class="calibre5">выделить удалось</em>)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return (<em class="calibre5">указатель на память</em>);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// выделить память не удалось; проверить, установлена ли</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// функция-обработчик new (см. ниже)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">new_handler globalHandler = set_new_handler(0);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">set_new_handler(globalHandler);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(globalHandler) (*globalHandler)();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else throw std::bad_alloc();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Трактовка запроса на 0 байтов так, как если бы запрашивался 1 байт, выглядит сомнительно, но это просто, это корректно, это работает, к тому же на сколько часто вы собираетесь запрашивать 0 байтов?</p>
      <p class="calibre2">Вам также может не понравиться то место в псевдокоде, где указатель на функцию-обработчик устанавливается в нуль, а затем восстанавливается его прежнее значение. К сожалению, нет способа непосредственно получить указатель на текущий обработчик new, поэтому приходится вызывать set_new_handler, чтобы получить его текущее значение. Грубо, но тоже эффективно, по крайней мере, в однопоточной программе. В многопоточной среде, возможно, понадобится какой-то механизм синхронизации для безопасного манипулирования (глобальными) структурами данных, связанными с функцией-обработчиком new.</p>
      <p class="calibre2">В правиле 49 отмечено, что оператор new содержит бесконечный цикл, и в приведенном выше коде этот цикл присутствует: «while(true)». Единственный способ выйти из цикла – успешно выделить память либо выполнить в функции-обработчике одно из описанных в правиле 49 действий: сделать доступной больше памяти, установить другой обработчик, убрать текущий обработчик, возбудить исключение типа, производного от bad_alloc, либо не возвращать управления вовсе. Теперь вам должно быть ясно, почему обработчик new должен вести себя подобным образом. Если он нарушит это соглашение, то цикл внутри оператора new никогда не завершится.</p>
      <p class="calibre2">Многие не понимают, что функция-член operator new наследуется производными классами. Это может привести к некоторым интересным осложнениям. Заметьте, что в приведенном псевдокоде operator new производится попытка выделить size байтов (если только size не равно нулю). Естественно, ведь size – это аргумент, переданный функции. Однако, как объясняется в правиле 50, одной из причин написания специального менеджера памяти является оптимизация размещения объектов <em class="calibre5">определенного</em> класса, но не любых его подклассов. Иными словами, если в классе X определен оператор new, то предполагается, что он рассчитан на объекты размера sizeof(X) – ни больше, ни меньше. Из-за наследования, однако, появляется возможность вызвать оператор new базового класса, чтобы выделить память для объекта производного класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size) throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base // в подклассе не объявлен operator new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Derived *p = new Derived; // вызывается Base::operator new!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если определенный в классе Base оператор new не был спроектирован с учетом этой проблемы (а такая вероятность есть), то для корректной работы в случае, когда поступил запрос на выделение памяти «неправильного» размера, лучше всего обратиться к стандартному оператору new:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void *Base::operator new(std::size_t) throw(std::bad_alloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(size != sizeof(Base)) // если size «неправильный»</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return ::operator new(size); // вызвать стандартный оператор new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// для обработки запроса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // в противном случае обработать запрос</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// здесь</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Я слышу возгласы: «Подождите! Вы забыли проверить патологический случай с нулевым размером!» На самом деле нет. Проверка присутствует, просто она является частью сравнения с sizeof(Base). C++ иногда предъявляется странные требования, например все автономные объекты должны иметь ненулевой размер (см. правило 39). По определению, sizeof(Base) никогда не может вернуть нуль, поэтому если size равно нулю, то запрос будет переадесован::operator new, и обязанность правильно обработать запрос возлагается на него.</p>
      <p class="calibre2">Если вы хотите управлять распределением памяти для массивов на уровне класса, то нужно будет реализовать оператор new[] – специально для массивов. (Эта функция обычно называется «new для массивов», потому что трудно представить, как надо произносить «operator new[]»). Если вы решите написать operator new[], то помните, что она должна лишь выделить блок неформатированной памяти. Вы не можете ничего делать с еще не существующими объектами в этом массиве. Фактически вы даже не можете определить, сколько объектов будет в этом массиве. Во-первых, вы не знаете размер объекта. А ведь из-за наследования может быть вызван оператор new[] базового класса для выделения памяти под массив объектов производного класса, которые обычно больше объектов базового класса. Поэтому вы не можете предполагать внутри Base::operator new[], что размер каждого объекта равен sizeof(Base), а значит, нельзя предполагать, что общее количество объектов в массиве будет равно <em class="calibre5">(запрошенное число</em> байmов)/sizeof(Base). Во-вторых, параметр size_t, переданный оператору new[], может соответствовать большему объему памяти, чем займут сами объекты, потому что, как объясняется в правиле 16, в динамически выделенных массивах может резервироваться место для хранения числа элементов массива.</p>
      <p class="calibre2">Это все соглашения, которым вы должны следовать при написании оператора new[]. Что касается оператора delete, то с ним все проще. Почти все, что вам нужно знать, – это то, что C++ гарантирует безопасность освобождения памяти по нулевому адресу, поэтому и вы должны предоставить такую гарантию. Вот псевдокод для оператора delete, не являющегося членом класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void operator delete(void *rawMemory) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(rawMemory == 0) return; // ничего не делать, если передан нулевой</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// указатель</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">освободить память, на которую указывает rawMemory</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Версия этой функции, являющаяся членом класса, также проста, за исключением того, что нужно проверить размер того, что вы собираетесь освобождать. Предполагая, что оператор new, определенный в классе, передает запрос на выделение «неправильного» количества байтов глобальному::operator new, вы также должны передать информацию о «неверном» размере функции::operator delete:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Base { // то же, что и раньше, но добавлено</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // объявление operator delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size) throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *rawMemory, std::size_t size) throw();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void Base::operator delete(void *rawMemory, std::size_t size) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(rawMemory == 0) return; // проверка на нулевой указатель</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(size != sizeof(Base)) { // если размер «неверный»,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">::operator delete(rawMemory); // вызвать стандартный оператор</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return; // delete для обработки запроса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">освободить память, на которую указывает rawMemory</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Интересно, что значение типа size_t, которое C++ передает оператору delete, может быть неправильным, если удаляется объект, производный от класса, в котором нет виртуального деструктора. Одного этого уже достаточно, чтобы требовать от базового класса наличия виртуального деструктора, но в правиле 7 описана и другая, более существенная причина. Пока просто отметьте, что если вы опустили виртуальный деструктор в базовом классе, то функция operator delete может работать неправильно.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Оператор new должен содержать бесконечный цикл, который пытается выделить память, должен вызывать функцию-обработчик new, если не удается удовлетворить запрос на выделение памяти, и должен обрабатывать запрос на выделение нуля байтов. Версии оператора new уровня класса должны обрабатывать запросы на выделение блоков большего размера, чем ожидается.</p>
      <p class="calibre2">• Оператор delete не должен ничего делать при передаче ему нулевого указателя. Версии оператора delete уровня класса должны обрабатывать запросы на освобождение блоков, которые больше, чем ожидается.</p>
    </div>
  </div>

{% endraw %}

