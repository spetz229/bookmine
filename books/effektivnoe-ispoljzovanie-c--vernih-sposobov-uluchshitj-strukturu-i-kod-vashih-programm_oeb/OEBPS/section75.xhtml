---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section74.xhtml
next: OEBPS/section76.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 42: Усвойте оба значения ключевого слова typename</h2>
      </div>
      <p class="calibre2">
        <em class="calibre5">Вопрос: какая разница между «class» и «typename» в следующем объявлении шаблона:</em>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;class T&gt; class Widget; // использует “class”</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename T&gt; class Widget; // использует “typename”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Ответ: никакой. Когда в шаблоне объявляется параметр типа, class и type-name означают абсолютно одно и то же. Некоторые программисты предпочитают всегда писать class, потому что это слово короче. Другие (включая меня) предпочитают typename, поскольку оно говорит о том, что параметром не обязательно должен быть тип класса. Некоторые разработчики используют typename, когда допускается любой тип, и резервируют слово class для случаев, когда допускается только тип, определяемый пользователем. Но с точки зрения C++, class и typename в объявлении параметра шаблона означают в точности одно и то же.</p>
      <p class="calibre2">Однако не всегда в C++ ключевые слова class и typename эквивалентны. Иногда вы обязаны использовать typename. Чтобы понять – когда именно, поговорим о двух типах имен, на которые можно ссылаться в шаблоне.</p>
      <p class="calibre2">Предположим, что у нас есть шаблон функции, принимающей в качестве параметра совместимый с STL-контейнер, содержащий объекты, которые могут быть присвоены величинам типа int. Далее предположим, что эта функция просто печатает значение второго элемента. Это не очень содержательная функция, которая к тому же и реализована по-дурацки. Как я уже говорил, она даже не будет компилироваться, но забудьте об этом на время – все это не так глупо, как кажется:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename C&gt; // печатает второй</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void print2nd(const C&amp; container) // элемент контейнера</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // <em class="calibre5">это некорректный C++!</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (container.size() &gt;= 2) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">C::const_iterator iter(container.begin()); // получить итератор,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// указывающий на первый</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// элемент</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++iter; // сместиться на второй</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// элемент</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int value = *iter; // скопировать элемент в int</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; value; // напечатать int</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Я выделил в этой функции две локальные переменные – iter и value. Типом iter является C::const_iterator – он зависит от параметра шаблона C. Имена в шаблоне, которые зависят от параметра шаблона, называются <em class="calibre5">зависимыми именами.</em> Зависимое имя внутри класса я буду называть <em class="calibre5">вложенным зависимым именем.</em> C::const_iterator – это вложенное зависимое имя. Фактически это даже <em class="calibre5">вложенное зависимое имя типа,</em> то есть вложенное имя, которое относится к типу.</p>
      <p class="calibre2">Другая локальная переменная в print2nd – value – имеет тип int, а int – это имя, которое не зависит ни от какого параметра шаблона. Такие имена называются <em class="calibre5">независимыми.</em></p>
      <p class="calibre2">Вложенные зависимые имена могут стать причиной затруднений на этапе синтаксического анализа исходного текста компилятором. Например, предположим, что мы реализуем print2nd еще более глупо, написав в начале такой код:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename C&gt; // печатает второй элемент контейнера</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void print2nd(const C&amp; container) // <em class="calibre5">это некорректный C++!</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">C::const_iterator *x;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Выглядит так, будто мы объявили x как локальную переменную – указатель на C::const_iterator. Но это только видимость, поскольку мы «знаем», что C::const_iterator является типом. А что, если в классе C есть статический член данных по имени const_iterator и что, если x будет именем глобальной переменной? В этом случае приведенный код не будет объявлять локальную переменную, а окажется умножением C::const_iterator на x! Звучит невероятно, но это <em class="calibre5">возможно,</em> и авторы синтаксических анализаторов исходного кода на C++ должны позаботиться обо всех возможных вариантах входных данных, даже самых сумасшедших.</p>
      <p class="calibre2">Пока о C ничего не известно, мы не можем узнать, является ли C::const_iterator типом или нет, а во время разбора шаблона print2nd компилятор ничего о C не знает. В C++ предусмотрено правило, разрешающее эту неопределенность: если синтаксический анализатор встречает вложенное зависимое имя в шаблоне, он предполагает, что это <em class="calibre5">не</em> имя типа, если только вы не укажете это явно. По умолчанию вложенные зависимые имена <em class="calibre5">не</em> являются типами. Есть исключение из этого правила, о котором я расскажу чуть ниже.</p>
      <p class="calibre2">Имея это в виду, посмотрите опять на начало print2nd:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename C&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void print2nd(const C&amp; container)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (container.size() &gt;= 2) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">C::const_iterator iter(container.begin()); // предполагается, что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // это <em class="calibre5">не </em>имя типа</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь должно быть ясно, почему это некорректный C++. Объявление iter имеет смысл только в случае, если C::const_iterator является типом, но мы не сообщили C++ об этом, потому C++ предполагает, что это не так. Чтобы исправить ситуацию, мы должны сообщить C++, что C::const_iterator – это тип. Для этого мы помещаем ключевое слово typename непосредственно перед ним:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename C&gt; // это корректный С++</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void print2nd(const C&amp; container)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (container.size() &gt;= 2) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typename C::const_iterator iter(container.begin());</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Общее правило просто: всякий раз, когда вы обращаетесь к вложенному зависимому имени в шаблоне, вы должны предварить его словом typename (скоро я опишу исключение).</p>
      <p class="calibre2">Слово typename следует использовать для идентификации только вложенных зависимых имен типов; для других имен оно не применяется. Вот пример шаблона функции, который принимает и контейнер, и итератор для этого контейнера:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename C&gt; // допускается typename (как и “class”)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void f(const C&amp; container, // typename не допускается</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typename C::iterator iter); // typename требуется</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">C не является вложенным зависимым именем типа (оно не вложено внутрь чего-либо, зависимого от параметра шаблона), поэтому его не нужно предварять словом typename при объявлении контейнера, но C::iterator – это вложенное зависимое имя типа, поэтому перед ним следует поставить typename.</p>
      <p class="calibre2">Из правила «typename должно предварять вложенные зависимые имена типов» есть исключение: typename не должно предварять вложенные зависимые имена типов в списке базовых классов или в идентификаторе базового класса в списке инициализации членов. Например:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base&lt;T&gt;::Nested { // список базовых классов:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // <em class="calibre5">typename не допускается</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit Derived(int x)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:Base&lt;T&gt;::Nested(x) // идентификатор базового класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // в списке инициализации членов:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// <em class="calibre5">typename не допускается</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typename Base&lt;T&gt;::Nested temp; // использование вложенного</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // зависимого имени типа не как</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // идентификатора базового</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // класса в списке инициализации</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // членов: <em class="calibre5">typename необходимо</em></code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Такая несогласованность несколько раздражает, но по мере приобретения опыта вы перестанете ее замечать.</p>
      <p class="calibre2">Рассмотрим еще один пример использования typename, потому нечто подобное можно встретить в реальном коде. Предположим, что мы пишем шаблон функции, которая принимает итератор, и хотим сделать локальную копию – temp – объекта, на который этот итератор указывает. Это можно сделать примерно так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename IterT&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void workWithIterator(IterT iter)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Не пугайтесь при виде выражения std::iterator_traits&lt;IterT&gt;::value_type. Здесь просто используются стандартные классы-характеристики (traits) (см. правило 47). Так, на C++ говорят «тип того, на что указывает объект типа *IterT». В этом предложении объявлена локальная переменная (temp) того же типа, что и объекты, на которые указывает IterT, а затем она инициализирована значением, на которое указывает iter. Если IterT будет типа vector&lt;int&gt;::iterator, то temp будет иметь тип int. Если же IterT будет типа vector&lt;string&gt;::iterator, то temp будет иметь тип string. Поскольку std::iterator_traits&lt;IterT&gt;::value_type – это вложенное зависимое имя типа (value_type вложено внутрь iterator_traits&lt;IterT&gt;, а IterT – параметр шаблона), мы должны предварить его словом typename.</p>
      <p class="calibre2">Если вам неприятно даже видеть выражение std::iterator_traits&lt;IterT&gt;::value_type, представьте, каково набирать его на клавиатуре. Если вы, как и большинство программистов, считаете, что набрать такое более одного раза немыслимо, определите псевдоним для этого типа посредством typedef. Для имен членов классов-характеристик, к каковым относится value_type, (см. в правиле 47 информацию о классах-характеристиках), принято соглашение, согласно которому имя typedef должно совпадать с именем члена. Таким образом, определение локального typedef обычно выглядит так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename IterT&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void workWithIterator(IterT iter)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">value_type temp(*iter);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Многих программистов соседство typedef и typename поначалу раздражает, но это логическое следствие из правила обращения к вложенным зависимым именам типов. Вы скоро привыкнете. К тому же у вас есть на то веские причины. Сколько раз вы готовы напечатать std::iterator_traits&lt;IterT&gt;::value_type?</p>
      <p class="calibre2">В качестве заключительного замечания я должен упомянуть, что не все компиляторы настаивают на строгом выполнении правил, касающихся ключевого слова typename. Некоторые принимают код, в котором typename требуется, но пропущено; некоторые принимают код, где typename присутствует, но не допускается; и некоторые (обычно это касается старых компиляторов) отвергают typename даже там, где оно необходимо. Это значит, что взаимосвязи между typename и вложенными зависимыми имен типов могут стать причиной некоторых не очень серьезных ошибок при переносе программ на другую платформу.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• В объявлениях параметров шаблона ключевые слова class и typename взаимозаменяемы.</p>
      <p class="calibre2">• Используйте typename для идентификации вложенных зависимых имен типов, если они не встречаются в списке базовых классов или в качестве идентификатора базового класса в списках инициализации членов.</p>
    </div>
  </div>

{% endraw %}

