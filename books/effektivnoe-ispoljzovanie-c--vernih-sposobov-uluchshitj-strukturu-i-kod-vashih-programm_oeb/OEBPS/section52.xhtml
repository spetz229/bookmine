---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section51.xhtml
next: OEBPS/section53.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 29: Стремитесь, чтобы программа была безопасна относительно исключений</h2>
      </div>
      <p class="calibre2">Безопасность исключений в чем-то подобна беременности… но пока отложим эту мысль в сторонку. Нельзя всерьез говорить о репродуктивной функции, пока не завершился этап ухаживания.</p>
      <p class="calibre2">Предположим, что у нас есть класс, представляющий меню с фоновыми картинками в графическом интерфейсе пользователя. Этот класс предназначен для использования в многопоточной среде, поэтому он включает мьютекс для синхронизации доступа:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class PrettyMenu {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void changeBackground(std::istream&amp; imgSrc); // сменить фоновую</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // картинку</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Mutex mutex; // мьютекс объекта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Image *bgImage; // текущая фоновая картинка</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int imageChanges; // сколько раз картинка менялась</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Рассмотрим следующую возможную реализацию функции-члена change-Background:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">lock(&amp;mutex); // захватить мьютекс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete bgImage; // избавиться от старой картинки</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++imageChanges; // обновить счетчик изменений картинки</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bgImage = new Image(imgSrc); // установить новый фон</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">unlock(&amp;mutex); // освободить мьютекс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">С точки зрения безопасности исключений, эта функция настолько плоха, насколько вообще возможно. К безопасности исключений предъявляется два требования, и она не удовлетворяет ни одному из них.</p>
      <p class="calibre2">Когда возбуждается исключение, то безопасная относительно исключений функция:</p>
      <p class="calibre2">• <strong class="calibre4">Не допускает утечки ресурсов.</strong> Приведенный код не проходит этот тест, потому что если выражение «new Image(imgSrc)» возбудит исключение, то вызов unlock никогда не выполнится, и мьютекс окажется захваченным навсегда.</p>
      <p class="calibre2">• <strong class="calibre4">Не допускает повреждения структур данных.</strong> Если «new Image(imgSrc)» возбудит исключение, в bgImage останется указатель на удаленный объект. Кроме того, счетчик imageChanges увеличивается, несмотря на то что новая картинка не установлена. (С другой стороны, старая картинка уже полностью удалена, так что трудно сделать вид, будто ничего не изменилось.)</p>
      <p class="calibre2">Справиться с утечкой ресурсов легко – в правиле 13 объяснено, как пользоваться объектами, управляющими ресурсами, а в правиле 14 представлен класс Lock, гарантирующий своеременное освобождение мьютексов:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Lock ml(mutex); // из правила 14: захватить мьютекс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// и гарантировать его последующее освобождение</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete bgImage;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++imageChanges;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bgImage = new Image(imgSrc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Одним из преимуществ классов для управления ресурсами, подобных Lock, является то, что обычно они уменьшают размер функций. Заметили, что вызов unlock уже не нужен? Общее правило гласит: чем меньше кода, тем лучше, потому что меньше возможностей для ошибок и меньше путаницы при внесении изменений.</p>
      <p class="calibre2">От утечки ресурсов перейдем к проблеме возможного повреждения данных. Здесь у нас есть выбор, но прежде чем его сделать, нужно уточнить терминологию.</p>
      <p class="calibre2">Безопасные относительно исключений функции предоставляют одну из трех гарантий.</p>
      <p class="calibre2">• Функции, предоставляющие <strong class="calibre4">базовую гарантию,</strong> обещают, что если исключение будет возбуждено, то все в программе остается в корректном состоянии. Никакие объекты или структуры данных не повреждены, и все объекты находятся в непротиворечивом состоянии (например, все инварианты классов не нарушены). Однако точное состояние программы может быть непредсказуемо. Например, мы можем написать функцию change-Background так, что при возникновении исключения объект PrettyMenu сохранит старую фоновую картинку либо у него будет какой-то фон по умолчанию, но пользователи не могут заранее знать, какой. (Чтобы выяснить это, им придется вызвать какую-то функцию-член, которая сообщит, какая сейчас используется картинка.)</p>
      <p class="calibre2">• Функции, предоставляющие <strong class="calibre4">строгую гарантию,</strong> обещают, что если исключение будет возбуждено, то состояние программы не изменится. Вызов такой функции является атомарным; если он завершился успешно, то все запланированные действия выполнены до конца, если же нет, то программа останется в таком состоянии, как будто функция никогда не вызывалась.</p>
      <p class="calibre2">Работать с функциями, представляющими такую гарантию, проще, чем с функциями, которые дают только базовую гарантию, потому что после их вызова может быть только два состояния программы: то, которое ожидается в результате ее успешного завершения, и то, которое было до ее вызова. Напротив, если исключение возникает в функции, представляющей только базовую гарантию, то программа может оказаться в <em class="calibre5">любом</em> корректном состоянии.</p>
      <p class="calibre2">• Функции, предоставляющие <strong class="calibre4">гарантию отсутствия исключений,</strong> обещают никогда не возбуждать исключений, потому что всегда делают то, что должны делать. Все операции над встроенными типами (например, целыми, указателями и т. п.) обеспечивают такую гарантию. Это основной строительный блок безопасного относительно исключений кода. Разумно предположить, что функции с пустой спецификацией исключений не возбуждают их, но это не всегда так. Например, рассмотрим следующую функцию:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int doSomething() throw(); // обратите внимание на пустую</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// спецификацию исключений</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это объявление не говорит о том, что doSomething никогда не возбуждает исключений. Утверждается лишь, что <em class="calibre5">если</em> doSomething возбудит исключение, значит, произошла серьезная ошибка и должна быть вызвана функция unexpected<a id="n_3_back" href="section98.xhtml#n_3" class="calibre6">[3]</a>. Фактически doSomething может вообще не представлять никаких гарантий относительно исключений. Объявление функции (включающее ее спецификацию исключений) ничего не сообщает относительно того, является ли она корректной, переносима, эффективной, какие гарантии безопасности исключений она предоставляет и предоставляет ли их вообще. Все эти характеристики определяются реализацией функции, а не ее объявлением.</p>
      <p class="calibre2">Безопасный относительно исключений код должен представлять одну из трех описанных гарантий. Если он этого не делает, он не является безопасным. Выбор, таким образом, в том, чтобы определить, какой тип гарантии должна представлять каждая из написанных вами функций. Если не считать унаследованный код, небезопасный относительно исключений (об этом мы поговорим далее в настоящем правиле), то отсутствие гарантий допустимо лишь, если в результате анализа требований было решено, что приложение просто обязано допускать утечку ресурсов и работать с поврежденными структурами данных.</p>
      <p class="calibre2">Вообще говоря, нужно стремиться предоставить максимально строгие гарантии. С точки зрения безопасности исключений функции, не возбуждающие исключений, чудесны, но очень трудно, не оставаясь в рамках языка C, обойтись без вызова функций, возбуждающих исключения. Любой класс, в котором используется динамическое распределение памяти (например, STL-контейнеры), может возбуждать исключение bad_alloc, когда не удается найти достаточного объема свободной памяти (см. правило 49). Предоставляйте гарантии отсутствия исключений, когда можете, но для большинства функций есть только выбор между базовой и строгой гарантией.</p>
      <p class="calibre2">Для функции changeBackground предоставить <em class="calibre5">почти</em> строгую гарантию нетрудно. Во-первых, измените тип данных bgImage в классе PrettyMenu со встроенного указателя *Image на один из «интеллектуальных» управляющих ресурсами указателей, описанных в правиле 13. Откровенно говоря, это в любом случае неплохо, поскольку позволяет избежать утечек ресурсов. Тот факт, что это заодно помогает обеспечить строгую гарантию безопасности исключений, просто подтверждает приведенные в правиле 13 аргументы в пользу применения объектов (наподобие интеллектуальных указателей) для управления ресурсами. Ниже я воспользовался классом tr1::shared_ptr, потому что он ведет себя более естественно при копировании, чем auto_ptr.</p>
      <p class="calibre2">Во-вторых, нужно изменить порядок предложений в функции changeBackground так, чтобы значение счетчика imageChanges не увеличивалось до тех пор, пока картинка не будет заменена. Общее правило таково: помечайте в объекте, что произошло некоторое изменение, только после того, как это изменение действительно выполнено.</p>
      <p class="calibre2">Вот что получается в результате:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class PrettyMenu {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Image&gt; bgImage;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Lock ml(mutex);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">BgImage.reset(new Image(imgSrc)); // заменить внутренний указатель</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// bgImage результатом выражения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// “new Image”</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++imageChanges;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Отметим, что больше нет необходимости вручную удалять старую картинку, потому что это делает «интеллектуальный» указатель. Более того, удаление происходит только в том случае, если новая картинка успешно создана. Точнее говоря, функция tr1::shared_ptr::reset будет вызвана, только в том случае, когда ее параметр (результат вычисления «new Image(imgSrc)») успешно создан. Оператор delete используется только внутри вызова reset, поэтому если функция не получает управления, то и delete не вызывается. Отметим также, что использование объекта (tr1::shared_ptr) для управления ресурсом (динамически выделенным объектом Image) ко всему прочему уменьшает размер функции changeBackground.</p>
      <p class="calibre2">Как я сказал, эти два изменения позволяют changeBackground предоставлять <em class="calibre5">почти</em> строгую гарантию безопасности исключений. Так чего же не хватает? Дело в параметре imgSrc. Если конструктор Image возбудит исключение, может случиться, что указатель чтения из входного потока сместится, и такое смещение может оказаться изменением состояния, видимым остальной части программы. До тех пор пока у функции changeBackground есть этот недостаток, она предоставляет только базовую гарантию безопасности исключений.</p>
      <p class="calibre2">Но оставим в стороне этот нюанс и будем считать, что changeBackground представляет строгую гарантию безопасности. (По секрету сообщу, что есть способ добиться этого, изменив тип параметра с istream на имя файла, содержащего данные картинки.) Существует общая стратегия проектирования, которая обеспечивает строгую гарантию, и важно ее знать. Стратегия называется «скопировать и обменять» (copy and swap). В принципе, это очень просто. Сделайте копию объекта, который собираетесь модифицировать, затем внесите все необходимые изменения в копию. Если любая из операций модификации возбудит исключение, исходный объект останется неизменным. Когда все изменения будут успешно внесены, обменяйте модифицированный объект с исходным с помощью операции, не возбуждающей исключений.</p>
      <p class="calibre2">Обычно это реализуется помещением всех имеющих отношение к объекту данных из «реального» объекта в отдельный внутренний объект, на который в «реальном» объекте имеется указатель. Часто этот прием называют «идиома pimpl», и в правиле 31 он описывается более подробно. Для класса PrettyMenu это может выглядеть примерно так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">struct PMImpl { // PMImpl = “PrettyMenu Impl”:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Image&gt; bgImage; // см. далее – почему это</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int imageChanges; // структура, а не класс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class PrettyMenu {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Mutex mutex;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;PMImpl&gt; pimpl;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using std::swap; // см. правило 25</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Lock ml(&amp;mutex); // захватить мьютекс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;PMImpl&gt; // копировать данные obj</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pNew(new PMImpl(*pimpl));</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pNew-&gt;bgImage.reset(new Image(imgSrc)); // модифицировать копию</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">++pNew-&gt;imageChanges;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">swap(pimpl, pNew); // обменять значения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // освободить мьютекс</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этом примере я решил сделать PMImpl структурой, а не классом, потому что инкапсуляция данных PrettyMenu достигается за счет того, что член pImpl объявлен закрытым. Объявить PMImpl классом было бы ничем не хуже, хотя и менее удобно (зато поборники «объектно-ориентированной чистоты» были бы довольны). Если нужно, PMImpl можно поместить внутрь PrettyMenu, но такое перемещение никак не влияет на написание безопасного относительно исключений кода.</p>
      <p class="calibre2">Стратегия копирования и обмена – это отличный способ внести изменения в состояние объекта по принципу «все или ничего», но в общем случае при этом не гарантируется, что вся функция в целом строго безопасна относительно исключений. Чтобы понять почему, абстрагируемся от функции changeBackground и рассмотрим вместо нее некоторую функцию someFunc, которая использует копирование с обменом, но еще и обращается к двум другим функциям: f1 и f2.</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void someFunc()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // скопировать локальное состояние</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">f1();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">f2();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // обменять модифицированное состояние с копией</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Должно быть ясно, что если f1 или f2 не обеспечивают строгих гарантий безопасности исключений, то будет трудно обеспечить ее и для someFunc в целом. Например, предположим, что f1 обеспечивает только базовую гарантию. Чтобы someFunc обеспечивала строгую гарантию, необходимо написать код, определяющий состояние всей программы до вызова f1, перехватить все исключения, которые может возбудить f1, а затем восстановить исходное состояние.</p>
      <p class="calibre2">Ситуация не становится существенно лучше, если и f1, и f2 обеспечивают строгую гарантию безопасности исключений. Ведь если f1 нормально доработает до конца, состояние программы может измениться произвольным образом, поэтому если f2 возбудит исключение, то состояние программы не будет тем же, как перед вызовом someFunc, даже если f2 не изменит ничего.</p>
      <p class="calibre2">Проблема в побочных эффектах. До тех пор пока функция оперирует только локальным состоянием (то есть someFunc влияет только на состояние объекта, для которого вызвана), относительно легко обеспечить строгую гарантию. Но когда функция имеет побочные эффекты, затрагивающие нелокальные данные, все становится сложнее. Если, например, побочным эффектом вызова f1 является модификация базы данных, будет трудно обеспечить строгую гарантию для someFunc. Не существует способа отменить модификацию базы данных, которая уже была совершена: другие клиенты могли уже увидеть новое состояние.</p>
      <p class="calibre2">Подобные ситуации могут помешать предоставлению строгой гарантии безопасности для функции, даже если вы хотели бы это сделать. Кроме того, надо принять во внимание эффективность. Смысл «копирования и обмена» в том, чтобы модифицировать копию данных объекта, а затем обменять модифицированные и исходные данные операцией, которая не возбуждает исключений. Для этого нужно сделать копию каждого объекта, который подлежит модификации, что потребует времени и памяти, которыми вы, возможно, не располагаете. Строгая гарантия весьма желательна, и вы должны обеспечивать ее, когда это разумно и практично, но не обязательно во всех случаях.</p>
      <p class="calibre2">Когда невозможно предоставить строгую гарантию, вы должны обеспечить базовую. На практике может оказаться так, что для некоторых функций можно обеспечить строгую гарантию, тогда как для многих других это неразумно из соображений эффективности и сложности. Если вы сделали все возможное для обеспечения строгой гарантии там, где это оправдано, никто не вправе критиковать вас за то, что в остальных случаях вы представляете только базовую гарантию. Для многих функций базовая гарантия – совершенно разумный выбор.</p>
      <p class="calibre2">Совсем другое дело, если вы пишете функцию, которая вообще не представляет никаких гарантий безопасности исключений. Тут вступает в силу презумпция виновности: подсудимый считается виновным, пока не докажет обратного. Вы <em class="calibre5">должны</em> писать код, безопасный относительно исключений. Однако у вас есть право на защиту. Рассмотрим еще раз реализацию функции someFunc, которая вызывает f1 и f2. Предположим, что f2 не представляет никаких гарантий безопасности исключений, даже базовой. Это значит, что если f2 возбудит исключение, то возможна утечка ресурсов внутри f2. Это также означает, что f2 может повредить структуры данных, например отсортированные массивы могут стать неотсортированными, объект, который копировался из одной структуры в другую, может потеряться и т. д. Функция someFunc ничего не может с этим поделать. Если вызываемые из someFunc функции не гарантируют безопасности относительно исключений, то и someFunc не может предоставить никаких гарантий.</p>
      <p class="calibre2">Вот теперь мы можем вернуться к теме беременности. Женщина либо беременна, либо нет. Невозможно быть чуть-чуть беременной. Аналогично программная система является либо безопасной по исключениям, либо нет. Нет такого понятия, как частично безопасная система. Если система имеет всего одну небезопасную относительно исключений функцию, то она небезопасна и в целом, потому что вызов этой функции может привести к утечке ресурсов и повреждению структур данных. К несчастью, большинство унаследованного кода на C++ было написано без учета требований безопасности исключений, поэтому многие системы на сегодня являются в этом отношении небезопасными. Они включают код, написанный в небезопасной манере.</p>
      <p class="calibre2">Но нет причин сохранять такое положение дел навсегда. При написании нового кода или модификации существующего тщательно продумывайте способы достижения безопасности исключений. Начните с применения объектов управления ресурсами (см. правило 13). Это предотвратит утечку ресурсов. Затем определите, какую максимальную из трех гарантий безопасности исключений вы можете обеспечить для разрабатываемых функций, оставляя их небезопасными только в том случае, когда вызовы унаследованного кода не оставляют другого выбора. Документируйте ваши решения как для пользователей ваших функций, так и для сопровождения в будущем. Гарантия безопасности исключений функции – это видимая часть ее интерфейса, поэтому вы должны подходить к ней столь же ответственно, как и к другим аспектам интерфейса.</p>
      <p class="calibre2">Сорок лет назад код, изобилующий операторами goto, считался вполне приемлемым. Теперь же мы стараемся писать структурированные программы. Двенадцать лет назад глобальные данные ни у кого не вызывали возражений. Теперь мы стремимся данные инкапсулировать. Десять лет назад написание функций без учета влияния исключений было нормой. А сейчас мы боремся за достижение безопасности относительно исключений.</p>
      <p class="calibre2">Времена меняются. Мы живем. Мы учимся.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Безопасные относительно исключений функции не допускают утечки ресурсов и повреждения структур данных, даже в случае возбуждения исключений. Такие функции предоставляют базовую гарантию, строгую гарантию либо гарантию полного отсутствия исключений.</p>
      <p class="calibre2">• Строгая гарантия часто может быть реализована посредством копирования и обмена, но предоставлять ее для всех функций непрактично.</p>
      <p class="calibre2">• Функция обычно может предоставить гарантию не строже, чем самая слабая гарантия, обеспечиваемая вызываемыми из нее функциями.</p>
    </div>
  </div>

{% endraw %}

