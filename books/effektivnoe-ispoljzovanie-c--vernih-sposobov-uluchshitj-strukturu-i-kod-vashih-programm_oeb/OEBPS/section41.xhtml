---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section40.xhtml
next: OEBPS/section42.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 20: Предпочитайте передачу по ссылке на const передаче по значению</h2>
      </div>
      <p class="calibre2">По умолчанию в C++ объекты передаются в функции и возвращаются функциями по значению (свойство, унаследованное от C). Если не указано противное, параметры функции инициализируются копиями реальных аргументов, а после вызова функции программа получает <em class="calibre5">копию</em> возвращаемой функцией величины. Копии вырабатываются конструкторами копирования. Поэтому передача по значению может оказаться накладной операцией. Например, рассмотрим следующую иерархию классов:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Person {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Person(); // параметры опущены для простоты</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual ~Person(); // см. в правиле 7 – почему виртуальный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string name;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string address;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Student: public Person {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Student(); // и здесь параметры опущены</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~ Student();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string schoolName;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string schoolAddress;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь взгляните на следующий код, где вызывается функция validateStudent, которая принимает аргумент Student (по значению) и возвращает признак его корректности:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">bool validateStudent(Student s); // функция принимает параметр</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// Student по значению</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Student plato; // Платон учился у Сократа</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool platoIsOk = validateStudent(plato); // вызов функции</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Что происходит при вызове этой функции?</p>
      <p class="calibre2">Ясно, что вызывается конструктор копирования Student для инициализации параметра plato. Также ясно, что s уничтожается при возврате из validate-Student. Поэтому передача параметра по значению этой функции обходится в один вызов конструктора копирования Student и один вызов деструктора Student.</p>
      <p class="calibre2">Но это еще не все. Объект Student содержит внутри себя два объекта string, поэтому каждый раз, когда вы конструируете объект Student, вы должны также конструировать и эти два объекта. Класс Student наследует класу Person, поэтому каждый раз, конструируя объект Student, вы должны сконструировать и объект Person. Но объект Person содержит еще два объекта string, поэтому каждое конструирование Person влечет за собой два вызова конструктора string. Итак, передача объекта Student по значению приводит к одному вызову конструктора копирования Student, одному вызову конструктора копирования Person и четырем вызовам конструкторов копирования string. Когда копия объекта Student разрушается, каждому вызову конструктора соответствует вызов деструктора, поэтому общая стоимость передачи Student по значению составляет шесть конструкторов и шесть деструкторов!</p>
      <p class="calibre2">Что ж, это корректное и желательное поведение. В конец концов, вы <em class="calibre5">хотите,</em> чтобы все ваши объекты были надежно инициализированы и уничтожены. И все же было бы неплохо найти способ пропустить все эти вызовы конструкторов и деструкторов. Способ есть! Это – передача по ссылке на константу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">bool validateStudent(const Student&amp; s);</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот способ гораздо эффективнее: не вызываются никакие конструкторы и деструкторы, поскольку не создаются никакие новые объекты. Квалификатор const в измененном объявлении параметра важен. Исходная версия validateStudent принимала параметр Student по значению, вызвавший ее знает о том, что он защищен от любых изменений, которые функция может внести в переданный ей объект; validateStudent сможет модифицировать только его копию. Теперь же, когда Student передается по ссылке, необходимо объявить его const, поскольку в противном случае вызывающая программа должна побеспокоиться о том, чтобы validateStudent не вносила изменений в переданный ей объект.</p>
      <p class="calibre2">Передача параметров по ссылке также позволяет избежать проблемы « <em class="calibre5">срезки</em> » (slicing). Когда объект производного класса передается (по значению) как объект базового класса, вызывается конструктор копирования базового класса, а те части, которые принадлежат производному, «срезаются». У вас остается только простой объект базового класса – что вполне естественно, так как его создал конструктор базового класса. Это почти всегда не то, что вам нужно. Например, предположим, что вы работаете с набором классов для реализации графической оконной системы:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Window {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string name() const; // возвращает имя окна</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void display() const; // рисует окно и его содержимое</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class WindwoWithScrollBars: public Window {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual void display() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Все объекты класса Window имеют имя, которое вы можете получить посредством функции name, и все окна могут быть отображены, на что указывает наличие функции display. Тот факт, что display – функция виртуальная, говорит о том, что способ отображения простых объектов базового класса Window может отличаться от способа отображения объектов WindowWithScrollBar (см. правила 34 и 36).</p>
      <p class="calibre2">Теперь предположим, что вы хотите написать функцию, которая будет печатать имя окна и затем отображать его. Вот <em class="calibre5">неверный</em> способ написания такой функции:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void printNameAndDisplay(Window w) // неправильно! Параметр</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // может быть «срезан»</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; w.name();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">w.display();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Посмотрим, что случится, если вызвать эту функцию, передав ей объект WindowWithScrollBar:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">WindowWithScrollBar wwsb;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">PrintNameAndDisplay(wwsb);</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Параметр w будет сконструирован – он передан по значению, помните? – как объект Window, и вся дополнительная информация, которая делает его объектом WindowWithScrollBar, будет срезана. Внутри printNameAndDisplay w всегда будет вести себя как объект класса Window (потому что это и есть объект класса Window), независимо от типа объекта, в действительности переданного функции. В частности, вызов функции display внутри printNameAndDisplay всегда вызовет Window::display и никогда – WindowWithScrollBar::display.</p>
      <p class="calibre2">Способ решения проблемы «срезки» – передать w по ссылке на константу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void printNameAndDisplay(const Window&amp; w) // правильно, параметр</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // не может быть «срезан»</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; w.name();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">w.display();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь w ведет себя правильно, какое бы окно он ни представлял в действительности.</p>
      <p class="calibre2">Если вы заглянете «под капот» C++, то увидите, что ссылки обычно реализуются как указатели, поэтому передача чего-либо по ссылке обычно означает передачу указателя. В результате объекты встроенного типа (например, int) всегда более эффективно передавать по значению, чем по ссылке. Поэтому для встроенных типов, если у вас есть выбор – передавать по значению или по ссылке на константу, имеет смысл выбрать передачу по значению. Тот же совет касается итераторов и функциональных объектов STL, потому что они специально спроектированы для передачи по значению. Программисты, реализующие итераторы и функциональные объекты, отвечают за то, чтобы обеспечить эффективность передачи их по значению и исключить «срезку». Это пример того, как меняются правила в зависимости от используемой вами части C++ (см. правило 1).</p>
      <p class="calibre2">Встроенные типы являются небольшими объектами, поэтому некоторые делают вывод, что все встроенные типы – хорошие кандидаты на передачу по значению, даже если они определены пользователем. Сомнительно. То, что объект небольшой, еще не значит, что вызов его конструктора копирования обойдется дешево. Многие объекты – среди них большинство контейнеров STL – содержат в себе немногим больше обычного указателя, но копирование таких объектов влечет за собой копирование всего, на что они указывают. Это может оказаться <em class="calibre5">очень</em> дорого.</p>
      <p class="calibre2">Даже когда маленькие объекты имеют ненакладные конструкторы копирования, все равно они могут оказывать влияние на производительность. Некоторые компиляторы рассматривают встроенные и пользовательские типы по-разному, даже если они имеют одинаковое внутреннее представление. Например, некоторые компиляторы не размещают объекты, состоящие из одного лишь double в регистрах, даже если готовы размещать там значения встроенного типа double. В таких случаях лучше передавать объекты по ссылке, потому что компилятор безусловно готов поместить в регистр указатель (реализующий ссылку).</p>
      <p class="calibre2">Другая причина того, почему маленькие пользовательские типы не обязательно хороши для передачи по значению, заключается в том, что их размер подвержен изменениям. Тип, который мал сегодня, может вырасти в будущем, потому что его внутренняя реализация может измениться. Ситуация меняется даже в том случае, если вы переключаетесь на другую реализацию C++. Например, в одних реализациях тип string из стандартной библиотеки <em class="calibre5">в семь раз больше,</em> чем в других.</p>
      <p class="calibre2">Вообще говоря, единственные типы, для которых можно предположить, что передача по значению будет недорогой, – это встроенные типы, а также итераторы и функциональные объекты STL. Для всего остального следуйте совету этого правила и передавайте параметры по ссылке на константу вместо передачи по значению.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Передаче по значению предпочитайте передачу по ссылке на константу. Обычно это более эффективно и позволяет избежать проблемы «срезки».</p>
      <p class="calibre2">• Это правило не касается встроенных типов, итераторов и функциональных объектов STL. Для них передача по значению обычно подходит больше.</p>
    </div>
  </div>

{% endraw %}

