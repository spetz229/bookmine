---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section52.xhtml
next: OEBPS/section54.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 30: Тщательно обдумывайте использование встроенных функций</h2>
      </div>
      <p class="calibre2">Встроенные функции – какая <em class="calibre5">замечательная</em> идея! Они выглядят подобно функциям, они работают подобно функциям, они намного лучше макросов (см. правило 2). Их можно вызывать, не опасаясь накладных расходов, связанных с вызовом обычных функций. Чего еще желать?</p>
      <p class="calibre2">В действительности вы получаете больше, чем рассчитывали, потому что возможность избежать затрат на вызов функции – это только полдела. Оптимизация, выполняемая компилятором, обычно наиболее эффективна на участке кода, не содержащем вызовов функций. Таким образом, вы даете компилятору возможность оптимизации тела встроенной функции в зависимости от объемлющего контекста. При использовании «обычного» функционального вызова большинство компиляторов такой оптимизации на обычных не выполняют.</p>
      <p class="calibre2">Все же давайте не будем слишком увлекаться. В программировании, как и в реальной жизни, не бывает «бесплатных завтраков», и встроенные функции – не исключение. Идея их использования состоит в замене каждого вызова такой функции ее телом. Не нужно быть доктором математических наук, чтобы заметить, что это увеличит общий размер вашего объектного кода. Слишком частое применение встроенных функций на машинах с ограниченной памятью может привести к созданию программы, которая превосходит доступную память. Даже при наличии виртуальной памяти «разбухание» кода, вызванное применением встроенных функций, может привести к дополнительному обмену с диском, уменьшить коэффициент попадания команд в кэш и, следовательно, снизить производительность программы.</p>
      <p class="calibre2">С другой стороны, если тело встроенной функции <em class="calibre5">очень</em> короткое, то сгенерированный для нее код может быть короче кода, сгенерированного для вызова функции. В таком случае встраивание функции может привести к <em class="calibre5">уменьшению</em> объектного кода и повышению коэффициента попаданий в кэш!</p>
      <p class="calibre2">Имейте в виду, что директива inline – это <em class="calibre5">совет,</em> а не команда компилятору. Совет может быть сформулирован явно или неявно. Неявный способ заключается в определении встроенной функции внутри определения класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Person {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int age() const { return theAge;} // неявный запрос на встраивание;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // функция age определена внутри класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int theAge;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Такие функции обычно являются функциями-членами, но в правиле 46 объясняется, что функции-друзья тоже могут быть определены внутри класса. В этом случае они также неявно считаются встроенными.</p>
      <p class="calibre2">Явно объявить встроенную функцию можно, предварив ее определение ключевым словом inline. Например, вот как обычно реализован стандартный шаблон max (из заголовочного файла &lt;algorithm&gt;):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename T&gt; // явный запрос на</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">inline const T&amp; std::max(const T&amp; a, const T&amp; b) // встраивание: функции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return a &lt; b ? b : c;} // std::max предшествует</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// слово inline</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Тот факт, что max – это шаблон, наводит на мысль, что встроенные функции и шаблоны обычно объявляются в заголовочных файлах. Некоторые программисты делают из этого вывод, что шаблоны функций обязательно должны быть встроенными. Это заключение одновременно неверно и потенциально опасно, поэтому рассмотрим его внимательнее.</p>
      <p class="calibre2">Встроенные функции обычно должны находиться в заголовочных файлах, поскольку большинство разработки программ выполняют встраивание во время компиляции. Чтобы заменить вызовы функции встраиванием ее тела, компилятор должен увидеть эту функцию. (Некоторые среды могут встраивать функции во время компоновки, а есть и такие – например, среды разработки на базе. NET Common Language Infrastructure (CLI), – которые осуществляют встраивание во время исполнения. Но это скорее исключение, чем правило. Встраивание функций в большинстве программ на C++ происходит во время компиляции.)</p>
      <p class="calibre2">Шаблоны обычно находятся в заголовочных файлах, потому что компилятор должен знать, как шаблон выглядит, чтобы конкретизировать его в момент использования. (Но и это правило не является универсальным. Некоторые среды разработки выполняют конкретизацию шаблонов во время компоновки. Однако конкретизация на этапе компиляции встречается чаще.)</p>
      <p class="calibre2">Конкретизация шаблонов никак не связана со встраиванием. Если вы полагаете, что все функции, конкретизированные из вашего шаблона, должны быть встроенными, объявите шаблон встроенным (inline); именно так разработчики стандартной библиотеки поступили с шаблоном std::max (см. пример выше). Но если вы пишете шаблон для функции, которую нет смысла делать встроенной, не объявляйте встроенным и ее шаблон (явно или неявно). Встраивание обходится дорого, и вряд ли вы захотите платить за это без должного размышления. Мы уже упоминали, что встраивание раздувает код (особенно это важно при разработке шаблонов – см. правило 44), но есть и другие затраты, которые мы скоро обсудим.</p>
      <p class="calibre2">Но прежде напомним, что встраивание – это совет, который компилятор может проигнорировать. Большинство компиляторов отвергают встраивание функций, которые представляются слишком сложными (например, содержат циклы или рекурсию), и за исключением наиболее тривиальных случаев, вызов виртуальной функции отменяет встраивание. В этом нет ничего удивительного: virtual означает «какую точно функцию вызвать, определяется в момент исполнения», а inline – «перед исполнением заменить вызов функции ее кодом». Если компилятор не знает, какую функцию вызывать, то трудно винить его в том, что он отказывается делать встраивание.</p>
      <p class="calibre2">Все это в конечном счете сводится к следующему: от реализации используемого компилятора зависит, встраивается ли в действительность встроенная функция. К счастью, большинство компиляторов обладают достаточными диагностическими возможностями и выдают предупреждение (см. правило 53), если не могут выполнить запрошенное вами встраивание.</p>
      <p class="calibre2">Иногда компилятор генерирует тела встроенной функции, даже если ничто не мешает ее встроить. Например, если ваша программа получает адрес встроенной функции, то компилятор, как правило, должен сгенерировать настоящее тело функции. Как иначе он может получить адрес функции, если ее не существует? В совокупности с тем фактом, что обычно компиляторы не выполняют встраивание, если функция вызывается по указателю, это значит, что вызовы встроенных функций могут встраиваться или не встраиваться в зависимости от того, как к ней производится обращение:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">inline void f() {...} // предположим, что компилятор может встроить вызовы f</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void (*pf)() = f; // pf указывает на f</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">f(); // этот вызов будет встроенным, потому что он</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// «нормальный»</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pf(); // этот вызов, вероятно, не будет встроен, потому что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// функция вызвана по указателю</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Призрак невстраиваемых inline-функций может преследовать вас, даже если вы никогда не используете указателей на функции, потому что указатели на функции может запрашивать не только программист. Иногда компилятор генерирует невстраиваемые копии конструкторов и деструкторов так, что они запрашивают указатели на функции во время конструирования и разрушения объектов в массивах.</p>
      <p class="calibre2">Фактически конструкторы и деструкторы часто являются наихудшими кандидатами для встраивания. Например, рассмотрим конструктор класса Derived:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string bm1, bm2; // члены базового класса 1 и 2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Derived(){} // конструктор Derived пуст – не так ли?</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string dm1, dm2, dm3; // члены производного класса 1–3</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот конструктор выглядит как отличный кандидат на встраивание, поскольку он не содержит никакого кода. Но впечатление обманчиво.</p>
      <p class="calibre2">C++ дает различные гарантии о том, что должно происходить при конструировании и разрушении объектов. Например, когда вы используете оператор new, динамически создаваемые объекты автоматически инициализируются своими конструкторами, а при обращении к delete вызываются соответствующие деструкторы. Когда вы создаете объект, то автоматически конструируются члены всех его базовых классов, а равно его собственные данные-члены, а во время удаления объекта автоматически происходит обратный процесс. Если во время конструирования объекта возбуждается исключение, то все части объекта, которые были к этому моменту сконструированы, автоматически разрушаются. Во всех этих случаях C++ говорит, <em class="calibre5">что</em> должно случиться, но не говорит – <em class="calibre5">как.</em> Это зависит от реализации компилятора, но должно быть понятно, что такие вещи не происходят сами по себе. В вашей программе должен быть какой-то код, который все это реализует, и этот код, который генерируется компилятором и вставляется в вашу программу, должен где-то находиться. Иногда он помещается в конструкторы и деструкторы, поэтому можем представить себе следующую реализацию сгенерированного кода в якобы пустом конструкторе класса Derived:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Derived::Derived() // концептуальная реализация</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // «пустого» конструктора класса Derived</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Base::Base(); // инициализировать часть Base</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">try {dm1.std::string::string();} // попытка сконструировать dm1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">catch(…) { // если возбуждается исключение,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Base::~Base(); // разрушить часть базового класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw; // распространить исключение выше</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">try {dm2.std::string::string();} // попытка сконструировать dm2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">catch(…){ // если возбуждается исключение,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">dm1.std::string::~string(); // разрушить dm1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Base::~Base(); // разрушить часть базового класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw; // распространить исключение</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">try {dm3.std::string::string();} // сконструировать dm3</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">catch(…){ // если возбуждается исключение,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">dm2.std::string::~string(); // разрушить dm2</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">dm1.std::string::~string(); // разрушить dm1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Base::~Base(); // разрушить часть базового класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw; // распространить исключение</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В действительности это не совсем тот код, который порождает компилятор, потому что реальные компиляторы обрабатывают исключения более сложным образом. И все же этот пример довольно точно отражает поведение «пустого» конструктора класса Derived. Независимо от того, насколько хитроумно обходится с исключениями компилятор, конструктор Derived должен, по крайней мере, вызывать конструкторы своих данных-членов и базового класса, и эти вызовы (которые сами по себе могут быть встроенными) могут свести преимущества встраивания на нет.</p>
      <p class="calibre2">То же самое относится и к конструктору класса Base, поэтому если он встроенный, то весь вставленный в него код вставляется также и в конструктор Derived (поскольку конструктор Derived вызывает конструктор Base). И если конструктор класса string тоже окажется встроенным, то в конструктор Derived его код войдет <em class="calibre5">пять</em> раз – по одному для каждой из пяти имеющихся в классе Derived строк (две унаследованные и три, объявленные в нем самом). Наверное, теперь вам ясно, почему решений о встраивании конструктора Derived не стоит принимать с легким сердцем. Аналогично обстоят дела и с деструктором класса Derived, который каким-то образом должен гарантировать правильное уничтожение всех объектов, инициализированных конструктором.</p>
      <p class="calibre2">Разработчики библиотек должны принимать во внимание, что произойдет при объявлении функций встроенными, потому что невозможно предоставить двоичное обновление видимых клиенту встроенных библиотечных функций. Другими словами, если f – встроенная библиотечная функция, то пользователи этой библиотеки встраивают ее тело в свои приложения. Если разработчик библиотеки позднее решит изменить f, то все программы, которые ее использовали, придется откомпилировать заново. Часто это нежелательно. С другой стороны, если f не будет встроенной функцией, то после ее модификации клиентские программы нужно будет лишь заново компоновать с библиотекой. Это ощутимо быстрее, чем перекомпиляция, а если библиотека, содержащая функцию, является динамической, то изменения в ней вообще будут прозрачны для пользователей.</p>
      <p class="calibre2">При разработке программ важно иметь в виду все эти соображения, но с практической точки зрения наиболее существен следующий факт: у большинства отладчиков возникают проблемы со встроенными функциями. Это совсем не удивительно. Как установить точку остановки в функции, которой не существует? Хотя некоторые среды разработки ухитряются поддерживать отладку встроенных функций, во многих встраивание для отладочных версий просто отключается.</p>
      <p class="calibre2">Это приводит нас к следующей стратегии выбора функций, подходящих для встраивания. Поначалу откажитесь от встроенных функций вовсе, или, по крайней мере, ограничьтесь теми, которые обязаны быть встроенными (см. правило 46) либо являются тривиальными (такие как Person::age выше). Применяя встроенные функции с должной аккуратностью, вы не только получаете возможность пользоваться отладчиком, но и определяете встраиванию подобающее место: тонкая оптимизация вручную. Не забывайте об эмпирическом правиле «80–20», которое утверждает, что типичная программа тратит 80 % времени на исполнение 20 % кода. Это важное правило, поскольку оно напоминает, что цель разработчика программного обеспечения – идентифицировать те 20 % кода, которые действительно способны повысить производительность программы. Можно до бесконечности оптимизировать и объявлять функции inline, но все это будет пустой тратой времени, если только вы не сосредоточите усилия на <em class="calibre5">нужных</em> функциях.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Делайте встраиваемыми только небольшие, часто вызываемые функции. Это облегчит отладку, даст возможность выполнять обновления библиотек на двоичном уровне, уменьшит эффект «разбухания» кода и поможет повысить быстродействие программы.</p>
      <p class="calibre2">• Не объявляйте шаблоны функций встроенными только потому, что они появляются в заголовочных файлах.</p>
    </div>
  </div>

{% endraw %}

