---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section38.xhtml
next: OEBPS/section40.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 18: Проектируйте интерфейсы так, что их легко было использовать правильно и трудно – неправильно</h2>
      </div>
      <p class="calibre2">C++ изобилует интерфейсами. Интерфейсы функций. Интерфейсы классов. Интерфейсы шаблонов. Каждый интерфейс – это средство, посредством которого пользователь взаимодействует с вашим кодом. Предположим, что вы имеете дело с разумными людьми, которые стремятся хорошо сделать свою работу. Они <em class="calibre5">хотят</em> применять ваши интерфейсы корректно. Если случится, что они применят какой-то из них неправильно, то часть вины за это ляжет на вас. В идеале, при попытке использовать интерфейс так, что пользователь не получит ожидаемого результата, код не должен компилироваться. А если компилируется, то должен делать то, что имел в виду пользователь.</p>
      <p class="calibre2">При разработке интерфейсов, простых для правильного применения и трудных – для неправильного, вы должны предвидеть, какие ошибки может допустить пользователь. Например, предположим, что вы разрабатываете конструктор класса, представляющего дату:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Date {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Date(int month, int day, int year);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">На первый взгляд, этот интерфейс может показаться разумным (во всяком случае, в США), но есть, по крайней мере, две ошибки, которые легко может допустить пользователь. Во-первых, он может передать параметры в неправильном порядке:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Date(30, 3, 1995); // должно быть “3, 30”, а не “30, 3”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Во-вторых, номер месяца или дня может быть указан неверно:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Date(2, 20, 1995); // Должно быть “3, 30”, а не “2, 20”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">(Последний пример может показаться надуманным, но вспомните, что на клавиатуре «2» находится рядом с «3». Такие опечатки случаются сплошь и рядом.)</p>
      <p class="calibre2">Многих ошибок можно избежать за счет введения новых типов. Система контроля типов – ваш первый союзник в деле предотвращения компилируемости нежелательного кода. В данном случае мы можем ввести простые типы-обертки, чтобы различать дни, месяцы и годы, затем использовать их в конструкторе Date:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">struct Day { struct Month { struct Year {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit Day(int d) explicit Month(int m) explicit Year(int y)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">: val(d) {} : val(m) {} : val(y) {}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int val; int val; int val;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; }; };</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Date {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Date(const Month&amp; m, const Day&amp; d, const Year&amp; y(;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Date d(30, 3, 1995); // ошибка! неправильные типы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Date d(Day(30), Month(3), Year(1995); // ошибка! неправильные типы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Date d(Month(3), Day(30), Year(1995)); // порядок, типы корректны</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Еще лучше сделать Day, Month и Year полноценными классами, инкапсулирующими свои данные (см. правило 22). Но даже применение простых структур наглядно демонстрирует, что разумное использование новых типов способно эффективно предотвратить ошибки при использовании интерфейсов.</p>
      <p class="calibre2">После того как определены правильные типы, иногда имеет смысл ограничить множество принимаемых ими значений. Например, есть только 12 допустимых значений месяцев, что и должен отразить тип Month. Один из способов сделать это – применить перечисление (enum) для представления месяца. Но перечисления не так безопасны по отношению к типам, как хотелось бы. Например, перечисления могут быть использованы как значения типа int (см. правило 2). Более безопасное решение – определить набор допустимых месяцев:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Month {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static Month Jan() {return Month(1);} // функции возвращают все</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static Month Feb() {return Month(2);} // допустимые значения Month.</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // Cм. ниже, почему это функции,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static Month Dec() {return Month(12);} // а не объекты</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // прочие функции-члены</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit Month(int m); // предотвращает создание новых</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// значений Month</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // специфичные для месяца данные</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Date d(Month::Mar(), Day(30), Year(1995));</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Идея применения функций вместо объектов для представления месяцев может показаться вам необычной. Но вспомните о ненадежности инициализации нелокальных статических объектов. Правило 4 поможет освежить вашу память.</p>
      <p class="calibre2">Другой способ предотвратить вероятные ошибки клиентов – ограничить множество разрешенных для типа операций. Общий способ установить ограничения – добавить const. Например, в правиле 3 объясняется, как добавление модификатора const к типу значения, возвращаемого функцией operator*, может предотвратить следующую ошибку клиента:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">if(a *b = c)... // имелось в виду сравнение</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Фактически это пример другого общего правила облегчения правильного использования типов и усложнения неправильного их использования: поведение ваших типов должно быть согласовано с поведением встроенных типов (кроме некоторых исключительных случаев). Клиенты уже знают, как должны себя вести типы вроде int, поэтому вы должны стараться, чтобы ваши типы по возможности вели себя аналогично. Например, присваивание выражению a*b недопустимо, если a и b – целые, поэтому если нет веской причины отклониться от этого поведения, оно должно быть недопустимо и для ваших типов. Когда сомневаетесь, делайте так, как ведет себя int.</p>
      <p class="calibre2">Избегать неоправданных расхождений с поведением встроенных типов необходимо для того, чтобы обеспечить согласованность интерфейсов. Из всех характеристик простых для применения интерфейсов согласованность – наверное, самая важная. И наоборот, несогласованность – прямая дорога к ухудшению качества интерфейса. Интерфейсы STL-контейнеров в большинстве случаев согласованы (хотя и не идеально), и это немало способствует простоте их использования. Например, каждый STL-контейнер имеет функцию-член size, которая сообщает, сколько объектов содержится в контейнере. Напротив, в языке Java для массивов используется <em class="calibre5">свойство</em> length, для класса String – <em class="calibre5">метод</em> length, а для класса List – метод size. Также и в. NET: класс Array имеет свойство Length, а класс ArrayList – свойство Count. Некоторые разработчики считают, что интегрированные среды разработки (IDE) делают эти несоответствия несущественными, но они ошибаются. Несоответствия мешают программисту продуктивно работать, и ни одна IDE это не компенсирует.</p>
      <p class="calibre2">Любой интерфейс, который требует, чтобы пользователь что-то помнил, может быть использован неправильно, ибо пользователь вполне способен забыть, что от него требуется. Например, в правиле 13 представлена фабричная функция, которая возвращает указатель на динамически распределенный объект в иерархии Investment:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Investment *createInvestment(); // из правила 13: параметры</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// для простоты опущены</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Чтобы избежать утечки ресурсов, указатель, возвращенный createInvestment, обязательно должен быть удален. Следовательно, пользователь может совершить, по крайней мере, две ошибки: забыть удалить указатель либо удалить его более одного раза.</p>
      <p class="calibre2">Правило 13 показывает, как клиенты могут поместить значение, возвращенное createInvestment, в «интеллектуальный» указатель наподобие auto_ptr или tr1::shared_ptr, возложив тем самым на него ответственность за вызов delete. Но что, если клиент забудет применить «интеллектуальный» указатель? Во многих случаях для предотвращения этой проблемы лучше было бы написать фабричную функцию, которая сама возвращает «интеллектуальный» указатель:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; createInvestment();</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Тогда пользователь будет вынужден сохранять возвращаемое значение в объекте типа tr1::shared_ptr, и ему не придется помнить о том, что объект Investment по завершении работы с ним необходимо удалить.</p>
      <p class="calibre2">Фактически возврат значения типа tr1::shared_ptr позволяет проектировщику интерфейса предотвратить и многие другие ошибки, связанные с освобождением ресурса, потому что, как объяснено в правиле 14, tr1::shared_ptr допускает привязку функции-чистильщика к интеллектуальному указателю при его создании (auto_ptr не имеет такой возможности).</p>
      <p class="calibre2">Предположим, что от пользователя, который получил указатель Investment* от createInvestment, ожидается, что в конце работы он передаст его функции getRidOfInvestment, вместо того чтобы применить к нему delete. Подобный интерфейс – прямая дорога к другой ошибке, заключающейся в использовании не того механизма удаления ресурсов (пользователь может все-таки вызвать delete вместо getRidOfInvestment). Реализация createInvestment может снять эту проблему за счет того, что вернет tr1::shared_ptr с привязанной к нему в качестве чистильщика функцией getRidOfInvestment.</p>
      <p class="calibre2">Конструктор tr1::shared_ptr принимает два аргумента: указатель, которым нужно управлять, и функцию-чистильщик, которая должна быть вызвана, когда счетчик ссылок достигнет нуля. Это наводит на мысль попытаться следующим образом создать нулевой указатель tr1::shared_ptr с getRidOfInvestment в качестве чистильщика:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1_shared_ptr&lt;Investment&gt; // попытка создать нулевой shared_ptr</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv(0, getRidOfInvestment); // с чистильщиком</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// <em class="calibre5">это не скомпилируется</em></code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">К сожалению, C++ это не приемлет. Конструктор tr1::shared_ptr требует, чтобы его первый параметр был указателем, а 0 – это не указатель, это целое. Да, оно <em class="calibre5">преобразуется</em> в указатель, но для данного случая этого недостаточно: tr1::shared_ptr настаивает на настоящем указателе. Приведение типа решает эту проблему:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1_shared_ptr&lt;Investment&gt; // создает null shared_ptr</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pInv(static_cast&lt;Investment*&gt;(0), // с getRidOfInvestment в качестве</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">getRidOfInvestment); // чистильщика. о static_cast см.</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в правиле 27</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это значит, что код, реализующий createInvestment, который должен возвратить tr1::shared_ptr с getRidOfInvestment в качества чистильщика, будет выглядеть примерно так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; createInvestment()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; retVal(static_cast&lt;Investment*&gt;(0),</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">getRidOfInvestment);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">retVal = ...; // retVal должен указывать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// на корректный объект</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return retVal;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Конечно, если указатель, которым должен управлять pInv, можно было бы определить до создания pInv, то лучше было бы передать его конструктору pInv вместо инициализации pInv нулем с последующим присваиванием значения (см. правило 26).</p>
      <p class="calibre2">Особенно симпатичное свойство tr1::shared_ptr заключается в том, что он автоматически использует определенного пользователем чистильщика, чтобы избежать другой потенциальной ошибки пользователя – «проблемы нескольких DLL». Она возникает, если объект создается оператором new в одной динамически скомпонованной библиотеке (DLL), а удаляется оператором delete в другой. На многих платформах в такой ситуации возникает ошибка во время исполнения. tr1::shared_ptr решает эту проблемы, поскольку его чистильщик по умолчанию использует delete из той же самой DLL, где был создан tr1::shared_ptr. Это значит, например, что если класс Stock является производным от Investment и функция createInvestment реализована следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; createInvestment()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return std::tr1::shared_ptr&lt;Investment&gt;(new Stock);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то возвращенный ей объект tr1::shared_ptr можно передавать между разными DLL без риска столкнуться с описанной выше проблемой. Объект tr1::shared_ptr, указывающий на Stock, «помнит», из какой DLL должен быть вызван delete, когда счетчик ссылок на Stock достигнет нуля.</p>
      <p class="calibre2">Впрочем, этот правило не о tr1::shared_ptr, а о том, как делать интерфейсы легкими для правильного использования и трудными – для неправильного. Но класс tr1::shared_ptr дает настолько простой способ избежать некоторых клиентских ошибок, что на нем стоило остановиться. Наиболее распространенная реализация tr1::shared_ptr находится в библиотеке Boost (см. правило 55). Размер объекта shared_ptr из Boost вдвое больше размера обычного указателя, в нем динамически выделяется память для служебных целей и данных, относящихся к чистильщику, используется вызов виртуальной функции для обращения к чистильщику, производится синхронизация потоков при изменении значения счетчика ссылок в многопоточной среде. (Вы можете отключить поддержку многопоточности, определив символ препроцессора.) Короче говоря, этот интеллектуальный указатель по размеру больше обычного, работает медленнее и использует дополнительную динамически выделяемую память. Но во многих приложениях эти дополнительные затраты времени исполнения будут незаметны, зато уменьшение числа ошибок пользователей заметят все.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Хорошие интерфейсы легко использовать правильно и трудно использовать неправильно. Вы должны стремиться обеспечить эти характеристики в ваших интерфейсах.</p>
      <p class="calibre2">• Для обеспечения корректного использования интерфейсы должны быть согласованы и совместимы со встроенными типами.</p>
      <p class="calibre2">• Для предотвращения ошибок применяют следующие способы: создание новых типов, ограничение допустимых операций над этими типами, ограничение допустимых значений, а также освобождение пользователя от обязанностей по управлению ресурсами.</p>
      <p class="calibre2">• Класс tr1::shared_ptr поддерживает пользовательские функции-чистильщики. Это снимает «проблему нескольких DLL» и может быть, в частности, использовано для автоматического освобождения мьютекса (см. правило 14).</p>
    </div>
  </div>

{% endraw %}

