---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section33.xhtml
next: OEBPS/section35.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 15: Предоставляйте доступ к самим ресурсам из управляющих ими классов</h2>
      </div>
      <p class="calibre2">Управляющие ресурсами классы заслуживают всяческих похвал. Это бастион, защищающий от утечек ресурсов, а отсутствие таких утечек – фундаментальное свойство хорошо спроектированных систем. В идеальном мире вы можете положиться на эти классы для любых взаимодействий с ресурсами, не утруждая себя доступом к ним напрямую. Но мир неидеален. Многие программные интерфейсы требуют доступа к ресурсам без посредников. Если вы не планируете отказаться от использования таких интерфейсов (что редко имеет смысл на практике), то должны как-то обойти управляющий объект и работать с самим ресурсом.</p>
      <p class="calibre2">Например, в правиле 13 изложена идея применения интеллектуальных указателей вроде auto_ptr или tr1::shared_ptr для хранения результата вызова фабричной функции createInvestment:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment()); // èç ïðàâèëà 13</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Предположим, есть функция, которую вы хотите применить при работе с объектами класса Investment:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int daysHeld(const Investment *pi); // возвращает количество дней</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// хранения инвестиций</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Вы хотите вызывать ее так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int days = daysHeld(pInv); // ошибка!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">но этот код не скомпилируется: функция daysHeld ожидает получить указатель на объект класса Investment, а вы передаете ей объект типа tr1::shared_ptr &lt;Investment&gt;.</p>
      <p class="calibre2">Необходимо как-то преобразовать объект RAII-класса (в данном случае tr1::shared_ptr) к типу управляемого им ресурса (то есть Investment*). Есть два основных способа сделать это: неявное и явное преобразование.</p>
      <p class="calibre2">И tr1::shared_ptr, и auto_ptr предоставляют функцию-член get для выполнения явного преобразования, то есть возврата (копии) указателя на управляемый объект:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int days = daysHeld(pInv.get()); // нормально, указатель, хранящийся</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в pInv, передается daysHeld</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как почти все классы интеллектуальных указателей, tr1::shared_ptr и auto_ptr перегружают операторы разыменования указателей (operator-&gt; и operator*), и это обеспечивает возможность неявного преобразования к типу управляемого указателя:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Investment { // корневой класс иерархии</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // типов инвестиций</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool isTaxFree() const;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Investment *createInvestment(); // фабричная функция</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::tr1::shared_ptr&lt;Investment&gt; // имеем tr1::shared_ptr</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pi1(createInvestment()); // для управления ресурсом</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool taxable1 = !(pi1-&gt;isTaxFree()); // доступ к ресурсу</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// через оператор -&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::auto_ptr&lt;Investment&gt; pi2(createInvestment()); // имеем auto_ptr для</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// управления ресурсом</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">bool taxable2 = !((*pi2).isTaxFree()); // доступ к ресурсу</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// через оператор *</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поскольку иногда необходимо получать доступ к ресурсу, управляемому RAII-объектом, то некоторые реализации RAII предоставляют функции для неявного преобразования. Например, рассмотрим следующий класс для работы со шрифтами, инкапсулирующий «родной» интерфейс, написанный на C:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">FontHandle getFont(); // из С API – параметры пропущены</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// для простоты</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void releaseFont(FontHandle fh); // из того же API</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Font { // класс RAII</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">explicit Font(FontHandle fh) // захватить ресурс:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">:f(fh) // применяется передача по значению,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{} // потому что того требует C API</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~Font() {releaseFont(f);} // освободить ресурс</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">FontHandle f; // управляемый ресурс – шрифт</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Предполагается, что есть обширный программный интерфейс, написанный на C, работающий исключительно в терминах FontHandle. Поэтому часто приходится преобразовывать объекты из типа Font в FontHandle. Класс Font может предоставить функцию явного преобразования, например get:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Font {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">FontHandle get() const {return f;} // функция явного преобразования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">К сожалению, пользователю придется вызывать get всякий раз при взаимодействии с API:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void changeFontSize(FontHandle f, int newSize); // из C API</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Font f(getFont());</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int newFontSize;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">changeFontSize(f.get(), newFontSize); // явное преобразование</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// из Font в FontHandle</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Некоторые программисты могут посчитать, что каждый раз выполнять явное преобразование настолько обременительно, что вообще откажутся от применения этого класса. В результате возрастет опасность утечки шрифтов, а именно для того, чтобы предотвратить это, и был разработан класс Font.</p>
      <p class="calibre2">Альтернативой может стать предоставление классом Font функции неявного преобразования к FontHandle:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Font {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">operator FontHandle() const // функция неявного преобразования</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{return f;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это сделает вызовы C API простыми и естественными:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Font f(getFont());</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int newSize;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">changeFontSize(f, newFontSize); // неявное преобразование из Font</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в FontHandle</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Увы, у этого решения есть и оборотная сторона: повышается вероятность ошибок. Например, пользователь может нечаянно создать объект FontHandle, имея в виду Font:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Font f1(getFont());</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">FontHandle f2 = f1; // Ошибка! Предполагалось скопировать объект Font,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// а вместо f1 неявно преобразован в управляемый</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// им FontHandle, который и скопирован в f2</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь в программе есть FontHandle, управляемый объектом Font f1, однако он же доступен и напрямую, как f2. Это почти всегда нехорошо. Например, если f1 будет уничтожен, шрифт освобождается, и f2 становится «висячей ссылкой».</p>
      <p class="calibre2">Решение о том, когда нужно предоставить явное преобразование RAII-объекта к управляемому им ресурсу (посредством функции get), а когда – неявное, зависит от конкретной задачи, для решения которой был спроектирован класс, и условий его применения. Похоже, что лучшее решение – следовать советам правила 18, а именно: делать интерфейсы простыми для правильного применения и трудными – для неправильного. Часто явное преобразование типа функции get – более предпочтительный вариант, поскольку минимизирует шанс получить нежелательное преобразование типов. Однако иногда естественность применения неявного преобразования поможет сделать ваш код чище.</p>
      <p class="calibre2">Может показаться, что функции, обеспечивающие доступ к управляемым ресурсам, противоречат принципам инкапсуляции. Верно, но в данном случае это не беда. Дело в том, что RAII-классы существуют не для того, чтобы что-то инкапсулировать. Их назначение – гарантировать, что определенное действие (а именно освобождение ресурса) обязательно произойдет. При желании инкапсуляцию ресурса можно реализовать поверх основной функциональности, но это не является необходимым. Более того, некоторые RAII-классы комбинируют истинную инкапсуляцию реализации с отказом от нее в отношении управляемого ресурса. Например, tr1::shared_ptr инкапсулирует подсчет ссылок, но предоставляет простой доступ к управляемому им указателю. Как и большинство хорошо спроектированных классов, он скрывает то, что клиенту не нужно видеть, но обеспечивает доступ к тому, что клиенту необходимо.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Программные интерфейсы (API) часто требуют прямого обращения к ресурсам. Именно поэтому каждый RAII-класс должен предоставлять возможность получения доступа к ресурсу, которым он управляет.</p>
      <p class="calibre2">• Доступ может быть обеспечен посредством явного либо неявного преобразования. Вообще говоря, явное преобразование безопаснее, но неявное более удобно для пользователей.</p>
    </div>
  </div>

{% endraw %}

