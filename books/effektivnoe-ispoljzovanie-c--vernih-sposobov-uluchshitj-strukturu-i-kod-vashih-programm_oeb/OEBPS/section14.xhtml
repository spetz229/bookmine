---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section13.xhtml
next: OEBPS/section15.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 2: Предпочитайте const, enum и inline использованию #define</h2>
      </div>
      <p class="calibre2">Это правило лучше было бы назвать «Компилятор предпочтительнее препроцессора», поскольку #define зачастую вообще не относят к языку C++. В этом и заключается проблема. Рассмотрим простой пример; попробуйте написать что-нибудь вроде:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">#define ASPECT_RATIO 1.653</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Символическое имя ASPECT_RATIO может так и остаться неизвестным компилятору или быть удалено препроцессором до того, как код поступит на обработку компилятору. Если это произойдет, то имя ASPECT_RATIO не попадет в таблицу символов. Поэтому в ходе компиляции вы получите ошибку (в сообщении о ней будет упомянуто значение 1.653, а не ASPECT_RATIO). Это вызовет путаницу. Если имя ASPECT_RATIO было определено в заголовочном файле, который писали не вы, то вы вообще не будете знать, откуда взялось значение 1.653, и на поиски ответа потратите много времени. Та же проблема может возникнуть и при отладке, поскольку выбранное вами имя будет отсутствовать в таблице символов.</p>
      <p class="calibre2">Решение состоит в замене макроса константой:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const double AspectRatio = 1.653; // имена, записанные большими буквами,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// обычно применяются для макросов,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// поэтому мы решили его изменить</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Будучи языковой константой, AspectRatio видима компилятору и, естественно, помещается в таблицу символов. К тому же в случае использования константы с плавающей точкой (как в этом примере) генерируется более компактный код, чем при использовании #define. Дело в том, что препроцессор, слепо подставляя вместо макроса ASPECT_RATIO величину 1.653, создает множество копий 1.653 в объектном коде, в то время как использование константы никогда не породит более одной копии этого значения.</p>
      <p class="calibre2">При замене #define константами нужно помнить о двух особых случаях. Первый касается константных указателей. Поскольку определения констант обычно помещаются в заголовочные файлы (где к ним получает доступ множество различных исходных файлов), важно, чтобы сам <em class="calibre5">указатель</em> был объявлен с ключевым словом const, в дополнение к объявлению const того, на что он указывает. Например, чтобы объявить в заголовочном файле константную строку типа char*, слово const нужно написать <em class="calibre5">дважды:</em></p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const char * const authorName = “Scott Meyers”;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Более подробно о сущности и применений слова const, особенно в связке с указателями, см. в правиле 3. Но уже сейчас стоит напомнить, что объекты типа string обычно предпочтительнее своих прародителей – строк типа char *, поэтому authorName лучше определить так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const std::string authorName(“Scott Meyers”);</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Второе замечание касается констант, объявляемых в составе класса. Чтобы ограничить область действия константы классом, необходимо сделать ее членом класса, и чтобы гарантировать, что существует только одна копия константы, требуется сделать ее <em class="calibre5">статическим</em> членом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class GamePlayer {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static const int NumTurns = 5; // объявление константы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int scores[NumTurns]; // использование константы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">То, что вы видите выше, – это <em class="calibre5">объявление</em> NumTurns, а не ее определение. Обычно C++ требует, чтобы вы представляли определение для всего, что используете, но объявленные в классе константы, которые являются статическими и имеют встроенный тип (то есть целые, символьные, булевские) – это исключение из правил. До тех пор пока вы не пытаетесь получить адрес такой константы, можете объявлять и использовать ее без предоставления определения. Если же вам нужно получить адрес либо если ваш компилятор настаивает на наличии определения, то можете написать что-то подобное:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">const int GamePlayer::NumTurns; // определение NumTurns; см. ниже,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// почему не указывается значение</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Поместите этот код в файл реализации, а не в заголовочный файл. Поскольку начальное значение константы класса представлено там, где она объявлена (то есть NumTurns инициализировано значением 5 при объявлении), то в точке определения задавать начальное значение не требуется.</p>
      <p class="calibre2">Отметим, кстати, что нет возможности объявить в классе константу посредством #define, потому что #define не учитывает области действия. Как только макрос определен, он остается в силе для всей оставшейся части компилируемого кода (если только где-то ниже не встретится #undef). Это значит, что директива #define неприменима не только для объявления констант в классе, но вообще не может быть использована для обеспечения какой бы то ни было инкапсуляции, то есть придать смысл выражению «private #define» невозможно. В то же время константные данные-члены могут быть инкапсулированы, примером может служить NumTurns.</p>
      <p class="calibre2">Старые компиляторы могут не поддерживать показанный выше синтаксис, так как в более ранних версиях языка было запрещено задавать значения статических членов класса во время объявления. Более того, инициализация в классе допускалась только для целых типов и для констант. Если вышеприведенный синтаксис не работает, то начальное значение следует задавать в определении:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class CostEstimate {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static const double FudgeFactor; // объявление статической константы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // класса – помещается в файл заголовка</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const double // определение статической константы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">CostEstimate::FudgeFactor = 1.35; // класса – помещается в файл реализации</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Обычно ничего больше и не требуется. Единственное исключение обнаруживается тогда, когда для компиляции класса необходима константа. Например, при объявлении массива GamePlayer::scores компилятору нужно знать размер массива. Чтобы работать с компилятором, ошибочно запрещающим инициализировать статические целые константы внутри класса, можно воспользоваться способом, известным под названием «трюка с перечислением». Он основан на том, что переменные перечисляемого типа можно использовать там, где ожидаются значения типа int, поэтому GamePlayer можно определить так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class GamePlayer {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">enum ( NumTurns = 5 }; // “трюк с перечислением” – делает из</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// NumTurns символ со значением 5</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int scores[NumTurns]; // нормально</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот прием стоит знать по нескольким причинам. Во-первых, поведение «трюка с перечислением» в некоторых отношениях более похоже на #define, чем на константу, а иногда это как раз то, что нужно. Например, можно получить адрес константы, но нельзя получить адрес перечисления, как нельзя получить и адрес #define. Если вы хотите запретить получать адрес или ссылку на какую-нибудь целую константу, то применение enum – хороший способ наложить такое ограничение. (Подробнее о поддержке проектных ограничений с помощью приемов кодирования можно узнать из правила 18). К тому же, хотя хорошие компиляторы не выделяют память для константных объектов целых типов (если только вы не создаете указателя или ссылки на объект), менее изощренные могут так поступать, а вам это, возможно, ни к чему. Как и #define, перечисления никогда не станут причиной подобного нежелательного распределения памяти.</p>
      <p class="calibre2">Вторая причина знать о «трюке с перечислением» чисто прагматическая. Он используется в очень многих программах, поэтому нужно уметь распознавать этот трюк, когда вы с ним сталкиваетесь. Вообще говоря, этот прием – фундаментальная техника, применяемая при метапрограммировании шаблонов (см. правило 48).</p>
      <p class="calibre2">Вернемся к препроцессору. Другой частый случай неправильного использования директивы #define – создание макросов, которые выглядят как функции, но не обременены накладными расходов, связанными с вызовом функций. Ниже представлен макрос, который вызывает некоторую функцию f c аргументом, равным максимальному из двух значений:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">// вызвать f, передав ей максимум из a и b</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В этой строчке содержится так много недостатков, что даже не совсем понятно, с какого начать.</p>
      <p class="calibre2">Всякий раз при написании подобного макроса вы должны помнить о том, что все аргументы следует заключать в скобки. В противном случае вы рискуете столкнуться с проблемой, когда кто-нибудь вызовет его с выражением в качестве аргумента. Но даже если вы сделаете все правильно, посмотрите, какие странные вещи могут произойти:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int a = 5, b = 0;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">CALL_WITH_MAX(++a, b); // a увеличивается дважды</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">CALL_WITH_MAX(++a, b+10); // a увеличивается один раз</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Происходящее внутри max зависит от того, с чем она сравнивается!</p>
      <p class="calibre2">К счастью, вы нет нужды мириться с поведением, так сильно противоречащим привычной логике. Существует метод, позволяющий добиться такой же эффективности, как при использовании препроцессора. Но при этом обеспечивается как предсказуемость поведения, так и контроль типов аргументов (что характерно для обычных функций). Этот результат достигается применением шаблона встроенной (inline) функции (см. правило 30):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename T&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">inline void callWithMax(const T&amp; a, const T&amp; b) // Поскольку мы не знаем,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // что есть T, то передаем</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">f(a &gt; b ? a : b); // его по ссылке на const -</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // см. параграф 20</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот шаблон генерирует целое семейство функций, каждая из которых принимает два аргумента одного и того же типа и вызывает f с наибольшим из них. Нет необходимости заключать параметры в скобки внутри тела функции, не нужно заботиться о многократном вычислении параметров и т. д. Более того, поскольку callWithMax – настоящая функция, на нее распространяются правила областей действия и контроля доступа. Например, можно говорить о встроенной функции, являющейся закрытым членом класса. Описать нечто подобное с помощью макроса невозможно.</p>
      <p class="calibre2">Наличие const, enum и inline резко снижает потребность в препроцессоре (особенно это относится к #define), но не устраняет ее полностью. Директива #include остается существенной, а #ifdef/#ifndef продолжают играть важную роль в управлении компиляцией. Пока еще не время отказываться от препроцессора, но определенно стоит задуматься, как избавиться от него в дальнейшем.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Для простых констант директиве #define следует предпочесть константные объекты и перечисления (enum).</p>
      <p class="calibre2">• Вместо имитирующих функции макросов, определенных через #define, лучше применять встроенные функции.</p>
    </div>
  </div>

{% endraw %}

