---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section22.xhtml
next: OEBPS/section24.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 6: Явно запрещайте компилятору генерировать функции, которые вам не нужны</h2>
      </div>
      <p class="calibre2">Агенты по продаже недвижимости и программные системы, обслуживающие их деятельность, могут нуждаться в классе, представляющем дома, выставленные на продажу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class HomeForSale {...};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Любой агент по продаже недвижимости скажет вам, что каждый объект уникален – не бывает двух, в точности одинаковых. Вот почему идея создания копии объекта HomeForSale бессмысленна. Как можно скопировать нечто, по определению, уникальное? Поэтому хотелось бы, чтобы попытки скопировать объекты HomeForSale не компилировались:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">HomeForSale h1;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HomeForSale h2;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HomeForSale h3(h1); // попытка скопировать h1 –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// не должно компилироваться!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">h1 = h2; // попытка скопировать h2 –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// не должно компилироваться!</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Увы, предотвратить такую компиляцию не так-то просто. Обычно, если вы не хотите, чтобы класс поддерживал определенного рода функциональность, вы просто не объявляете функций, которые ее реализуют. Но с конструктором копирования и оператором присваивания эта стратегия не работает, поскольку, как следует из правила 5, если вы их не объявляете, а где-то в программе производится попытка их вызвать, то компилятор сгенерирует их автоматически.</p>
      <p class="calibre2">Похоже на безвыходное положение. Если вы сами не объявите конструктор копирования или оператор присваивания, то их сгенерирует компилятор. И ваш класс будет поддерживать копирование. Но то же самое произойдет, если вы объявите эти функции самостоятельно. Однако наша цель – <em class="calibre5">предотвратить</em> копирование!</p>
      <p class="calibre2">Ключ к решению в том, что все сгенерированные компилятором функции являются открытыми. Чтобы предотвратить автоматическое генерирование, вы должны объявить их самостоятельно, но никто не требует, чтобы они были открытыми. Ну так и объявите конструктор копирования и оператор присваивания <em class="calibre5">закрытыми.</em> Объявляя явно функцию-член, вы предотвращаете генерирование ее компилятором, а сделав ее закрытой, не позволяете кому-либо вызывать ее.</p>
      <p class="calibre2">Схема не идеальна, потому что другие члены класса и функции-друзья по-прежнему могут вызывать закрытые функции. <em class="calibre5">Если только</em> вы не включите лишь объявление, опустив определение. Тогда если кто-то случайно вызовет такую функцию, то получит сообщение об ошибке на этапе компоновки. Этот трюк – объявление функций-членов закрытыми и сознательный отказ от их реализации – как раз и используется для предотвращения копирования в некоторых классах библиотеки iostreams. Взгляните, например, на объявления классов ios_base, basic_ios и sentry в вашей реализации стандартной библиотеки. Вы обнаружите, что в каждом случае как конструктор копирования, так и оператор присваивания объявлены закрытыми и нигде не определены.</p>
      <p class="calibre2">Применить эту уловку в классе HomeForSale несложно:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class HomeForSale {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HomeForSale(const HomeForSale&amp;); // только объявления</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">HomeForSale&amp; oparetor=( const HomeForSale&amp;);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Заметьте, что я не указал имена параметров функций. Это необязательно, просто таково общее соглашение. Ведь раз эти функции никогда не будут реализовываться и использоваться, то какой смысл задавать имена их параметров?</p>
      <p class="calibre2">При таком определении компилятор будет блокировать любые попытки клиентов копировать объекты HomeForSale, а если вы случайно попытаетесь сделать это в функции-члене или функции-друге класса, то об ошибке сообщит компоновщик.</p>
      <p class="calibre2">Существует возможность переместить ошибку с этапа компоновки на этап компиляции (это всегда полезно – лучше обнаружить ошибку как можно раньше), если объявить конструктор копирования и оператор присваивания закрытыми не в самом классе HomeForSale, а в его базовом классе, специально созданном для предотвращения копирования. Такой базовый класс очень прост:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Uncopyable {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">protected:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Uncopyable() {} // разрешить конструирование</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~Uncopyable() {} // и уничтожение</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// объектов производных классов</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Uncopyable(const Uncopyable&amp;); // но предотвратить копирование</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Uncopyable&amp; operator=(const Uncopyable&amp;);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Чтобы предотвратить копирование объектов HomeForSale, нужно лишь унаследовать его от Uncopyable:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class HomeForSale : private Uncopyable { // в этом класс больше нет ни</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // конструктора копирования, ни</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // оператора присваивания</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Такое решение работает, потому что компилятор пытается генерировать конструктор копирования и оператор присваивания, если где-то – пусть даже в функции-члене или дружественной функции – производится попытка скопировать объект HomeForSale. Как объясняется в правиле 12, сгенерированные компилятором версии будут вызывать соответствующие функции из базового класса. Но это не получится, так как в базовом классе они объявлены закрытыми.</p>
      <p class="calibre2">Реализация и использование класса Uncopyable сопряжена с некоторыми тонкостями. Например, наследование от Uncopyable не должно быть открытым (см. правила 32 и 39), а деструктор Uncopyable не должен быть виртуальным (см. правило 7). Поскольку Uncopyable не имеет данных-членов, то компилятор может прибегнуть к оптимизации пустых базовых классов, описанной в правиле 39, но коль скоро этот класс базовый, то возможно возникновение множественного наследования (см. правило 40). А множественное наследование в некоторых случаях не дает возможности провести оптимизацию пустых базовых классов (см. правило 39). Вообще говоря, вы можете игнорировать эти тонкости и просто использовать Uncopyable, как показано выше. Можете также воспользоваться версией из билиотеки Boost (см. правило 55). В ней этот класс называется noncopyable. Это хороший класс, но мне просто показалось, что его название немного, скажем так, неестественное.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Чтобы отключить функциональность, автоматически предоставляемую компилятором, объявите соответствующую функцию-член закрытой и не включайте ее реализацию. Наследование базовому классу типа Uncopyable – один из способов сделать это.</p>
    </div>
  </div>

{% endraw %}

