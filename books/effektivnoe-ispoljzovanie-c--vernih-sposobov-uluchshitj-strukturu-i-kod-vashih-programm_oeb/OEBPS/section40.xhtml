---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section39.xhtml
next: OEBPS/section41.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 19: Рассматривайте проектирование класса как проектирование типа</h2>
      </div>
      <p class="calibre2">В C++, как и в других объектно-ориентированных языках программирования, при определении нового класса определяется новый тип. Потому большую часть времени вы как разработчик C++ будете тратить на совершенствование вашей системы типов. Это значит, что вы – не просто разработчик классов, но еще и разработчик типов. Перегруженные функции и операторы, управление распределением и освобождением памяти, определение инициализации и порядка уничтожения объектов – все это находится в ваших руках. Поэтому вы должны подходить к проектированию классов так, как разработчики языка подходят к проектированию встроенных типов.</p>
      <p class="calibre2">Проектирование хороших классов – ответственная работа, и этим все сказано. Хорошие типы имеют естественный синтаксис, интуитивно воспринимаемую семантику и одну или более эффективных реализаций. В C++ плохо спланированное определение класса может сделать невозможным достижение любой из этих целей. Даже характеристики производительности функций-членов класса могут зависеть от того, как они объявлены.</p>
      <p class="calibre2">Итак, как же проектировать эффективные классы? Прежде всего вы должны понимать, с чем имеете дело. Проектирование почти любого класса ставит перед разработчиком вопросы, ответы на которые часто ограничивают спектр возможных решений:</p>
      <p class="calibre2">• <strong class="calibre4">Как должны создаваться и уничтожаться объекты нового типа?</strong> От ответа на этот вопрос зависит дизайн конструкторов и деструкторов, а равно функций распределения и освобождения памяти (оператор new, оператор new[], оператор delete и оператор delete[] – см. главу 8), если вы собираетесь их переопределить.</p>
      <p class="calibre2">• <strong class="calibre4">Чем должна отличаться инициализация объекта от присваивания значений?</strong> Ответ на этот вопрос определяет разницу в поведении между конструкторами и операторами присваивания. Важно не путать инициализацию с присваиванием, потому что им соответствуют разные вызовы функций (см. правило 4).</p>
      <p class="calibre2">• <strong class="calibre4">Что означает для объектов нового типа быть переданными по значению?</strong> Помните, что конструктор копирования определяет реализацию передачи по значению для данного типа.</p>
      <p class="calibre2">• <strong class="calibre4">Каковы ограничения на допустимые значения вашего нового типа?</strong> Обычно только некоторые комбинации значений данных-членов класса являются правильными. Эти комбинации определяют инварианты, которые должен поддерживать класс. А инварианты уже диктуют, как следует контролировать ошибки в функциях-членах, в особенности в конструкторах, операторах присваивания и функциях установки значений («setter» functions). Могут быть также затронуты исключения, которые возбуждают ваши функции, и спецификации этих исключений.</p>
      <p class="calibre2">• <strong class="calibre4">Укладывается ли ваш новый тип в граф наследования?</strong> Наследуя свои классы от других, вы должны следовать ограничениям, налагаемым базовыми классами. В частности, нужно учитывать, как объявлены в них функции-члены: виртуальными или нет (см. правила 34 и 36). Если вы хотите, чтобы вашему классу могли наследовать другие, то нужно тщательно продумать, какие функции объявить виртуальными; в особенности это относится к деструктору (см. правило 7).</p>
      <p class="calibre2">• <strong class="calibre4">Какие варианты преобразования типов допустимы для вашего нового типа?</strong> Ваш тип существует в море других типов, поэтому должны ли быть предусмотрены варианты преобразования между вашим типом и другими? Если вы хотите разрешить <em class="calibre5">неявное</em> преобразование объекта типа T1 в объект типа T2, придется либо написать функцию преобразования в классе T1 (то есть operator T2), либо неявный конструктор в классе T2, который может быть вызван с единственным аргументом. Если же вы хотите разрешить только <em class="calibre5">явные</em> преобразования, то нужно будет написать специальные функции, но ни в коем случае не делать их операторами преобразования или не-explicit конструкторами с одним аргументом. (Примеры явных и неявных функций преобразования приведены в правиле 15.)</p>
      <p class="calibre2">• <strong class="calibre4">Какие операторы и функции имеют смысл для нового типа?</strong> Ответ на этот вопрос определяет набор функций, которые вы объявляете в вашем классе. Некоторые из них будут функциями-членами, другие – нет (см. правила 23, 24 и 46).</p>
      <p class="calibre2">
        <strong class="calibre4">• Какие стандартные функции должны стать недоступными?</strong> Их надо будет объявить закрытыми (см. правило 6).</p>
      <p class="calibre2">• <strong class="calibre4">Кто должен получить доступ к членам вашего нового типа?</strong> Ответ на этот вопрос помогает определить, какие члены должны быть открытыми (public), какие – защищенными (protected) и какие – закрытыми (private). Также вам предстоит решить, какие классы и/или функции должны быть друзьями класса, а также когда имеет смысл вложить один класс внутрь другого.</p>
      <p class="calibre2">• <strong class="calibre4">Что такое «необъявленный интерфейс» вашего нового типа?</strong> Какого рода гарантии могут быть предоставлены относительно производительности, безопасности относительно исключений (см. правило 29) и использования ресурсов (например, блокировок и динамической памяти)? Такого рода гарантии определяют ограничения на реализацию вашего класса.</p>
      <p class="calibre2">• <strong class="calibre4">Насколько общий ваш новый тип?</strong> Возможно, в действительности вы не определяете новый тип. Возможно, вы определяете целое <em class="calibre5">семейство</em> типов. Если так, то вам нужно определять не новый класс, а новый шаблон класса.</p>
      <p class="calibre2">• <strong class="calibre4">Действительно ли новый тип представляет собой то, что вам нужно?</strong> Если вы определяете новый производный класс только для того, чтобы расширить функциональность существующего класса, то, возможно, этой цели лучше достичь простым определением одной или более функций-нечленов либо шаблонов.</p>
      <p class="calibre2">На эти вопросы нелегко ответить, поэтому определение эффективных классов – непростая задача. Но при ее должном выполнении определенные пользователями классы C++ дают типы, которые ничем не уступают встроенным и уже оправдывают все ваши усилия.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Проектирование класса – это проектирование типа. Прежде чем определять новый тип, убедитесь, что рассмотрены все вопросы, которые обсуждаются в настоящем правиле.</p>
    </div>
  </div>

{% endraw %}

