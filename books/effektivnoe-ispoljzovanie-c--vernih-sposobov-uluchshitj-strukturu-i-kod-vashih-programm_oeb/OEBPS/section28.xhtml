---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section27.xhtml
next: OEBPS/section29.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 11: В operator= осуществляйте проверку на присваивание самому себе</h2>
      </div>
      <p class="calibre2">Присваивание самому себе возникает примерно в такой ситуации:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget w;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">w = w; // присваивание себе</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Код выглядит достаточно нелепо, однако он совершенно корректен, и в том, что программисты на такое способны, вы можете не сомневаться ни секунды.</p>
      <p class="calibre2">Кроме того, присваивание самому себе не всегда так легко узнаваемо. Например:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">a[i] = a[j]; // потенциальное присваивание себе</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">это присваивание себе, если i и j равны одному и тому же значению, и</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">*px = *py; // потенциальное присваивание себе</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">тоже становится присваиванием самому себе, если окажется, что px и py указывают на одно и то же.</p>
      <p class="calibre2">Эти менее очевидные случаи присваивания себе являются результатом совмещения имен <em class="calibre5">(aliasing),</em> когда для ссылки на объект существует более одного способа. Вообще, программа, которая оперирует ссылками или указателями на различные объекты одного и того же типа, должна считаться с тем, что эти объекты могут совпадать. Необязательно даже, чтобы два объекта имели одинаковый тип, ведь если они принадлежат к одной иерархии классов, то ссылка или указатель на базовый класс может в действительно относиться к объекту производного класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Base {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void doSomething(const Base&amp; rb, // rb и *pd могут быть одним и тем же</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Derived * pd); // объектом</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если вы следуете правилам 13 и 14, то всегда пользуетесь объектами для управления ресурсами; следите за тем, чтобы управляющие объекты правильно вели себя при копировании. В таком случае операторы присваивания должны быть безопасны относительно присваивания самому себе. Если вы пытаетесь управлять ресурсами самостоятельно (а как же иначе, если вы пишете класс для управления ресурсами), то можете попасть в ловушку, нечаянно освободив ресурс до его использования. Например, предположим, что вы создали класс, который содержит указатель на динамически распределенный объект класса Bitmap:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Bitmap {...};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Bitmap *pb; // указатель на объект, размещенный в куче</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Ниже приведена реализация оператора присваивания operator=, которая выглядит совершенно нормально, но становится опасной в случае выполнения присваивания самому себе (она также небезопасна с точки зрения исключений, но сейчас не об этом).</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget&amp;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget::operator=(const Widget&amp; rhs) // небезопасная реализация operator=</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete pb; // прекратить использование текущего</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// объекта Bitmap</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pb = new Bitmap(*rhs.pb); // начать использование копии объекта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// Bitmap, указанной в правой части</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return *this; // см. правило 10</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Проблема состоит в том, что внутри operator= *this (чему присваивается значение) и rhs (что присваивается) могут оказаться одним и тем же объектом. Если это случится, то delete уничтожит не только Bitmap, принадлежащий текущему объекту, но и Bitmap, принадлежащий объекту в правой части. По завершении работы этой функции Widget, который не должен был бы измениться в процессе присваивания самому себе, содержит указатель на удаленный объект!</p>
      <p class="calibre2">Традиционный способ предотвратить эту ошибку состоит в том, что нужно выполнить проверку совпадения в начале operator=:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget&amp;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget::operator=(const Widget&amp; rhs) // небезопасная реализация operator=</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(this == &amp;rhs) return *this; // проверка совпадения: если</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// присваивание самому себе, то</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// ничего не делать</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete pb;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pb = new Bitmap(*rhs.pb);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return *this;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Это решает проблему, но я уже упоминал, что предыдущая версия оператора присваивания была не только опасна в случае присваивания себе, но и небезопасна в смысле исключений, и последняя опасность остается актуальной во второй версии. В частности, если выражение «new Bitmap» вызовет исключение (либо по причине недостатка свободной памяти, либо исключение возбудит конструктор копирования Bitmap), то Widget также будет содержать указатель на несуществующий Bitmap. Такие указатели – источник неприятностей. Их нельзя безопасно удалить, их даже нельзя разыменовывать. А вот потратить массу времени на отладку, выясняя, откуда они взялись, – это можно.</p>
      <p class="calibre2">К счастью, существует способ одновременно сделать operator= безопасным в смысле исключений и безопасным по части присваивания самому себе. Поэтому все чаще программисты не занимаются специально присваиванием самому себе, а сосредоточивают усилия на достижении безопасности в смысле исключений. В правиле 29 эта проблема рассмотрена детально, а сейчас достаточно упомянуть, что во многих случаях продуманная последовательность операторов присваивания может обеспечить безопасность в смысле исключений (а заодно безопасность присваивания самому себе) кода. Например, ниже мы просто не удаляем pb до тех пор, пока не скопируем то, на что он указывает:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget&amp; Widget::operator=(const Widget&amp; rhs)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Bitmap *pOrig = pb; // запомнить исходный pb</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pb = new Bitmap(*rhs.pb); // установить указатель pb на копию *pb</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete pOrig; // удалить исходный pb</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return *this;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Теперь, если «new Bitmap» возбудит исключение, то pb (и объект Widget, которому он принадлежит) останется неизменным. Даже без проверки на совпадение здесь обрабатывается присваивание самому себе, потому что мы сделали копию исходного объекта Bitmap, удалили его, а затем направили указатель на сделанную копию. Возможно, это не самый эффективный способ обработать присваивание самому себе, но он работает.</p>
      <p class="calibre2">Если вы печетесь об эффективности, то можете вернуть проверку на совпадение в начале функции. Но прежде спросите себя, как часто может происходить присваивание самому себе, потому что выполнение проверки тоже не обходится даром. Это делает код (исходный и объектный) чуть больше, а ветвление несколько снижает скорость исполнения. Эффективность предварительной выборки команд, кэширования и конвейеризации тоже может пострадать.</p>
      <p class="calibre2">Альтернативой ручному упорядочиванию предложений в operator= может быть обеспечение и безопасности в смысле исключений, и безопасности присваивания самому себе за счет применения техники «копирования с обменом» («copy and swap»). Она тесно связана с безопасностью в смысле исключений, поэтому рассматривается в правиле 29. Тем не менее это достаточно распространенный способ написания operator=, и на него стоит взглянуть:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void swap(Widget&amp; rhs); // обмен данными *this и rhs</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // см. подробности в правиле 29</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget&amp; Widget:: operator=(const Widget&amp; rhs)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Widget temp(rhs); // создать копию данных rhs</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">swap(tmp); // обменять данные *this с копией</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return *this;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Здесь мы пользуемся тем, что: (1) оператор присваивания можно объявить как принимающим аргумент по значению и (2) передача объекта по значению означает создание копии этого объекта (см. правило 20):</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget&amp; Widget::operator=(Widget rhs) // rhs – копия переданного объекта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ // обратите внимание на передачу по</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// значению</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">swap(rhs); // обменять данные *this с копией</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">return *this;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Лично меня беспокоит, что такой подход приносит ясность в жертву изощренности, но, перемещая операцию копирования из тела функции в конструирование параметра, компилятор иногда может сгенерировать более эффективный код.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Убедитесь, что operator= правильно ведет себя, когда объект присваивается самому себе. Для этого можно сравнить адреса исходного и целевого объектов, аккуратно упорядочить предложения или применить идиому копирования обменом.</p>
      <p class="calibre2">• Убедитесь, что все функции, оперирующие более чем одним объектом, ведут себя корректно при совпадении двух или более объектов.</p>
    </div>
  </div>

{% endraw %}

