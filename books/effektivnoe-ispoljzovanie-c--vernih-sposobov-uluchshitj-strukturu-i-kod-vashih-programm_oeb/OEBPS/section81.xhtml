---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section80.xhtml
next: OEBPS/section82.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 48: Изучите метапрограммирование шаблонов</h2>
      </div>
      <p class="calibre2">Метапрограммирование шаблонов (template metaprogramming – TMP) – это процесс написания основанных на шаблонах программ на C++, исполняемых во время компиляции. На минуту задумайтесь об этом: шаблонная метапрограмма – это программа, написанная на C++, которая исполняется <em class="calibre5">внутри компилятора C+ +.</em> Когда TMP-программа завершает исполнение, ее результат – фрагменты кода на C++, конкретизированные из шаблонов, – компилируется как обычно.</p>
      <p class="calibre2">Если эта идея не поразила вас до глубины души, значит, вы недостаточно напряженно думали о ней.</p>
      <p class="calibre2">C++ не предназначался для метапрограммирования шаблонов, но с тех пор, как технология TMP была открыта в начале 90-х годов, она оказалась настолько полезной, что, вероятно, и в сам язык, и в стандартную библиотеку будут включены расширения, облегчающие работу с TMP. Да, TMP было именно открыто, а не придумано. Средства, лежащие в основе TMP, появились в C++ вместе с шаблонами. Нужно было только, чтобы кто-то заметил, как они могут быть использованы изобретательным и неожиданным образом.</p>
      <p class="calibre2">Технология TMP дает два преимущества. Во-первых, она позволяет делать такие вещи, которые иными способами сделать было бы трудно либо вообще невозможно. Во-вторых, поскольку шаблонные метапрограммы исполняются во время компиляции C++, они могут переместить часть работы со стадии исполнения на стадию компиляции. В частности, некоторые ошибки, которые обычно всплывают во время исполнения, можно было бы обнаружить при компиляции. Другое преимущество – это то, что программы C++, написанные с использованием TMP, можно сделать эффективными почти во всех смыслах: компактность исполняемого, код быстродействия, потребления памяти. Но коль скоро часть работы переносится на стадию компиляции, то, очевидно, компиляция займет больше времени. Для компиляции программ, в которых применяется технология TMP, может потребоваться <em class="calibre5">намного</em> больше времени, чем для компиляции аналогичных программ, написанных без применения TMP.</p>
      <p class="calibre2">Рассмотрим псевдокод шаблонной функции advance, представленный на стр. 227 (см. правило 47; возможно, имеет смысл перечитать это правило сейчас, поскольку ниже я предполагаю, что вы знакомы с изложенным в нем материалом). Я выделил в этом фрагменте часть, написанную на псевдокоде:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename IterT, typename DistT&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void advance(IterT&amp; iter, DistT d)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (<em class="calibre5">iter является итератором с произвольным доступом</em>) {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">iter += d; // использовать итераторную арифметику</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // для итераторов с произвольным доступом</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(d&gt;=0) {while (d–) ++iter;} // вызывать ++ или – в цикле</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else {while(d++) –iter;} // для итераторов других категорий</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Мы можем использовать typeid, чтобы заменить псевдокод реальным кодом. Тогда задача будет решена «нормальным» для C++ способом – вся работа выполняется во время исполнения:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename IterT, typename DistT&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void advance(IterT&amp; iter, DistT d)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category)==</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typeid(std::random_access_iterator_tag))</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">iter += d; // использовать итеративную арифметику</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">} // для итераторов с произвольным доступом</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(d&gt;=0) {while (d–) ++iter;} // вызывать ++ или – в цикле</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else {while(d++) –iter;} // для итераторов других категорий</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В правиле 47 отмечено, что подход, основанный на typeid, менее эффективен, чем при использовании классов-характеристик, поскольку в этом случае: (1) проверка типа происходит во время исполнения, а не во время компиляции, и (2) код, выполняющий проверку типа, должен быть включен в исполняемую программу. Фактически этот пример показывает, как технология TMP может порождать более эффективные программы на C++, потому что характеристики – это и <em class="calibre5">есть</em> частный случай TMP. Напомню, что характеристики делают возможным вычисление выражения if…else во время компиляции.</p>
      <p class="calibre2">Я уже отмечал выше, что некоторые вещи технология TMP позволяет сделать проще, чем «нормальный» C++, и advance можно считать иллюстраций этого утверждения. В правиле 47 упоминается о том, что основанная на typeid реализация advance может привести к проблемам во время компиляции, и вот вам пример такой ситуации:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">std::list&lt;int&gt;::iterator iter;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">advance(iter, 10); // сдвинуть iter на 10 элементов вперед</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// не скомпилируется для приведенной</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// выше реализации</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Рассмотрим версию advance, которая будет сгенерирована для этого вызова. После подстановки типов iter и 10 в качестве параметров шаблона IterT и DistT мы получим следующее:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void advance(std::list&lt;int&gt;::iterator&amp; iter, int d)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if (typeid(std::iterator_traits&lt;std::list&lt;int&gt;::iterator&gt;::iterator_category)==</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">typeid(std::random_access_iterator_tag))</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">iter += d; // ошибка!</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">if(d&gt;=0) {while (d–) ++iter;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">else {while(d++) –iter;}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Проблема в выделенной строке, где встречается оператор +=. В данном случае мы пытаемся использовать += для типа list&lt;int&gt;::iterator, но list&lt;int&gt;::iterator – это двунаправленный итератор (см. правило 47), поэтому он не поддерживает +=. Оператор += поддерживают только итераторы с произвольным доступом. Мы знаем, что никогда не попытаемся исполнить предложение, содержащее +=, потому что для list&lt;int&gt;::iterator проверка с привлечением typeid никогда не выполнится успешно, но компилятор-то обязан гарантировать, что весь исходный код корректен, даже если он никогда не исполняется, а «iter += d» – некорректный код в случае, когда iter не является итератором с произвольным доступом. Решение же на основе технологии TMP предполагает, что код для разных типов вынесен в разные функции, каждая из которых использует только операции, применимые к типам, для которых она написана.</p>
      <p class="calibre2">Было доказано, что технология TMP представляет собой полную машину Тьюринга, то есть обладает достаточной мощью для любых вычислений. Используя TMP, вы можете объявлять переменные, выполнять циклы, писать и вызывать функции и т. д. Но такие конструкции выглядят совершенно иначе, чем их аналоги из «нормального» C++. Например, в правиле 47 показано, как в TMP условные предложения if…else выражаются с помощью шаблонов и их специализаций. Но такие конструкции можно назвать «TMP уровня ассемблера». В библиотеках для работы с TMP (например, MPL из Boost – см. правило 55) предлагается более высокоуровневый синтаксис, хотя его также нельзя принять за «нормальный» С++.</p>
      <p class="calibre2">Чтобы взглянуть на TMP с другого боку, посмотрим, как там выглядят циклы. Технология TMP не предоставляет настоящих циклических конструкций, поэтому цикл моделируется с помощью рекурсии. (Если вы не очень уверенно владеете рекурсией, придется освоиться с ней прежде, чем приступать к использованию TMP. Ведь TMP – по существу функциональный язык, а для таких языков рекурсия – то же, что телевидение для американской поп-культуры – неотъемлемая принадлежность.) Но и рекурсия-то не совсем обычная, поскольку при реализации циклов TMP нет рекурсивных вызовов функций, а есть рекурсивные <em class="calibre5">конкретизации шаблонов.</em></p>
      <p class="calibre2">Аналогом программы «Hello World» на TMP является вычисление факториала во время компиляции. Конечно, она, как и «Hello World», не поразит воображение, но обе полезны для демонстрации базовых возможностей языка. Вычисление факториала с помощью TMP сводится к последовательности рекурсивных конкретизаций шаблона. Кроме того, демонстрируется один из способов создания и использования переменных в TMP. Смотрите:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;unsigned n&gt; // общий случай: значение Factorial&lt;n&gt; – это</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">struct Factorial { // произведение n и Factorial&lt;n-1&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">enum { value = n*Factorial&lt;n-1&gt;::value };</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;&gt; // частный случай: значение Factorial&lt;0&gt; –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">struct Factorial&lt;0&gt; { // это 1</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">enum { value = 1 };</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Имея такую шаблонную метапрограмму (на самом деле просто единственную шаблонную метафункцию Factorial), вы получаете значение факториала n, обращаясь к Factorial&lt;n&gt;::value.</p>
      <p class="calibre2">Циклическая часть кода возникает там, где конкретизация шаблона Factorial&lt;n&gt; ссылается на конкретизацию шаблона Factorial&lt;n-1&gt;. Как во всякой рекурсивной программе, здесь есть особый случай, прекращающий рекурсию. В данном случае это специализация шаблона Factorial&lt;0&gt;.</p>
      <p class="calibre2">Каждая конкретизация шаблона Factorial является структурой struct, и в каждой структуре используется «трюк с перечислением» (см. правило 2) для объявления переменной TMP с именем value. В переменной value хранится текущее значение факториала. Если бы в TMP были настоящие циклы, то значение value обновлялось бы на каждой итерации цикла. Но поскольку в TMP место циклов заменяет рекурсивная конкретизация шаблонов, то каждая конкретизация получает свою собственную копию value, и значение копии соответствует «итерации цикла».</p>
      <p class="calibre2">Использовать Factorial можно следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">int main()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; Factorial&lt;5&gt;::value; // печатается 120</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::cout &lt;&lt; Factorial&lt;10&gt;::value; // печатается 3628800</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если вы находите описанный прием элегантным, значит, вы стали на путь превращения в метапрограммиста шаблонов. Если же все эти шаблоны, специализации, рекурсивные конкретизации, трюк с перечислением и необходимость набирать нечто вроде Factorial&lt;n-1&gt;::value не вызывают у вас восторга, стало быть, вы вполне нормальный программист C++.</p>
      <p class="calibre2">Конечно, шаблон Factorial в такой же мере демонстрирует полезность TMP, как «Hello World» – полезность любого обычного языка программирования. Чтобы понять, почему о TMP стоит знать, важно представлять себе, чего можно достичь с помощью этой технологии. Вот три примера:</p>
      <p class="calibre2">• <strong class="calibre4">Обеспечение корректности единиц измерения.</strong> В научных и инженерных приложениях важно, чтобы единицы измерения (например, массы, расстояния, времени и т. п.) правильно сочетались. Присваивание переменной, представляющей массу, значения переменной, представляющей скорость, – это ошибка, но деление переменной расстояния на переменную времени и присваивание результата переменной скорости правильно. Используя TMP, можно обеспечить (во время компиляции), что все комбинации единиц измерения в программе будут корректны, независимо от того, насколько сложны вычисления. (Это пример того, как можно использовать TMP для ранней диагностики ошибок.) Одним интересным аспектом такого использования TMP может быть поддержка вычисления дробных степеней. Смысл в том, чтобы дроби сокращались во время компиляции, то есть чтобы компилятор мог подтвердить, например, что единица времени в степени 1/2 – это то же самое, что единица времени в степени 4/8.</p>
      <p class="calibre2">• <strong class="calibre4">Оптимизация операций с матрицами.</strong> В правиле 21 объясняется, что некоторые функции, включая operator*, должны возвращать новые объекты, а в правиле 44 представлен класс SquareMatrix, поэтому рассмотрим такой код:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">typedef SquareMatrix&lt;double, 10000&gt; BigMatrix;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">BigMatrix m1, m2, m3, m4, m5; // создать матрицы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // и присвоить им значения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">BigMatrix result = m1 * m2 * m3 * m4 * m5; // вычислить произведение</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Вычисление result «нормальным» способом приводит к созданию четырех временных матриц, по одной для каждого вызова operator*. Более того, независимые операции умножения порождают последовательность из четырех циклов по элементам матрицы. Но применение передовой шаблонной технологии, тесно связанной с TMP и получившей название <em class="calibre5">шаблоны выражений</em> (expression templates), позволяет избежать создания временных объектов и объединить циклы, причем все это без изменения приведенного выше пользовательского кода. В результате программа требует меньше памяти и выполняется значительно быстрее.</p>
      <p class="calibre2">
        <strong class="calibre4">• Генерация специализированных реализаций паттернов проектирования.</strong> Паттерны проектирования, подобные Strategy (см. правило 35), Observer, Visitor и т. п., могут быть реализованы многими способами. Используя основанную на TMP технологию, называемую <em class="calibre5">проектирование на основе политик</em> (policy-based design), можно создавать шаблоны, представляющие независимые проектные решения («политики»), которые могут быть соответствующим образом скомбинированы для порождения реализаций паттернов с заданным поведением. Например, эта техника применялась для того, чтобы из нескольких шаблонов, реализующих различное поведение «интеллектуальных» указателей, породить (во время компиляции) любой из <em class="calibre5">сотен</em> разных типов «интеллектуальных» указателей. В результате обобщения, выходящего за рамки привычных программных конструкций, к примеру паттернов проектирования и «интеллектуальных» указателей, эта технология ложится в основу так называемого <em class="calibre5">порождающего программирования</em> (generative programming).</p>
      <p class="calibre2">Технология TMP предназначена не для всех. Применяемый в ней синтаксис интуитивно не очевиден, а поддерживающий инструментарий не развит. (Отладчики для шаблонных метапрограмм? Ну насмешили, право!) Поскольку это вспомогательный язык, открытый сравнительно недавно, то применяемые в нем соглашения носят пока экспериментальный характер. Тем не менее повышение эффективности за счет переноса части со стадии исполнения на стадию компиляции может оказаться значительным, а возможность выразить поведение, которое трудно или невозможно реализовать во время исполнения, также весьма привлекательно.</p>
      <p class="calibre2">Поддержка TMP растет. Вероятно, в следующей версии C++ будет реализована явная поддержка этой технологии, в TR1 это уже декларировано (см. правило 54). Начали появляться книги, посвященные этой теме, а информация о TMP в Internet становится все богаче. Видимо, TMP никогда не станет главным направлением развития, но для некоторых программистов (особенно разработчиков библиотек) она почти наверняка займет важное место.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Метапрограммирование шаблонов позволяет перенести часть работы со стадии исполнения на стадию компиляции. За счет этого можно раньше обнаружить ошибки и повысить производительность программ.</p>
      <p class="calibre2">• Технология TMP может быть использована для генерации кода на основе комбинации политик, а также чтобы предотвратить генерацию кода, некорректного для определенных типов данных.</p>
    </div>
  </div>

{% endraw %}

