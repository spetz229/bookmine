---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section92.xhtml
next: OEBPS/section94.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Приложение А</h2>
        <h2 class="calibre3">За пределами «Эффективного использования C++»</h2>
      </div>
      <p class="calibre2">В книгу «Эффективное использование C++» вошло то, что я считаю наиболее важными рекомендациями для практикующих программистов на C++. Если вы интересуетесь дополнительными возможностями повысить эффективность своей работы, я рекомендую ознакомиться с другими моими книгами: «Наиболее эффективное использование C++» и «Эффективное использование STL».</p>
      <p class="calibre2">В книгу «Наиболее эффективное использование C++» включены дополнительные рекомендации и подробно рассмотрены такие темы, как эффективность и программирование с учетом исключений. Кроме того, в ней описываются такие важные приемы программирования на C++, как «интеллектуальные» указатели, подсчет ссылок и прокси-объекты.</p>
      <p class="calibre2">«Эффективное использование STL» – это тоже набор рекомендаций, организованный подобно «Эффективному использованию C++», но основное внимание в ней уделено применению стандартной библиотеки шаблонов.</p>
      <p class="calibre2">Содержание обеих книг приведено ниже.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <em class="calibre5">
            <strong class="calibre4">Наиболее эффективное использование C++</strong>
          </em>
        </p>
      </div>
      <p class="calibre2">
        <strong class="calibre4">Основы</strong>
      </p>
      <p class="calibre2">Параграф 1: Различайте указатели и ссылки</p>
      <p class="calibre2">Параграф 2: Предпочитайте приведение типов в стиле C++</p>
      <p class="calibre2">Параграф 3: Никогда не используйте полиморфизм в массивах</p>
      <p class="calibre2">Параграф 4: Избегайте неоправданных конструкторов по умолчанию</p>
      <p class="calibre2">
        <strong class="calibre4">Операторы</strong>
      </p>
      <p class="calibre2">Параграф 5: Опасайтесь определяемых пользователем функций преобразования типов</p>
      <p class="calibre2">Параграф 6: Различайте префиксную и постфиксную формы операторов инкремента и декремента</p>
      <p class="calibre2">Параграф 7: Никогда не перегружайте «&amp;&amp;», «||» или «,»</p>
      <p class="calibre2">Параграф 8: Различайте значение операторов new и delete</p>
      <p class="calibre2">
        <strong class="calibre4">Исключения</strong>
      </p>
      <p class="calibre2">Параграф 9: Чтобы избежать утечки ресурсов, используйте деструкторы</p>
      <p class="calibre2">Параграф 10: Не допускайте утечки ресурсов в конструкторах</p>
      <p class="calibre2">Параграф 11: Не распространяйте обработку исключений за пределы деструктора</p>
      <p class="calibre2">Параграф 12: Отличайте генерацию исключения от передачи параметра или вызова виртуальной функции</p>
      <p class="calibre2">Параграф 13: Перехватывайте исключения, передаваемые по ссылке</p>
      <p class="calibre2">Параграф 14: Разумно используйте спецификации исключений</p>
      <p class="calibre2">Параграф 15: Оценивайте затраты на обработку исключений</p>
      <p class="calibre2">
        <strong class="calibre4">Эффективность</strong>
      </p>
      <p class="calibre2">Параграф 16: Не забывайте о правиле «80–20»</p>
      <p class="calibre2">Параграф 17: Используйте отложенные вычисления</p>
      <p class="calibre2">Параграф 18: Снижайте затраты на ожидаемые вычисления</p>
      <p class="calibre2">Параграф 19: Изучите причины возникновения временных объектов</p>
      <p class="calibre2">Параграф 20: Облегчайте оптимизацию возвращаемого значения</p>
      <p class="calibre2">Параграф 21: Используйте перегрузку, чтобы избежать неявного преобразования типов</p>
      <p class="calibre2">Параграф 22: По возможности применяйте оператор присваивания вместо отдельного оператора</p>
      <p class="calibre2">Параграф 23: Используйте разные библиотеки</p>
      <p class="calibre2">Параграф 24: Учитывайте затраты, связанные с виртуальными функциями, множественным наследованием, виртуальными базовыми классами и RTTI</p>
      <p class="calibre2">
        <strong class="calibre4">Приемы</strong>
      </p>
      <p class="calibre2">Параграф 25: Делайте виртуальными конструкторы и функции, не являющиеся членами класса</p>
      <p class="calibre2">Параграф 26: Ограничивайте числа объектов в классе</p>
      <p class="calibre2">Параграф 27: В зависимости от ситуации требуйте или запрещайте размещать объекты в куче</p>
      <p class="calibre2">Параграф 28: Используйте интеллектуальные указатели</p>
      <p class="calibre2">Параграф 29: Используйте подсчет ссылок</p>
      <p class="calibre2">Параграф 30: Применяйте прокси-классы</p>
      <p class="calibre2">Параграф 31: Создавайте функции, виртуальные по отношению более чем к одному объекту</p>
      <p class="calibre2">
        <strong class="calibre4">Разное</strong>
      </p>
      <p class="calibre2">Параграф 32: Программируйте, заглядывая в будущее</p>
      <p class="calibre2">Параграф 33: Делайте нетерминальные классы абстрактными</p>
      <p class="calibre2">Параграф 34: Умейте использовать C++ и C в одной программе</p>
      <p class="calibre2">Параграф 35: Ознакомьтесь со стандартом языка</p>
      <div class="subtitle">
        <p class="subtitle1">
          <em class="calibre5">
            <strong class="calibre4">Эффективное использование STL</strong>
          </em>
        </p>
      </div>
      <p class="calibre2">
        <strong class="calibre4">Глава 1: Контейнеры</strong>
      </p>
      <p class="calibre2">Параграф 1: Проявляйте здравый смысл при выборе контейнера</p>
      <p class="calibre2">Параграф 2: Остерегайтесь иллюзий относительно контейнерно-независимого кода</p>
      <p class="calibre2">Параграф 3: Делайте копирование объектов в контейнерах дешевым и корректным</p>
      <p class="calibre2">Параграф 4: Вызывайте функцию empty вместо сравнения size() с нулем</p>
      <p class="calibre2">Параграф 5: Предпочитайте функции, работающие с диапазонами, их одноэлементным аналогам</p>
      <p class="calibre2">Параграф 6: Обращайте внимание на неприятные особенности синтаксического анализа в C++</p>
      <p class="calibre2">Параграф 7: При использовании контейнеров, хранящих указатели, выделенные new, не забывайте вызвать delete перед уничтожением контейнера</p>
      <p class="calibre2">Параграф 8: Никогда не помещайте объекты типа auto_ptr в контейнеры</p>
      <p class="calibre2">Параграф 9: Тщательно выбирайте способ очистки</p>
      <p class="calibre2">Параграф 10: Помните о соглашениях и ограничениях распределителей памяти</p>
      <p class="calibre2">Параграф 11: О правильном применении специализированных распределителей памяти</p>
      <p class="calibre2">Параграф 12: О реалистических ожиданиях относительно потоковой безопасности STL-контейнеров</p>
      <p class="calibre2">
        <strong class="calibre4">Глава 2: vector и string</strong>
      </p>
      <p class="calibre2">Параграф 13: Предпочитайте vector и string динамически выделенным массивам</p>
      <p class="calibre2">Параграф 14: Используйте reserve для избежания ненужных операций перераспределения памяти</p>
      <p class="calibre2">Параграф 15: Учитывайте различия в реализациях string</p>
      <p class="calibre2">Параграф 16: Как передавать vector и string унаследованным программным интерфейсам</p>
      <p class="calibre2">Параграф 17: Используйте «swap-трюк» для сокращения избыточной емкости</p>
      <p class="calibre2">Параграф 18: Избегайте применять vector&lt;bool&gt;</p>
      <p class="calibre2">
        <strong class="calibre4">Глава 3: Ассоциативные контейнеры</strong>
      </p>
      <p class="calibre2">Параграф 19: Разберитесь, чем равенство отличается от эквивалентности</p>
      <p class="calibre2">Параграф 20: Специфицируйте способ сравнения для ассоциативных контейнеров, содержащих указатели</p>
      <p class="calibre2">Параграф 21: Позаботьтесь о том, чтобы функции сравнения возвращали false для равных значений</p>
      <p class="calibre2">Параграф 22: Избегайте модификации ключей «по месту» в контейнерах set и multiset</p>
      <p class="calibre2">Параграф 23: Рассмотрите замену ассоциативных контейнеров отсортированными векторами</p>
      <p class="calibre2">Параграф 24: Тщательно выбирайте между map::operator[] и map::insert, когда важна эффективность.</p>
      <p class="calibre2">Параграф 25: Ознакомьтесь с нестандартными кэшированными контейнерами</p>
      <p class="calibre2">
        <strong class="calibre4">Глава 4: Итераторы</strong>
      </p>
      <p class="calibre2">Параграф 26: Старайтесь использовать iterator вместо const_iterator, reverse_iterator и const_reverse_iterator</p>
      <p class="calibre2">Параграф 27: Используйте distance и advance для преобразования const_iterator в iterator</p>
      <p class="calibre2">Параграф 28: Научитесь использовать базовый iterator, соответствующий reverse_iterator</p>
      <p class="calibre2">Параграф 29: Подумайте о применении istreambuf_iterator для посимвольного ввода</p>
      <p class="calibre2">
        <strong class="calibre4">Глава 5: Алгоритмы</strong>
      </p>
      <p class="calibre2">Параграф 30: Обеспечивайте достаточно большие целевые диапазоны при копировании</p>
      <p class="calibre2">Параграф 31: Изучите различные варианты сортировки</p>
      <p class="calibre2">Параграф 32: После вызова алгоритма remove или ему подобного не забывайте вызвать алгоритм erase, если действительно хотите что-то удалить</p>
      <p class="calibre2">Параграф 33: Будьте осторожны при использовании алгоритма remove и ему подобных для контейнеров, содержащих указатели</p>
      <p class="calibre2">Параграф 34: Не забывайте, что некоторые алгоритмы ожидают отсортированных диапазонов</p>
      <p class="calibre2">Параграф 35: Реализуйте простое независимое от регистра сравнение строк с помощью алгоритмов mismatch или lexicographical_compare</p>
      <p class="calibre2">Параграф 36: Разберитесь, как правильно реализовать алгоритм copy_if</p>
      <p class="calibre2">Параграф 37: Используйте accumulate или for_each для суммирования диапазонов</p>
      <p class="calibre2">
        <strong class="calibre4">Глава 6: Функторы, функторные классы, функции и т. п.</strong>
      </p>
      <p class="calibre2">Параграф 38: Проектируйте классы-функторы для передачи по значению</p>
      <p class="calibre2">Параграф 39: Делайте предикаты свободными функциями</p>
      <p class="calibre2">Параграф 40: Делайте классы-функторы адаптируемыми</p>
      <p class="calibre2">Параграф 41: Зачем нужны ptr_fun, mem_fun и mem_fun_ref</p>
      <p class="calibre2">Параграф 42: Убедитесь, что less&lt;T&gt; означает operator&lt;</p>
      <p class="calibre2">
        <strong class="calibre4">Глава 7: Программирование с использованием STL</strong>
      </p>
      <p class="calibre2">Параграф 43: Предпочитайте вызовы алгоритмов вручную написанным циклам</p>
      <p class="calibre2">Параграф 44: Предпочитайте функции-члены алгоритмам с теми же именами</p>
      <p class="calibre2">Параграф 45: О различиях между count, find, binary_search, lower_bound, upper_bound и equal_range.</p>
      <p class="calibre2">Параграф 46: Рассмотрите применение функциональных объектов вместо функций в качестве параметров алгоритмов</p>
      <p class="calibre2">Параграф 47: Избегайте создания кода «только для записи»</p>
      <p class="calibre2">Параграф 48: Всегда включайте необходимые заголовочные файлы</p>
      <p class="calibre2">Параграф 49: Научитесь понимать диагностические сообщения компилятора, касающиеся STL</p>
      <p class="calibre2">Параграф 50: Посещайте Web-сайты, посвященные STL</p>
    </div>
  </div>

{% endraw %}

