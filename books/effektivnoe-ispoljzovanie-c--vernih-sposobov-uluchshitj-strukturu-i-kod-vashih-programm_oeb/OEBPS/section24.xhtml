---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section23.xhtml
next: OEBPS/section25.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 7: Объявляйте деструкторы виртуальными в полиморфном базовом классе</h2>
      </div>
      <p class="calibre2">Существует много способов отслеживать время, поэтому имеет смысл создать базовый класс TimeKeeper и производные от него классы, которые реализуют разные подходы к хронометражу:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class TimeKeeper {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">TimeKeeper();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~TimeKeeper();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class AtomicClock: public TimeKeeper {…};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class WaterClock: public TimeKeeper {….};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class WristWatch: public TimeKeeper {…};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Многие клиенты захотят иметь доступ к данным о времени, не заботясь о деталях того, как они получаются, поэтому мы можем воспользоваться <em class="calibre5">фабричной функцией (factory function),</em> которая возвращает указатель на базовый класс созданного ей объекта производного класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">TimeKeeper *getTimeKeeper(); // возвращает указатель на динамически</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// выделенный объект класса,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// производного от TimeKeeper</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В соответствии с соглашением о фабричных функциях объекты, возвращаемые getTimeKeeper, выделяются из кучи, поэтому для того, чтобы избежать утечек памяти и других ресурсов, важно, чтобы каждый полученный объект был рано или поздно уничтожен:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">TomeKeeper *ptk = getTimeKeeper(); // получить динамически выделенный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// объект из иерархии TimeKeeper</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // использовать его</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete ptk; // уничтожить, чтобы избежать утечки</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// ресурсов</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как объясняется в правиле 13, полагаться на то, что объект уничтожит клиент, чревато ошибками, а в правиле 18 говорится, как можно модифицировать фабричную функцию для предотвращения наиболее частых ошибок в клиентской программе. Здесь же мы обсудим более серьезный недостаток приведенного выше кода: даже если клиент все делает правильно, мы не можем узнать, как будет вести себя программа.</p>
      <p class="calibre2">Проблема в том, что getTimeKeeper возвращает указатель на объект производного класса (например, AtomicClock), а удалять этот объект нужно через указатель на базовый класс (то есть на TimeKeeper), при этом в базовом классе (TimeKeeper) объявлен невиртуальный деструктор. Это прямой путь к неприятностям, потому что в спецификации C++ постулируется, что когда объект производного класса уничтожается через указатель на базовый класс с невиртуальным деструктором, то результат не определен. Во время исполнения это обычно приводит к тому, что часть объекта, принадлежащая производному классу, никогда не будет уничтожена. Если getTimeKeeper() возвращает указатель на объект класс AtomicClock, то часть объекта, принадлежащая AtomicClock (то есть данные-члены, объявленные в этом классе), вероятно, не будут уничтожены, так как не будет вызван деструктор AtomicClock. Те же члены, что относятся к базовому классу (то есть TimeKeeper), будут уничтожены, что приведет к появлению так называемых «частично разрушенных» объектов. Это верный путь к утечке ресурсов, повреждению структур данных и проведению изрядного времени в обществе отладчика.</p>
      <p class="calibre2">Решить эту проблему легко: нужно объявить в базовом классе виртуальный деструктор. Тогда при удалении объектов производных классов будет происходить именно то, что нужно. Объект будет разрушен целиком, включая все его части:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class TimeKeeper {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">TimeKeeper();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual ~TimeKeeper();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">TimeKeeper *ptk = get TimeKeeper();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete ptk; // теперь работает правильно</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Обычно базовые классы вроде TimeKeeper содержат и другие виртуальные функции, кроме деструктора, поскольку назначение виртуальных функций – обеспечить возможность настройки производных классов (см. правило 34). Например, в классе TimeKeeper может быть определена виртуальная функция getCurrentTime, реализованная по-разному в разных производных классах. Любой класс с виртуальными функциями почти наверняка должен иметь виртуальный деструктор.</p>
      <p class="calibre2">Если же класс не имеет виртуальных функций, это часто означает, что он не предназначен быть базовым. А в таком классе определять виртуальный деструктор не стоит. Рассмотрим класс, представляющий точку на плоскости:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Point { // точка на плоскости</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Point(int xCoord, int yCoord);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">~Point();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">private:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">int x,y;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если int занимает 32 бита, то объект Point обычно может поместиться в 64-битовый регистр. Более того, такой объект Point может быть передан как 64-битовое число функциям, написанным на других языках (таких как C или FORTRAN). Если же деструктор Point сделать виртуальным, то ситуация изменится.</p>
      <p class="calibre2">Для реализации виртуальных функций необходимо, чтобы в объекте хранилась информация, которая во время исполнения позволяет определить, какая виртуальная функция должна быть вызвана. Эта информация обычно представлена указателем на таблицу виртуальных функций vptr (virtual table pointer). Сама таблица – это массив указателей на функции, называемый vtbl (virtual table). С каждым классом, в котором определены виртуальные функции, ассоциирована таблица vtbl. Когда для некоторого объекта вызывается виртуальная функция, то с помощью указателя vptr в таблице vtbl ищется та реальная функция, которую нужно вызвать.</p>
      <p class="calibre2">Детали реализации виртуальных функций не важны. Важно то, что если класс Point содержит виртуальную функцию, то объект этого типа увеличивается в размере. В 32-битовой архитектуре его размер возрастает с 64 бит (два целых int) до 96 бит (два int плюс vptr); в 64-битовой архитектуре он может вырасти с 64 до 128 бит, потому что указатели в этой архитектуре имеют размер 64 бита. Таким образом, добавление vptr к объекту Point увеличивает его размер на величину от 50 до 100 %! После этого объект Point уже не может поместиться в 64-битный регистр. Более того, объекты этого типа в C++ перестают выглядеть так, как аналогичные структуры, объявленные на других языках, например на C, потому что в других языках нет понятия vptr. В результате становится невозможно передавать объекты типа Point написанным на других языках программам, если только вы не учтете наличия vptr. А это уже деталь реализации, и, следовательно, такой код не будет переносимым.</p>
      <p class="calibre2">Практический вывод из всего вышесказанного состоит в том, что необоснованно объявлять все деструкторы виртуальными так же неверно, как не объявлять их виртуальными никогда. Можно высказать этот совет и в таком виде: деструкторы следует объявлять виртуальными тогда, когда в классе есть хотя бы одна виртуальная функция.</p>
      <p class="calibre2">Однако невиртуальные деструкторы могут стать причиной неприятностей даже при полном отсутствии в классе виртуальных функций. Например, в стандартном классе string нет виртуальных функций, но программисты временами все же используют его как базовый класс:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class SpecialString: public std::string { // плохо! std::string содержит</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // невиртуальный деструктор</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">На первый взгляд такой код может показаться безвредным, но если где-то в приложении вы преобразуете указатель на SpecialString в указатель на string, а затем выполните для этого указателя delete, то немедленно попадете в область неопределенного поведения:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">SpecialString *pss = new SpecialString(“Надвигающаяся опасность”);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string *ps;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">ps = pss; // SpecialString*=&gt;std::string*</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">delete ps; // неопределенность! На практике ресурсы, выделенные</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// объекту SpecialString, не будут освобождены, потому</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// что деструктор SpecialString не вызывается</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">То же относится к любому классу, в котором нет виртуального деструктора, в частности ко всем типам STL-контейнеров (например, vector, list, set, tr1::unordered_map [см. правило 54] и т. д.). Если у вас когда-нибудь возникнет соблазн унаследовать стандартному контейнеру или любому другому классу с невиртуальным деструктором, воздержитесь! (К сожалению, в C++ не предусмотрено никакого механизма предотвращения наследования, как, скажем, final в языке Java, или sealed в C#).</p>
      <p class="calibre2">Иногда может быть удобно добавить в класс чисто виртуальный деструктор. Вспомним, что чисто виртуальные функции порождают <em class="calibre5">абстрактные</em> классы, то есть классы, экземпляры которых создать нельзя. Иногда, однако, у вас есть класс, который вы хотели бы сделать абстрактным, но в нем нет ни одной пустой виртуальной функции. Что делать? Поскольку абстрактный класс предназначен для использования в качестве базового и поскольку базовый класс должен иметь виртуальный деструктор, а чисто виртуальная функция порождает абстрактный класс, то решение очевидно: объявить чисто виртуальный деструктор в классе, который вы хотите сделать абстрактным. Вот пример:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class AWOV { // AWOV = “Abstract w/o Virtuals”</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">virtual ~AWOV() = 0; // объявление чисто виртуального</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}; // деструктора</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Этот класс включает в себя чисто виртуальную функцию, поэтому он абстрактный. А раз в нем объявлен виртуальный деструктор, то можно не беспокоиться о том, что деструкторы базовых классов не будут вызваны. Однако есть одна тонкость: вы должны предоставить <em class="calibre5">определение</em> чисто виртуального деструктора:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">AWOV::~AWOV(){}; // определение чисто виртуального деструктора</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Дело в том, что сначала всегда вызывается деструктор «самого производного» класса (то есть находящегося на нижней ступени иерархии наследования), а затем деструкторы каждого базового класса. Компилятор сгенерирует вызов ~AWOV из деструкторов производных от него классов, а значит, вы должны позаботиться о его реализации. Если этого не сделать, компоновщик будет недоволен.</p>
      <p class="calibre2">Правило включения в базовые классы виртуальных деструкторов касается только <em class="calibre5">полиморфных</em> базовых классов, то есть таких, которые позволяют манипулировать объектами производных классов с помощью указателя на базовый. TimeKeeper – полиморфный базовый класс, мы ожидаем, что при наличии указателя на объект TimeKeeper сможем манипулировать объектами AtomicClock и WaterClock.</p>
      <p class="calibre2">Не все базовые классы разрабатываются с учетом полиморфизма. Например, и стандартный тип string, и типы STL-контейнеров спроектированы так, что не допускают возможности использования в качестве базовых, так как не являются полиморфными. Некоторые классы предназначены служить в качестве базовых, но полиморфно использоваться не могут; примером могут служить класс Uncopyable из правила 6 и класс input_iterator_tag из стандартной библиотеки (см. правило 47). Таким классам не нужны виртуальные деструкторы.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Полиморфные базовые классы должны объявлять виртуальные деструкторы. Если класс имеет хотя бы одну виртуальную функцию, он должен иметь виртуальный деструктор.</p>
      <p class="calibre2">• В классах, не предназначенных для использования в качестве базовых или для полиморфного применения, не следует объявлять виртуальные деструкторы.</p>
    </div>
  </div>

{% endraw %}

