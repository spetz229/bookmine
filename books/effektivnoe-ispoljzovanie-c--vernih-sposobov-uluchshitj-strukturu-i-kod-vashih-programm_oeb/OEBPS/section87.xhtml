---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section86.xhtml
next: OEBPS/section88.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 52: Если вы написали оператор new с размещением, напишите и соответствующий оператор delete</h2>
      </div>
      <p class="calibre2">Операторы new и delete с размещением встречаются в C++ не слишком часто, поэтому в том, что вы с ними не знакомы, нет ничего страшного. Вспомните (правила 16 и 17), что когда вы пишете такое выражение new:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw = new Widget;</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то вызываются две функции: оператор new, чтобы выделить память, и конструктор Widget по умолчанию.</p>
      <p class="calibre2">Предположим, что первый вызов завершился успешно, а второй возбудил исключение. В этом случае необходимо отменить выделение памяти, выполненное на шаге 1. В противном случае мы получим утечку памяти. Пользовательский код не может освободить память, потому что конструктор Widget возбудил исключение и pw ничего так и не было присвоено. Следовательно, пользователь так и не получил указатель на память, которая должна быть освобождена. Поэтому ответственность за отмену шага 1 возлагается на систему времени исполнения C++.</p>
      <p class="calibre2">Исполняющая система рада бы вызвать оператор delete, соответствующий использованному на шаге 1 оператору new, но сделать это может лишь тогда, когда знает, какой именно вариант оператора delete – а их много – нужно вызвать. Это не проблема, если вы пользуетесь формами new и delete с обычными сигнатурами, потому что обычный оператор new:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void *operator new(std::size_t size) throw(std::bad_alloc);</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">соответствует обычному оператору delete:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void operator delete(void *rawMemory) throw(); // обычная сигнатура</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в глобальной области</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// видимости</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void operator delete(void *rawMemory, // наиболее распространенная</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::size_t size) throw(); // сигнатура в области</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// видимости класса</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если вы пользуетесь только обычными формами new и delete, то исполняющая система легко найдет тот вариант delete, который знает, как отменить действие, выполненное оператором new. Проблема поиска правильного варианта delete возникает тогда, когда вы объявляете необычные формы оператора new – такие, которые принимают дополнительные параметры.</p>
      <p class="calibre2">Например, предположим, что вы написали оператор new уровня класса, который требует задания потока ofstream, куда должна выводиться отладочная информация о выделении памяти, и вместе с ним написали также обычный оператор delete уровня класса:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std:size_t size, // необычная</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::ostream&amp; logStream) // форма new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory, // обычная</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std:size_t size) throw(); // форма delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// уровня класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Такое решение наверняка приведет к ошибкам, но чтобы понять, почему это так, придется познакомиться с некоторыми терминами.</p>
      <p class="calibre2">Функция operator new, принимающая дополнительные параметры (помимо обязательного аргумента size_t), называется <em class="calibre5">оператором new с размещением</em> или <em class="calibre5">размещающим оператором new</em> (placement new). Приведенный выше оператор new как раз и является таковым. Особенно полезным бывает размещающий оператор new, для которого вторым аргументом служит указатель на область памяти, где объект должен быть сконструирован. Этот оператор new выглядит так:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void *operator new(std::size_t, void *pMemory) throw(); // “размещающий new”</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Эта версия new является частью стандартной библиотеки C++, и вы получаете к ней доступ, включая в исходный текст директиву #include &lt;new&gt;. Кстати говоря, такой оператор new используется в реализации класса vector для создания объектов в выделенной для вектора памяти. Это также <em class="calibre5">первоначальная</em> версия оператора new с размещением; именно она и получила название «placement new». Таким образом, сам термин «размещающий new» перегружен. Обычно, когда говорят о <em class="calibre5">размещающем</em> new, имеют в виду эту конкретную функцию: оператор new, принимающий дополнительный аргумент типа void*. Реже так говорят о любой другой версии new, принимающей дополнительные аргументы. Обычно контекст исключает противоречивые толкования, но важно понимать, что общий термин <em class="calibre5">«размещающий</em> new» означает любую версию new, принимающую дополнительные аргументы, поскольку выражение <em class="calibre5">«размещающий</em> delete» или «delete <em class="calibre5">с размещением»</em> (которое мы сейчас обсудим) происходит от него.</p>
      <p class="calibre2">Но вернемся к объявлению класса Widget, которое я не одобрил. Проблема в том, что этот класс открывает возможность утечки памяти. Рассмотрим следующий пользовательский код, который протоколирует информацию о выделении памяти в поток cerr при динамическом создании объектов Widget:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw = new (std::cerr) Widget; // вызвать оператор new, передав cerr</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// в качестве параметра типа ofstream;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// <em class="calibre5">это ведет к утечке памяти в случае,</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// <em class="calibre5">когда конструктор Widget возбуждает</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// <em class="calibre5">исключение</em></code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если выделение памяти прошло успешно, но конструктор Widget возбуждает исключение, то исполняющая система отвечает за освобождение той памяти, которую успел выделить оператор new. Исполняющая система понятия не имеет, как работает вызванная версия оператора new, поэтому не может отменить результат операции самостоятельно. Вместо этого исполняющая система ищет версию оператора delete, которая принимает <em class="calibre5">то же количество аргументов того же типа,</em> что и new, и если находит его, то вызывает. В данном случае оператор new принимает дополнительный аргумент типа ostream&amp;, поэтому соответствующий оператор delete должен иметь следующую сигнатуру:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void operator delete(void *, std::ostream&amp;) throw();</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">По аналогии с размещающими версиями new версии оператора delete, которые принимают дополнительные параметры, называются <em class="calibre5">размещающими delete.</em> Но в классе Widget не объявлена размещающая версия оператора delete, поэтому исполняющая система не знает, как отменить то, что сделал размещающий new. В результате она не делает ничего. В этом примере <em class="calibre5">никакой оператор delete не вызывается,</em> если конструктор Widget возбуждает исключение!</p>
      <p class="calibre2">Правило простое: если оператору new с дополнительными аргументами не соответствует оператор delete с такими же аргументами, то никакой delete не вызывается в случае необходимости отменить выделение памяти, выполненное new. Чтобы избежать утечек памяти в приведенном выше коде, Widget должен объявить размещающий оператор delete, который соответствует размещающему оператору new, который выполняет протоколирование:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std:size_t size, std::ostream&amp; logStream)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory) throw();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory, std::ostream&amp; logStream)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw();</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">С этим изменением, если конструктор Widget возбудит исключение в предложении</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">Widget *pw = new (std::cerr) Widget; // как раньше, но теперь никаких</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// утечек</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то автоматически будет вызван соответственный размещающий оператор delete, так что Widget гарантирует, что никаких утечек памяти по этой причине не будет.</p>
      <p class="calibre2">Посмотрим, что произойдет, если никаких исключений нет (как обычно и бывает), а в пользовательском коде присутствует явный вызов delete:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">delete pw; // вызов обычного оператора delete</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как сказано в комментарии, здесь вызывается обычный оператор delete, а не размещающая версия. Размещающий delete вызывается, <em class="calibre5">только</em> если возбуждает исключение конструктор, следующий за вызовом размещающего new. Если delete применяется к указателю (в примере выше – pw), то версия delete с размещением <em class="calibre5">никогда</em> не будет вызвана.</p>
      <p class="calibre2">Это значит, что для предотвращения всех утечек памяти, ассоциированных с размещающей версией new, вы должны также предоставить и обычный оператор delete (на случай, если в конструкторе не возникнет исключений), и размещающую версию с теми же дополнительными аргументами, что и у размещающего new (если таковой имеется). Поступайте так, и вы никогда не потеряете сон из-за неуловимых утечек памяти. Ну, по крайней мере, из-за утечек памяти <em class="calibre5">по этой причине.</em></p>
      <p class="calibre2">Кстати, поскольку имена функций-членов скрывают одноименные функции в объемлющих контекстах (см. правило 33), вы должны быть осторожны, чтобы избежать того, что операторы new уровня класса скроют другие версии new (в том числе обычные), на которые рассчитывают пользователи. Например, если у вас есть базовый класс, в котором объявлена только размещающая версия оператора new, пользователи обнаружат, что обычная форма new стала недоступной:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size, // скрывает обычные</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::ostream&amp; logStream) // глобальные формы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(std::bad_alloc);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Base *pb = new Base; // ошибка! Обычная форма</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// оператора new скрыта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Base *pb = new (std::cerr)Base; // правильно, вызывается</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// размещающий new из Base</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Аналогично оператор new в производных классах скрывает и глобальную, и унаследованную версии оператора new:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Derived: public Base {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size) // переопределяет</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(std::bad_alloc); // обычную форму new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Derived *pd = new (std::cerr)Derived; // ошибка! заменяющая</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// форма теперь скрыта</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Derived *pd = new Derived; // правильно, вызывается</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// оператор new из Derived</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">В правиле 33 достаточно подробно рассмотрен этот вид сокрытия имен в классе, но при написании функций распределения памяти нужно помнить, что по умолчанию C++ представляет следующие формы оператора new в глобальной области видимости:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">void operator new(std::size_t) throw(bad_alloc); // обычный new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void operator new(std::size_t, void*) throw(bad_alloc); // размещающий new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void operator new(std::size_t, // new, не возбуждающий</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">const std::nothrow_t&amp;) throw(); // исключений –</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// см. правило 49</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Если вы объявляете любой оператор new в классе, то тем самым скрываете все эти стандартные формы. Убедитесь, что вы сделали их доступными в дополнение к любым специальным формам new, объявленным вами в классе, если только в ваши намерения не входит запретить использование этих форм пользователям класса. И для каждого оператора new, к которому вы даете доступ, должен быть также предоставлен соответствующий оператор delete. Если вы хотите, чтобы эти функции вели себя обычным образом, просто вызывайте соответствующие глобальные их версии из своих функций.</p>
      <p class="calibre2">Самый простой способ – создать базовый класс, содержащий все нормальные формы new и delete:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class StandardNewDeleteForms {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// нормальные new/delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size) throw(bad_alloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return ::operator new(size);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ ::operator delete(pMemory);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// размещающие new/delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size, void *ptr) throw(bad_alloc)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return ::operator new(size, ptr);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory, void *ptr) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ ::operator delete(pMemory, ptr);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// не возбуждающие исключений new/delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t, const std::nothrow_t&amp; nt) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ return ::operator new(size, nt)}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory, const std::nothrow_t&amp;) throw()</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{ ::operator delete(pMemory, nt);}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Пользователи, которые хотят пополнить свой арсенал специальными формами new, применяют наследование и using-объявления (см. правило 33), чтобы получить доступ к стандартным формам:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class Widget: public StandardNewDeleteForms { // наследование</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // стандартных форм</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using StandardNewDeleteForms::operator new; // сделать эти формы</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using StandardNewDeleteForms::operator delete; // видимыми</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void *operator new(std::size_t size, // добавляется</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::ostream&amp; logStream) // специальный</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(bad_alloc); // размещающий new</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">static void operator delete(void *pMemory, // добавляется</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::ostream&amp; logStream) // соответствующий</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">throw(); // размещающий delete</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• Когда вы пишете размещающую версию оператора new, убедитесь, что не забыли о соответственном размещающем операторе delete. Если его не будет, то в вашей программе могут возникать тонкие, трудноуловимые утечки памяти.</p>
      <p class="calibre2">• Объявляя размещающие версии new и delete, позаботьтесь о том, чтобы нечаянно не скрыть нормальных версий этих функций.</p>
    </div>
  </div>

{% endraw %}

