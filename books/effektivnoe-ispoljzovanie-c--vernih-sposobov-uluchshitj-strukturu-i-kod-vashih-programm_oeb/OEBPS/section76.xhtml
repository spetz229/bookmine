---
layout: page
title: "Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ"
prev: OEBPS/section75.xhtml
next: OEBPS/section77.xhtml
book_path: books/effektivnoe-ispoljzovanie-c--vernih-sposobov-uluchshitj-strukturu-i-kod-vashih-programm_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <div class="calibre">
      <div class="title1">
        <h2 class="calibre3">Правило 43: Необходимо знать, как обращаться к именам в шаблонных базовых классах</h2>
      </div>
      <p class="calibre2">Предположим, что нам нужно написать программу, которая будет посылать сообщения нескольким компаниям. Сообщения должны отправляться как в зашифрованной форме, так и в форме открытого текста. Если во время компиляции у нас достаточно информации для определения того, какие сообщения должны быть отправлены каким компаниям, то мы можем прибегнуть к решению, основанному на шаблонах:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class CompanyA {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearText(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendEncryptedText(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class CompanyB{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearText(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendEncryptedText(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // классы для других компаний</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class MsgInfo {...}; // класс, содержащий информацию,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// используемую для создания</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// сообщения</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">template&lt;typename Company&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class MsgSender {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // конструктор, деструктор и т. п.</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClear(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">std::string msg;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">создать msg из info</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">Company c;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">c.sendClearText(msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendSecret(const MsgInfo&amp; info) // аналогично sendClear, но вызывает</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{...} // c.sendEncrypted</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Эта программа будет работать. Но предположим, что иногда мы хотим протоколировать некоторую информацию при отправке сообщений. Такую возможность легко добавить, написав производный класс, и, на первый взгляд, разумно это сделать следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename Company&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearMsg(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">записать в протокол перед отправкой;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">sendClear(info); // вызвать функцию из базового класса</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// <em class="calibre5">этот код не будет компилироваться!</em></code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">записать в протокол после отправки;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Отметим, что функция, отправляющая сообщение, в производном классе называется иначе (sendClearMsg), чем в базовом (sendClear). Это хорошее решение, потому что таким образом мы обходим проблему сокрытия унаследованных имен (см. правило 33), а равно сложности, возникающие при переопределении наследуемых невиртуальных функций (см. правило 36). Но этот код не будет компилироваться, по крайней мере, компилятором, совместимым со стандартом. Такой компилятор решит, что функции sendClear не существует. Мы видим, что эта функция определена в базовом классе, но компилятор не станет искать ее там. Попытаемся понять – почему.</p>
      <p class="calibre2">Проблема в том, что когда компилятор встречает определение шаблона класса LoggingMsgSender, он не знает, какому классу тот наследует. Понятно, что классу MsgSender&lt;Company&gt;, но Company – параметр шаблона, который не известен до момента конкретизации LoggingMsgSender. Не зная, что такое Company, невозможно понять, как выглядит класс MsgSender&lt;Company&gt;. В частности, не существует способа узнать, есть ли в нем функция sendClear.</p>
      <p class="calibre2">Чтобы яснее почувствовать, в чем сложность, предположим, что у нас есть класс CompanyZ, описывающий компанию, которая настаивает на том, чтобы все сообщения шифровались:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">class CompanyZ { // этот класс не представляет</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // функции sendCleartext</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendEncrypted(const std::string&amp; msg);</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Общий шаблон MsgSender не подходит для CompanyZ, потому что в нем определена функция sendClear, которая для объектов класса CompanyZ не имеет смысла. Чтобы решить эту проблему, мы можем создать специализированную версию MsgSender для CompanyZ:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;&gt; // полная специализация MsgSender;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class MsgSender &lt;CompanyZ&gt; { // отличается от общего шаблона</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public: // только отсутствием функции</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // sendCleartext</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendSecret(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{...}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Обратите внимание на синтаксическую конструкцию «template&lt;&gt;» в начале определения класса. Она означает, что это и не шаблон, и не автономный класс. Это специализированная версия шаблона MsgSender, которая должна использоваться, если параметром шаблона является CompanyZ. Называется это <em class="calibre5">полной специализацией шаблона</em> : шаблон MsgSender специализирован для типа CompanyZ, и эта специализация применяется, коль скоро в качестве параметра указан тип CompanyZ, никакие другие особенности параметров шаблона во внимание не принимаются.</p>
      <p class="calibre2">Имея специализацию шаблона MsgSender для CompanyZ, снова рассмотрим производный класс LoggingMsgSender:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename Company&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearMsg(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">записать в протокол перед отправкой;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">sendClear(info); // если Company == CompanyZ,</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// то этой функции не существует</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">записать в протокол после отправки;</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Как следует из комментария, этот код просто не имеет смысла, если базовым классом является MsgSender&lt;CompanyZ&gt;, так как в нем нет функции sendClear. Поэтому C++ отвергнет такой вызов; компилятор понимает, что шаблон базового класса можно специализировать, и интерфейс, предоставляемый этой специализацией, может быть не таким, как в общем шаблоне. В результате компилятор обычно не ищет унаследованные имена в шаблонных базовых классах. В некотором смысле, когда мы переходим от «объектно-ориентированного C++» к «C++ с шаблонами» (см. правило 1), наследование перестает работать.</p>
      <p class="calibre2">Чтобы исправить ситуацию, нужно как-то заставить C++ отказаться от догмы «не заглядывай в шаблонные базовые классы». Добиться этого можно тремя способами. Во-первых, можно предварить обращения к функциям из базового класса указателем this:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename Company&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearMsg(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">записать в протокол перед отправкой</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">this-&gt;sendClear(info); // порядок! Предполагается, что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">// sendClear будет унаследована</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">
          <em class="calibre5">записать в протокол после отправки</em>
        </code>
      </p>
      <p class="calibre2">
        <code class="calibre7">;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Во-вторых, можно воспользоваться using-объявлением. Мы уже обсуждали эту тему в правиле 33, где было сказано, что using-объявлением делает скрытые имена из базового класса видимыми в производном классе. Поэтому мы можем переписать sendClearMsg следующим образом:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename Company&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">public:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">using MsgSender&lt;Company&gt;::sendClear; // сообщает компилятору о том, что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // sendClear есть в базовом классе</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearMsg(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">sendClear(info); // нормально, предполагается, что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // sendClear будет унаследована</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Хотя using-объявление будет работать как здесь, так и в правиле 33, но используются они для решения разных задач. Здесь проблема не в том, что имена из базового класса скрыты за именами, объявленными в производном классе, а в том, что компилятор вообще не станет производить поиск в области видимости базового класса, если только вы явно не попросите его об этом.</p>
      <p class="calibre2">И последний способ заставить ваш код компилироваться – явно указать, что вызываемая функция находится в базовом классе:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">template &lt;typename Company&gt;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">pubilc:</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">void sendClearMsg(const MsgInfo&amp; info)</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">{</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">MsgSender&lt;Company&gt;::sendClear(info); // нормально, предполагается, что</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // sendClear будет унаследована</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">}</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">...</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">};</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">Но этот способ хуже прочих, посколько если вызываемая функция виртуальна, то явная квалификация отключает динамическое связывание.</p>
      <p class="calibre2">С точки зрения видимости имен, все три подхода эквивалентны: они обещают компилятору, что любая специализация шаблона базового класса будет поддерживать интерфейс, предоставленный общим шаблоном. Такое обещание – это все, что необходимо компилятору во время синтаксического анализа производного шаблонного класса, подобного LoggingMsgSender, но если данное обещание не будет выполнено, истина всплывет позже. Например, если в программе есть такой код:</p>
      <p class="empty-line"> </p>
      <p class="calibre2">
        <code class="calibre7">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">MsgInfo msgData;</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">... // поместить info в msgData</code>
      </p>
      <p class="calibre2">
        <code class="calibre7">zMsgSender.sendClearMsg(msgData); // ошибка! не скомпилируется</code>
      </p>
      <p class="empty-line"> </p>
      <p class="calibre2">то вызов sendClearMsg не скомпилируется, потому что в этой точке компилятор знает, что базовый класс – это специализация шаблона MsgSender&lt;CompanyZ&gt; и в нем нет функции sendClear, которую sendClearMsg пытается вызвать.</p>
      <p class="calibre2">Таким образом, суть дела в том, когда компилятор диагностирует неправильные обращения к членам базового класса – раньше (когда анализируются определения шаблонов производного класса) или позже (когда эти шаблоны конкретизируются переданными в шаблон аргументами). C++ предпочитает раннюю диагностику, и поэтому предполагает, что о содержимом базовых классов, конкретизируемых из шаблонов, не известно ничего.</p>
      <div class="subtitle">
        <p class="subtitle1">
          <strong class="calibre4">
            <em class="calibre5">Что следует помнить</em>
          </strong>
        </p>
      </div>
      <p class="calibre2">• В шаблонах производных классов ссылки на имена из шаблонов базовых классов осуществляются с помощью префикса «this-&gt;», using-объявления либо посредством явного указания базового класса.</p>
    </div>
  </div>

{% endraw %}

