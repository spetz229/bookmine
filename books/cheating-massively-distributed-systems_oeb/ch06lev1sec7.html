---
layout: page
title: "Exploiting Online Games: Cheating Massively Distributed Systems"
prev: ch06lev1sec6.html
next: ch06lev1sec8.html
book_path: books/cheating-massively-distributed-systems_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<a name="toppage" class="pcalibre calibre1"></a><table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody"><tr valign="top" class="calibre2"><td class="calibre3"><a name="MainContent" class="pcalibre calibre1"></a><table width="95%" class="sfbody"><tr class="calibre2"><td class="pcalibre1 v"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2" class="calibre4"><tr class="calibre2"><td valign="middle" class="v1 pcalibre1" height="5"><img src="pixel.gif" alt="" border="0" class="calibre5"/></td></tr><tr class="calibre2"><td valign="middle" class="v1 pcalibre1"><table cellpadding="0" cellspacing="0" border="0" width="100%" class="calibre4"><tr class="calibre2"><td class="calibre6"><span class="calibre7"> </span>
                   
                  <span class="calibre7">   </span>
             <span class="calibre7"> </span></td></tr></table></td><td class="calibre8"/><td valign="middle" class="v2 pcalibre1"> 
           
          <span class="calibre7"><a target="_self" href="ch06lev1sec6.html" title="Previous section" class="pcalibre calibre1"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre16"/></a></span>
				
				 
				
				<span class="calibre7"><a target="_self" href="ch06lev1sec8.html" title="Next section" class="pcalibre calibre1"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre16"/></a></span></td></tr></table><div id="section" class="calibre15"><table width="100%" border="0" cellspacing="0" cellpadding="0" class="calibre4"><tr class="calibre2"><td valign="top" class="calibre8">Security Game Programming Networking Programming Greg Hoglund Gary McGraw Addison Wesley Professional Exploiting Online Games: Cheating Massively Distributed Systems<a name="ch06lev1sec7" class="pcalibre calibre1"></a>
<h3 id="title-IDA3Y13H" class="docSection1Title">Getting Under the Game: Manipulating Rendering Information</h3>
<p class="docText">As we have noted, game client software often relies on calling into functionality below it to get things done. One classic approach to game hacking is to get under the game by getting down to graphics.</p>
<p class="docText">All objects in the online game world must eventually be rendered. That means that the locations of all 3D-rendered objects are eventually pushed out to the video card for graphics processing.</p>
<p class="docText"><a name="iddle1787" class="pcalibre calibre1"></a><a name="iddle1933" class="pcalibre calibre1"></a><a name="iddle1935" class="pcalibre calibre1"></a><a name="iddle2179" class="pcalibre calibre1"></a><a name="iddle2283" class="pcalibre calibre1"></a>Even if you have no clue how to obtain object location information outside of the game client, you can be sure that it will eventually end up in the video card in a standard format for rendering. Unlike video games of old, 3D games today all use industry-standard APIs for rendering. Examples of standard packages are OpenGL and Direct3D. But under these programming APIs exists yet another standard—the video hardware standard itself.</p>
<p class="docText">As usual, specifics may help clarify things. NVIDIA cards, a popular video card for gamers, all use a documented format for video information. That means that at some layer in the rendering chain, you can access a known format and in this way obtain the exact coordinates of objects in the field of vision.</p>
<a name="ch06lev2sec20" class="pcalibre calibre1"></a>
<h4 id="title-IDAW013H" class="docSection2Title">3D = X Y Z</h4>
<p class="docText">Anyone who has taken a computer graphics course knows that by using some simple geometry (or better yet, some linear algebra), you can determine where you stand relative to other objects. Automatically calculating how to move toward objects, how to aim at them, and how to flee from them is often valuable information indeed.</p>
<a name="ch06lev2sec21" class="pcalibre calibre1"></a>
<h4 id="title-IDAC113H" class="docSection2Title">Wall Hacking</h4>
<p class="docText">First-person shooter games were the first computer games in which simple geometric hacks were used. One great example of a hardware-level or API-level hack has come to be known as <span class="docEmphasis">wall hacking</span>. This cheat is used to this day in online FPS games. The idea is simple and elegant: Make walls transparent so that you can tell even from around the corner when someone is sneaking up on you. This allows you to play with a definite unfair advantage. (See <a class="pcalibre6 pcalibre5 calibre1" href="ch02.html#ch02">Chapter 2</a>.)</p>
<p class="docText">The server-side game program itself cannot afford to calculate when it should and should not show you an object in your field of vision. This can get complicated when objects such as walls occlude other objects such as enemies. Instead, the game server sends all of the objects down the rendering pipeline, and the video card itself computes when your vision is blocked by a wall. That means by reading the video buffer, you can tell where everything is. It's not much of a move after that to overlay the information on the screen. Or, even better, you can find the wall object in the video buffer and just change its texture identifier to "transparent"—in which case, the wall simply disappears.</p>
<p class="docText">Interestingly, many times the game client can't control this type of information because it has already relinquished rendering control to the video card. Naturally, the video card becomes a target.</p>
<a name="ch06lev2sec22" class="pcalibre calibre1"></a>
<h4 id="title-IDA5113H" class="docSection2Title">DLL Injection</h4>
<p class="docText"><a name="iddle1409" class="pcalibre calibre1"></a><a name="iddle1411" class="pcalibre calibre1"></a><a name="iddle1928" class="pcalibre calibre1"></a><a name="iddle1930" class="pcalibre calibre1"></a>The most common method for introducing new code into an application (including a game client) is known as DLL injection. With this method, you force the remote process to load a new DLL of your own design. The DLL can then take subsequent steps to hook functions or otherwise modify the target program memory space. DLL injection is by no means the stealthiest of approaches (in fact, it's fairly easy to spot, and a number of common countermeasures are set up to do so), but it is very convenient. We cover more stealthy approaches later in this chapter.</p>
<p class="docText">The trick with DLL injection is to make an existing thread in the target process jump to a code snippet that calls <tt class="calibre38">LoadLibrary</tt>. This idea has multiple instantiations. Some people prefer to create a new thread using <tt class="calibre38">CreateRemoteThread</tt>. The technique we show you here doesn't create any new threads—it just hijacks an existing thread for the loading operation.</p>
<p class="docText">First, you need to write code to the remote process that can load the DLL. We define a short code snippet for this purpose:</p>
<div class="docText1"><pre class="calibre43">char InjectedCodePage[4096] =
{      0xB8, 00, 00, 00, 00,
       // mov EAX,  0h | Pointer to LoadLibraryA() (DWORD)
       0xBB, 00, 00, 00, 00,
       // mov EBX,  0h | DLLName to inject (DWORD)
       0x53,                              // push EBX
       0xFF, 0xD0,                        // call EAX
       0x5b,                              // pop EBX
       0xcc                               // INT 3h
       // DLL name string will be placed here
};
int length_of_injection_code=15;
</pre></div><br class="calibre15"/>
<p class="docText">Our code above has some placeholders that need to be filled in: the address of <tt class="calibre38">LoadLibraryA()</tt> and a pointer to the name of the DLL we wish to load. To get the address of <tt class="calibre38">LoadLibrary</tt>, we simply assume it will be at the same address in the remote process as well as our own. We have never seen a situation where this wasn't the case, so we consider this safe:</p>
<div class="docText1"><pre class="calibre43">       FARPROC LoadLibProc = GetProcAddress(
               GetModuleHandle("KERNEL32.dll"),
               "LoadLibraryA");
</pre></div><br class="calibre15"/>
<p class="docText">For the DLL name, we are going to write the string to the region of memory that directly follows the above code snippet. That is, we'll write at offset 15. We calculate all the offsets we are going to use here:</p>
<div class="docText1"><pre class="calibre43">       char *DLLName;
       DWORD *EAX, *EBX;
       ///////////////////////////////////////////////////////////
       // pointers to be used for "stamping" values into the
       // injection code (see below)
       ///////////////////////////////////////////////////////////
       DLLName = (char*)((DWORD)InjectedCodePage
              + length_of_injection_code);
       EAX = (DWORD*)( InjectedCodePage +  1);
       EBX = (DWORD*) ( InjectedCodePage +  6);
</pre></div><br class="calibre15"/>
<p class="docText"><a name="iddle1626" class="pcalibre calibre1"></a>Now we have pointers to both placeholder addresses, as well as to the spot where we are going to write the DLL name. We can't fill in the values yet because we haven't written the code to remote process memory yet. Remember, we need to use the remote address values, not the local ones!</p>
<p class="docText">You might notice the embedded <tt class="calibre38">INT3</tt> in the code snippet. Our system is designed to be combined with a debugger. The embedded breakpoint will be used to signal that the injected code snippet has finished executing. Before we get to that, however, let's explore how we find a location to inject code into.</p>
<p class="docText">In the following code, we assume that we have connected a debugger and that the initial debugger breakpoint has fired. If this is an attach operation, a new thread will have been created for the initial breakpoint event. This thread will be the one we hijack to run the injected code snippet. We obtain a handle to this thread from within the debug event loop:</p>
<div class="docText1"><pre class="calibre43">hThread = fOpenThread(
              THREAD_ALL_ACCESS,
              FALSE,
              dbg_evt.dwThreadId );
</pre></div><br class="calibre15"/>
<p class="docText">Don't forget to close this handle when you're done with it!</p>
<p class="docText">The DLL name will be a fully qualified path to the DLL we wish to inject. <tt class="calibre38">hProcess</tt> is the handle to the remote process we are debugging. The <tt class="calibre38">hModuleBase</tt> can be obtained from the debug event loop, or you can safely assume that it is <tt class="calibre38">0x00400000</tt> (as it almost always is). If you want to obtain it from the debug event loop, use the following snippet:</p>
<div class="docText1"><pre class="calibre43">if(dbg_evt.dwDebugEventCode==CREATE_PROCESS_DEBUG_EVENT)
{
       hModuleBase = dbg_evt.u.CreateProcessInfo.lpBaseOfImage;
}
</pre></div><br class="calibre15"/>
<p class="docText">The next step in our injection is to locate a valid executable section of memory in the remote process. The process involves a lot of ugly pointer arithmetic to scan the remote process's PE header. First we need to find the DOS header:</p>
<div class="docText1"><pre class="calibre43">res = ReadProcessMemory(
       hProcess,
       hModuleBase,
       &amp;DOShdr,
       sizeof(DOShdr),
       &amp;read);
if( (!res) || (read!=sizeof(DOShdr)) )
{
  printf("Could not get DOS header\n");
  return FALSE;
}
</pre></div><br class="calibre15"/>
<p class="docText">Now we double-check that the <tt class="calibre38">MZ</tt> characters are present. This is a magic string used with the DOS header:</p>
<div class="docText1"><pre class="calibre43">if( DOShdr.e_magic != IMAGE_DOS_SIGNATURE ) //Check for 'MZ
{
  printf("Could not find MZ for DOS header\n");
  return FALSE;
}
</pre></div><br class="calibre15"/>
<p class="docText">We can now parlay the DOS header information to find the NT header information.</p>
<div class="docText1"><pre class="calibre43">//Get NT header
res = ReadProcessMemory(
       hProcess,
       (VOID*)((DWORD)hModuleBase +
       (DWORD)DOShdr.e_lfanew),
       &amp;NThdr,
       sizeof(NThdr),
       &amp;read);

if( (!res) || (read!=sizeof(NThdr)) )
{
  printf("Could not get NT header\n");
  return FALSE;
}
</pre></div><br class="calibre15"/>
<p class="docText">Again, we check for the magic string—in this case <tt class="calibre38">PE</tt>:</p>
<div class="docText1"><pre class="calibre43">//Check for 'PE\0\0
if( NThdr.Signature != IMAGE_NT_SIGNATURE )
{
  printf("Could not find PE in NT header\n");
  return 0;
}
</pre></div><br class="calibre15"/>
<p class="docText">We arrive here if we have a valid .<tt class="calibre38">exe</tt> header. We now look for a usable writable code page:</p>
<div class="docText1"><pre class="calibre43">if( (dwD=NThdr.FileHeader.NumberOfSections) &lt; 1 )
{
  printf("No sections to scan!\n");
  return FALSE;//Section table: (after optional header)
}

// nasty ptr arithmetic (yucky PE)
pSecHdr = (IMAGE_SECTION_HEADER*)
       (
       ((DWORD)hModuleBase + (DWORD)DOShdr.e_lfanew) +
       (DWORD)sizeof(NThdr.FileHeader) +
       (DWORD)NThdr.FileHeader.SizeOfOptionalHeader + 4
       );

res=FALSE;
dwD2 = (DWORD)GetModuleHandle(0);

for( dwD2=0 ; dwD2&lt;dwD ; dwD2++ )
{
</pre></div><br class="calibre15"/>
<p class="docText">Next we iterate sections to look for a writable part of memory that is <span class="docEmphasis">not</span> <tt class="calibre38">.idata</tt>. We don't want to mess with <tt class="calibre38">.idata</tt> since it's required for the correct operation of the program:</p>
<div class="docText1"><pre class="calibre43">         if( !ReadProcessMemory(
                hProcess,
                pSecHdr,
                &amp;SecHdr,
                sizeof(SecHdr),
                &amp;read) )
         {
           printf("ReadProcessMemory failed, error %08X\n",
GetLastError());
           return FALSE;
         }
        if(read != sizeof(SecHdr))
        {
          printf("section size mismatch!\n");
          return FALSE;
        }

      printf("looking at target section, %s\n", SecHdr.Name);

      //writable section? And
      //not .idata (import data)

      if(
       (SecHdr.Characteristics &amp; IMAGE_SCN_MEM_WRITE)&amp;&amp;
       ( strcmpi((const char*)SecHdr.Name, ".idata")!=NULL ))
      {
        printf("FOUND useable code page: %s\n",
               SecHdr.Name );

        res = TRUE;
        break;//OK!!
       }

      pSecHdr++;
    }

    if(!res)
    {
      printf("couldn't find usable code page!\n");
      return FALSE;
    }
</pre></div><br class="calibre15"/>
<p class="docText">We arrive here if we found a writable code section. We are going to write our code snippet to this location after we preserve what is originally found here.</p>
<div class="docText1"><pre class="calibre43">    gRemoteSectionPtr = (VOID*)(SecHdr.VirtualAddress +
                        (DWORD)hModuleBase);
    printf("Using section pointer 0x%08X\n", gRemoteSectionPtr);
</pre></div><br class="calibre15"/>
<p class="docText">Now that we know the real address in remote memory, we can go ahead and "stamp" the correct values into our placeholder addresses:</p>
<div class="docText1"><pre class="calibre43">strcpy( DLLName, DllName );
*EAX = (DWORD)LoadLibProc;
*EBX = length_of_injection_code + (DWORD)gRemoteSectionPtr;
</pre></div><br class="calibre15"/>
<p class="docText">Next we save the original code that is in the target memory so we can put it back when we are done:</p>
<div class="docText1"><pre class="calibre43">if(!ReadProcessMemory(
       hProcess,
       gRemoteSectionPtr,
       gOriginalCodePage,
       gSizeOfRemoteCodePage,
       &amp;read) )
{
  printf("ReadProcessMemory failed, error %08X\n",
         GetLastError());
  return FALSE;
}

if(read != gSizeOfRemoteCodePage)
{
  printf("Could not write the correct number of bytes\n");
  return FALSE;
}

printf("writing new code to remote address 0x%08X\n",
       gRemoteSectionPtr);
</pre></div><br class="calibre15"/>
<p class="docText">Next we write our injected code into the remote process memory:</p>
<div class="docText1"><pre class="calibre43">       res = WriteProcessMemory(
              hProcess,
              gRemoteSectionPtr,
              InjectedCodePage,
              gSizeOfRemoteCodePage,
              &amp;written);

       if( (written!=0) &amp;&amp; (written!=gSizeOfRemoteCodePage) )
       {
         printf("Error writing injection code. Remote process MAY
CRASH\n");

       // try to save face and put the old code back...
       WriteProcessMemory(
              hProcess,
              gRemoteSectionPtr,
              gOriginalCodePage,
              gSizeOfRemoteCodePage, &amp;written);
       return FALSE;
       }

       if((!res) || (written!=gSizeOfRemoteCodePage))
       {
         printf("Error injecting code\n");
         return FALSE;
       }
</pre></div><br class="calibre15"/>
<p class="docText">Now comes the fun part! We have injected code into a remote memory location, and we now hijack a remote thread (the primary thread in the remote process) and force its execution instruction pointer (EIP) to point to the new code location:</p>
<div class="docText1"><pre class="calibre43">       printf("setting thread EIP to 0x%08X\n", gRemoteSectionPtr);

       Context = gRemoteThreadOriginalContext;
       Context.Eip = (DWORD)gRemoteSectionPtr;
       res = SetThreadContext(hThread, &amp;Context);
       if(!res)
       {
         printf("Error, could not set remote thread EIP, process
MAY CRASH\n");
         return FALSE;
       }
</pre></div><br class="calibre15"/>
<p class="docText">The code snippet will have caused the DLL in question to load. Now what remains is to put back the original code and restore the original thread context. Remember that when the snippet is done, it will execute a breakpoint instruction (<tt class="calibre38">INT3</tt>). Because we are attached with a debugger, we can catch this event, put back the original code page, and restore the thread.</p>
<div class="docText1"><pre class="calibre43">if(EXCEPTION_BREAKPOINT ==
       dbg_evt.u.Exception.ExceptionRecord.ExceptionCode)
       &amp;&amp;
       g_codepage_breakpoint_has_fired == FALSE )
{
       //////////////////////////////////////////////////
       // the breakpoint in our injected code has fired
       // this means the "injected" DLL has been loaded
       // and it's now time to fix the remote exe
       // back to normal and let the DLL do the rest
       // of the work.
       //////////////////////////////////////////////////
       CONTEXT ctx;

       ctx.ContextFlags = CONTEXT_FULL;
       if(!GetThreadContext(hThread, &amp;ctx))
       {
         printf("[!] GetThreadContext failed ! \n");
         return 0;
       }

       printf("Hit codepage breakpoint\n");
       printf("EAX: 0x%08X\n", ctx.Eax);
       printf("EIP: 0x%08X\n", ctx.Eip);

       g_codepage_breakpoint_has_fired = TRUE;
</pre></div><br class="calibre15"/>
<p class="docText">The <tt class="calibre38">RestoreOriginalCodePage</tt> function just puts back our saved version of what we overwrote.</p>
<div class="docText1"><pre class="calibre43">       RestoreOriginalCodePage( hTargetProc, hThread, 0);

       // we are done using the debugging loop
       bDoneDebugging = TRUE;
}
</pre></div><br class="calibre15"/>
<p class="docText">Note that after the code page is restored, we exit the debugger. If we wanted to, we could keep the debugger running and use the injected DLL in conjunction with it. There are many options at this point, and the way forward depends on what you want to do.</p>
<p class="docText">The <tt class="calibre38">RestoreOriginalCodePage</tt> function is very simple:</p>
<div class="docText1"><pre class="calibre43">DWORD RestoreOriginalCodePage(
       HANDLE hProcess,
       HANDLE hThread,
       DWORD *outSize )
{
       BOOL res;
       DWORD written;
       CONTEXT Context;
       if(outSize) *outSize = gSizeOfRemoteCodePage;

       Context.ContextFlags = CONTEXT_FULL;
       GetThreadContext( hThread, &amp;Context);

       printf("Restoring original code to remote section ptr
0x%08X, len %d\n",
              gRemoteSectionPtr,
              gSizeOfRemoteCodePage);

       res = WriteProcessMemory(
              hProcess,
              gRemoteSectionPtr,
              gOriginalCodePage,
              gSizeOfRemoteCodePage,
              &amp;written );

       if(!res)
       {
         printf("WriteProcessMemory error %08X\n",
              GetLastError());
         return -1;
       }

       if(written!=gSizeOfRemoteCodePage)
       {
         return written+1;
       }

       res=SetThreadContext(
              hThread,
              (CONST CONTEXT*)&amp;gRemoteThreadOriginalContext);
       if(!res)
       {
         printf("SetThreadContext error %08X\n", GetLastError());
         return -1;
       }

       return 0;
}
</pre></div><br class="calibre15"/>
<p class="docText">We've just covered a very advanced technique that allows injection and removal from a running program. This technique is still actively used in game hacking.</p>
<a name="ch06lev3sec19" class="pcalibre calibre1"></a>
<h5 id="title-IDACG23H" class="docSection3Title">Pondering Attacker-in-the-Middle DLLs</h5>
<p class="docText"><a name="iddle1044" class="pcalibre calibre1"></a><a name="iddle1247" class="pcalibre calibre1"></a><a name="iddle1401" class="pcalibre calibre1"></a><a name="iddle1402" class="pcalibre calibre1"></a><a name="iddle1796" class="pcalibre calibre1"></a><a name="iddle1925" class="pcalibre calibre1"></a><a name="iddle1926" class="pcalibre calibre1"></a><a name="iddle1932" class="pcalibre calibre1"></a><a name="iddle1934" class="pcalibre calibre1"></a><a name="iddle2184" class="pcalibre calibre1"></a><a name="iddle2284" class="pcalibre calibre1"></a>A much easier way to inject a DLL is simply to replace an existing DLL that the program depends on with your Trojan'ed copy. Your replacement DLL must either forward function calls to the original DLL (the easiest way to mimic functionality) or replicate the functionality of the DLL itself. This can be cumbersome if the DLL supports a lot of functions. This is particularly problematic if the DLL is updated on a regular basis during patching. Overall, the Trojan replacement technique is no longer in wide use. Historically, this technique was used to hook into the rendering chain with OpenGL for wall-hacking cheats in FPS games. One good example is the wall hack associated with Call of Duty 2.</p>
<p class="docText">Calling conventions are very important when creating a replacement DLL. You must adhere to the exact function arguments, types, and calling conventions when exporting your attacker-in-the-middle functions. If you don't, the linker will not be able to resolve the call and the DLL will not load. Subsequently, the game program will throw up an error dialog stating it could not find a required DLL.</p>
<p class="docText">Some programs may check the version of the DLL before use. A DLL contains housekeeping data in the form of strings, including the name of the manufacturer, the version number, and a human-readable name for the DLL. With the right tool, you can modify all of these strings. A number of PE editing utilities available for free on the Net will do this for you.</p>
<a name="ch06lev3sec20" class="pcalibre calibre1"></a>
<h5 id="title-IDAJJ23H" class="docSection3Title">Direct3D, DirectX Specifics</h5>
<p class="docText">Getting back to the graphics story, a common method for intercepting Direct3D or OpenGL rendering data is to replace the original DLL installed by the game with a Trojan version that interposes in an attacker-in-the-middle sense. A Trojan DLL is usually set up to pass through all system calls, keeping an eye on things as they go by and changing things when it's convenient. By interposing between the game client and the video system, a Trojan DLL can hijack, intercept, and alter any rendering function call.</p>
<p class="docText">As an example, a wall hack may selectively alter the rendering setting for certain objects, making them show through walls. Or maybe it will alter colors, making enemies appear to be fluorescent orange.</p>
<a name="ch06lev2sec23" class="pcalibre calibre1"></a>
<h4 id="title-IDA1J23H" class="docSection2Title">Hiding Injected DLLs</h4>
<p class="docText"><a name="iddle1408" class="pcalibre calibre1"></a><a name="iddle1785" class="pcalibre calibre1"></a><a name="iddle1927" class="pcalibre calibre1"></a>Injected DLLs are very popular, so some games have started scanning for injected DLLs. A DLL can be loaded and removed from the loaded modules list, however, and will escape detection as a loaded DLL. That doesn't mean the DLL's memory is safe, however.</p>
<p class="docText">To remove a DLL from the loaded module list, you can adapt a solution based on the NtIllusion rootkit available for download at &lt;<a class="pcalibre6 pcalibre5 calibre1" target="_blank" href="http://www.rootkit.com">http://www.rootkit.com</a>&gt;. What follows is a short description of how NtIllusion removes DLLs from the linked list of loaded modules.</p>
<p class="docText">Three different doubly linked lists are referenced from the PEB. We saw earlier how to get the PEB pointer in a remote process. Remember that now we are within an injected DLL, so we don't have the overhead of using remote process calls. Instead, we can just reference the memory directly since it's local (this makes things a bit easier, eh?).</p>
<p class="docText">The following call is intended to be called with the list identifier that should be examined for the DLL in question. To be complete, you would want to call this function three times, once for each list: <tt class="calibre38">LOAD_ORDER_TYPE</tt>, <tt class="calibre38">MEM_ORDER_TYPE</tt>, and <tt class="calibre38">INIT_ORDER_TYPE</tt>. All three lists are identical in regards to parsing and removing the DLL entry.</p>
<div class="docText1"><pre class="calibre43">#define LOWCASE(a) ((a&gt;='A' &amp;&amp; a&lt;='Z')?a-('Z'-'z'):a)
#define LOAD_ORDER_TYPE 0
#define MEM_ORDER_TYPE  1
#define INIT_ORDER_TYPE 2

int WalkModuleList(char ModuleListType, char *szDllToStrip)
{
       PLIST_ENTRY pUserModuleListHead, pUserModuleListPtr;
       PLIST_ENTRY *pHiddenModuleListPtr;

       int i;
       DWORD PebBaseAddr, dwOffset=0;
       DWORD ImageBase, ImageSize;
       PPEB_LDR_DATA pLdrData;
       PUNICODE_STRING pImageName;
       char szImageName[BUFMAXLEN]; // Non-unicode string
</pre></div><br class="calibre15"/>
<p class="docText">The following call gets the PEB pointer for local memory; see below for this function.</p>
<div class="docText1"><pre class="calibre43">       PebBaseAddr = GetPEB(0);
       if(PebBaseAddr == FUNC_ERROR)
         return 0;
         // PEB.ProcessModuleInfo = PEB + 0x0C
         pLdrData = (PPEB_LDR_DATA)(DWORD *)(*(DWORD *)
                (PebBaseAddr + PEB_LDR_DATA_OFFSET));
         if(!pLdrData-&gt;Initialized)
           return 0;

         // Init chained list head and offset
         if(ModuleListType == LOAD_ORDER_TYPE)
         {
           // LOAD_ORDER_TYPE
           pUserModuleListHead =
           pUserModuleListPtr =
           (PLIST_ENTRY)(&amp;(pLdrData-&gt;ModuleListLoadOrder));
           pHiddenModuleListPtr = &amp;pUserModuleListLoadOrder;
           dwOffset = 0x0;
         } else if(ModuleListType == MEM_ORDER_TYPE)
         {
           // MEM_ORDER_TYPE
           pUserModuleListHead =
           pUserModuleListPtr =
           (PLIST_ENTRY)(&amp;(pLdrData-&gt;ModuleListMemoryOrder));
           pHiddenModuleListPtr = &amp;pUserModuleListMemoryOrder;
           dwOffset = 0x08;
         } else if(ModuleListType == INIT_ORDER_TYPE)
         {
           // INIT_ORDER_TYPE
           pUserModuleListHead =
           pUserModuleListPtr =
           (PLIST_ENTRY)(&amp;(pLdrData-&gt;ModuleListInitOrder));
           pHiddenModuleListPtr = &amp;pUserModuleListInitOrder;
           dwOffset = 0x10;
         }
         else return 0;

         do
         {
           // Jump to next MODULE_ITEM structure
           pUserModuleListPtr = pUserModuleListPtr-&gt;Flink;
           pImageName = (PUNICODE_STRING)(
                       ((DWORD)(pUserModuleListPtr)) +
                       (LDR_DATA_PATHFILENAME_OFFSET-dwOffset));

           ImageBase = *(DWORD *)(((DWORD)
                       (pUserModuleListPtr)) +
                       (LDR_DATA_IMAGE_BASE-dwOffset));
           ImageSize = *(DWORD *)(((DWORD)(pUserModuleListPtr)) +
                       (LDR_DATA_IMAGE_SIZE-dwOffset));

           //Convert string from unicode and to lower case
           for(i=0; i &lt; (pImageName-&gt;Length)/2 &amp;&amp; i&lt;BUFMAXLEN;i++)
             szImageName[i] =
                    LOWCASE(*( (pImageName-&gt;Buffer)+(i) ));
             szImageName[i] = '\0';

             if( strstr((char*)szImageName, szDllToStrip) != 0 )
             {
</pre></div><br class="calibre15"/>
<p class="docText">If there is a filename match, we now hide the DLL. We remove the entry from the doubly linked list.</p>
<div class="docText1"><pre class="calibre43">             (pUserModuleListPtr-&gt;Blink)-&gt;Flink =
                    (pUserModuleListPtr-&gt;Flink);

             (pUserModuleListPtr-&gt;Flink)-&gt;Blink =
                    (pUserModuleListPtr-&gt;Blink);

              whImageBase = ImageBase;
              whImageSize = ImageSize;

             *pHiddenModuleListPtr = pUserModuleListPtr;
             }
         }
         while(pUserModuleListPtr-&gt;Flink != pUserModuleListHead);

         return 1;
}
</pre></div><br class="calibre15"/>
<p class="docText">At this point, if the DLL was found, it will have been stripped from the linked list. This doesn't affect the DLL's ability to work, and it prevents the DLL from showing up in the loaded modules list for the process. Remember, however, that the memory pages allocated for the DLL can still be read and accessed by any countermeasures.</p>
<p class="docText">Getting the PEB is straightforward when you're in local memory:</p>
<div class="docText1"><pre class="calibre43">DWORD dwPebBase
__asm
{
       push eax
       mov eax, FS:[0x30]
       mov [dwPebBase], eax
       pop eax
}
</pre></div><br class="calibre15"/>
<p class="docText"><a name="iddle1452" class="pcalibre calibre1"></a><a name="iddle1576" class="pcalibre calibre1"></a><a name="iddle1800" class="pcalibre calibre1"></a><a name="iddle1803" class="pcalibre calibre1"></a><a name="iddle1805" class="pcalibre calibre1"></a>As we can see, the PEB is referenced at offset <tt class="calibre38">0x30</tt> from the <tt class="calibre38">FS</tt> register.</p>
<a href="10061538.html" class="pcalibre calibre1"><img src="pixel.gif" alt="" border="0" class="calibre23"/></a><ul class="calibre18"></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2" class="calibre4"><tr class="calibre2"><td valign="middle" class="v1 pcalibre1" height="5"><img src="pixel.gif" alt="" border="0" class="calibre5"/></td></tr><tr class="calibre2"><td valign="middle" class="v1 pcalibre1"><table cellpadding="0" cellspacing="0" border="0" width="100%" class="calibre4"><tr class="calibre2"><td class="calibre6"><span class="calibre7"> </span>
                   
                  <span class="calibre7">   </span>
             <span class="calibre7"> </span></td></tr></table></td><td class="calibre8"/><td valign="middle" class="v2 pcalibre1"> 
           
          <span class="calibre7"><a target="_self" href="ch06lev1sec6.html" title="Previous section" class="pcalibre calibre1"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre16"/></a></span>
				
				 
				
				<span class="calibre7"><a target="_self" href="ch06lev1sec8.html" title="Next section" class="pcalibre calibre1"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre16"/></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2" class="calibre4"><tr class="calibre2"><td valign="top" class="calibre14"><span class="calibre7"></span></td></tr></table></div><!--IP User 2--></td></tr></table></td><td class="calibre3">
                         
                      </td></tr><tr class="calibre2"><td colspan="3" valign="bottom" class="calibre3"><br class="calibre15"/><p class="v5 pcalibre1"></p><br class="calibre15"/></td></tr></table></div>

{% endraw %}

