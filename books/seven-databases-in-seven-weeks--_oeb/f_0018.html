---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0017.html
next: f_0019.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N103C5" class="calibre18">2.2 Day 1: Relations, CRUD, and Joins</h2>
<p id="N103C9" class="calibre5">
  While we won’t assume you’re a relational database expert, we do assume you have confronted a database or two in the past. Odds are good that the database was relational. We’ll start with creating our own schemas and populating them. Then we’ll take a look at querying for values and finally what makes relational databases so special: the table join.
  </p>
<p id="N103CC" class="calibre5">
    Like most databases we’ll read about, Postgres provides a back-end server that does all of the work and a command-line shell to connect to the running server. The server communicates through port 5432 by default, which you can connect to with the <code class="cf">psql</code> shell.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">psql book</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N103F6" class="calibre5">
    PostgreSQL prompts with the name of the database followed by a hash mark if you run as an administrator and by dollar sign as a regular user. The shell also comes equipped with the best built-in documentation you will find in any console. Typing <code class="cf">\h</code> lists information about SQL commands, and <code class="cf">\?</code> helps with <code class="cf">psql</code>-specific commands, namely, those that begin with a backslash. You can find usage details about each SQL command in the following way:
  </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​book=<em class="comment"># \h CREATE INDEX</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Command:     <strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Description: define a new <strong class="prompt">index</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Syntax:​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> [ <strong class="prompt">UNIQUE</strong> ] <strong class="prompt">INDEX</strong> [ CONCURRENTLY ] [ name ] <strong class="prompt">ON</strong> <strong class="prompt">table</strong> [ <strong class="prompt">USING</strong> method ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ( { column | ( expression ) } [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | ...​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    [ WITH ( storage_parameter = value [, ... ] ) ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    [ TABLESPACE tablespace ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    [ <strong class="prompt">WHERE</strong> predicate ]​</code>​</div>
</td>
</tr>
</table>
<p id="N10462" class="calibre5">
    Before we dig too deeply into Postgres, it would be good to familiarize yourself with this useful tool. It’s worth looking over (or brushing up on) a few common commands, like <code class="cf">SELECT</code> or <code class="cf">CREATE TABLE</code>.
  </p>
<h3 class="calibre20">Starting with SQL</h3>
<p id="N1046F" class="calibre5">
    PostgreSQL follows the <span class="initials">SQL</span> convention of calling relations <code class="cf">TABLE</code>s, attributes <code class="cf">COLUMN</code>s, and tuples <code class="cf">ROW</code>s. For consistency we will use this terminology, though you may encounter the mathematical terms <span class="calibre6">relations</span>, <span class="calibre6">attributes</span>, and <span class="calibre6">tuples</span>.  For more on these concepts, see <a href="#sb.relations">​<em class="calibre6">Mathematical Relations</em>​</a>.
    </p>
<div class="sidebar" id="sb.relations">
<div class="sidebar-title">Mathematical Relations</div>
<div class="calibre2">
<p id="N104AC" class="calibre5">
        Relational databases are so named because they contain <span class="calibre6">relations</span> (i.e., tables), which are sets of <span class="calibre6">tuples</span> (i.e., rows), which map <span class="calibre6">attributes</span> to atomic values (for example, <code class="cf2">{name: ’Genghis Khan’, p.died_at_age: 65}</code>). The available attributes are defined by a <span class="calibre6">header</span> tuple of attributes mapped to some <span class="calibre6">domain</span> or constraining type (i.e., columns; for example, <code class="cf2">{name: string, age: int}</code>). That’s the gist of the relational structure.
      </p>
<p id="N104D3" class="calibre5">
        Implementations are much more practically minded than the names imply, despite sounding so mathematical. So, why bring them up? We’re trying to make the point that relational databases are <span class="calibre6">relational</span> based on mathematics. They aren’t relational because tables “relate” to each other via foreign keys. Whether any such constraints exist is beside the point.
      </p>
<p id="N104D9" class="calibre5">
        Though much of the math is hidden from you, the power of the model is certainly in the math. This magic allows users to express powerful queries and then lets the system optimize based on predefined patterns. RDBMSs are built atop a set-theory branch called <span class="calibre6">relational algebra</span>—a combination of selections (<code class="cf2">WHERE ...</code>), projections (<code class="cf2">SELECT ...</code>), Cartesian products (<code class="cf2">JOIN ...</code>), and more, as shown below:
      </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/postgres-ra2sql.png" alt="images/postgres-ra2sql.png" class="calibre27"/>
</div>
<p id="N104F0" class="calibre5">
        Imagining a relation as a physical table (an array of arrays, repeated in database introduction classes <span class="calibre6">ad infinitum</span>) can cause pain in practice, such as writing code that iterates over all rows. Relational queries are much more declarative than that, springing from a branch of mathematics known as <span class="calibre6">tuple relational calculus</span>, which can be converted to relational algebra. PostgreSQL and other RDBMSs optimize queries by performing this conversion and simplifying the algebra. You can see that the SQL in the diagram below is the same as the previous diagram.
      </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/postgres-trc2sql.png" alt="images/postgres-trc2sql.png" class="calibre27"/>
</div>
</div>
</div>
<h4 class="calibre21">Working with Tables</h4>
<p id="N10501" class="calibre5">
    PostgreSQL, being of the relational style, is a design-first datastore. First you design the schema, and then you enter data that conforms to the definition of that schema. </p>
<p id="N1050B" class="calibre5">
      Creating a table consists of giving it a name and a list of columns with types and (optional) constraint information. Each table should also nominate a unique identifier column to pinpoint specific rows. That identifier is called a <code class="cf">PRIMARY KEY</code>.  The <span class="initials">SQL</span> to create a <code class="cf">countries</code> table looks like this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> countries (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  country_code <strong class="prompt">char</strong>(2) <strong class="prompt">PRIMARY</strong> <strong class="prompt">KEY</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  country_name <strong class="prompt">text</strong> <strong class="prompt">UNIQUE</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
</table>
<p id="N1056A" class="calibre5">
      This new table will store a set of rows, where each is identified by a two-character code and the name is unique. These columns both have <span class="calibre6">constraints</span>. The <code class="cf">PRIMARY KEY</code> constrains the <code class="cf">country_code</code> column to disallow duplicate country codes. Only one <code class="cf">us</code> and one <code class="cf">gb</code> may exist. We explicitly gave <code class="cf">country_name</code> a similar unique constraint, although it is not a primary key. We can populate the <code class="cf">countries</code> table by inserting a few rows.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">INSERT</strong> <strong class="prompt">INTO</strong> countries (country_code, country_name)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">VALUES</strong> (<em class="string">'us'</em>,<em class="string">'United States'</em>), (<em class="string">'mx'</em>,<em class="string">'Mexico'</em>), (<em class="string">'au'</em>,<em class="string">'Australia'</em>),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​       (<em class="string">'gb'</em>,<em class="string">'United Kingdom'</em>), (<em class="string">'de'</em>,<em class="string">'Germany'</em>), (<em class="string">'ll'</em>,<em class="string">'Loompaland'</em>);​</code>​</div>
</td>
</tr>
</table>
<p id="N105C9" class="calibre5">
      Let’s test our unique constraint. Attempting to add a duplicate <code class="cf">country_name</code> will cause our unique constraint to fail, thus disallowing insertion. Constraints are how relational databases like PostgreSQL ensure kosher data.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">INSERT</strong> <strong class="prompt">INTO</strong> countries​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">VALUES</strong> (<em class="string">'uk'</em>,<em class="string">'United Kingdom'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ERROR:  duplicate key value violates unique constraint "countries_country_name_key"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​DETAIL:  Key (country_name)=(United Kingdom) already exists.​</code>​</div>
</td>
</tr>
</table>
<div class="sidebar">
<div class="sidebar-title">On CRUD</div>
<div class="calibre2">
<p id="N1060B" class="calibre5">
<span class="initials">CRUD</span> is a useful mnemonic for remembering the basic data management operations: <span class="calibre6">Create</span>, <span class="calibre6">Read</span>, <span class="calibre6">Update</span>, and <span class="calibre6">Delete</span>. These generally correspond to inserting new records (<span class="calibre6">creating</span>), modifying existing records (<span class="calibre6">updating</span>), and removing records you no longer need (<span class="calibre6">deleting</span>). All of the other operations you use a database for (any crazy query you can dream up) are <span class="calibre6">read operations</span>. If you can <span class="initials">CRUD</span>, you can do anything.
      </p>
</div>
</div>
<p id="N10630" class="calibre5">
      We can validate that the proper rows were inserted by reading them using the <code class="cf">SELECT...FROM</code> table command.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> countries;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ country_code | country_name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">--------------+---------------</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ us           | United States​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ mx           | Mexico​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ au           | Australia​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ gb           | United Kingdom​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ de           | Germany​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ ll           | Loompaland​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(6 rows)​</code>​</div>
</td>
</tr>
</table>
<p id="N10679" class="calibre5">
      According to any respectable map,  Loompaland  isn’t a real place—let’s remove it from the table. We specify which row to remove by the <code class="cf">WHERE</code> clause. The row whose <code class="cf">country_code</code> equals <code class="cf">ll</code> will be removed.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">DELETE</strong> <strong class="prompt">FROM</strong> countries​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> country_code = <em class="string">'ll'</em>;​</code>​</div>
</td>
</tr>
</table>
<p id="N106C2" class="calibre5">
      With only real countries left in the <code class="cf">countries</code> table, let’s add a <code class="cf">cities</code> table. To ensure any inserted <code class="cf">country_code</code> also exists in our <code class="cf">countries</code> table, we add the <code class="cf">REFERENCES</code> keyword. Since the <code class="cf">country_code</code> column references another table’s key, it’s known as the <span class="calibre6">foreign key</span> constraint.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> cities (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  name <strong class="prompt">text</strong> <strong class="prompt">NOT</strong> NULL,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  postal_code <strong class="prompt">varchar</strong>(9) CHECK (postal_code &lt;&gt; <em class="string">''</em>),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  country_code <strong class="prompt">char</strong>(2) REFERENCES countries,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">PRIMARY</strong> <strong class="prompt">KEY</strong> (country_code, postal_code)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
</table>
<p id="N1072B" class="calibre5"></p>
<p id="N1072E" class="calibre5">
      This time, we constrained the name in cities by disallowing <code class="cf">NULL</code> values. We constrained <code class="cf">postal_code</code> by checking that no values are empty strings (<code class="cf">&lt;&gt;</code> means <span class="calibre6">not equal</span>).  

      Furthermore, since a <code class="cf">PRIMARY KEY</code> uniquely identifies a row, we created a compound key: <code class="cf">country_code</code> + <code class="cf">postal_code</code>. Together, they uniquely define a row.   
      </p>
<p id="N1075A" class="calibre5">
      Postgres also has a rich set of datatypes. You’ve just seen three different string representations: <code class="cf">text</code> (a string of any length), <code class="cf">varchar(9)</code> (a string of variable length up to nine characters), and <code class="cf">char(2)</code> (a string of exactly two characters).

        With our schema in place, let’s insert <span class="calibre6">Toronto, CA</span>.  </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">INSERT</strong> <strong class="prompt">INTO</strong> cities​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">VALUES</strong> (<em class="string">'Toronto'</em>,<em class="string">'M4C1B5'</em>,<em class="string">'ca'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ERROR:  insert or update on table "cities" violates foreign key constraint​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "cities_country_code_fkey"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​DETAIL:  Key (country_code)=(ca) is not present in table "countries".​</code>​</div>
</td>
</tr>
</table>
<div class="figure" id="fig.join.text">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/postgres-join-text.png" alt="images/postgres-join-text.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 1. The <code class="cf">REFERENCES</code> keyword constrains fields to another table’s primary key.</div>
</div>
<p id="N107D8" class="calibre5">
      This failure is good! Since <code class="cf">country_code</code> <code class="cf">REFERENCES</code> <code class="cf">countries</code>, the <code class="cf">country_code</code> must exist in the <code class="cf">countries</code> table. This is called <span class="calibre6">maintaining referential integrity</span>, as in Figure 1, <a href="#fig.join.text">​<em class="calibre6">The REFERENCES keyword constrains fields to another table's primary key</em>​</a>, and ensures our data is always correct. It’s worth noting that <code class="cf">NULL</code> is valid for <code class="cf">cities</code>.<code class="cf">country_code</code>, since <code class="cf">NULL</code> represents the lack of a value. If you want to disallow a <code class="cf">NULL</code> <code class="cf">country_code</code> reference, you would define the table <code class="cf">cities</code> column like this: <code class="cf">country_code char(2) REFERENCES countries NOT NULL</code>.
    </p>
<p id="N10813" class="calibre5">
      Now let’s try another insert, this time with a U.S. city.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">INSERT</strong> <strong class="prompt">INTO</strong> cities​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">VALUES</strong> (<em class="string">'Portland'</em>,<em class="string">'87200'</em>,<em class="string">'us'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​INSERT 0 1​</code>​</div>
</td>
</tr>
</table>
<p id="N1084A" class="calibre5">
      This is a successful insert, to be sure. But we mistakenly entered the wrong <code class="cf">postal_code</code>.  The correct postal code for Portland is <code class="cf1">97205</code>. Rather than delete and reinsert the value, we can update it inline.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">UPDATE</strong> cities​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SET</strong> postal_code = <em class="string">'97205'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> name = <em class="string">'Portland'</em>;​</code>​</div>
</td>
</tr>
</table>
<p id="N1087A" class="calibre5">
      We have now Created, Read, Updated, and Deleted table rows.
    </p>
<h4 class="calibre21">Join Reads</h4>
<p id="N10884" class="calibre5">
        All of the other databases we’ll read about in this book perform CRUD operations as well. What sets relational databases like PostgreSQL apart is their ability to join tables together when reading them. Joining, in essence, is an operation taking two separate tables and combining them in some way to return a single table. It’s somewhat like shuffling up Scrabble pieces from existing words to make new words.
      </p>
<p id="N1089E" class="calibre5">
        The basic form of a join is the <span class="calibre6">inner join</span>. In the simplest form, you specify two columns (one from each table) to match by, using the <code class="cf">ON</code> keyword.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> cities.*, country_name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> cities <strong class="prompt">INNER</strong> <strong class="prompt">JOIN</strong> countries​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">ON</strong> cities.country_code = countries.country_code;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ country_code |   name   | postal_code | country_name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​--------------+----------+-------------+---------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ us           | Portland | 97205       | United States​</code>​</div>
</td>
</tr>
</table>
<p id="N108E9" class="calibre5">
        The join returns a single table, sharing all columns’ values of the <code class="cf">cities</code> table plus the matching <code class="cf">country_name</code> value from the <code class="cf">countries</code> table.
      </p>
<p id="N108F5" class="calibre5">
        We can also join a table like <code class="cf">cities</code> that has a compound primary key. To test a compound join, let’s create a new table that stores a list of venues.
      </p>
<p id="N108FB" class="calibre5">
        A venue exists in both a <span class="calibre6">postal code</span> and a specific <span class="calibre6">country</span>. The <span class="calibre6">foreign key</span> must be two columns that reference both <code class="cf">cities</code> <span class="calibre6">primary key</span> columns. (<code class="cf">MATCH FULL</code> is a constraint that ensures either both values exist or both are <code class="cf">NULL</code>.)
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> venues (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  venue_id SERIAL <strong class="prompt">PRIMARY</strong> <strong class="prompt">KEY</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  name <strong class="prompt">varchar</strong>(255),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  street_address <strong class="prompt">text</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  type <strong class="prompt">char</strong>(7) CHECK ( type in (<em class="string">'public'</em>,<em class="string">'private'</em>) ) <strong class="prompt">DEFAULT</strong> <em class="string">'public'</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  postal_code <strong class="prompt">varchar</strong>(9),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  country_code <strong class="prompt">char</strong>(2),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  FOREIGN <strong class="prompt">KEY</strong> (country_code, postal_code)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    REFERENCES cities (country_code, postal_code) MATCH FULL​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
</table>
<p id="N10968" class="calibre5">
      This <code class="cf">venue_id</code> column is a common primary key setup: automatically incremented integers (1, 2, 3, 4, and so on…). We make this identifier using the <code class="cf">SERIAL</code> keyword (MySQL has a similar construct called <code class="cf">AUTO_INCREMENT</code>).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">INSERT</strong> <strong class="prompt">INTO</strong> venues (name, postal_code, country_code)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">VALUES</strong> (<em class="string">'Crystal Ballroom'</em>, <em class="string">'97205'</em>, <em class="string">'us'</em>);​</code>​</div>
</td>
</tr>
</table>
<p id="N109AA" class="calibre5">
        Although we did not set a <code class="cf">venue_id</code> value, creating the row populated it.
      </p>
<p id="N109B0" class="calibre5">
        Back to our compound join. Joining the <code class="cf">venues</code> table with the <code class="cf">cities</code> table requires <span class="calibre6">both</span> foreign key columns. To save on typing, we can alias the table names by following the real table name directly with an alias, with an optional <code class="cf">AS</code> between (for example, <code class="cf">venues v</code> or <code class="cf">venues AS v</code>).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> v.venue_id, v.name, c.name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> venues v <strong class="prompt">INNER</strong> <strong class="prompt">JOIN</strong> cities c​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">ON</strong> v.postal_code=c.postal_code <strong class="prompt">AND</strong> v.country_code=c.country_code;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ venue_id |       name       |   name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------+------------------+----------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        1 | Crystal Ballroom | Portland​</code>​</div>
</td>
</tr>
</table>
<p id="N109F8" class="calibre5">
        You can optionally request that PostgreSQL return columns after insertion by ending the query with a <code class="cf">RETURNING</code> statement.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">INSERT</strong> <strong class="prompt">INTO</strong> venues (name, postal_code, country_code)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">VALUES</strong> (<em class="string">'Voodoo Donuts'</em>, <em class="string">'97205'</em>, <em class="string">'us'</em>) RETURNING venue_id;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ id​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​- - - -​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  2​</code>​</div>
</td>
</tr>
</table>
<p id="N10A38" class="calibre5">
        This provides the new <code class="cf">venue_id</code> without issuing another query.
      </p>
<h4 class="calibre21">The Outer Limits</h4>
<p id="N10A48" class="calibre5">
        In addition to inner joins, PostgreSQL can also perform <span class="calibre6">outer joins</span>. Outer joins are a way of merging two tables when the results of one table must always be returned, whether or not any matching column values exist on the other table.
      </p>
<p id="N10A58" class="calibre5">
        It’s easiest to give an example, but to do that, we’ll create a new table named <code class="cf">events</code>. This one is up to you.  Your <code class="cf">events</code> table should have these columns: a <code class="cf">SERIAL</code> integer <code class="cf">event_id</code>, a <code class="cf">title</code>, <code class="cf">starts</code> and <code class="cf">ends</code> (of type <span class="calibre6">timestamp</span>), and a <code class="cf">venue_id</code> (foreign key that references <code class="cf">venues</code>). A schema definition diagram covering all the tables we’ve made so far is shown in Figure 2, <a href="#fig.erd">​<em class="calibre6">The crow’s-feet entity relationship diagram (ERD)</em>​</a>.
      </p>
<div class="figure" id="fig.erd">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/postgres-erd.png" alt="images/postgres-erd.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 2. The crow’s-feet entity relationship diagram (<span class="initials">ERD</span>)</div>
</div>
<p id="N10AA8" class="calibre5">
        After creating the <code class="cf">events</code> table, <code class="cf">INSERT</code> the following values (timestamps are inserted as a string like <code class="cf1">2012-02-15 17:30</code>), two holidays, and a club we <span class="calibre6">do not talk about</span>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      title     |       starts        |        ends         | venue_id | event_id​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">----------------+---------------------+---------------------+----------+---------</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​LARP Club       | 2012-02-15 17:30:00 | 2012-02-15 19:30:00 |        2 |        1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​April Fools Day | 2012-04-01 00:00:00 | 2012-04-01 23:59:00 |          |        2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Christmas Day   | 2012-12-25 00:00:00 | 2012-12-25 23:59:00 |          |        3​</code>​</div>
</td>
</tr>
</table>
<p id="N10ADA" class="calibre5">
        Let’s first craft a query that returns an event title and venue name as an inner join (the word <code class="cf">INNER</code> from <code class="cf">INNER JOIN</code> is not required, so leave it off here).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> e.title, v.name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> events e <strong class="prompt">JOIN</strong> venues v​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">ON</strong> e.venue_id = v.venue_id;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​       title  |       name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​--------------+------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ LARP Club    | Voodoo Donuts​</code>​</div>
</td>
</tr>
</table>
<p id="N10B10" class="calibre5">
<code class="cf">INNER JOIN</code> will  return a row only <span class="calibre6">if the column values match</span>. Since we can’t have <code class="cf">NULL</code>
<code class="cf">venues</code>.<code class="cf">venue_id</code>, the two <code class="cf">NULL</code>
<code class="cf">events</code>.<code class="cf">venue_id</code>s refer to nothing. Retrieving all of the events, whether or not they have a venue, requires a <code class="cf">LEFT OUTER JOIN</code> (shortened to <code class="cf">LEFT JOIN</code>).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> e.title, v.name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> events e <strong class="prompt">LEFT</strong> <strong class="prompt">JOIN</strong> venues v​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">ON</strong> e.venue_id = v.venue_id;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      title      |      name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-----------------+----------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ LARP Club       | Voodoo Donuts​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ April Fools Day |​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Christmas Day   |​</code>​</div>
</td>
</tr>
</table>
<p id="N10B73" class="calibre5">
        If you require the inverse, all venues and only matching events, use a <code class="cf">RIGHT JOIN</code>. Finally, there’s the <code class="cf">FULL JOIN</code>, which is the union of <code class="cf">LEFT</code> and <code class="cf">RIGHT</code>; you’re guaranteed all values from each table, joined wherever columns match.
      </p>
<h3 class="calibre20">Fast Lookups with Indexing</h3>
<p id="N10BA7" class="calibre5">
      The speed of PostgreSQL (and any other RDBMS) lies in its efficient management of blocks of data, reducing disk reads, query optimization, and other techniques. But those  go only so far in fetching results fast. If we select the title of <code class="cf1">Christmas Day</code> from the <code class="cf">events</code> table, the algorithm must scan every row for a match to return. Without an <span class="calibre6">index</span>, each row must be read from disk to know whether a query should return it.  See the following.
       </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/postgres-scan.png" alt="images/postgres-scan.png" class="calibre27"/>
</div>
<p id="N10BD9" class="calibre5">
      An index is a special data structure built to avoid a full table scan when performing a query. When running <code class="cf">CREATE TABLE</code> commands, you may have noticed a message like this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> / <strong class="prompt">PRIMARY</strong> <strong class="prompt">KEY</strong> will <strong class="prompt">create</strong> implicit <strong class="prompt">index</strong> <em class="string">"events_pkey"</em> \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​for <strong class="prompt">table</strong> <em class="string">"events"</em>​</code>​</div>
</td>
</tr>
</table>
<p id="N10C16" class="calibre5">
      PostgreSQL automatically creates an index on the primary key, where the key is the primary key value and where the value points to a row on disk, as shown in the graphic below. Using the <code class="cf">UNIQUE</code> keyword is another way to force an index on a table column.
     </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/postgres-hash-index.png" alt="images/postgres-hash-index.png" class="calibre27"/>
</div>
<p id="N10C35" class="calibre5">
      You can explicitly add a hash index using the <code class="cf">CREATE INDEX</code> command, where each value must be unique (like a hashtable or a map).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> events_title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">ON</strong> events <strong class="prompt">USING</strong> hash (title);​</code>​</div>
</td>
</tr>
</table>
<p id="N10C64" class="calibre5">
      For less-than/greater-than/equals-to matches, we want an index more flexible than a simple hash, like a B-tree (see Figure 3, <a href="#fig.btree.index">​<em class="calibre6">A B-tree index can match on ranged queries</em>​</a>).  Consider a query to find all events that are on or after April 1.
    </p>
<div class="figure" id="fig.btree.index">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/postgres-big-btree.png" alt="images/postgres-big-btree.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 3. A B-tree index can match on ranged queries.</div>
</div>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> events​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> starts &gt;= <em class="string">'2012-04-01'</em>;​</code>​</div>
</td>
</tr>
</table>
<p id="N10C9A" class="calibre5">
      For this, a tree is the perfect data structure. To index the <code class="cf">starts</code> column with a B-tree, use this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> events_starts​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">ON</strong> events <strong class="prompt">USING</strong> btree (starts);​</code>​</div>
</td>
</tr>
</table>
<p id="N10CBA" class="calibre5">
      Now our query over a range of dates will avoid a full table scan. It makes a huge difference when scanning millions or billions of rows.
    </p>
<p id="N10CBD" class="calibre5">
      We can inspect our work with this command to list all indexes in the schema:</p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​book=<em class="comment"># \di</em>​</code>​</div>
</td>
</tr>
</table>
<p id="N10CD0" class="calibre5">
      It’s worth noting that when you set a <code class="cf">FOREIGN KEY</code> constraint, PostgreSQL will automatically create an index on the targeted column(s). Even if you don’t like using database constraints (that’s right, we’re looking at you, Ruby on Rails developers), you will often find yourself creating indexes on columns you plan to join against in order to help speed up foreign key joins.
      </p>
<h3 class="calibre20">Day 1 Wrap-Up</h3>
<p id="N10CE6" class="calibre5">
      We sped through a lot today and covered many terms. Here’s a recap:
    </p>
<table class="simpletable1">
<thead class="calibre29">
<tr class="calibre8">
<th class="hlines">
<p class="last-para-in-cell">Term</p>
</th>
<th class="hlines">
<p class="last-para-in-cell">Definition</p>
</th>
</tr>
</thead>
<tbody class="calibre7">
<tr class="calibre8">
<td class="calibre30">
<p class="last-para-in-cell">Column</p>
</td>
<td class="calibre30">
<p class="last-para-in-cell">A domain of values of a certain type, sometimes called an <span class="calibre6">attribute</span>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Row</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">An object comprised as a set of column values, sometimes called a <span class="calibre6">tuple</span>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Table</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">A set of rows with the same columns, sometimes called a <span class="calibre6">relation</span>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Primary key</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">The unique value that pinpoints a specific row</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">CRUD</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">Create, Read, Update, Delete</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">SQL</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">Structured Query Language, the <span class="calibre6">lingua franca</span> of a relational database</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Join</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">Combining two tables into one by some matching columns</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Left join</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">Combining two tables into one by some matching columns or <code class="cf">NULL</code> if nothing matches the left table</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Index</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">A data structure to optimize selection of a specific set of columns</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">B-tree</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">A good standard index; values are stored as a balanced tree data structure; very flexible</p>
</td>
</tr>
</tbody>
</table>
<p id="N10D5C" class="calibre5">
      Relational databases have been the <span class="calibre6">de facto</span> data management strategy for forty years—many of us began our careers in the midst of their evolution. So, we took a look at some of the core concepts of the relational model via basic <span class="initials">SQL</span> queries. We will expound on these root concepts tomorrow.
    </p>
<h4 class="calibre21">Day 1 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N10DA5" class="calibre5">Bookmark the online PostgreSQL FAQ and documents.</p>
</li>
<li class="calibre23">
<p id="N10DA9" class="calibre5">Acquaint yourself with the command-line <code class="cf">\?</code> and <code class="cf">\h</code> output.</p>
</li>
<li class="calibre23">
<p id="N10DB3" class="calibre5">In the addresses <code class="cf">FOREIGN KEY</code>, find in the docs what <code class="cf">MATCH FULL</code> means.</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N10DC3" class="calibre5">Select all the tables we created (and only those) from <code class="cf">pg_class</code>.</p>
</li>
<li class="calibre23">
<p id="N10DCA" class="calibre5">Write a query that finds the country name of the LARP Club event.</p>
</li>
<li class="calibre23">
<p id="N10DCE" class="calibre5">Alter the <code class="cf">venues</code> table to contain a boolean column called <code class="cf">active</code>, with the default value of <code class="cf">TRUE</code>.</p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

