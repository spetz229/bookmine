---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0019.html
next: f_0021.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N119A8" class="calibre18">2.4 Day 3: Full-Text and Multidimensions</h2>
<p id="N119AC" class="calibre5">
    We’ll spend Day 3 investigating the many tools at our disposal to build a movie query system. We’ll begin with the many ways that PostgreSQL can search actor/movie names using fuzzy string matching. Then we’ll discover the cube package by creating a movie suggestion system based on similar genres of movies we already like. Since these are all contributed packages, the implementations are special to PostgreSQL and not part of the SQL standard.
  </p>
<p id="N119AF" class="calibre5">
    Commonly, when designing a relational database schema, you’ll start with an entity diagram. We’ll be writing a personal movie suggestion system that keeps track of movies, their genres, and their actors, as modeled in Figure 6, <a href="#fig.rel.movies">​<em class="calibre6">Our movie suggestion system</em>​</a>.
      </p>
<div class="figure" id="fig.rel.movies">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/postgres-movies.png" alt="images/postgres-movies.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 6. Our movie suggestion system</div>
</div>
<p id="N119D1" class="calibre5">
    As a reminder, on Day 1 we installed several contributed packages. Today we’ll need them all. Again, the list we’ll need installed is as follows: <code class="cf">tablefunc</code>, <code class="cf">dict_xsyn</code>, <code class="cf">fuzzystrmatch</code>, <code class="cf">pg_trgm</code>, and <code class="cf">cube</code>.
  </p>
<p id="N119E3" class="calibre5">
    Let’s first build the database. It’s often good practice to create indexes on foreign keys to speed up reverse lookups (such as what movies this actor is involved in). You should also set a <code class="cf">UNIQUE</code> constraint on join tables like <code class="cf">movies_actors</code> to avoid duplicate join values.
  </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/postgres/create_movies.sql">postgres/create_movies.sql</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> genres (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        name <strong class="prompt">text</strong> <strong class="prompt">UNIQUE</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        position <strong class="prompt">integer</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> movies (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        movie_id SERIAL <strong class="prompt">PRIMARY</strong> <strong class="prompt">KEY</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        title <strong class="prompt">text</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        genre cube​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> actors (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        actor_id SERIAL <strong class="prompt">PRIMARY</strong> <strong class="prompt">KEY</strong>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        name <strong class="prompt">text</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> movies_actors (​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        movie_id <strong class="prompt">integer</strong> REFERENCES movies <strong class="prompt">NOT</strong> NULL,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        actor_id <strong class="prompt">integer</strong> REFERENCES actors <strong class="prompt">NOT</strong> NULL,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        <strong class="prompt">UNIQUE</strong> (movie_id, actor_id)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> movies_actors_movie_id <strong class="prompt">ON</strong> movies_actors (movie_id);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> movies_actors_actor_id <strong class="prompt">ON</strong> movies_actors (actor_id);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> movies_genres_cube <strong class="prompt">ON</strong> movies <strong class="prompt">USING</strong> gist (genre);​</code>​</div>
</td>
</tr>
</table>
<p id="N11A9D" class="calibre5">
    You can download the <code class="cf">movies_data.sql</code> file as a file alongside the book and populate the tables by piping the file into the database. Any questions you may have about the <code class="cf">genre</code> <code class="cf">cube</code> will be covered later today.
  </p>
<h3 class="calibre20">Fuzzy Searching</h3>
<p id="N11AAD" class="calibre5">
    Opening up  a system to text searches means opening your system to inaccurate inputs. You have to expect typos like “Brid of Frankstein.” Sometimes, users can’t remember the full name of “J. Roberts.” In other cases, we just plain don’t know how to spell “Benn Aflek.” We’ll look into a few PostgreSQL packages that make text searching easy.
    
    It’s worth noting that as we progress, this kind of string matching blurs the lines between relational queries and searching frameworks like Lucene.<a id="FNPTR-8" href="f_0021.html#FOOTNOTE-8">[8]</a> Although some may feel features like full-text search belong with the application code, there can be performance and administrative benefits of pushing these packages to the database, where the data lives.
    </p>
<h4 class="calibre21">SQL Standard String Matches</h4>
<p id="N11ACC" class="calibre5">
        PostgreSQL has many ways of performing text matches, but the two big default methods are <code class="cf">LIKE</code> and regular expressions.
      </p>
<p class="calibre5">
<strong class="calibre32">I Like LIKE and ILIKE</strong>
</p>
<p id="N11AE2" class="calibre5">
<code class="cf">LIKE</code> and <code class="cf">ILIKE</code> (case-insensitive <code class="cf">LIKE</code>) are the simplest forms of text search. They are fairly universal in relational databases. <code class="cf">LIKE</code> compares column values against a given pattern string. The % and _ characters are wildcards.  % matches any number of any characters, and _ matches exactly one character.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> title <strong class="prompt">FROM</strong> movies <strong class="prompt">WHERE</strong> title ILIKE <em class="string">'stardust%'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​       title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">-------------------</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Stardust​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Stardust Memories​</code>​</div>
</td>
</tr>
</table>
<p id="N11B3D" class="calibre5">
        If we want to be sure the substring <code class="cf1">stardust</code> is not at the end of the string, we can use the underscore (_) character as a little trick.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> title <strong class="prompt">FROM</strong> movies <strong class="prompt">WHERE</strong> title ILIKE <em class="string">'stardust_%'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​       title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">-------------------</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Stardust Memories​</code>​</div>
</td>
</tr>
</table>
<p id="N11B6D" class="calibre5">
      This is useful in basic cases, but <code class="cf">LIKE</code> is limited to simple wildcards.
      </p>
<p class="calibre5">
<strong class="calibre32">Regex</strong>
</p>
<p id="N11B83" class="calibre5">
        A more powerful string-matching syntax is a <span class="calibre6">regular expression</span> (regex). Regexes appear often throughout this book, because many databases support them.  There are entire books dedicated to writing powerful expressions—the topic is far too wide and complex to cover in depth.  Postgres conforms (mostly) to the POSIX style.
      </p>
<p id="N11B9E" class="calibre5">
      In Postgres, a regular expression match is led by the ~ operator, with the optional ! (meaning, <span class="calibre6">not</span> matching) and * (meaning <span class="calibre6">case insensitive</span>). So, to count all movies that do <span class="calibre6">not</span> begin with <code class="cf1">the</code>, the following case-insensitive query will work. The characters inside the string are the regular expression.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> COUNT(*) <strong class="prompt">FROM</strong> movies <strong class="prompt">WHERE</strong> title !~* <em class="string">'^the.*'</em>;​</code>​</div>
</td>
</tr>
</table>
<p id="N11BE2" class="calibre5">
        You can index strings for pattern matching the previous queries by creating a <code class="cf">text_pattern_ops</code> operator class index, as long as the values are indexed in lowercase.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> movies_title_pattern <strong class="prompt">ON</strong> movies (lower(title) text_pattern_ops);​</code>​</div>
</td>
</tr>
</table>
<p id="N11BFC" class="calibre5">
        We used the <code class="cf">text_pattern_ops</code> because the title is of type <code class="cf">text</code>. If you need to index varchars, chars, or names, use the related ops: <code class="cf">varchar_pattern_ops</code>, <code class="cf">bpchar_pattern_ops</code>, and <code class="cf">name_pattern_ops</code>.
        </p>
<h4 class="calibre21">Bride of Levenshtein</h4>
<p id="N11C18" class="calibre5">
      Levenshtein is a string comparison algorithm that compares how similar two strings are by how many <span class="calibre6">steps</span> are required to change one string into another. Each replaced, missing, or added character counts as a step. The distance is the total number of steps away. In PostgreSQL, the <code class="cf">levenshtein</code> function is provided by the <code class="cf">fuzzystrmatch</code> contrib package.

        Say we have the string <code class="cf1">bat</code> and the string <code class="cf1">fads</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> levenshtein(<em class="string">'bat'</em>, <em class="string">'fads'</em>);​</code>​</div>
</td>
</tr>
</table>
<p id="N11C4A" class="calibre5">
        The Levenshtein distance is 3 because—compared to the string <code class="cf1">bat</code>—we replaced two letters (b=&gt;f, t=&gt;d), and we added a letter (+s). Each change increments the distance. We can watch the distance close as we step closer (so to speak).  The total goes down until we get zero (the two strings are equal).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> levenshtein(<em class="string">'bat'</em>, <em class="string">'fad'</em>) fad,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  levenshtein(<em class="string">'bat'</em>, <em class="string">'fat'</em>) fat,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  levenshtein(<em class="string">'bat'</em>, <em class="string">'bat'</em>) bat;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ fad | fat | bat​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-----+-----+-----​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   2 |   1 |   0​</code>​</div>
</td>
</tr>
</table>
<p id="N11C87" class="calibre5">
        Changes in case cost a point too, so you may find it best to convert all strings to the same case when querying.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> movie_id, title <strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> levenshtein(lower(title), lower(<em class="string">'a hard day nght'</em>)) &lt;= 3;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ movie_id |       title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------+--------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      245 | A Hard Day’s Night​</code>​</div>
</td>
</tr>
</table>
<p id="N11CB4" class="calibre5">
        This ensures minor differences won’t over-inflate the distance.
      </p>
<h4 class="calibre21">Try a Trigram</h4>
<p id="N11CC1" class="calibre5">
        A trigram is a group of three consecutive characters taken from a string. The <code class="cf">pg_trgm</code> contrib module breaks a string into as many trigrams as it can.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> show_trgm(<em class="string">'Avatar'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​              show_trgm​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-------------------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ {"  a"," av","ar ",ata,ava,tar,vat}​</code>​</div>
</td>
</tr>
</table>
<p id="N11CF3" class="calibre5">
        Finding a matching string is as simple as counting the number of matching trigrams. The strings with the most matches are the most similar. It’s useful for doing a search where you’re OK with either slight misspellings or even minor words missing. The longer the string, the more trigrams and the more likely a match—they’re great for something like movie titles, since they have relatively similar lengths.
      </p>
<p id="N11CF6" class="calibre5">
      We’ll create a trigram index against movie names to start (we use Generalized Index Search Tree [<span class="initials">GIST</span>], a generic index API made available by the PostgreSQL engine).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> movies_title_trigram <strong class="prompt">ON</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">USING</strong> gist (title gist_trgm_ops);​</code>​</div>
</td>
</tr>
</table>
<p id="N11D1B" class="calibre5">
        Now you can query with a few misspellings and still get decent results.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> title % <em class="string">'Avatre'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​---------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Avatar​</code>​</div>
</td>
</tr>
</table>
<p id="N11D4A" class="calibre5">
        Trigrams are an excellent choice for accepting user input, without weighing them down with wildcard complexity.
      </p>
<h3 class="calibre20">Full-Text Fun</h3>
<p id="N11D57" class="calibre5">
      Next, we want to allow users to perform full-text searches based on matching words, even if they’re pluralized. If a user wants to search for certain words in a movie title but can remember only  some of them, Postgres supports simple natural-language processing.
    </p>
<h4 class="calibre21">TSVector and TSQuery</h4>
<p id="N11D68" class="calibre5">
      Let’s look for a movie that contains the words <span class="calibre6">night</span> and <span class="calibre6">day</span>. This is a perfect job for text search using the @@ full-text query operator.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> title @@ <em class="string">'night &amp; day'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​             title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-------------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ A Hard Day’s Night​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Six Days Seven Nights​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Long Day’s Journey Into Night​</code>​</div>
</td>
</tr>
</table>
<p id="N11DB7" class="calibre5">
      The query returns titles like <code class="cf1">A Hard Day’s Night</code>, despite the word <code class="cf1">Day</code> being in possessive form, and the two words are out of order in the query. The @@ operator converts the name field into a <code class="cf">tsvector</code> and converts the query into a <code class="cf">tsquery</code>.
    </p>
<p id="N11DC6" class="calibre5">
    A <code class="cf">tsvector</code> is a datatype that splits a string into an array (or a <span class="calibre6">vector</span>) of tokens, which are searched against the given query, while the <code class="cf">tsquery</code> represents a query in some language, like English or French. The language corresponds to a dictionary (which we’ll see more of in a few paragraphs). The previous query  is equivalent to the following (if your system language is set to English):
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> to_tsvector(title) @@ to_tsquery(<em class="string">'english'</em>, <em class="string">'night &amp;amp; day'</em>);​</code>​</div>
</td>
</tr>
</table>
<p id="N11DF0" class="calibre5">
      You can take a look at how the vector and the query break apart the values by running the conversion functions on the strings outright.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> to_tsvector(<em class="string">'A Hard Day''s Night'</em>), to_tsquery(<em class="string">'english'</em>, <em class="string">'night &amp;amp; day'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      to_tsvector         |   to_tsquery​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------------------------+-----------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​'day':3 'hard':2 'night':5 | 'night' &amp; 'day'​</code>​</div>
</td>
</tr>
</table>
<p id="N11E1B" class="calibre5">
      The tokens on a <code class="cf">tsvector</code> are called <span class="calibre6">lexemes</span> and are coupled with their positions in the given phrase.
    </p>
<p id="N11E24" class="calibre5">
      You may have noticed the <code class="cf">tsvector</code> for <span class="calibre6">A Hard Day’s Night</span> did not contain the lexeme <span class="calibre6">a</span>. Moreover, simple English words like <span class="calibre6">a</span> are missing if you try to query by them.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> title @@ to_tsquery(<em class="string">'english'</em>, <em class="string">'a'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​NOTICE:  text-search query contains only stop words or doesn’t \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​       contain lexemes, ignored​</code>​</div>
</td>
</tr>
</table>
<p id="N11E5F" class="calibre5">
      Common words like <span class="calibre6">a</span> are called <span class="calibre6">stop words</span> and are generally not useful for performing queries. The English dictionary was used by the parser to normalize our string into useful English components. In your console, you can view the output of the stop words under the English <code class="cf">tsearch_data</code> directory.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​cat `pg_config --sharedir`/tsearch_data/english.stop​</code>​</div>
</td>
</tr>
</table>
<p id="N11E7A" class="calibre5">
      We could remove <code class="cf1">a</code> from the list, or we could use another dictionary like <code class="cf">simple</code> that just breaks up strings by nonword characters and makes them lowercase. Compare these two vectors:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> to_tsvector(<em class="string">'english'</em>, <em class="string">'A Hard Day''s Night'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      to_tsvector​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​'day':3 'hard':2 'night':5​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> to_tsvector(<em class="string">'simple'</em>, <em class="string">'A Hard Day''s Night'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​            to_tsvector​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------------------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​'a':1 'day':3 'hard':2 'night':5 's':4​</code>​</div>
</td>
</tr>
</table>
<p id="N11ED5" class="calibre5">
      With <code class="cf">simple</code>, you can retrieve any movie containing the lexeme <code class="cf1">a</code>.
    </p>
<h4 class="calibre21">Other Languages</h4>
<p id="N11EEE" class="calibre5">
      Since Postgres is doing some natural-language processing here, it only makes sense that different configurations would be used for different languages. All of the installed configurations can be viewed with this command:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​book=# \dF​</code>​</div>
</td>
</tr>
</table>
<p id="N11EFD" class="calibre5">
      Dictionaries are part of what Postgres uses to generate <code class="cf">tsvector</code> lexemes (along with stop words and other tokenizing rules we haven’t covered called <span class="calibre6">parsers</span> and <span class="calibre6">templates</span>). You can view your system’s list here:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​book=# \dFd​</code>​</div>
</td>
</tr>
</table>
<p id="N11F3F" class="calibre5">
      You can test any dictionary outright by calling the <code class="cf">ts_lexize</code> function. Here we find the English stem word of the string <code class="cf1">Day’s</code>.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> ts_lexize(<em class="string">'english_stem'</em>, <em class="string">'Day''s'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ ts_lexize​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-----------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ {day}​</code>​</div>
</td>
</tr>
</table>
<p id="N11F6D" class="calibre5">
    Finally, the previous full-text commands work for other languages too. If you have German installed, try this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> to_tsvector(<em class="string">'german'</em>, <em class="string">'was machst du gerade?'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  to_tsvector​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​--------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​'gerad':4 'mach':2​</code>​</div>
</td>
</tr>
</table>
<p id="N11F9F" class="calibre5">
    Since <code class="cf1">was</code> (what) and <code class="cf1">du</code> (you) are common, they are marked as stop words in the German dictionary, while <code class="cf1">machst</code> (doing) and <code class="cf1">gerade</code> (now) are stemmed.
    </p>
<h4 class="calibre21">Indexing Lexemes</h4>
<p id="N11FC7" class="calibre5">
        Full-text search is powerful. But if we don’t index our tables, it’s also slow. The <code class="cf">EXPLAIN</code> command is a powerful tool for digging into how queries are internally planned.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​EXPLAIN​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> title @@ <em class="string">'night &amp; day'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​                                QUERY PLAN​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​---------------------------------------------------------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Seq Scan on movies  (cost=10000000000.00..10000000001.12 rows=1 width=68)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   Filter: (title @@ 'night &amp; day'::text)​</code>​</div>
</td>
</tr>
</table>
<p id="N1202B" class="calibre5">
        Note the line <code class="cf1">Seq Scan on movies</code>. That’s rarely a good sign in a query, because it means a whole table scan is taking place; each row will be read. So, we need the right index.
      </p>
<p id="N12031" class="calibre5">
      We’ll use Generalized Inverted iNdex (GIN)—like GIST, it’s an index API—to create an index of lexeme values we can query against. The term <span class="calibre6">inverted index</span> may sound familiar to you if you’ve ever used a search engine like Lucene or Sphinx. It’s a common data structure to index full-text searches.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">CREATE</strong> <strong class="prompt">INDEX</strong> movies_title_searchable <strong class="prompt">ON</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">USING</strong> gin(to_tsvector(<em class="string">'english'</em>, title));​</code>​</div>
</td>
</tr>
</table>
<p id="N12053" class="calibre5">
        With our index in place, let’s try to search again.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​EXPLAIN​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> title @@ <em class="string">'night &amp; day'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​                                QUERY PLAN​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​---------------------------------------------------------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Seq Scan on movies  (cost=10000000000.00..10000000001.12 rows=1 width=68)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   Filter: (title @@ 'night &amp; day'::text)​</code>​</div>
</td>
</tr>
</table>
<p id="N12088" class="calibre5">
        What happened? Nothing. The index is there, but Postgres isn’t using it. It’s because our GIN index specifically uses the <code class="cf">english</code> configuration for building its <code class="cf">tsvector</code>s, but we aren’t specifying that vector. We need to specify it in the <code class="cf">WHERE</code> clause of the query.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​EXPLAIN​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> to_tsvector(<em class="string">'english'</em>,title) @@ <em class="string">'night &amp; day'</em>;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​                                     QUERY PLAN​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">------------------------------------------------------------------------------------</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Bitmap Heap Scan <strong class="prompt">on</strong> movies  (cost=4.26..8.28 rows=1 width=68)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   Recheck Cond: (to_tsvector(<em class="string">'english'</em>::regconfig, title) @@ <em class="string">'''day'''</em>::tsquery)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   -&gt; Bitmap <strong class="prompt">Index</strong> Scan <strong class="prompt">on</strong> movies_title_searchable  (cost=0.00..4.26 rows=1 width=0)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        <strong class="prompt">Index</strong> Cond: (to_tsvector(<em class="string">'english'</em>::regconfig, title) @@ <em class="string">'''day'''</em>::tsquery)​</code>​</div>
</td>
</tr>
</table>
<p id="N120EC" class="calibre5">
<code class="cf">EXPLAIN</code> is important to ensure indexes are used as you expect them. Otherwise, the index is just wasted overhead.
        </p>
<h4 class="calibre21">Metaphones</h4>
<p id="N1210D" class="calibre5">
        We’ve inched toward matching less-specific inputs. <code class="cf">LIKE</code> and regular expressions require crafting patterns that can match strings precisely according to their format. Levenshtein distance allows finding matches that contain minor misspellings but must ultimately be very close to the same string. Trigrams are a good choice for finding reasonable misspelled matches. Finally, full-text searching allows natural-language flexibility, in that it can ignore minor words like <span class="calibre6">a</span> and <span class="calibre6">the</span> and can deal with pluralization. Sometimes we just don’t know how to spell words correctly but we know how they sound.
      </p>
<p id="N12125" class="calibre5">
        We love Bruce Willis and would love to see what movies he’s in. Unfortunately, we can’t remember exactly how to spell his name, so we sound it out as best we can.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> actors​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> name = <em class="string">'Broos Wlis'</em>;​</code>​</div>
</td>
</tr>
</table>
<p id="N12143" class="calibre5">
      Even a trigram is no good here (using % rather than =).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> actors​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> name % <em class="string">'Broos Wlis'</em>;​</code>​</div>
</td>
</tr>
</table>
<p id="N12161" class="calibre5">
      Enter the metaphones, which are algorithms for creating a string representation of word sounds. You can define how many characters are in the output string. For example, the seven-character metaphone of the name  Aaron Eckhart  is <code class="cf1">ARNKHRT</code>.
      </p>
<p id="N12167" class="calibre5">
        To find all films acted by someone sounding like Broos Wils, we can query against the metaphone output. Note that <code class="cf">NATURAL JOIN</code> is an <code class="cf">INNER JOIN</code> that automatically joins <code class="cf">ON</code> matching column names (for example, <code class="cf">movies.actor_id=</code>
<code class="cf">movies_actors.actor_id</code>).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies NATURAL <strong class="prompt">JOIN</strong> movies_actors NATURAL <strong class="prompt">JOIN</strong> actors​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> metaphone(name, 6) = metaphone(<em class="string">'Broos Wils'</em>, 6);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​            title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-----------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ The Fifth Element​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Twelve Monkeys​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Armageddon​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Die Hard​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Pulp Fiction​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ The Sixth Sense​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​:​</code>​</div>
</td>
</tr>
</table>
<p id="N121BF" class="calibre5">
        If you peek at the online documentation, you’d see the <code class="cf1">fuzzystrmatch</code> module contains other functions: <code class="cf">dmetaphone</code> (double metaphone), <code class="cf">dmetaphone_alt</code> (for alternative name pronunciations), and <code class="cf">soundex</code> (a really old algorithm from the 1880s made by the U.S. Census to compare common American surnames).
      </p>
<p id="N121CE" class="calibre5">
        You can dissect the functions’ representations by selecting their output.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> name, dmetaphone(name), dmetaphone_alt(name),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  metaphone(name, 8), soundex(name)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> actors;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      name      | dmetaphone | dmetaphone_alt | metaphone | soundex​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------------+------------+----------------+-----------+--------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ 50 Cent        | SNT        | SNT            | SNT       | C530​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Aaron Eckhart  | ARNK       | ARNK           | ARNKHRT   | A652​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Agatha Hurle   | AK0R       | AKTR           | AK0HRL    | A236​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​:​</code>​</div>
</td>
</tr>
</table>
<p id="N12201" class="calibre5">
        There is no single best function to choose, and the optimal choice depends on your dataset.
      </p>
<h3 class="calibre20">Combining String Matches</h3>
<p id="N1220E" class="calibre5">
      With all of our string searching ducks in a row, we’re ready to start combining them in interesting ways.
    </p>
<p id="N1221B" class="calibre5">
      One of the most flexible aspects of metaphones is that their outputs are just strings. This allows you to mix and match with other string matchers. 
    </p>
<p id="N1221E" class="calibre5">
      For example, we could use the trigram operator against <code class="cf">metaphone</code> outputs and then order the results by the lowest Levenshtein distance. This means “Get me names that sound the most like <code class="cf">Robin Williams</code>, in order.”
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> * <strong class="prompt">FROM</strong> actors​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> metaphone(name,8) % metaphone(<em class="string">'Robin Williams'</em>,8)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">ORDER</strong> <strong class="prompt">BY</strong> levenshtein(lower(<em class="string">'Robin Williams'</em>), lower(name));​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ actor_id |      name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------+-----------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     2442 | John Williams​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     4090 | Robin Shou​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     4093 | Robin Williams​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     4479 | Steven Williams​</code>​</div>
</td>
</tr>
</table>
<p id="N12265" class="calibre5">
    Note it isn’t perfect. Robin Williams ranked at #3. Unbridled exploitation of this flexibility can yield other funny results, so be careful.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> * <strong class="prompt">FROM</strong> actors <strong class="prompt">WHERE</strong> dmetaphone(name) % dmetaphone(<em class="string">'Ron'</em>);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ actor_id |    name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------+-------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     3911 | Renji Ishibashi​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     3913 | Renée Zellweger​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​:​</code>​</div>
</td>
</tr>
</table>
<p id="N12296" class="calibre5">
      The combinations are vast, limited only by your experimentations.
    </p>
<h3 id="sec.genresasaHypercube" class="calibre20">Genres as a Multidimensional Hypercube</h3>
<p id="N1229E" class="calibre5">
      The last contributed package we investigate is <code class="cf">cube</code>. We’ll use the <code class="cf">cube</code> datatype to map a movie’s genres as a multidimensional vector. We will then use methods to efficiently query for the closest points within the boundary of a hypercube to give us a list of similar movies.
    </p>
<p id="N122B8" class="calibre5">
      As you may have noticed in the beginning of Day 3, we created a column named <code class="cf">genres</code> of type <code class="cf">cube</code>. Each value is a point in 18-dimensional space with each dimension representing a genre. Why represent movie genres as points in n-dimensional space? Movie categorization is not an exact science, and many movies are not 100 percent comedy or 100 percent tragedy—they are something in between.
    </p>
<p id="N122C1" class="calibre5">
      In our system, each genre is scored from (the totally arbitrary numbers) 0 to 10 based on how strong the movie is within that genre—with 0 being nonexistent and  10 being the strongest.
    </p>
<p id="N122C4" class="calibre5">
<span class="calibre6">Star Wars</span> has a genre vector of <code class="cf">(0,7,0,0,0,0,0,0,0,7,0,0,0,0,10,0,0,0)</code>. The <code class="cf">genres</code> table describes the <code class="cf">position</code> of each dimension in the vector. We can decrypt its genre values by extracting the <code class="cf">cube_ur_coord(vector,dimension)</code> using each <code class="cf">genres</code>.<code class="cf">position</code>. For clarity, we filter out genres with scores of 0.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> name,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  cube_ur_coord(<em class="string">'(0,7,0,0,0,0,0,0,0,7,0,0,0,0,10,0,0,0)'</em>, position) <strong class="prompt">as</strong> score​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> genres g​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> cube_ur_coord(<em class="string">'(0,7,0,0,0,0,0,0,0,7,0,0,0,0,10,0,0,0)'</em>, position) &gt; 0;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   name    | score​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-----------+-------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Adventure |     7​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Fantasy   |     7​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ SciFi     |    10​</code>​</div>
</td>
</tr>
</table>
<p id="N12317" class="calibre5">
      We will find similar movies by finding the nearest points. To understand why this works, we can envision two movies on a two-dimensional genre graph, like the graph shown below.. If your favorite movie is <span class="calibre6">Animal House</span>, you’ll probably want to see <span class="calibre6">The 40 Year Old Virgin</span> more than <span class="calibre6">Oedipus</span>—a story distinctly lacking in comedy. In our two-dimensional universe, it’s a simple nearest-neighbor search to find likely matches.
     </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/postgres-2d-genres.png" alt="images/postgres-2d-genres.png" class="calibre27"/>
</div>
<p id="N1232D" class="calibre5">
      We can extrapolate this into more dimensions with more genres, be it 2, 3, or 18. The principle is the same: a nearest-neighbor match to the nearest points in genre space will yield the closest genre matches.
    </p>
<p id="N12330" class="calibre5">
      The nearest matches to the genre vector can be discovered by the <code class="cf">cube_distance(point1, point2)</code>. Here we can find the distance of all movies to the <span class="calibre6">Star Wars</span> genre vector, nearest first.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> *,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  cube_distance(genre, <em class="string">'(0,7,0,0,0,0,0,0,0,7,0,0,0,0,10,0,0,0)'</em>) dist​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">ORDER</strong> <strong class="prompt">BY</strong> dist;​</code>​</div>
</td>
</tr>
</table>
<p id="N1235B" class="calibre5">
      We created the <code class="cf">movies_genres_cube</code> cube index earlier when we created the tables. However, even with an index, this query is still relatively slow, since it requires a full-table scan. It computes the distance on every row and then sorts them.
    </p>
<p id="N12361" class="calibre5">
      Rather than compute the distance of every point, we can instead focus on likely points by way of a <span class="calibre6">bounding cube</span>. Just like finding the closest five towns on a map will be faster on a state map than a world map, bounding reduces the points we need to look at.
    </p>
<p id="N12367" class="calibre5">
      We use <code class="cf">cube_enlarge(cube,radius,dimensions)</code> to build an 18-dimensional cube that is some length (radius) wider than a point. 
    </p>
<p id="N1236E" class="calibre5">
      Let’s view a simpler example. If we built a two-dimensional square one unit around a point (1,1), the lower-left point of the square would be at (0,0), and the upper-right point would be (2,2).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> cube_enlarge(<em class="string">'(1,1)'</em>,1,2);​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ cube_enlarge​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​---------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ (0, 0),(2, 2)​</code>​</div>
</td>
</tr>
</table>
<p id="N12393" class="calibre5">
      The same principle applies in any number of dimensions. With our bounding hypercube, we can use a special cube operator, <code class="cf">@&gt;</code>, which means <span class="calibre6">contains</span>. This query finds the distance of all points contained within a five-unit cube of the <span class="calibre6">Star Wars</span> genre point.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> title, cube_distance(genre, <em class="string">'(0,7,0,0,0,0,0,0,0,7,0,0,0,0,10,0,0,0)'</em>) dist​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> cube_enlarge(<em class="string">'(0,7,0,0,0,0,0,0,0,7,0,0,0,0,10,0,0,0)'</em>::cube, 5, 18) @&gt; genre​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">ORDER</strong> <strong class="prompt">BY</strong> dist;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​                     title                      |       dist​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​------------------------------------------------+------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Star Wars                                      |                0​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Star Wars: Episode V - The Empire Strikes Back |                2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Avatar                                         |                5​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Explorers                                      | 5.74456264653803​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ Krull                                          | 6.48074069840786​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ E.T. The Extra-Terrestrial                     | 7.61577310586391​</code>​</div>
</td>
</tr>
</table>
<p id="N123E5" class="calibre5">
      Using a subselect, we can get the genre by movie name and perform our calculations against that genre using a table alias.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">SELECT</strong> m.movie_id, m.title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">FROM</strong> movies m, (<strong class="prompt">SELECT</strong> genre, title <strong class="prompt">FROM</strong> movies <strong class="prompt">WHERE</strong> title = <em class="string">'Mad Max'</em>) s​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">WHERE</strong> cube_enlarge(s.genre, 5, 18) @&gt; m.genre <strong class="prompt">AND</strong> s.title &lt;&gt; m.title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">ORDER</strong> <strong class="prompt">BY</strong> cube_distance(m.genre, s.genre)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​LIMIT 10;​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ movie_id |           title​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​----------+----------------------------​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1405 | Cyborg​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1391 | Escape from L.A.​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1192 | Mad Max Beyond Thunderdome​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1189 | Universal Soldier​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1222 | Soldier​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1362 | Johnny Mnemonic​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      946 | Alive​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      418 | Escape from New York​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1877 | The Last Starfighter​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     1445 | The Rocketeer​</code>​</div>
</td>
</tr>
</table>
<p id="N12446" class="calibre5">
      This method of movie suggestion is not perfect, but it’s an excellent start. We will see more dimensional queries in later chapters, such as two-dimensional geographic searches in MongoDB (see <a href="f_0038.html#sec.mongo.geo">​<em class="calibre6">GeoSpatial Queries</em>​</a>).
    </p>
<h3 class="calibre20">Day 3 Wrap-Up</h3>
<p id="N1245F" class="calibre5">
    Today we jumped headlong into PostgreSQL’s flexibility at string searches and used the <code class="cf">cube</code> package for multidimensional searching. Most importantly, we caught a glimpse of the nonstandard extensions that puts PostgreSQL at the top of the open source RDBMS field. There are dozens (if not hundreds) of more extensions at your disposal, from geographic storage to cryptographic functions, custom datatypes, and language extensions. Beyond the core power of SQL, contrib packages are what makes PostgreSQL shine.
    </p>
<h4 class="calibre21">Day 3 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N12470" class="calibre5">Find online documentation of all contributed packages bundled into Postgres.</p>
</li>
<li class="calibre23">
<p id="N12474" class="calibre5">Find online POSIX regex documentation (it will also be handy for future chapters).</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N1247E" class="calibre5">Create a stored procedure where you can input a movie title or actor’s name you like, and it will return the top five suggestions based on either movies the actor has starred in or films with similar genres.</p>
</li>
<li class="calibre23">
<p id="N12482" class="calibre5">Expand the movies database to track user comments and extract keywords (minus English stopwords). Cross-reference these keywords with actors’ last names, and try to find the most talked about actors.</p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

