---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0029.html
next: f_0031.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N13C1C" class="calibre18">4.2 Day 1: CRUD and Table Administration</h2>
<p id="N13C20" class="calibre5">
Today’s goal is to learn the nuts and bolts of working with HBase.  We’ll get a local instance of HBase running in stand-alone mode, and then we’ll use the HBase shell to create and alter tables and to insert and modify data using basic commands.  After that, we’ll explore how to perform some of those operations programmatically by using the HBase Java API in JRuby.  Along the way, we’ll uncover some HBase architectural concepts, such as the relationship between rows, column families, columns, and values in a table.
    </p>
<p id="N13C23" class="calibre5">
A fully operational, production-quality HBase cluster should really consist of no fewer than five nodes, or so goes the conventional wisdom.  Such a setup would be overkill for our needs.  Fortunately, HBase supports three  running modes:
      </p>
<ul class="calibre22">
<li class="calibre23">
<p id="N13C3D" class="calibre5">Stand-alone mode is a single machine acting alone.</p>
</li>
<li class="calibre23">
<p id="N13C41" class="calibre5">Pseudodistributed mode is a single node pretending to be a cluster.</p>
</li>
<li class="calibre23">
<p id="N13C45" class="calibre5">Fully distributed mode is a cluster of nodes working together.</p>
</li>
</ul>
<p id="N13C48" class="calibre5">
For most of this chapter, we’ll be running HBase in stand-alone mode.  Even that can be a bit of a challenge, so although we won’t cover every aspect of installation and administration, we’ll give some relevant troubleshooting tips where appropriate.
      </p>
<h3 class="calibre20">Configuring HBase</h3>
<p id="N13C4F" class="calibre5">
Before using HBase, it has to be configured.  Configuration settings for HBase are kept in a file called <code class="cf">hbase-site.xml</code>, which can be found in the <code class="cf">${HBASE_HOME}/</code>
<code class="cf">conf/</code> directory.  Note that <code class="cf">HBASE_HOME</code> is an environment variable pointing to the directory where HBase has been installed.
        </p>
<p id="N13C66" class="calibre5">
Initially, this file contains just an empty <code class="cf">&lt;configuration&gt;</code> tag.  You can add any number of property definitions to your configuration using this format:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">&lt;property&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">&lt;name&gt;</strong>some.property.name<strong class="prompt">&lt;/name&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">&lt;value&gt;</strong>A property value<strong class="prompt">&lt;/value&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">&lt;/property&gt;</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N13C8D" class="calibre5">
A full list of available properties, along with default values and descriptions, is available in <code class="cf">hbase-default.xml</code> under <code class="cf">${HBASE_HOME}/src/main/resources</code>.
        </p>
<p id="N13C96" class="calibre5">
By default, HBase uses a temporary directory to store its data files.  This means you’ll lose <span class="calibre6">all your data</span> whenever the operating system decides to reclaim the disk space.
        </p>
<p id="N13C9C" class="calibre5">
To keep your data around, you should specify an involatile storage location.  Set the <code class="cf">hbase.rootdir</code> property to an appropriate path like so:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">&lt;property&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">&lt;name&gt;</strong>hbase.rootdir<strong class="prompt">&lt;/name&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">&lt;value&gt;</strong>file:///path/to/hbase<strong class="prompt">&lt;/value&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">&lt;/property&gt;</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N13CC6" class="calibre5">
To start HBase, open a terminal (command prompt) and run this command:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​${HBASE_HOME}/bin/start-hbase.sh​</code>​</div>
</td>
</tr>
</table>
<p id="N13CD5" class="calibre5">
To shut down HBase, use the <code class="cf">stop-hbase.sh</code> command in the same directory.
        </p>
<p id="N13CDB" class="calibre5">
If anything goes wrong, take a look at the most recently modified files in the <code class="cf">${HBASE_HOME}/logs</code> directory.  On *nix-based systems, the following command will pipe the latest log data to the console as it’s written:
</p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">cd</strong> ${HBASE_HOME}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​find ./logs -name <em class="string">"hbase-*.log"</em> -exec tail -f {} \;​</code>​</div>
</td>
</tr>
</table>
<h3 class="calibre20">The HBase Shell</h3>
<p id="N13D06" class="calibre5">
The HBase shell is a JRuby-based command-line program you can use to interact with HBase.  In the shell, you can add and remove tables, alter table schema, add or delete data, and do a bunch of other tasks.  Later we’ll explore other means of connecting to HBase, but for now the shell will be our home.
        </p>
<p id="N13D16" class="calibre5">
With HBase running, open a terminal and fire up the HBase shell:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​${HBASE_HOME}/bin/hbase shell​</code>​</div>
</td>
</tr>
</table>
<p id="N13D25" class="calibre5">
To confirm that it’s working properly, try asking it for version information.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> version</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​0.90.3, r1100350, Sat May  7 13:31:12 PDT 2011​</code>​</div>
</td>
</tr>
</table>
<p id="N13D3A" class="calibre5">
You can enter <code class="cf">help</code> at any time to see a list of available commands or to get usage information about a particular command.
        </p>
<p id="N13D40" class="calibre5">
Next, execute the <code class="cf">status</code> command to see how your HBase server is holding up.</p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> status</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1 servers, 0 dead, 2.0000 average load​</code>​</div>
</td>
</tr>
</table>
<p id="N13D5A" class="calibre5">
If an error occurs for any of these commands or if the shell hangs, it could be a connection problem.  HBase does its best to automatically configure its services based on your network setup, but sometimes it gets it wrong.  If you’re seeing these symptoms, check out <a href="#sb.hbase.network.settings">​<em class="calibre6">HBase Network Settings</em>​</a>.
        </p>
<div class="sidebar" id="sb.hbase.network.settings">
<div class="sidebar-title">HBase Network Settings</div>
<div class="calibre2">
<p id="N13D64" class="calibre5">
By default, HBase tries to make its services available to external clients, but in our case, we simply need to connect from the same machine.  So, it might help to add some or all of the following properties to your <code class="cf2">hbase-site.xml</code> file (your mileage may vary).  Note that the values in the following table will help only if you plan to connect locally and not remotely:
          </p>
<table class="simpletable1">
<thead class="calibre29">
<tr class="calibre8">
<th class="hlines">
<p class="last-para-in-cell">property name</p>
</th>
<th class="hlines">
<p class="last-para-in-cell">value</p>
</th>
</tr>
</thead>
<tbody class="calibre7">
<tr class="calibre8">
<td class="calibre30">
<p class="last-para-in-cell">hbase.master.dns.interface</p>
</td>
<td class="calibre30">
<p class="last-para-in-cell">lo</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">hbase.master.info.bindAddress</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">127.0.0.1</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">hbase.regionserver.info.bindAddress</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">127.0.0.1</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">hbase.regionserver.dns.interface</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">lo</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">hbase.zookeeper.dns.interface</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">lo</p>
</td>
</tr>
</tbody>
</table>
<p id="N13DB4" class="calibre5">
The properties tell HBase how to establish connections for the master server and region servers (both of which we’ll discuss later) and the zookeeper configuration service.  The properties with the value “lo” refer to the so-called  loopback interface.  On *nix systems, the loopback interface is not a real network interface (like your Ethernet or wireless cards) but rather a software-only interface for the computer to use to connect to itself.  The <code class="cf2">bindAddress</code> properties tell HBase what IP address to try to listen on.
          </p>
</div>
</div>
<h3 class="calibre20">Creating a Table</h3>
<p id="N13DBE" class="calibre5">
A map is a key-value pair, like a hash in Ruby or a hashmap in Java. A table in HBase is basically a big map.  Well, more accurately, it’s a map of maps.
      </p>
<p id="N13DD3" class="calibre5">
In an HBase table, keys are arbitrary strings that each map to a <span class="calibre6">row</span> of data.  A row is itself a map, in which keys are called <span class="calibre6">columns</span> and values are uninterpreted arrays of bytes.  Columns are grouped into <span class="calibre6">column families</span>, so a column’s full name consists of two parts: the column family name and the <span class="calibre6">column qualifier</span>.  Often these are concatenated together using a colon (for example, <code class="cf">’family:qualifier’</code>).
      </p>
<p id="N13DF4" class="calibre5">
To illustrate these concepts, take a look at Figure 13, <a href="#fig.hbase.simple.architecture">​<em class="calibre6">HBase tables consist of rows, keys, column families, columns, and values</em>​</a>.
      </p>
<div class="figure" id="fig.hbase.simple.architecture">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/hbase-simple-architecture.png" alt="images/hbase-simple-architecture.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 13. HBase tables consist of rows, keys, column families, columns, and values.</div>
</div>
<p id="N13E0F" class="calibre5">
In this figure, we have a hypothetical table with two column families: <code class="cf">color</code> and <code class="cf">shape</code>.  The table has two rows—denoted by dashed boxes—identified by their row keys: <code class="cf">first</code> and <code class="cf">second</code>.  Looking at just the <code class="cf">first</code> row, we see that it has three columns in the <code class="cf">color</code> column family (with qualifiers <code class="cf">red</code>, <code class="cf">blue</code>, and <code class="cf">yellow</code>) and one column in the <code class="cf">shape</code> column family (<code class="cf">square</code>).  The combination of row key and column name (including both family and qualifier) creates an address for locating data.  In this example, the tuple <code class="cf">first/color:red</code> points us to the value <code class="cf">’#F00’</code>.
      </p>
<p id="N13E39" class="calibre5">
Now let’s take what we’ve learned about table structure and use it to do something fun—we’re going to make a wiki!
      </p>
<p id="N13E3C" class="calibre5">
There are lots of juicy info bits we might want to associate with a wiki, but we’ll start with the bare minimum.  A wiki contains pages, each of which has a unique title string and contains some article text.
      </p>
<p id="N13E3F" class="calibre5">
Use the <code class="cf">create</code> command to make our wiki table:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> create 'wiki', 'text'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​0 row(s) in 1.2160 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N13E57" class="calibre5">
Here, we’re creating a table called <code class="cf">wiki</code> with a single column family called <code class="cf">text</code>.  The table is currently empty; it has no rows and thus no columns.  Unlike a relational database, in HBase a column is specific to the row that contains it.  When we start adding rows, we’ll add columns to store data at the same time.
      </p>
<p id="N13E60" class="calibre5">
Visualizing our table architecture, we arrive at something like Figure 14, <a href="#fig.hbase.simple.wiki.architecture">​<em class="calibre6">The wiki table has one column family</em>​</a>.  By our own convention, we expect each row to have exactly one column within the <code class="cf">text</code> family, qualified by the empty string (<code class="cf">”</code>).  So, the full column name containing the text of a page will be <code class="cf">’text:’</code>.
      </p>
<p id="N13E6F" class="calibre5">
Of course, for our wiki table to be useful, it’s going to need content.  Let’s add some!
</p>
<div class="figure" id="fig.hbase.simple.wiki.architecture">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/hbase-simple-wiki-architecture.png" alt="images/hbase-simple-wiki-architecture.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 14. The wiki table has one column family.</div>
</div>
<h3 class="calibre20">Inserting, Updating, and Retrieving Data</h3>
<p id="N13E96" class="calibre5">
Our wiki needs a Home page, so we’ll start with that.  To add data to an HBase table, use the <code class="cf">put</code> command:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> put 'wiki', 'Home', 'text:', 'Welcome to the wiki!'</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N13EBA" class="calibre5">
This command inserts a new row into the wiki table with the key <code class="cf">’Home’</code>, adding <code class="cf">’Welcome to the wiki!’</code> to the column called <code class="cf">’text:’</code>.
      </p>
<p id="N13EC6" class="calibre5">
We can query the data for the <code class="cf">’Home’</code> row using <code class="cf">get</code>, which requires two parameters: the table name and the row key.  You can optionally specify a list of columns to return.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> get 'wiki', 'Home', 'text:'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​COLUMN    CELL​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ text:    timestamp=1295774833226, value=Welcome to the wiki!​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1 row(s) in 0.0590 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N13EE7" class="calibre5">
Notice the <code class="cf">timestamp</code> field in the output.  HBase stores an integer timestamp for all data values, representing time in milliseconds since the epoch (00:00:00 UTC on January 1, 1970).  When a new value is written to the same cell, the old value hangs around, indexed by its timestamp.  This is a pretty awesome feature.  Most databases require you to specifically handle historical data yourself, but in HBase, versioning is baked right in!
      </p>
<div class="sidebar" id="sb.hbase.facebook.casestudy">
<div class="sidebar-title">Case Study: Facebook's Messaging Index Table</div>
<div class="calibre2">
<p id="N13F00" class="calibre5">
          Facebook uses HBase as a principal component of its messaging infrastructure, both for storing message data and for maintaining an inverted index for search.
        </p>
<p id="N13F08" class="calibre5">
          In its index table schema:
        </p>
<ul class="calibre22">
<li class="calibre23">
<p id="N13F0E" class="calibre5">The row keys are user IDs.</p>
</li>
<li class="calibre23">
<p id="N13F12" class="calibre5">Column qualifiers are words that appear in that user’s messages.</p>
</li>
<li class="calibre23">
<p id="N13F16" class="calibre5">Timestamps are message IDs of messages that contain that word.</p>
</li>
</ul>
<p id="N13F19" class="calibre5">
          Since messages between users are immutable, the index entries for a message are static as well.  The concept of versioned values doesn’t make sense.
        </p>
<p id="N13F1C" class="calibre5">
          For Facebook, manipulating the timestamp to match message IDs gives them another dimension for storing data.
        </p>
</div>
</div>
<h4 class="calibre21">Put and Get</h4>
<p id="N13F23" class="calibre5">
The <code class="cf">put</code> and <code class="cf">get</code> commands allow you to specify a timestamp explicitly. If using milliseconds since the epoch doesn’t strike your fancy, you can specify another integer value of your choice.  This gives you an extra dimension to work with if you need it.  If you don’t specify a timestamp, HBase will use the current time when inserting, and it will return the most recent version when reading.
      </p>
<p id="N13F4A" class="calibre5">
For an example of how one company chose to overload the timestamp field, see <a href="#sb.hbase.facebook.casestudy">​<em class="calibre6">Case Study: Facebook’s Messaging Index Table</em>​</a>.  In the rest of this chapter, we’ll continue to use the default timestamp interpretation.
      </p>
<h3 class="calibre20">Altering Tables</h3>
<p id="N13F54" class="calibre5">
So far, our wiki schema has pages with titles, text, and an integrated version history but nothing else.  Let’s expand our requirements to include the following:
      </p>
<ul class="calibre22">
<li class="calibre23">
<p id="N13F64" class="calibre5">In our wiki, a page is uniquely identified by its title.</p>
</li>
<li class="calibre23">
<p id="N13F68" class="calibre5">A page can have unlimited revisions.</p>
</li>
<li class="calibre23">
<p id="N13F6C" class="calibre5">A revision is identified by its timestamp.</p>
</li>
<li class="calibre23">
<p id="N13F70" class="calibre5">A revision contains text and optionally a commit comment.</p>
</li>
<li class="calibre23">
<p id="N13F74" class="calibre5">A revision was made by an author, identified by name.</p>
</li>
</ul>
<p id="N13F77" class="calibre5">
Visually, our requirements can be sketched, like in Figure 15, <a href="#fig.hbase.requirements">​<em class="calibre6">Requirements for a wiki page (including time dimension)</em>​</a>.  In this abstract representation of our requirements for a page, we see that each revision has an author, a commit comment, some article text, and a timestamp.  The title of a page is not part of a revision, because it’s the identifier we use to denote revisions belonging to the same page.
      </p>
<p id="N13F82" class="calibre5">
Mapping our vision to an HBase table takes a somewhat different form, as illustrated in Figure 16, <a href="#fig.hbase.wiki.architecture">​<em class="calibre6">Updated wiki table architecture (time dimension not shown)</em>​</a>.  Our wiki table uses the title as the row key and will group other page data into two column families called <code class="cf">text</code> and <code class="cf">revision</code>.  The <code class="cf">text</code> column family is the same as before; we expect each row to have exactly one column, qualified by the empty string (<code class="cf">”</code>), to hold the article contents.  The job of the <code class="cf">revision</code> column family is to hold other revision-specific data, such as the author and commit comment.
      </p>
<div class="figure" id="fig.hbase.requirements">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/hbase-wiki-requirements.png" alt="images/hbase-wiki-requirements.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 15. Requirements for a wiki page (including time dimension)</div>
</div>
<div class="figure" id="fig.hbase.wiki.architecture">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/hbase-wiki-architecture.png" alt="images/hbase-wiki-architecture.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 16. Updated wiki table architecture (time dimension not shown)</div>
</div>
<h4 class="calibre21">Defaults</h4>
<p id="N13FBF" class="calibre5">
We created the wiki table with no special options, so all the HBase default values were used. One such default value is to keep only three <code class="cf">VERSIONS</code> of column values, so let’s increase that.  To make schema changes, first we have to take the table offline with the <code class="cf">disable</code> command.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> disable 'wiki'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​0 row(s) in 1.0930 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N13FDA" class="calibre5">
Now we can modify column family characteristics using the <code class="cf">alter</code> command.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> alter 'wiki', { NAME =&gt; 'text', VERSIONS =&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string">hbase*</em>   <strong class="prompt">org.apache.hadoop.hbase.HConstants::ALL_VERSIONS }</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​0 row(s) in 0.0430 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N13FF9" class="calibre5">
Here, we’re instructing HBase to alter the <code class="cf">text</code> column family’s <code class="cf">VERSIONS</code> attribute.  There are a number of other attributes we could have set, some of which we’ll discuss in Day 2. The <code class="cf">hbase*</code> line means that it’s a continuation of the previous line.
</p>
<h4 class="calibre21">Altering a Table</h4>
<p id="N1400F" class="calibre5">
Operations that alter column family characteristics can be very expensive because HBase has to create a new column family with the chosen specifications and then copy all the data over.  In a production system, this may incur significant downtime.  For this reason, settling on column family options up front is a good thing.
      </p>
<p id="N1401E" class="calibre5">
With the wiki table still disabled, let’s add the <code class="cf">revision</code> column family, again using the <code class="cf">alter</code> command:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> alter 'wiki', { NAME =&gt; 'revision', VERSIONS =&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string">hbase*</em>   <strong class="prompt">org.apache.hadoop.hbase.HConstants::ALL_VERSIONS }</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​0 row(s) in 0.0660 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N14040" class="calibre5">
Just as before, with the <code class="cf">text</code> family, we’re only adding a <code class="cf">revision</code> <span class="calibre6">column family</span> to the table schema, not individual <span class="calibre6">columns</span>.  Though we expect each row to eventually contain a <code class="cf">revision:author</code> and <code class="cf">revision:comment</code>, it’s up to the client to honor this expectation; it’s not written into any formal schema.  If someone wants to add a <code class="cf">revision:foo</code> for a page, HBase won’t stop them.
</p>
<h4 class="calibre21">Moving On</h4>
<p id="N14062" class="calibre5">
With these additions in place, let’s reenable our wiki:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> enable 'wiki'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​0 row(s) in 0.0550 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N14077" class="calibre5">
Now that our wiki table has been modified to support our growing requirements list, we can start adding data to columns in the <code class="cf">revision</code> column family. 
      </p>
<h3 class="calibre20">Adding Data Programmatically</h3>
<p id="N14081" class="calibre5">
As we’ve seen, the HBase shell is great for tasks such as manipulating tables.  Sadly, the shell’s data insertion support isn’t the best.  The <code class="cf">put</code> command only allows setting one column value at a time, and in our newly updated schema, we need to add multiple column values simultaneously so they all share the same timestamp.  We’re going to need to start scripting.
      </p>
<p id="N14097" class="calibre5">
The following script can be executed directly in the HBase shell, since the shell is also a JRuby interpreter.  When run, it adds a new version of the text for the Home page, setting the author and comment fields at the same time.  JRuby runs on the Java virtual machine (JVM), giving it access to the HBase Java code. These examples will not work with non-JVM Ruby.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/hbase/put_multiple_columns.rb">hbase/put_multiple_columns.rb</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​import <em class="string">'org.apache.hadoop.hbase.client.HTable'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​import <em class="string">'org.apache.hadoop.hbase.client.Put'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">def</strong> jbytes( *args )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  args.map { |arg| arg.to_s.to_java_bytes }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​table = HTable.new( @hbase.configuration, <em class="string">"wiki"</em> )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​p = Put.new( *jbytes( <em class="string">"Home"</em> ) )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​p.add( *jbytes( <em class="string">"text"</em>, <em class="string">""</em>, <em class="string">"Hello world"</em> ) )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​p.add( *jbytes( <em class="string">"revision"</em>, <em class="string">"author"</em>, <em class="string">"jimbo"</em> ) )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​p.add( *jbytes( <em class="string">"revision"</em>, <em class="string">"comment"</em>, <em class="string">"my first edit"</em> ) )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​table.put( p )​</code>​</div>
</td>
</tr>
</table>
<p id="N140FD" class="calibre5">
The <code class="cf">import</code> lines bring references to useful HBase classes into the shell.  This saves us from having to write out the full namespace later.  Next, the <code class="cf">jbytes</code> function takes any number of arguments and returns an array converted to Java byte arrays, as the HBase API methods demand.
      </p>
<p id="N14106" class="calibre5">
After that, we create a local variable (<code class="cf">table</code>) pointing to our wiki table, using the <code class="cf">@hbase</code> administration object for configuration information.
      </p>
<p id="N1410F" class="calibre5">
Next we stage a commit operation by creating and preparing a new instance of <code class="cf">Put</code>, which takes the row to be modified.  In this case, we’re sticking with the Home page we’ve been working with thus far.  Finally, we <code class="cf">add</code> properties to our <code class="cf">Put</code> instance and then call on the <code class="cf">table</code> object to execute the <code class="cf">put</code> operation we’ve prepared. The <code class="cf">add</code> method has several forms; in our case, we used the three-argument version: <code class="cf">add(column_family, column_qualifier, value)</code>.  
</p>
<h4 class="calibre21">Why Column Families?</h4>
<p id="N1412F" class="calibre5">
      You may be tempted to build your whole structure without column families; why not store all of a row’s data in a single column family? That solution would be simpler to implement. But there are downsides to avoiding column families, namely, missing out on fine-grained performance tuning.  Each column family’s performance options are configured independently.  These settings affect things such as read and write speed and disk space consumption.
      </p>
<p id="N1413C" class="calibre5">
All operations in HBase are atomic at the <span class="calibre6">row level</span>.  No matter how many columns are affected, the operation will have a consistent view of the particular row being accessed or modified.  This design decision helps clients reason intelligently about the data.
      </p>
<p id="N14142" class="calibre5">
Our <code class="cf">put</code> operation affects several columns and doesn’t specify a timestamp, so all column values will have the same timestamp (the current time in milliseconds).  Let’s verify by invoking <code class="cf">get</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> get 'wiki', 'Home'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​COLUMN             CELL​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ revision:author   timestamp=1296462042029, value=jimbo​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ revision:comment  timestamp=1296462042029, value=my first edit​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ text:             timestamp=1296462042029, value=Hello world​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​3 row(s) in 0.0300 seconds​</code>​</div>
</td>
</tr>
</table>
<p id="N14169" class="calibre5">
As you can see, each column value listed previously has the same <code class="cf">timestamp</code>.
      </p>
<h3 class="calibre20">Day 1 Wrap-Up</h3>
<p id="N14173" class="calibre5">
Today, we got a firsthand look at a running HBase server.  We learned how to configure it and monitor log files for troubleshooting.  Using the HBase shell, we performed basic administration and data manipulation tasks.
      </p>
<p id="N14176" class="calibre5">
In modeling a wiki system, we explored schema design in HBase. We learned how to create tables and manipulate column families.  Designing an HBase schema means making choices about column family options and, just as important, our semantic interpretation of features like timestamps and row keys.
     </p>
<p id="N1417C" class="calibre5">
We also started poking around in the HBase Java API by executing JRuby code in the shell.  In Day 2, we’ll take this a step further, using the shell to run custom scripts for big jobs like data import.
      </p>
<p id="N1417F" class="calibre5">
Ideally you’ve begun to shrug off some of the relational concepts that burden terms such as <span class="calibre6">table</span>, <span class="calibre6">row</span>, and <span class="calibre6">column</span>. The difference between how HBase uses these terms and what they mean in other systems will become even starker as we explore deeper into HBase’s features.
      </p>
<h3 class="calibre20">Day 1 Homework</h3>
<p id="N1418F" class="calibre5">
 HBase documentation online generally comes in two flavors: extremely technical and nonexistent.  This is slowly changing as “getting started” guides start to appear, but be prepared to spend some time trolling through Javadoc or source code to find answers.
      </p>
<h4 class="calibre21">Find</h4>
<ol class="calibre33">
<li class="calibre23">
<p id="N14199" class="calibre5">Figure out how to use the shell to do the following:</p>
<ul class="calibre38">
<li class="calibre23">
<p id="N1419F" class="calibre5">Delete individual column values in a row</p>
</li>
<li class="calibre23">
<p id="N141A3" class="calibre5">Delete an entire row</p>
</li>
</ul>
</li>
<li class="calibre23">
<p id="N141A7" class="calibre5">Bookmark the HBase API documentation for the version of HBase you’re using.</p>
</li>
</ol>
<h4 class="calibre21">Do</h4>
<ol class="calibre33">
<li class="calibre23">
<p id="N141B1" class="calibre5">
Create a function called <code class="cf">put_many</code> that creates a <code class="cf">Put</code> instance, adds any number of column-value pairs to it, and commits it to a table.  The signature should look like this:
            </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">def</strong> put_many( table_name, row, column_values )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <em class="comment"># your code here</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
</table>
</li>
<li class="calibre23">
<p id="N141D2" class="calibre5">
Define your <code class="cf">put_many</code> function by pasting it in the HBase shell, and then call it like so:
            </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​hbase&gt;<strong class="prompt"> put_many 'wiki', 'Some title', {</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string">hbase*</em>   <strong class="prompt">"text:" =&gt; "Some article text",</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string">hbase*</em>   <strong class="prompt">"revision:author" =&gt; "jschmoe",</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string">hbase*</em>   <strong class="prompt">"revision:comment" =&gt; "no comment" }</strong>​</code>​</div>
</td>
</tr>
</table>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

