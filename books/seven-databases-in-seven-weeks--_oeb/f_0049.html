---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0048.html
next: f_0050.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N18CE2" class="calibre18">7.3 Day 2: REST, Indexes, and Algorithms</h2>
<p id="N18CE6" class="calibre5">
      Today we’ll start with Neo4j’s REST interface. We’ll create nodes and relationships using REST and then use REST to index and execute a full-text search. We’ll then look at a plug-in that lets us execute Gremlin queries on the server through REST, freeing our code from the confines of the Gremlin console—or even running Java at all in our application server or clients.
    </p>
<h3 id="sec.takingARest" class="calibre20">Taking a REST</h3>
<p id="N18CEE" class="calibre5">
        Just like Riak, HBase, Mongo, and CouchDB, Neo4j ships with a REST interface. One of the reasons all of these databases support REST is because it allows language-agnostic interactions in a standard connection interface. We can connect to Neo4j—which requires Java to work—from a separate machine with no trace of Java whatsoever. And with the Gremlin plug-in, we’ll see how to gain the power of its terse query syntax over REST.
      </p>
<p id="N18CFD" class="calibre5">
        First you might want to check that the REST server is running by issuing a <code class="cf">GET</code> against the base URL, which retrieves the root node. It runs on the same port as the web admin tool you used yesterday, at the <code class="cf">/db/data/</code> path. We’ll use our trusty friend <code class="cf">curl</code> to issue the REST commands.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:7474/db/data/</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "relationship_index" : "http://localhost:7474/db/data/index/relationship",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "node" : "http://localhost:7474/db/data/node",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "relationship_types" : "http://localhost:7474/db/data/relationship/types",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "extensions_info" : "http://localhost:7474/db/data/ext",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "node_index" : "http://localhost:7474/db/data/index/node",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "extensions" : {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18D33" class="calibre5">
        It will return a nice JSON object describing the URLs of other commands, like node actions or indices.
        </p>
<h4 id="sec.creatingNodesandRelationships" class="calibre21">Creating Nodes and Relationships Using REST</h4>
<p id="N18D46" class="calibre5">
        It’s as easy to create nodes and relationships in Neo4j REST as in CouchDB or Riak. Creating a node is a <code class="cf">POST</code> to the <code class="cf">/db/data/node</code> path with JSON data. As matter of convention, it pays to give each node a <code class="cf">name</code> property. This makes viewing any node’s information easy: just call <code class="cf">name</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -i -X POST http://localhost:7474/db/data/node \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{"name": "P.G. Wodehouse", "genre": "British Humour"}'</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N18D83" class="calibre5">
        When posted, you’ll get the node path in the header and a body of metadata about the node (both are truncated here for brevity). All of this data is retrievable by calling <code class="cf">GET</code> on the given header <code class="cf">Location</code> value (or the <code class="cf">self</code> property in the metadata).
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​HTTP/1.1 201 Created​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Location: http://localhost:7474/db/data/node/9​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Content-Type: application/json​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "outgoing_relationships" :​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/9/relationships/out",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "data" : {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "genre" : "British Humour",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "name" : "P.G. Wodehouse"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "traverse" : "http://localhost:7474/db/data/node/9/traverse/{returnType}",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "all_typed_relationships" :​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/9/relationships/all/{-list|&amp;|types}",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "property" : "http://localhost:7474/db/data/node/9/properties/{key}",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "self" : "http://localhost:7474/db/data/node/9",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "properties" : "http://localhost:7474/db/data/node/9/properties",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "outgoing_typed_relationships" :​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/9/relationships/out/{-list|&amp;|types}",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "incoming_relationships" :​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/9/relationships/in",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "extensions" : {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "create_relationship" : "http://localhost:7474/db/data/node/9/relationships",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "paged_traverse" :​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/.../{returnType}{?pageSize,leaseTime}",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "all_relationships" : "http://localhost:7474/db/data/node/9/relationships/all",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "incoming_typed_relationships" :​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/9/relationships/in/{-list|&amp;|types}"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18DF5" class="calibre5">
          If you just want the node properties (not the metadata), you can <code class="cf">GET</code> that by appending <code class="cf">/properties</code> to the node URL or even an individual property by further appending the property name.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:7474/db/data/node/9/properties/genre</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"British Humour"​</code>​</div>
</td>
</tr>
</table>
<p id="N18E10" class="calibre5">
          One node doesn’t do us much good, so go ahead and create another one with the properties <code class="cf">["name" : "Jeeves Takes Charge", "style" : "short story"]</code>.
        </p>
<p id="N18E16" class="calibre5">
          Since P.G. Wodehouse wrote the short story “Jeeves Takes Charge,” we can make a relationship between them.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -i -X POST http://localhost:7474/db/data/node/9/relationships \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{"to": "http://localhost:7474/db/data/node/10", "type": "WROTE",</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "data": {"published": "November 28, 1916"}}'​</code>​</div>
</td>
</tr>
</table>
<p id="N18E33" class="calibre5">
          A nice thing about the REST interface is that it actually reported on how to create a relationship early in the body metadata’s <code class="cf">create_relationship</code> property.  In this way, the REST interfaces tend to be mutually discoverable.
          </p>
<h4 id="sec.findingYourPath" class="calibre21">Finding Your Path</h4>
<p id="N18E47" class="calibre5">
          Through the REST interface, you can find the path between two nodes by posting the request data to the starting node’s <code class="cf">/paths</code> URL. The <code class="cf">POST</code> request data must be a JSON string denoting the node you want the path to, the type of relationships you want to follow, and the path-finding algorithm to use.
        </p>
<p id="N18E5C" class="calibre5">
          For example, here we’re looking for a path following relationships of the type <code class="cf">WROTE</code> from node 1 using the <code class="cf">shortestPath</code> algorithm and capping out at a depth of 10.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST http://localhost:7474/db/data/node/9/paths \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{"to":"http://localhost:7474/db/data/node/10",</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "relationships": {"type" : "WROTE"},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "algorithm":"shortestPath", "max_depth":10}'​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "start" : "http://localhost:7474/db/data/node/9",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "nodes" : [​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/9",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "http://localhost:7474/db/data/node/10"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "length" : 1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "relationships" : [ "http://localhost:7474/db/data/relationship/14" ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "end" : "http://localhost:7474/db/data/node/10"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​} ]​</code>​</div>
</td>
</tr>
</table>
<p id="N18EA0" class="calibre5">
          The other path algorithm choices are <code class="cf">allPaths</code>, <code class="cf">allSimplePaths</code>, and <code class="cf">dijkstra</code>. Details on these algorithms can be found in the online documentation,<a id="FNPTR-47" href="f_0051.html#FOOTNOTE-47">[47]</a> but covering them in detail is outside the scope of this book.
          </p>
<h4 id="sec.indexing" class="calibre21">Indexing</h4>
<p id="N18EBD" class="calibre5">
        Like other databases we’ve seen, Neo4j supports fast data lookups by constructing indexes. There is a twist, though. Unlike other database indexes where you perform queries in much the same way as without one, Neo4j indexes have a different path. This is because the indexing service is actually a separate service.
        </p>
<p id="N18ECB" class="calibre5">
        The simplest index is the key-value or hash style. You key the index by some node data, and the value is a REST URL, which points to the node in the graph. You can have as many indexes as you like, so we’ll name this one “authors.” The end of the URL will contain the author name we want to index and pass in node 1 as the value (or whatever your Wodehouse node was).
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST http://localhost:7474/db/data/index/node/authors \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{ "uri" : "http://localhost:7474/db/data/node/9",</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"key" : "name", "value" : "P.G.+Wodehouse"}'​</code>​</div>
</td>
</tr>
</table>
<p id="N18EE8" class="calibre5">
          Retrieving the node is simply a call to the index, which you’ll notice doesn’t return the URL we set but instead the actual node data.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:7474/db/data/index/node/authors/name/P.G.+Wodehouse</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N18EFA" class="calibre5">
          Besides key-value, Neo4j provides a full-text search inverted index, so you can perform queries like this: “Give me all books that have names beginning with ’Jeeves.’” To build this index, we need to build it against the entire dataset, rather than our one-offs earlier. Like Riak, Neo4j incorporates Lucene to build our inverted index.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST http://localhost:7474/db/data/index/node \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{"name":"fulltext", "config":{"type":"fulltext","provider":"lucene"}}'</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N18F1F" class="calibre5">
          The <code class="cf">POST</code> will return a JSON response containing information about the newly added index.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "template" : "http://localhost:7474/db/data/index/node/fulltext/{key}/{value}",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "provider" : "lucene",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "type" : "fulltext"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18F3C" class="calibre5">
          Now if we add Wodehouse to the full-text index, we get this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl -X POST http://localhost:7474/db/data/index/node/fulltext \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-H "Content-Type: application/json" \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-d '{ "uri" : "http://localhost:7474/db/data/node/9",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"key" : "name", "value" : "P.G.+Wodehouse"}'​</code>​</div>
</td>
</tr>
</table>
<p id="N18F53" class="calibre5">
          Then a search is as easy as a Lucene syntax query on the index URL.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:7474/db/data/index/node/fulltext?query=name:P*</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N18F65" class="calibre5">
          Indexes can also be built on edges like earlier; just replace the instances of <code class="cf1">node</code> in the URLs with <code class="cf1">relationship</code>, for example <code class="cf">http://localhost:7474/db/data/index/relationship/published/date/1916-11-28</code>.
          </p>
<h4 id="sec.rESTandGremlin" class="calibre21">REST and Gremlin</h4>
<p id="N18F7C" class="calibre5">
          We spent much of Day 1 using Gremlin and the first half of today using the REST interface. If you wondered which you should use, fear not. The Neo4j REST interface has a Gremlin plug-in (which is installed by default in the version of Neo4j we’re using).<a id="FNPTR-48" href="f_0051.html#FOOTNOTE-48">[48]</a> You can send through REST any commands you could in the Gremlin console. This allows you the power and flexibility of both tools in production. This is a great combination, since Gremlin is better geared toward powerful queries, where REST is geared toward deployment and language flexibility.
          </p>
<p id="N18F94" class="calibre5">
          The following code will return all vertex names. You only  need to send the data to the plug-in URL as a JSON string value, under the field <code class="cf">script</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">http://localhost:7474/db/data/ext/GremlinPlugin/graphdb/execute_script \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "content-type:application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{"script":"g.V.name"}'</strong>​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ "P.G. Wodehouse", "Jeeves Takes Charge" ]​</code>​</div>
</td>
</tr>
</table>
<p id="N18FC0" class="calibre5">
          Although code samples from here on out will use Gremlin, bear in mind that you could instead choose to use REST.
        </p>
<h3 id="sec.bigData" class="calibre20">Big Data</h3>
<p id="N18FC8" class="calibre5">
      Up until now we’ve dealt with very small data sets, so now it’s time to see what Neo4j can do with some big data.
      </p>
<p id="N18FD1" class="calibre5">
      Let’s explore some movie data by grabbing a dataset from Freebase.com. We’ll be using the “performance” tab-separated set.<a id="FNPTR-49" href="f_0051.html#FOOTNOTE-49">[49]</a> Download the file and use the following script, which iterates through each line and creates a relationship between new or existing nodes (matches are found by name in the index).
      </p>
<p id="N18FDA" class="calibre5">
      Be warned, this dataset contains a vast amount of movie information, from blockbusters to foreign films to, well, adult entertainment. You will need the <code class="cf">json</code> and <code class="cf">faraday</code> Ruby gems installed to run this script.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/neo4j/importer.rb">neo4j/importer.rb</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​REST_URL = <em class="string">'http://localhost:7474/'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​HEADER = { <em class="string">'Content-Type'</em> =&gt; <em class="string">'application/json'</em> }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string">%w{rubygems json cgi faraday}</em>.each{|r| require r}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"># make a connection to the Neo4j REST server</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​conn = Faraday.new(:url =&gt; REST_URL) <strong class="prompt">do</strong> |builder|​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  builder.adapter :net_http​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"># method to get existing node from the index, or create one</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">def</strong> get_or_create_node(conn, index, value)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <em class="comment"># look for node in the index</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  r = conn.get(<em class="string">"/db/data/index/node/</em>#{index}<em class="string">/name/</em>#{CGI.escape(value)}<em class="string">"</em>)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  node = (JSON.parse(r.body).first || {})[<em class="string">'self'</em>] <strong class="prompt">if</strong> r.status == 200​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">unless</strong> node​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment"># no indexed node found, so create a new one</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    r = conn.post(<em class="string">"/db/data/node"</em>, JSON.unparse({<em class="string">"name"</em> =&gt; value}), HEADER)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    node = (JSON.parse(r.body) || {})[<em class="string">'self'</em>] <strong class="prompt">if</strong> [200, 201].include? r.status​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment"># add new node to an index</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    node_data = <em class="string">"{</em>\"<em class="string">uri</em>\"<em class="string"> : </em>\"#{node}\"<em class="string">, </em>\"<em class="string">key</em>\"<em class="string"> : </em>\"<em class="string">name</em>\"<em class="string">,</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="string"></em>\"<em class="string">value</em>\"<em class="string"> : </em>\"#{CGI.escape(value)}\"<em class="string">}"</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    conn.post(<em class="string">"/db/data/index/node/</em>#{index}<em class="string">"</em>, node_data, HEADER)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  node​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​puts <em class="string">"begin processing..."</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​count = 0​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​File.open(ARGV[0]).each <strong class="prompt">do</strong> |line|​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  _, _, actor, movie = line.split(<em class="string">"</em>\t<em class="string">"</em>)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">next</strong> <strong class="prompt">if</strong> actor.empty? || movie.empty?​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <em class="comment"># build the actor and movie nodes</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  actor_node = get_or_create_node(conn, <em class="string">'actors'</em>, actor)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  movie_node = get_or_create_node(conn, <em class="string">'movies'</em>, movie)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <em class="comment"># create relationship between actor and movie</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  conn.post(<em class="string">"</em>#{actor_node}<em class="string">/relationships"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    JSON.unparse({ :to =&gt; movie_node, :type =&gt; <em class="string">'ACTED_IN'</em> }), HEADER)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  puts <em class="string">"  </em>#{count}<em class="string"> relationships loaded"</em> <strong class="prompt">if</strong> (count += 1) % 100 == 0​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​puts <em class="string">"done!"</em>​</code>​</div>
</td>
</tr>
</table>
<p id="N190FF" class="calibre5">
      With everything set up, just run the script and point it to the downloaded <code class="cf">performance.tsv</code> file.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">ruby importer.rb performance.tsv</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N19114" class="calibre5">
      This can take hours to run the whole dataset, but you can stop the process at any time for a partial movie/actor list. 
      If you’re running Ruby 1.9, you might have better luck replacing the line <code class="cf">builder.adapter :net_http</code> with <code class="cf">builder.adapter :em_synchrony</code>, which creates a nonblocking connection.
      </p>
<h3 id="sec.fancyAlgorithms" class="calibre20">Fancy Algorithms</h3>
<p id="N19125" class="calibre5">
        With our big movie dataset, it’s time to hang up our REST interface for a while and jump back into Gremlin.
      </p>
<h4 id="sec.ofCourseKevinBacon" class="calibre21">Of Course, Kevin Bacon</h4>
<p id="N1912D" class="calibre5">
          Let’s have a little fun implementing one of the more famous graph algorithms in existence: the Kevin Bacon algorithm. This algorithm is based on a game to find the shortest distance between any actor and Kevin Bacon through commonly acted movies. For instance, Alec Guinness acted in <span class="calibre6">Kafka</span> with Theresa Russell, who was in <span class="calibre6">Wild Things</span> with Kevin Bacon.
        </p>
<p id="N19146" class="calibre5">
          Before continuing, fire up your Gremlin console and start up the graph. Then we’ll create the <code class="cf">costars</code> custom step with the following code. This is similar to the <code class="cf">friendsuggest</code> from yesterday. It finds the costars of an actor node (actors who share an edge with the initial actor’s movies).
        </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/neo4j/costars.groovy">neo4j/costars.groovy</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Gremlin.defineStep( <em class="string">'costars'</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [Vertex, <strong class="prompt">Pipe</strong>],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    _().sideEffect{start = it}.outE(<em class="string">'ACTED_IN'</em>).​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    inV.inE(<em class="string">'ACTED_IN'</em>).outV.filter{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      !start.equals(it)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }.dedup​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​)​</code>​</div>
</td>
</tr>
</table>
<p id="N19180" class="calibre5">
          In Neo4j you don’t so much “query” for a set of values as you “walk” the graph. The nice thing about this concept is that generally the first node walked to will be the closest to your starting node (in terms of raw edge/node distance, not of weighted distance). Let’s begin by finding our starting and ending nodes.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; bacon = g.V.filter{it.name=='Kevin Bacon'}.next()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; elvis = g.V.filter{it.name=='Elvis Presley'}.next()​</code>​</div>
</td>
</tr>
</table>
<p id="N19191" class="calibre5">
          We start by finding an actor’s costars’ costars’ costars…the classic stopping distance is six degrees, but practically we can stop at four (if you don’t find a match, you can try again). Here we can loop through the graph four times, which finds all actors with “four degrees of separation.” We’ll use the costars step we just created.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​elvis.costars.loop(1){it.loops &lt; 4}​</code>​</div>
</td>
</tr>
</table>
<p id="N1919F" class="calibre5">
          Only vertices that end with Bacon are to be retained. All others are ignored.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​elvis.costars.loop(1){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt; 4​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.filter{it.equals(bacon)}​</code>​</div>
</td>
</tr>
</table>
<p id="N191B3" class="calibre5">
          Just to ensure we don’t want to continue looping back to the Kevin Bacon node for a second pass, hitting the bacon node short-circuits the loop. Or, in other words, loop as long as the loop hasn’t occurred four times and we are not on the bacon node. Then we can output the paths taken to arrive at each bacon node.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​elvis.costars.loop(1){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt; 4 &amp; !it.object.equals(bacon)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.filter{it.equals(bacon)}.paths​</code>​</div>
</td>
</tr>
</table>
<p id="N191C7" class="calibre5">
          With that, we only need to pop the first path off the top of the list of possible paths—the shortest path will be arrived at first. The <code class="cf">&gt;&gt;</code> nomenclature just pops the first item off the list of all nodes.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(elvis.costars.loop(1){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt; 4 &amp; !it.object.equals(bacon)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.filter{it.equals(bacon)}.paths &gt;&gt; 1)​</code>​</div>
</td>
</tr>
</table>
<p id="N191DE" class="calibre5">
        Finally, we get the name of each vertex and filter out any null edge data using the Groovy grep command.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(elvis.costars.loop(1){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt; 4 &amp; !it.object.equals(bacon)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.filter{it.equals(bacon)}.paths &gt;&gt; 1).name.grep{it}​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Elvis Presley​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Double Trouble​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Roddy McDowall​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;The Big Picture​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Kevin Bacon​</code>​</div>
</td>
</tr>
</table>
<p id="N19209" class="calibre5">
          We didn’t know who Roddy McDowall was, but that’s the beauty of our graph database. We didn’t have to know to get a good answer.
          Feel free to sharpen your Groovy-foo if you want the output to be fancier than our simple list, but the data is all there.
          </p>
<h4 id="sec.randomWalk" class="calibre21">Random Walk</h4>
<p id="N1921A" class="calibre5">
          When looking for good sample from a large data set, a useful trick is the “random walk.” You start with a random number generator.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​rand = new Random()​</code>​</div>
</td>
</tr>
</table>
<p id="N19234" class="calibre5">
          Then you filter out some target ratio of the total. If we  want to return only about one-third of Kevin Bacon’s ~60 movies, we could filter out any random number less than 0.33.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bacon.outE.filter{rand.nextDouble() &lt;= 0.33}.inV.name​</code>​</div>
</td>
</tr>
</table>
<p id="N19242" class="calibre5">
          The count should be somewhere around twenty random titles from the Bacon canon.
        </p>
<p id="N19245" class="calibre5">
          Taking a second-degree step away from Kevin Bacon, his costars’ costars, creates quite a list (more than 300,000 in our data set).
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bacon.outE.inV.inE.outV.loop(4){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt; 3​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.count()​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; 316198​</code>​</div>
</td>
</tr>
</table>
<p id="N19264" class="calibre5">
          But if you need only about 1 percent of that list, add a filter. Also note the filter is itself a step, so you’ll need to add one more to your loop number.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bacon.outE{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  rand.nextDouble() &lt;= 0.01​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.inV.inE.outV.loop(5){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt; 3​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.name​</code>​</div>
</td>
</tr>
</table>
<p id="N1927E" class="calibre5">
          We received Elijah Wood, who we can run through our Bacon path algorithm and reasonably expect two steps (Elijah Wood acted in <span class="calibre6">Deep Impact</span> with Ron Eldard, who was in <span class="calibre6">Sleepers</span> with Kevin Bacon).
          </p>
<h4 id="sec.centralityPark" class="calibre21">Centrality Park</h4>
<p id="N19292" class="calibre5">
          Centrality is a measure of individual nodes against a full graph. For example, if we wanted to measure how important each node in a network is based on its distance to all the other nodes, that would require a centrality algorithm.
        </p>
<p id="N192B3" class="calibre5">
          The most famous centrality algorithm is probably Google’s PageRank, but there are several styles. We’ll execute a simple version called <span class="calibre6">eigenvector centrality</span>, which just counts the number of in or out edges related to a node. We’re going to give each actor a number related to how many roles they have played.
        </p>
<p id="N192B9" class="calibre5">
          We need a map for <code class="cf">groupCount</code> to populate and a <code class="cf">count</code> to set a maximum number or loops.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​role_count = [:]; count = 0​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.V.in.groupCount(role_count).loop(2){ count++ &lt; 1000 }; ''​</code>​</div>
</td>
</tr>
</table>
<p id="N192D0" class="calibre5">
          The <code class="cf">role_count</code> map will be keyed by vertices, with values of the count of edges the vertex has. The easiest way to read the output is by sorting the map.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​role_count.sort{a,b -&gt; a.value &lt;=&gt; b.value}​</code>​</div>
</td>
</tr>
</table>
<p id="N192E1" class="calibre5">
          The last value will be the actor with the greatest number of acting credits. In our dataset that honor belonged to legendary voice actor Mel Blanc with 424 credits (which you can list by running <code class="cf">g.V.filter{it.name==’Mel Blanc’}.out.name</code>).
        </p>
<h4 id="sec.externalAlgorithms" class="calibre21">External Algorithms</h4>
<p id="N192EC" class="calibre5">
        Writing your own algorithms is fine, but most of this work has already been done for you. The Java Universal Network/Graph (JUNG) Framework is a collection of common graph algorithms and other tools for modeling and visualizing graphs. Thanks to the Gremlin/Blueprint project, it’s easy to access JUNG’s algorithms, such as PageRank, HITS, Voltage, centrality algorithms, and graph-as-a-matrix tools.
        </p>
<p id="N192FD" class="calibre5">
          To use JUNG, we need to wrap the Neo4j Graph into a new JUNG Graph.<a id="FNPTR-50" href="f_0051.html#FOOTNOTE-50">[50]</a> To access the JUNG graph, we need to do one of two options: download and install all of the Blueprint and JUNG jars into your Neo4j server libs directory and restart the server, or download the prepackaged Gremlin console. We recommend the latter option for this project, since it will save you the hassle of hunting down several Java archive files (jars).
        </p>
<p id="N19306" class="calibre5">
          Assuming you’ve downloaded the gremlin console, shut down your neo4j server and start up Gremlin. You’ll have to create the Neo4jGraph object and point it to your installation’s <code class="cf">data/graph</code> directory.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g = new Neo4jGraph('/users/x/neo4j-enterprise-1.7/data/graph.db')​</code>​</div>
</td>
</tr>
</table>
<p id="N19317" class="calibre5">
        We’ll keep the Gremlin graph named <code class="cf">g</code>. The Neo4jGraph object needs to be wrapped in a GraphJung object, which we’ll call <code class="cf">j</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​j = new GraphJung( g )​</code>​</div>
</td>
</tr>
</table>
<p id="N1932B" class="calibre5">
        Part of the reason Kevin Bacon was chosen as the ultimate path destination is his relative closeness to other actors. He has starred in movies with other popular stars. To be important, he didn’t need to be in many roles himself but simply be connected to those who are well connected.
        </p>
<p id="N1932F" class="calibre5">
        This raises the question: can we find a better actor than Kevin Bacon, in terms of distance from other actors?
        </p>
<p id="N19332" class="calibre5">
        JUNG contains a scoring algorithm called BarycenterScorer that gives a score to each vertex based on its distance to all other vertices. If Kevin Bacon is indeed the best choice, we would expect his score to be the lowest, meaning he is “closest” to all other actors.
        </p>
<p id="N19335" class="calibre5">
        Our JUNG algorithm should  apply only to actors, so we construct a <span class="calibre6">transformer</span> to filter only actor nodes. The <code class="cf">EdgeLabelTransformer</code>  permits only those nodes with an edge of <code class="cf">ACTED_IN</code> to the algorithm.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​t = new EdgeLabelTransformer(['ACTED_IN'] as Set, false)​</code>​</div>
</td>
</tr>
</table>
<p id="N1934C" class="calibre5">
        Next, we need to import the algorithm itself, passing in our GraphJung and transformer.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​import edu.uci.ics.jung.algorithms.scoring.BarycenterScorer​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​barycenter = new BarycenterScorer&lt;Vertex,Edge&gt;( j, t )​</code>​</div>
</td>
</tr>
</table>
<p id="N1935D" class="calibre5">
        With that, we can get the BarycenterScorer score of any node. Let’s find out what Kevin Bacon’s score is.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bacon = g.V.filter{it.name=='Kevin Bacon'}.next()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bacon_score = barycenter.getVertexScore(bacon)​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​~0.0166​</code>​</div>
</td>
</tr>
</table>
<p id="N19379" class="calibre5">
        Once we have Kevin Bacon’s score, we can go through every vertex and store any that have a score lower than his.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​connected = [:]​</code>​</div>
</td>
</tr>
</table>
<p id="N19387" class="calibre5">
        It could take a really long time to execute the BarycenterScorer score for each actor in our database. So, instead, let’s just run the algorithm against each of Kevin’s costars. This may take a few minutes, depending on your hardware. BarycenterScorer is fast, but executing over each of Bacon’s costars adds up. 
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bacon.costars.each{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  score = b.getVertexScore(it);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  if(score &lt; bacon_score) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    connected[it] = score;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N193A4" class="calibre5">
        All of the keys that exist in the <code class="cf">connected</code> map represent a better choice than Kevin Bacon. But it’s good to have a name we recognize, so let’s output them all and pick one we like. Your output will vary from ours, since the public movie dataset is always in flux.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​connected.collect{k,v -&gt; k.name + " =&gt; " + v}​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Donald Sutherland =&gt; 0.00925​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Clint Eastwood =&gt; 0.01488​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​...​</code>​</div>
</td>
</tr>
</table>
<p id="N193C6" class="calibre5">
        Donald Sutherland appeared in the list with a respectable ~0.00925. So, hypothetically, the  Six Degrees of Donald Sutherland should be an easier game to play with your friends than the traditional Six Degrees of Kevin Bacon.
        </p>
<p id="N193C9" class="calibre5">
        With our <code class="cf">j</code> graph we can now run any JUNG algorithm on our dataset, for example PageRank. Like BarycenterScorer, you need to import the class first.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​import edu.uci.ics.jung.algorithms.scoring.PageRank​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​pr = new PageRank&lt;Vertex,Edge&gt;( j, t, 0.25d )​</code>​</div>
</td>
</tr>
</table>
<p id="N193DD" class="calibre5">
        The full list of JUNG algorithms can be found in their online Javadoc API. More are added all the time, so it’s a good place to look before implementing your own.
        </p>
<h3 class="calibre20">Day 2 Wrap-Up</h3>
<p id="N193ED" class="calibre5">
        On Day 2 we broadened our ability to interact with Neo4j by taking a look at the REST interface. We saw how, using the Gremlin plug-in, we can execute Gremlin code on the server and have the REST interface return results. We played around with a larger dataset and finally finished up with a handful of algorithms for diving into that data.
      </p>
<h4 class="calibre21">Day 2 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N193FB" class="calibre5">Bookmark the documentation for the Neo4j REST API.</p>
</li>
<li class="calibre23">
<p id="N193FF" class="calibre5">Bookmark the API for the JUNG project and the algorithms it implements.</p>
</li>
<li class="calibre23">
<p id="N19403" class="calibre5">Find a binding or REST interface for your favorite programming language.</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N1940D" class="calibre5">Turn the path-finding portion of the Kevin Bacon algorithm into its own step. Then implement a general-purpose Groovy function (for example, <code class="cf">def actor_path(g, name1, name2) {…}</code>) that accepts the graph and two names and compares the distance.</p>
</li>
<li class="calibre23">
<p id="N19414" class="calibre5">Choose and run one of the many JUNG algorithms on a node (or the data set, if the API demands it).</p>
</li>
<li class="calibre23">
<p id="N19418" class="calibre5">Install your driver of choice, and use it to manage your company graph with the people and the roles they play, with edges describing their interactions (reports to, works with). If your company is huge, just try your close teams; if you’re with a small organization, try including some customers. Find the most well-connected person in the organization by closest distance to all other nodes.</p>
</li>
</ol>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/neo4j-crud.png" alt="images/neo4j-crud.png" class="calibre27"/>
</div>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

