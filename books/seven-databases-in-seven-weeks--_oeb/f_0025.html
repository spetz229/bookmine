---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0024.html
next: f_0026.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.day2MapreduceandServerClusters" class="calibre18">3.3 Day 2: Mapreduce and Server Clusters</h2>
<p id="N12BF7" class="calibre5">
    Today we’ll dive into the mapreduce framework to perform more powerful queries than the standard key-value paradigm can normally provide. We’ll then expand on this power by including link walking with mapreduce. Finally, we will investigate the server architecture of Riak and how it uses a novel server layout to provide flexibility in consistency or availability, even in the face of network partitions.
  </p>
<h3 class="calibre20">Population Script</h3>
<p id="N12BFE" class="calibre5">
    We’ll need a bit more data in this section. To achieve that, we’ll switch to an example using a different kind of hotel, one for people and not pets. A quick populator script in Ruby will create data for a gigantic 10,000-room hotel.
  </p>
<p id="N12C0D" class="calibre5">
    If you are not familiar with Ruby, it is a popular general-purpose programming language. It’s quite useful for writing quick scripts in a straightforward and readable manner. You can learn more about Ruby in <em class="calibre6">Programming Ruby: The Pragmatic Programmer’s Guide</em> [TH01] by Dave Thomas and Andy Hunt, as well as online.<a id="FNPTR-12" href="f_0027.html#FOOTNOTE-12">[12]</a>
</p>
<p id="N12C18" class="calibre5">
    You’ll also need Ruby’s package manager called RubyGems.<a id="FNPTR-13" href="f_0027.html#FOOTNOTE-13">[13]</a> With Ruby and RubyGems installed, next install the Riak driver.<a id="FNPTR-14" href="f_0027.html#FOOTNOTE-14">[14]</a> You may also require the json driver and can run both to make sure.
  </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">gem install riak-client json</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N12C36" class="calibre5">
  Each room in our hotel will have a random capacity from one to eight people and be of a random style such as a single room or a suite.
  </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/riak/hotel.rb">riak/hotel.rb</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"># generate loads and loads of rooms with random styles and capacities</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​require <em class="string">'rubygems'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​require <em class="string">'riak'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​STYLES = <em class="string">%w{single double queen king suite}</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​client = Riak::Client.new(:http_port =&gt; 8091)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bucket = client.bucket(<em class="string">'rooms'</em>)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"># Create 100 floors to the building</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">for</strong> floor <strong class="prompt">in</strong> 1..100​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  current_rooms_block = floor * 100​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  puts <em class="string">"Making rooms </em>#{current_rooms_block}<em class="string"> - </em>#{current_rooms_block + 100}<em class="string">"</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <em class="comment"># Put 100 rooms on each floor (huge hotel!)</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">for</strong> room <strong class="prompt">in</strong> 1...100​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment"># Create a unique room number as the key</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ro = Riak::RObject.new(bucket, (current_rooms_block + room))​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment"># Randomly grab a room style, and make up a capacity</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    style = STYLES[rand(STYLES.length)]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    capacity = rand(8) + 1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment"># Store the room information as a JSON value</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ro.content_type = <em class="string">"application/json"</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ro.data = {<em class="string">'style'</em> =&gt; style, <em class="string">'capacity'</em> =&gt; capacity}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ro.store​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">ruby hotel.rb</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N12CCD" class="calibre5">
  We’ve now populated a human hotel we’ll mapreduce against.
  </p>
<h3 id="sec.introMapreduce" class="calibre20">Introducing Mapreduce</h3>
<p id="N12CDB" class="calibre5">
      One of Google’s greatest lasting contributions to computer science is the popularization of mapreduce as an algorithmic framework for executing jobs in parallel over several nodes. It is described in Google’s seminal paper<a id="FNPTR-15" href="f_0027.html#FOOTNOTE-15">[15]</a> on the topic and has become a valuable tool for executing custom queries in the class of partition-tolerant datastores.
    </p>
<p id="N12CF6" class="calibre5">
      Mapreduce breaks down problems into two parts. Part 1 is to convert a list of data into another type of list by way of a <code class="cf">map</code> function. Part 2 is to convert this second list to one or more scalar values by way of a <code class="cf">reduce</code> function.
      Following this pattern allows a system to divide tasks into smaller components and run them across a massive cluster of servers in parallel. We could count up all Riak values containing <code class="cf">{country : ’CA’}</code> by mapping each matching document to <code class="cf">{count : 1}</code> and reducing the sum of all of these counts. 
    </p>
<p id="N12D05" class="calibre5">
      If there were 5,012 Canadian values in our dataset, the reduce result would be <code class="cf">{count : 5012}</code>.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​map = function(v) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  var parsedData = JSON.parse(v.values[0].data);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  if(parsedData.country === 'CA')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    return [{count : 1}];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  else​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    return [{count : 0}];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​reduce = function(mappedVals) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  var sums = {count : 0};​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  for (var i in mappedVals) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    sums[count] += mappedVals[i][count];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  return [sums];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N12D3F" class="calibre5">
      In one way, mapreduce is the opposite of how we normally run queries. A Ruby on Rails system might grab data like this (via its ActiveRecord interface):
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"># Construct a Hash to store room capacity count keyed by room style</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​capacity_by_style = {}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​rooms = Room.all​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">for</strong> room <strong class="prompt">in</strong> rooms​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  total_count = capacity_by_style[room.style]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  capacity_by_style[room.style] = total_count.to_i + room.capacity​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N12D72" class="calibre5">
<code class="cf">Room.all</code> runs an SQL query against the backing database similar to this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​SELECT * FROM rooms;​</code>​</div>
</td>
</tr>
</table>
<p id="N12D83" class="calibre5">
      The database sends all of the results to the app server, and the app server code performs some action on that data. In this case, we’re looping through each room in the hotel and then counting the total capacity for each room style (for example, the capacity of all the suites in the hotel may be 448 guests). This is acceptable for small datasets. But as room count grows, the system slows as the database continues to stream each room’s data to the application.
    </p>
<p id="N12D86" class="calibre5">
      Mapreduce runs in an inverse manner. Rather than grabbing data from the database and running it on a client (or app server), mapreduce is a pattern to pass an algorithm to all of the database nodes, which are then each responsible for returning a result. <span class="calibre6">Each object on the server is “mapped” to some common key that groups the data together, and then all matching keys are “reduced” into some single value.</span>
</p>
<div class="figure" id="fig.riak.mapReduce">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/riak-mapreduce.png" alt="images/riak-mapreduce.png" class="calibre27"/>
<p id="N12DAE" class="calibre5">The map function outputs feed into the reduce outputs and then to other reducers.</p>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 7. The map function outputs </div>
</div>
<p id="N12DB1" class="calibre5">
      For Riak, that means the database servers are responsible for mapping and reducing the values on each node. Those reduced values are passed around, where some other server (usually the requesting server) reduces those values further, until a final result is passed to the requesting client (or Rails application server, as the case may be).
    </p>
<p id="N12DB4" class="calibre5">
      This simple reversal is a powerful way to allow complex algorithms to run locally on each server and return a very small result to the calling client. <span class="calibre6">It’s faster to send the algorithm to the data and then send the data to the algorithm.</span> In Figure 7, <a href="#fig.riak.mapReduce">​<em class="calibre6">The map function outputs</em>​</a>, we can see how a bucket of phone bills keyed by phone number may calculate the total charged against all numbers across three servers, where each server contains all numbers with a similar prefix.
    </p>
<p id="N12DBD" class="calibre5">
    The results of map functions will populate reduce functions; however, a combination of the results of map <span class="calibre6">and</span> previous reduce function calls populate successive reduce functions. We’ll revisit this idea in later chapters because it’s an important yet subtle component to the art of writing effective mapreduce queries.
    </p>
<h3 id="sec.mrInRiak" class="calibre20">Mapreduce in Riak</h3>
<p id="N12DD1" class="calibre5">
    Let’s create mapreduce functions for our Riak dataset that work like the previous hotel capacity counter. A neat feature of Riak’s mapreduce is that you can run the <code class="cf">map</code> function alone and see what all the results are mid-run (assuming you even want to run a reduce). Let’s take it slow and look at the results for rooms 101, 102, and 103 only.
    </p>
<p id="N12DF4" class="calibre5">
    The map setting needs the language we’re using and the source code; only then do we actually write the JavaScript map function (the function is just a string, so we always need to escape any characters accordingly).
    </p>
<p id="N12DF7" class="calibre5">
    Using the @- command in cURL keeps the console’s standard input open until receiving <span class="calibre35">Ctrl</span>+<span class="calibre35">D</span>. This data will populate the HTTP body sent to the URL, which we post to the <code class="cf">/mapred</code> command (look carefully—the URL is <code class="cf">/mapred</code>, not <code class="cf">/riak/mapred</code>).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST -H "content-type:application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">http://localhost:8091/mapred --data @-</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "inputs":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ["rooms","101"],["rooms","102"],["rooms","103"]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "query":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"map":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "language":"javascript",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "source":​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        "function(v) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          /* From the Riak object, pull data and parse it as JSON */​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          var parsed_data = JSON.parse(v.values[0].data);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          var data = {};​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          /* Key capacity number by room style string */​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          data[parsed_data.style]<strong class="prompt"> = parsed_data.capacity;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          return [data];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        }"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N12E63" class="calibre5">
<span class="calibre35">Ctrl</span>-<span class="calibre35">D</span>
</p>
<p id="N12E6A" class="calibre5">
    The <code class="cf">/mapred</code> command expects valid JSON, and here we specified the form of our mapreduce commands. We choose the three rooms we want by setting the “inputs” value to be an array containing <code class="cf">[bucket, key]</code> pairs. But the real meat of the settings is under the <code class="cf1">query</code> value, which accepts an array of JSON objects containing objects, keyed by <code class="cf1">map</code>, <code class="cf1">reduce</code>, and/or <code class="cf1">links</code> (more on links later).
    </p>
<p id="N12E82" class="calibre5">
      All this does is dig down into the data (<code class="cf">v.values[0].data</code>), parse the value as a  JSON object (<code class="cf">JSON.parse(...)</code>), and return the capacity (<code class="cf">parsed_data.capacity</code>) keyed by room style (<code class="cf">parsed_data.style</code>). You’ll get a result like this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[{"suite":6},{"single":1},{"double":1}]​</code>​</div>
</td>
</tr>
</table>
<p id="N12E9D" class="calibre5">
      It’s just the three objects’ JSON data from rooms 101, 102, and 103.
    </p>
<p id="N12EA0" class="calibre5">
      We didn’t need to simply output the data as JSON. We could have converted the value of each key value into anything we wanted. We dug into the body data only but could have retrieved metadata, link information, the key, or data. Anything is possible after that—we are mapping each key value into some other value.
    </p>
<p id="N12EA3" class="calibre5">
      If you feel up to it, you can return the maps of all 10,000 rooms by replacing the input-specific [bucket, key] arrays with the <code class="cf">rooms</code> bucket name, like this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"inputs":"rooms"​</code>​</div>
</td>
</tr>
</table>
<p id="N12EB5" class="calibre5">
      Fair warning: it will dump a lot of data. Finally, it’s worth mentioning that since Riak version 1.0, mapreduce functions are handled by a subsystem called Riak Pipe. Any older systems will use the legacy mapred_system. This should not affect you much as an end user, but it’s certainly a boost in speed and stability.
      </p>
<h4 id="sec.storeFunctions" class="calibre21">Stored Functions</h4>
<p id="N12EC9" class="calibre5">
        Another option Riak provides us with is to store the map function in a bucket value. This is another example of moving the algorithm to the database. This is a stored procedure or, more specifically, a user-defined function—of similar philosophy to those used in relational databases for years.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT -H "content-type:application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">http://localhost:8091/riak/my_functions/map_capacity --data @-</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​function(v) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  var parsed_data = JSON.parse(v.values[0].data);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  var data = {};​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  data[parsed_data.style]<strong class="prompt"> = parsed_data.capacity;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  return [data];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N12F0C" class="calibre5">
        With your function safely stored, we’ll run the function by pointing to the new bucket and key containing the function.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST -H "content-type:application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">http://localhost:8091/mapred --data @-</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "inputs":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ["rooms","101"],["rooms","102"],["rooms","103"]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "query":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"map":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "language":"javascript",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "bucket":"my_functions",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "key":"map_capacity"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N12F46" class="calibre5">
        You should receive the same results you received by putting the JavaScript source inline.
        </p>
<h4 id="builtInFunctions" class="calibre21">Built-in Functions</h4>
<p id="N12F5A" class="calibre5">
        You can use some of Riak’s built-in functions attached to the JavaScript object <code class="cf">Riak</code>. If you run the following code, your room objects will map the values into JSON and return them. The <code class="cf">Riak.mapValuesJson</code> function returns values as JSON.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl -X POST http://localhost:8091/mapred \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-H "content-type:application/json" --data @-​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "inputs":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ["rooms","101"],["rooms","102"],["rooms","103"]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "query":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"map":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "language":"javascript",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "name":"Riak.mapValuesJson"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N12FA3" class="calibre5">
        Riak provides more of these in a file named <code class="cf">mapred_builtins.js</code>, which you can find online (or, deep in the code). You can also use this syntax to call your own built-in functions, which is something we’ll investigate tomorrow.
        </p>
<h4 id="sec.thereCanBeOnlyOne" class="calibre21">Reducing</h4>
<p id="N12FB4" class="calibre5">
        Mapping is useful, but you’re limited to converting individual values into other individual values.  Performing some sort of analysis over that set of data, even something as simple as counting the records, requires another step. This is where reduce comes into play.
      </p>
<p id="N12FB9" class="calibre5">
        The SQL/Ruby example that we looked at earlier (in <a href="#sec.introMapreduce">​<em class="calibre6">Introducing Mapreduce</em>​</a>) showed how each value could be iterated over and how capacity was totaled for each style of room. We will perform this in our <code class="cf">reduce</code> function in JavaScript.
      </p>
<p id="N12FCD" class="calibre5">
        Most of the command we pass to <code class="cf">/mapred</code> will be the same. This time, we add the <code class="cf">reduce</code> function.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST -H "content-type:application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">http://localhost:8091/mapred --data @-</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "inputs":"rooms",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "query":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"map":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "language":"javascript",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "bucket":"my_functions",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "key":"map_capacity"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"reduce":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "language":"javascript",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "source":​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        "function(v) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          var totals = {};​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          for (var i in v) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​            for(var style in v[i]) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​              if( totals[style] ) totals[style] += v[i][style];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​              else                totals[style] = v[i][style];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​            }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​          return [totals];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        }"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N13031" class="calibre5">
        Running this on all rooms should return total counts of capacity, keyed by room style.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[{"single":7025,"queen":7123,"double":6855,"king":6733,"suite":7332}]​</code>​</div>
</td>
</tr>
</table>
<p id="N13040" class="calibre5">
        Your totals won’t match the previous exactly, since we randomly generated room data.
        </p>
<div class="sidebar" id="sb.reducerPatterns">
<div class="sidebar-title">Reducer Patterns</div>
<div class="calibre2">
<p id="N1304A" class="calibre5">
          It’s easier to write a <code class="cf2">reduce</code> function if it follows the same pattern as your map function. Meaning, if you map a single value as...        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre36">
​<code class="calibre37">​[{name:'Eric', count:1}]​</code>​</div>
</td>
</tr>
</table>
<p id="N13066" class="calibre5">
          ...then the result of <code class="cf2">reduce</code> should be like this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre36">
​<code class="calibre37">​[{name:'Eric', count:105}, {name:'Jim', count:215}, …]​</code>​</div>
</td>
</tr>
</table>
<p id="N13078" class="calibre5">
          This certainly isn’t a requirement; it’s just practical. Since reducers can feed into other reducers, you don’t know whether the values you receive on any particular <code class="cf2">reduce</code>  function call will be populated by map output, reduce output, or a combination of both. However, if they follow the same object pattern, you don’t need to care; they’re all the same! Otherwise, your <code class="cf2">reduce</code> function must always check for the type of data it’s receiving and make a decision accordingly. 
        </p>
</div>
</div>
<h4 id="sec.keyFilters" class="calibre21">Key Filters</h4>
<p id="N13086" class="calibre5">
        A rather recent addition to Riak is the concept of key filters. A key filter is a collection of commands that process each key before executing mapreduce on it. This shortcut saves the operation the pain of loading unwanted values. In the following example, we’ll convert each room number key into an integer and check that it’s less than 1,000 (one of the first ten floors; any room over the tenth floor will be ignored).
      </p>
<p id="N13093" class="calibre5">
        In our mapreduce to return room capacity, replace <code class="cf">“inputs”:”rooms”,</code> with the following block (it must end with a comma):
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"inputs":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "bucket":"rooms",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "key_filters":[["string_to_int"], ["less_than", 1000]]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​},​</code>​</div>
</td>
</tr>
</table>
<p id="N130AE" class="calibre5">
        You should notice two things: the query ran much faster (since we  processed only the values we needed), and the totals were fewer (since we  added only the first ten floors).
      </p>
<p id="N130B1" class="calibre5">
        Mapreduce is a powerful tool for bundling data and performing some overarching analysis on it. It’s a concept we’ll revisit often in this book, but the core concept is the same. Riak has one slight tweak to the basic mapreduce form, and that’s the addition of links.
      </p>
<h4 id="sec.linkWalkingLikeanEgyptian" class="calibre21">Link Walking with Mapreduce</h4>
<p id="N130B9" class="calibre5">
        Yesterday we introduced link walking. Today we’ll look at how to do the same thing using mapreduce. The query section has one more value option along with <code class="cf">map</code> and <code class="cf">reduce</code>. It’s <code class="cf">link</code>.
      </p>
<p id="N130D1" class="calibre5">
        Let’s return to our <code class="cf">cages</code> bucket from yesterday’s dog hotel example and write a mapper that returns only cage 2 (remember, the one housing Ace the dog).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X POST -H "content-type:application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">http://localhost:8091/mapred --data @-</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "inputs":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "bucket":"cages",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "key_filters":[["eq", "2"]]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "query":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"link":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "bucket":"animals",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "keep":false​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    {"map":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "language":"javascript",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "source":​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        "function(v) { return [v]; }"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1311D" class="calibre5">
        Although we ran the mapreduce query against the <code class="cf">cages</code> bucket, this will return <span class="calibre6">Ace the dog</span>’s information, because he was linked to cage 2.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "bucket":"animals",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "key":"ace",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "vclock":"a85hYGBgzmDKBVIsrDJPfTKYEhnzWBn6LfiP80GFWVZay0KF5yGE2ZqTGPmCLiJLZAEA",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "values":[{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "metadata":{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "Links":[],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "X-Riak-VTag":"4JVlDcEYRIKuyUhw8OUYJS",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "content-type":"application/json",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "X-Riak-Last-Modified":"Tue, 05 Apr 2011 06:54:22 GMT",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "X-Riak-Meta":[]},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "data":"{\"nickname\" : \"The Wonder Dog\", \"breed\" : \"German Shepherd\"}"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}]​</code>​</div>
</td>
</tr>
</table>
<p id="N13159" class="calibre5">
        Both data and metadata (which would normally be returned in the HTTP header) appear under a values array.
      </p>
<p id="N1315C" class="calibre5">

      Put map, reduce, link walking, and key filters together, and you can execute arbitrary queries on a wide array of Riak keys. It’s considerably more efficient than scanning all data from a client.

       Since these queries are generally run across several servers simultaneously, you should never have to wait long. But if you really cannot wait, a query has one more option: <code class="cf">timeout</code>. Set <code class="cf">timeout</code> to a value in milliseconds (the default is <code class="cf">"timeout": 60000</code>, or 60 seconds), and if the query does not complete in the allotted time, it will abort.
      </p>
<h3 id="sec.theSecretServerSauce" class="calibre20">Of Consistency and Durability</h3>
<p id="N1317E" class="calibre5">
      Riak server architecture removes single points of failure (all nodes are peers) and allows you to grow or shrink the cluster at will. This is important when dealing with large-scale deployments, since it allows your database to remain available even if several nodes fail or are otherwise unresponsive.
    </p>
<p id="N1319A" class="calibre5">
    Distributing data across several servers is saddled with an inherent problem. If you want your database to continue running when a network partition occurs (meaning, some messages were lost), it means you must make a trade-off. Either you can remain <span class="calibre6">available</span> to server requests or you can refuse requests and ensure the <span class="calibre6">consistency</span> of your data. It is not possible to create a distributed database that is fully consistent, available, and  partition tolerant. You can have only  two (partition tolerant and consistent, partition tolerant and available, or consistent and available but not distributed). This is known as the CAP theorem (Consistency, Availability, Partition tolerance). See Appendix 2, <a href="f_0063.html#apx.cap">​<em class="calibre6">The CAP Theorem</em>​</a> for more details, but suffice to say it is a problem in system design.
    </p>
<p id="N131A6" class="calibre5">
    But the theorem has a loophole. The reality is that at <span class="calibre6">any moment in time</span> you cannot be consistent, available, and partition tolerant. Riak takes advantage of this fact by allowing you to trade availability for consistency on a per-request basis. We’ll first look at how Riak clusters its servers and then how to tune reads and writes to interact with the cluster.
    </p>
<h4 id="sec.theRiakRing" class="calibre21">The Riak Ring</h4>
<p id="N131B1" class="calibre5">
        Riak divides its server configuration into partitions denoted by a 160-bit number (that’s 2^160). The Riak team likes to represent this massive integer as a circle, which they call the <span class="calibre6">ring</span>. When a key is hashed to a partition, the ring helps direct which Riak servers store the value.
      </p>
<p id="N131C9" class="calibre5">
        One of the first decisions you’ll make when setting up a Riak cluster is how many partitions you’d like. Let’s consider the case where you have 64 partitions (Riak’s default). If you divide those sixty-four partitions across three nodes (or, servers), then Riak will give each node twenty-one or twenty-two partitions (64 / 3). Each partition is called a virtual node, or <span class="calibre6">vnode</span>. Each Riak service counts around the ring on boot, claiming partitions in turn until all  vnodes  are claimed, as shown in Figure 8, <a href="#fig.riak.ring">​<em class="calibre6">“The Riak ring” of sixty-four vnodes, assigned across three physical nodes</em>​</a>.
      </p>
<div class="figure" id="fig.riak.ring">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/riak-ring.png" alt="images/riak-ring.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 8. “The Riak ring” of sixty-four vnodes, assigned across three physical nodes</div>
</div>
<p id="N131F2" class="calibre5">
        Node A manages vnodes 1, 4, 7, 10...63. These vnodes are mapped to partitions of the 160-bit ring.  If you view the status of your three development servers (remember <code class="cf">curl -H "Accept: text/plain" http://localhost:8091/stats</code> from yesterday), you can see a line like this:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"ring_ownership": \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"[{'dev3@127.0.0.1',21},{'dev2@127.0.0.1',21},{'dev1@127.0.0.1',22}]"​</code>​</div>
</td>
</tr>
</table>
<p id="N1321F" class="calibre5">
        The second number of each object is the number of vnodes each node owns. They will total sixty-four (21 + 21 + 22).
      </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/riak-crud.png" alt="images/riak-crud.png" class="calibre27"/>
</div>
<p id="N13226" class="calibre5">
        Each vnode represents a range of hashed keys. When we insert the room data for key <code class="cf1">101</code>, it may get hashed into the vnode 2 range, so then the key-value object gets stored onto Node B. The benefit is that if we need to find which server the key lives on, Riak just hashes the key to find the corresponding vnode.  Specifically, Riak will convert the hash into a list of potential vnodes and use the first value.
        </p>
<h4 id="sec.nwr" class="calibre21">Nodes/​Writes/​Reads</h4>
<p id="N1323A" class="calibre5">
        Riak allows us to control reads and writes into the cluster by altering three values: N, W, and R. <span class="calibre6">N</span> is the number of nodes a write ultimately replicates to, in other words, the number of copies in the cluster. <span class="calibre6">W</span> is the number of nodes that must be successfully written to before a successful response. If W is less than N, a write will be considered successful even while Riak is still copying the value. Finally, <span class="calibre6">R</span> is the number of nodes required to read a value successfully. If R is greater than the number of copies available, the request will fail.
      </p>
<p id="N13246" class="calibre5">
        Let’s investigate each of these in more detail.
      </p>
<p id="N13249" class="calibre5">
        When we write an object in Riak, we have the choice to replicate that value across multiple nodes. The benefit here is that if one server goes down, then a copy is available on another.
        The <code class="cf">n_val</code> bucket property stores the number of nodes to replicate a value to (the N value); it’s <code class="cf">3</code> by default. We can alter a bucket’s properties by putting a new value in the <code class="cf">props</code> object. Here we set animals to have an <code class="cf">n_val</code> of 4:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT http://localhost:8091/riak/animals \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -d '{"props":{"n_val":4}}'</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N1326F" class="calibre5">
<span class="calibre6">N</span> is simply the total number of nodes that will <span class="calibre6">eventually</span> contain the correct value. This doesn’t mean we must wait for the value to replicate to <span class="calibre6">all</span> of those nodes in order to return. Sometimes we just want our client to return immediately and let Riak replicate in the background. Or sometimes we want to wait until Riak has replicated to all <span class="calibre6">N</span> nodes (just to be safe) before returning.
      </p>
<p id="N1327D" class="calibre5">
        We can set the <span class="calibre6">W</span> value to the number of successful writes that must occur before our operation is considered a success. Although we’re writing to four nodes eventually, if we set W to 2,  a write operation will return after only two copies are made. The remaining two will replicate in the background.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl -X PUT http://localhost:8091/riak/animals \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  -H "Content-Type: application/json" \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  -d '{"props":{"w":2}}'​</code>​</div>
</td>
</tr>
</table>
<p id="N13295" class="calibre5">
        Finally, we can use the <span class="calibre6">R</span> value. <span class="calibre6">R</span> is the number of nodes that must be read in order to be considered a successful read. You can set a default <span class="calibre6">R</span> like we did earlier with <code class="cf">n_val</code> and <code class="cf">w</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl -X PUT http://localhost:8091/riak/animals \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  -H "Content-Type: application/json" \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  -d '{"props":{"r":3}}'​</code>​</div>
</td>
</tr>
</table>
<p id="N132B9" class="calibre5">
        But Riak provides a more flexible solution. We may choose the number of nodes we want to read by setting an <code class="cf">r</code> parameter in the URL <span class="calibre6">per request</span>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl http://localhost:8091/riak/animals/ace?r=3​</code>​</div>
</td>
</tr>
</table>
<p id="N132CE" class="calibre5">
        You may be asking yourself why we would ever need to read from more than one node. After all, values we write will eventually be replicated to <span class="calibre6">N</span> nodes, and we can read from any of them. We find the idea is easier to visualize.
      </p>
<div class="figure" id="fig.riak.eventual">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/riak-consistency-eventual.png" alt="images/riak-consistency-eventual.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 9. Eventual consistency: W+R &lt;= N</div>
</div>
<p id="N132F4" class="calibre5">
        Let’s say we set our NRW values to <code class="cf">{"n_val":3, "r":2, "w":1}</code>, like Figure 9, <a href="#fig.riak.eventual">​<em class="calibre6">Eventual consistency: W+R &lt;= N</em>​</a>. This makes our system more responsive on writes, since only one node needs to be written before returning. But there is a chance that another operation could perform a read before the nodes had a chance to synchronize. Even if we read from two nodes, it’s possible we could receive an old value.
      </p>
<p id="N132FD" class="calibre5">
        One way to be certain we have the most current value is to set W=N and R=1 like this: <code class="cf">{"n_val":3, "r":1, "w":3}</code> (see Figure 10, <a href="#fig.riak.reads">​<em class="calibre6">Consistency by writes: W=N, R=1</em>​</a>). In essence, this is what relational databases do; they enforce consistency by ensuring a write is complete before returning. We can certainly read faster, since we need to access only one node. But this can really slow down writes.
      </p>
<div class="figure" id="fig.riak.reads">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/riak-consistency-writes.png" alt="images/riak-consistency-writes.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 10. Consistency by writes: W=N, R=1</div>
</div>
<p id="N13326" class="calibre5">
        Or you could just write to a single node but read from all of them. This would be setting W=1 and R=N like this: <code class="cf">{"n_val":3, "r":3, "w":1}</code> (see Figure 11, <a href="#fig.riak.writes">​<em class="calibre6">Consistency by reads: W=1, R=N</em>​</a>). Although you may read a few old values, you are guaranteed to retrieve the most recent value, too. You’ll just have to resolve which one that is (using a vector clock, which we’ll cover tomorrow). Of course, this has the opposite problem as shown earlier and slows down reads.
      </p>
<div class="figure" id="fig.riak.writes">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/riak-consistency-reads.png" alt="images/riak-consistency-reads.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 11. Consistency by reads: W=1, R=N</div>
</div>
<p id="N1334F" class="calibre5">
        Or you could set W=2 and R=2 as <code class="cf">{"n_val":3, "r":2, "w":2}</code> (see Figure 12, <a href="#fig.riak.quorum">​<em class="calibre6">Consistency by quorum: W+R &gt; N</em>​</a>). This way, you need only write to more than half of the nodes and read from more than half, but you still get the benefits of consistency while sharing the time delays between reads and writes. This is called a <span class="calibre6">quorum</span> and is the minimum amount to keep consistent data. 
      </p>
<div class="figure" id="fig.riak.quorum">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/riak-consistency-quorum.png" alt="images/riak-consistency-quorum.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 12. Consistency by quorum: W+R &gt; N</div>
</div>
<p id="N1337B" class="calibre5">
        You are free to set your R or W to any values between 1 and N but will generally want to stick with one, all, or a quorum. These are such common values that R and W can accept string values representing them, defined in the following table:
      </p>
<table class="simpletable1">
<thead class="calibre29">
<tr class="calibre8">
<th class="hlines">
<p class="last-para-in-cell">Term</p>
</th>
<th class="hlines">
<p class="last-para-in-cell">Definition</p>
</th>
</tr>
</thead>
<tbody class="calibre7">
<tr class="calibre8">
<td class="calibre30">
<p class="last-para-in-cell">One</p>
</td>
<td class="calibre30">
<p class="last-para-in-cell">This is just the value 1. Setting W or R means only one node need respond for the request to succeed.</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">All</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">This is the same value as N. Setting W or R to this means all replicated nodes must respond.</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Quorum</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">This equals setting the value to N/2+1. Setting W or R means most nodes must respond to succeed.</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">Default</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">Whatever the W or R value is set for the bucket. Generally defaults to 3.</p>
</td>
</tr>
</tbody>
</table>
<p id="N133AF" class="calibre5">
        In addition to the previous values as valid bucket properties, you can also use them as query parameter values.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl http://localhost:8091/riak/animals/ace?r=all​</code>​</div>
</td>
</tr>
</table>
<p id="N133CD" class="calibre5">
        The danger with requiring reading from all nodes is that if one goes down, Riak may be unable to fulfill your request. As an experiment, let’s shut down dev server 3.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">dev/dev3/bin/riak stop</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N133DF" class="calibre5">
        Now if we attempt to read from all nodes, there’s a good chance our request will fail (if it doesn’t, try shutting down dev2 as well, or possibly shut down dev1 and read from port 8092 or 8093; we cannot control what vnodes Riak writes to).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -i http://localhost:8091/riak/animals/ace?r=all</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​HTTP/1.1 404 Object Not Found​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Server: MochiWeb/1.1 WebMachine/1.7.3 (participate in the frantic)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Date: Thu, 02 Jun 2011 17:18:18 GMT​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Content-Type: text/plain​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Content-Length: 10​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​not found​</code>​</div>
</td>
</tr>
</table>
<p id="N13405" class="calibre5">
        If your request cannot be fulfilled, you’ll get a 404 code (Object Not Found), which makes sense in the scope of the request. That object cannot be found, because there aren’t enough copies to fulfill the URL request. This isn’t a good thing, of course, so this kicks Riak to do a <span class="calibre6">read repair</span>: to request <span class="calibre6">N</span> replications of the key across the servers still available. If you attempt to access the same URL again, you’ll get the key’s value rather than another 404. The online Riak docs have an excellent example<a id="FNPTR-16" href="f_0027.html#FOOTNOTE-16">[16]</a> using Erlang.
      </p>
<p id="N13417" class="calibre5">
        But a safer play is to require a quorum (data from most, but not all, vnodes).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl http://localhost:8091/riak/animals/polly?r=quorum​</code>​</div>
</td>
</tr>
</table>
<p id="N13426" class="calibre5">
        As long as you write to a quorum, which you can force on a per-write basis, your reads should be consistent. Another value you can set on-the-fly is W. If you don’t want to wait for Riak to write to any nodes, you can set W to 0 (zero), which means “I trust you’ll write it, Riak; just return.”
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​curl -X PUT http://localhost:8091/riak/animals/jean?w=0 \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-H "Content-Type: application/json"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-d '{"nickname" : "Jean", "breed" : "Border Collie"}' \​</code>​</div>
</td>
</tr>
</table>
<p id="N1343B" class="calibre5">
        All this power aside, much of the time you’ll want to stick with the default values unless you have a good reason. Logs are great for setting W=0, and you can set W=N and R=1 for seldom written data for extra-fast reads.
        </p>
<h4 id="sec.durableWrites" class="calibre21">Writes and Durable Writes</h4>
<p id="N1344F" class="calibre5">
        We’ve been keeping a secret from you. Writes in Riak aren’t necessarily durable, meaning they aren’t immediately written to disk. Although a <span class="calibre6">node write</span> may be considered successful, it’s still possible that a failure could occur where a node loses data; even if W=N, servers may fail and lose data. A write is buffered in memory for a moment before being stored on disk, and that split millisecond is a danger zone.
      </p>
<p id="N1346D" class="calibre5">
        That’s the bad news. The good news is Riak has provided us with a separate setting named <span class="initials">DW</span> for <span class="calibre6">durable write</span>. This is slower but further reduces risk, since Riak will not return a success until after the object is written to disk on the given number of nodes. Just like we did with writes, you can set this property on the bucket. Here we’re setting <code class="cf">dw</code> to be <code class="cf">one</code> to be certain at least one node has stored our data.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT http://localhost:8091/riak/animals \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">-d '{"props":{"dw":"one"}}'</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N13493" class="calibre5">
        Or, if you like, you can override this on a per-write basis using the <code class="cf">dw</code> query parameter in the URL.
        </p>
<h4 id="sec.hintedhandoff" class="calibre21">A Note on Hinted Handoff</h4>
<p id="N134AA" class="calibre5">
        Attempting to write to nodes that aren’t available still succeeds with a “204 No Content.” This is because Riak will write the value to a nearby node that holds that data until such a time that it can hand it to the unavailable node. This is a fantastic safety net in the short-term, since if a server goes down, another Riak node will take over. Of course, if all of server A’s requests get routed to server B, then server B is now dealing with double the load. There is a danger this will cause B to fail, which might spread to C and D, and so on. This is known as a <span class="calibre6">cascading failure</span>, and it’s rare but possible. Consider this a fair warning not to tax every Riak server at full capacity, since you never know when one will have to pick up the slack.
      </p>
<h3 id="sec.day2Recap" class="calibre20">Day 2 Wrap-Up</h3>
<p id="N134B5" class="calibre5">
      Today you saw two of the biggest topics in Riak: the powerful mapreduce method and its flexible server clustering ability. Mapreduce is used by many of the other databases in this book, so if you still have any questions about it, we recommend rereading the first part of Day 2 and checking out the Riak online documentation<a id="FNPTR-17" href="f_0027.html#FOOTNOTE-17">[17]</a> and Wikipedia<a id="FNPTR-18" href="f_0027.html#FOOTNOTE-18">[18]</a> articles.
    </p>
<h4 class="calibre21">Day 2 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N134CF" class="calibre5">Read the online Riak mapreduce documentation.</p>
</li>
<li class="calibre23">
<p id="N134D3" class="calibre5">Find the Riak contrib functions repository, with lots of prebuilt mapreduce functions.</p>
</li>
<li class="calibre23">
<p id="N134D7" class="calibre5">Find the online documentation for a complete list of key filters, which range from converting strings <code class="cf">to_upper</code> to finding numerical values between some range to even some simple Levenshtein distance string matches and logical and/or/not operations.</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N134E4" class="calibre5">Write map and reduce functions against the <code class="cf">rooms</code> bucket  to find the total guest capacity per floor.</p>
</li>
<li class="calibre23">
<p id="N134EB" class="calibre5">Extend the previous function with a filter to find the capacities only for rooms on floors 42 and 43.</p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

