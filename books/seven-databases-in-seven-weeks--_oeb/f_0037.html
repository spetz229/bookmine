---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0036.html
next: f_0038.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N15DCD" class="calibre18">5.3 Day 2: Indexing, Grouping, Mapreduce</h2>
<p id="N15DD1" class="calibre5">
    Increasing MongoDB’s query performance is the first item on today’s docket, followed by some more powerful and complex grouped queries. Finally, we’ll round out the day with some data analysis using mapreduce, similar to what we did with Riak.
  </p>
<h3 class="calibre20">Indexing: When Fast Isn’t Fast Enough</h3>
<p id="N15DD8" class="calibre5">
      One of Mongo’s useful built-in features is indexing to increase query performance—something, as we’ve seen, that’s not available on all NoSQL databases. MongoDB provides several of the best data structures for indexing, such as the classic B-tree, and other additions such as two-dimensional and spherical GeoSpatial indexes.
    </p>
<p id="N15DF6" class="calibre5">
      For now we’re going to do a little experiment to see the power of MongoDB’s B-tree index by populating a series of phone numbers with a random country prefix (feel free to replace this code with your own country code). Enter the following code into your console. This will generate 100,000 phone numbers (it may take a while), between <code class="cf1">1-800-555-0000</code> and <code class="cf1">1-800-565-9999</code>.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/mongo/populate_phones.js">mongo/populate_phones.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​populatePhones = <strong class="prompt">function</strong>(area,start,stop) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">for</strong>(<strong class="prompt">var</strong> i=start; i &lt; stop; i++) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">var</strong> country = 1 + ((Math.random() * 8) &lt;&lt; 0);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">var</strong> num = (country * 1e10) + (area * 1e7) + i;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    db.phones.insert({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      _id: num,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      components: {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        country: country,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        area: area,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        prefix: (i * 1e-4) &lt;&lt; 0,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        number: i​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      display: <em class="string">"+"</em> + country + <em class="string">" "</em> + area + <em class="string">"-"</em> + i​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    });​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N15E51" class="calibre5">
      Run the function with a three-digit area code (like 800) and a range of seven-digit numbers (5,550,000 to 5,650,000—please verify your zeros when typing).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​populatePhones( 800, 5550000, 5650000 )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.find().limit(2)​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ "_id" : 18005550000, "components" : { "country" : 1, "area" : 800,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "prefix" : 555, "number" : 5550000 }, "display" : <em class="string">"+1 800-5550000"</em> }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ "_id" : 88005550001, "components" : { "country" : 8, "area" : 800,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "prefix" : 555, "number" : 5550001 }, "display" : <em class="string">"+8 800-5550001"</em> }​</code>​</div>
</td>
</tr>
</table>
<p id="N15E7E" class="calibre5">
      Whenever a new collection is created, Mongo automatically creates an index by the <code class="cf">_id</code>. These indexes can be found in the <code class="cf">system.indexes</code> collection. The following query shows all indexes in the database:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.system.indexes.find()​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ "name" : <em class="string">"_id_"</em>, "ns" : <em class="string">"book.phones"</em>, "key" : { "_id" : 1 } }​</code>​</div>
</td>
</tr>
</table>
<p id="N15EA5" class="calibre5">
      Most queries will include more fields than just the <code class="cf">_id</code>, so we need to make indexes on those fields.
    </p>
<p id="N15EB0" class="calibre5">
      We’re going to create a B-tree index on the <code class="cf">display</code> field. But first, let’s verify that the index will improve speed. To do this, we’ll first check a query without an index. The <code class="cf">explain</code> method is used to output details of a given operation.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.find({display: <em class="string">"+1 800-5650001"</em>}).explain()​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "cursor" : <em class="string">"BasicCursor"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "nscanned" : 109999,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "nscannedObjects" : 109999,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "n" : 1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "millis" : 52,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "indexBounds" : {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N15EEF" class="calibre5">
      Your output will not equal ours, but note the <code class="cf">millis</code> field—milliseconds to complete the query—will likely be double digits.
    </p>
<p id="N15EF5" class="calibre5">
      We create an index by calling <code class="cf">ensureIndex(fields,options)</code> on the collection. The <code class="cf">fields</code> parameter is an object containing the fields to be indexed against.  The <code class="cf">options</code> parameter describes the type of index to make. In this case, we’re building a unique index on <code class="cf">display</code> that should just drop duplicate entries.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.ensureIndex(​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  { display : 1 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  { unique : true, dropDups : true }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​)​</code>​</div>
</td>
</tr>
</table>
<p id="N15F1A" class="calibre5">
      Now try <code class="cf">find</code> again, and check <code class="cf">explain</code> to see whether the situation improves.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.find({ display: <em class="string">"+1 800-5650001"</em> }).explain()​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "cursor" : <em class="string">"BtreeCursor display_1"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "nscanned" : 1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "nscannedObjects" : 1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "n" : 1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "millis" : 0,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "indexBounds" : {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "display" : [​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      [​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        <em class="string">"+1 800-5650001"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        <em class="string">"+1 800-5650001"</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N15F70" class="calibre5">
      The millis value changed from 52 to 0—an infinity improvement (52 / 0)! Just kidding, but it is an orders of magnitude speedup. Also notice the cursor changed from a Basic to a B-tree cursor (it’s called a cursor because it points to where values are stored; it doesn’t contain them). Mongo is no longer doing a full collection scan but instead walking the tree to retrieve the value. Importantly, scanned objects dropped from 109999 to 1—since it has become just a unique lookup.
    </p>
<p id="N15F73" class="calibre5">
<code class="cf">explain</code> is a useful function, but you’ll  use it only when testing specific query calls. If you need to profile in a normal test or production environment, you’ll need the <span class="calibre6">system profiler</span>.
    </p>
<p id="N15F7B" class="calibre5">
      Let’s set the profiling level to 2 (level 2 stores all queries; profiling level 1  stores only slower queries greater than 100 milliseconds) and then run <code class="cf">find</code> as normal.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.setProfilingLevel(2)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.find({ display : <em class="string">"+1 800-5650001"</em> })​</code>​</div>
</td>
</tr>
</table>
<p id="N15F93" class="calibre5">
      This will create a new object in the <code class="cf">system.profile</code> collection, which you can read as any other table. <code class="cf1">ts</code> is the timestamp of when the query was performed, <code class="cf1">info</code> is a string description of the operation, and <code class="cf1">millis</code> is the length of time it took.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.system.profile.find()​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ts" : ISODate(<em class="string">"2011-12-05T19:26:40.310Z"</em>),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "op" : <em class="string">"query"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ns" : <em class="string">"book.phones"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "query" : { "display" : <em class="string">"+1 800-5650001"</em> },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "responseLength" : 146,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "millis" : 0,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "client" : <em class="string">"127.0.0.1"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "user" : <em class="string">""</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N15FE6" class="calibre5">
      Like yesterday’s nested queries, Mongo can build your index on nested values. If you wanted to index on all area codes, use the dot-notated field representation: <code class="cf">components.area</code>. In production, you should always build indexes in the background using the <code class="cf">{ background : 1 }</code> option.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.ensureIndex({ "components.area": 1 }, { background : 1 })​</code>​</div>
</td>
</tr>
</table>
<p id="N1600D" class="calibre5">
      If we <code class="cf">find</code> all of the system indexes for our <code class="cf">phones</code> collection, the new one should appear last. The first index is always automatically created to quickly look up by <code class="cf">_id</code>, and the second is the unique index we made previously.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.system.indexes.find({ "ns" : <em class="string">"book.phones"</em> })​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "name" : <em class="string">"_id_"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ns" : <em class="string">"book.phones"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "key" : { "_id" : 1 }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id" : ObjectId(<em class="string">"4d2c96d1df18c2494fa3061c"</em>),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ns" : <em class="string">"book.phones"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "key" : { "display" : 1 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "name" : <em class="string">"display_1"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "unique" : true,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "dropDups" : true​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id" : ObjectId(<em class="string">"4d2c982bdf18c2494fa3061d"</em>),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ns" : <em class="string">"book.phones"</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "key" : { "components.area" : 1 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "name" : <em class="string">"components.area_1"</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N16084" class="calibre5">
    Our <code class="cf1">book.phones</code> indexes have rounded out quite nicely.
    </p>
<p id="N1608A" class="calibre5">
    We should close this section by noting that creating an index on a large collection can be slow and resource-intensive. You should always consider these impacts when building an index by creating indexes off-peak times, running index creation in the background, and running them manually rather than using automated index creation. There are plenty more indexing tricks and tips online, but these are the basics that are good to know.
    </p>
<h3 class="calibre20">Aggregated Queries</h3>
<p id="N1609A" class="calibre5">
    The queries we investigated yesterday are useful for basic extraction of data, but any post-processing would be up to you to handle. For example, say we wanted to count the phone numbers greater than 559--9999; we would prefer the database perform such a count on the back end. Like in PostgreSQL, <code class="cf">count</code> is the most basic aggregator. It takes a query and returns a number (of matches).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.count({'components.number': { $gt : 5599999 } })​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​50000​</code>​</div>
</td>
</tr>
</table>
<div class="sidebar">
<div class="sidebar-title">Change Is Good</div>
<div class="calibre2">
<p id="N160C7" class="calibre5">
      Aggregated queries return a structure other than the individual documents we’re used to. <code class="cf2">count</code> aggregates the result into a count of documents, <code class="cf2">distinct</code> aggregates the results into an array of results, and <code class="cf2">group</code> returns documents of its own design. Even mapreduce generally takes a bit of effort to retrieve objects that resemble your internal stored documents.
      </p>
</div>
</div>
<p id="N16100" class="calibre5">
    To see the power of the next few aggregating queries, let’s add another 100,000 phone numbers to our <code class="cf">phones</code> collection, this time with a different area code.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​populatePhones( 855, 5550000, 5650000 )​</code>​</div>
</td>
</tr>
</table>
<p id="N16112" class="calibre5">
    The <code class="cf">distinct</code> command returns each matching value (not a full document) where one or more exists. We can get the distinct component numbers that are less than 5,550,005 in this way:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.distinct(<em class="string">'components.number'</em>, {'components.number': { $lt : 5550005 } })​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ 5550000, 5550001, 5550002, 5550003, 5550004 ]​</code>​</div>
</td>
</tr>
</table>
<p id="N16133" class="calibre5">
    Although we have two 5,550,000 numbers (one with an 800 area code and one with 855), it appears in the list  only once.
    </p>
<p id="N16136" class="calibre5">
    The <code class="cf">group</code> aggregate query is akin to <code class="cf">GROUP BY</code> in SQL. It’s also the most complex basic query in Mongo. We can count all phone numbers greater than 5,599,999 and group the results into different buckets keyed by area code. <code class="cf">key</code> is the field we want to group by, <code class="cf">cond</code> (condition) is the range of values we’re interested in, and <code class="cf">reduce</code> takes a function that manages how the values are to be output.
    </p>
<p id="N1614F" class="calibre5">
    Remember mapreduce from the Riak chapter? Our data is already <span class="calibre6">mapped</span> into our existing collection of documents. No more mapping is necessary; simply reduce the documents.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.group({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  initial: { count:0 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  reduce:  <strong class="prompt">function</strong>(phone, output) { output.count++; },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  cond:    { 'components.number': { $gt : 5599999 } },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  key:     { 'components.area' : true }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​})​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ { "800" : 50000, "855" : 50000 } ]​</code>​</div>
</td>
</tr>
</table>
<p id="N1617F" class="calibre5">
    The following two examples are, admittedly, odd use cases. They serve only to show the flexibility of <code class="cf">group</code>.
    </p>
<p id="N16185" class="calibre5">
    You can easily replicate the <code class="cf">count</code> function with the following <code class="cf">group</code> call. Here we leave off the aggregating <code class="cf">key</code>:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.group({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  initial: { count:0 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  reduce:  <strong class="prompt">function</strong>(phone, output) { output.count++; },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  cond:    { 'components.number': { $gt : 5599999 } }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​})​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ { "count" : 100000 } ]​</code>​</div>
</td>
</tr>
</table>
<p id="N161B8" class="calibre5">
    The first thing we did here was set an initial object with a field named <code class="cf">count</code> set to 0—fields created here will appear in the output. Next we describe what to do with this field by declaring a reduce function that adds one for every document we encounter. Finally, we gave group a condition restricting which documents to reduce over. Our result was the same as <code class="cf">count</code> because our condition was the same. We left off a key, since we want every document encountered added to our list.
    </p>
<p id="N161C1" class="calibre5">
    We can also replicate the <code class="cf">distinct</code> function. For performance sake, we’ll start by creating an object to store the numbers as fields (we’re effectively creating an ad hoc <span class="calibre6">set</span>). In the reduce function (which is run for each matching document), we just set the value to 1 as a placeholder (it’s the field we want).
    </p>
<p id="N161D4" class="calibre5">
    Technically this is all we need. However, if we want to really replicate <code class="cf">distinct</code>, we should return an array of integers. So, we add a <code class="cf">finalize(out)</code> method that is run one last time before returning a value to convert the object into an array of field values. The function then converts those number strings into integers (if you really want to see the sausage being made, run the following without the <code class="cf">finalize</code> function set).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.phones.group({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  initial: { prefixes : {} },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  reduce:  <strong class="prompt">function</strong>(phone, output) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    output.prefixes[phone.components.prefix] = 1;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  finalize: <strong class="prompt">function</strong>(out) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">var</strong> ary = [];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">for</strong>(<strong class="prompt">var</strong> p <strong class="prompt">in</strong> out.prefixes) { ary.push( parseInt( p ) ); }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    out.prefixes = ary;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​})[0].prefixes​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ 555, 556, 557, 558, 559, 560, 561, 562, 563, 564 ]​</code>​</div>
</td>
</tr>
</table>
<p id="N16229" class="calibre5">
      The <code class="cf">group</code> function is powerful—like <span class="initials">SQL</span>’s <code class="cf">GROUP BY</code>—but Mongo’s implementation has a downside, too. First, you are limited to a result of 10,000 documents. Moreover, if you shard your Mongo collection (which we will tomorrow) <code class="cf">group</code> won’t work. There are also much more flexible ways of crafting queries. For these and other reasons, we’ll dive into MongoDB’s version of mapreduce in just a bit. But first, we’ll touch on the boundary between client-side and server-side commands, which is a distinction that has important consequences for your applications.
      </p>
<h3 class="calibre20">Server-Side Commands</h3>
<p id="N1625B" class="calibre5">
      If you were to run the following function through a command line (or through a driver), the client will pull each phone locally, all 100,000 of them, and save each phone document one by one to the server.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/mongo/update_area.js">mongo/update_area.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​update_area = <strong class="prompt">function</strong>() {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  db.phones.find().forEach(​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">function</strong>(phone) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      phone.components.area++;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      phone.display = <em class="string">"+"</em>+​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        phone.components.country+<em class="string">" "</em>+​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        phone.components.area+<em class="string">"-"</em>+​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        phone.components.number;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      db.phone.update({ _id : phone._id }, phone, false);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N162B1" class="calibre5">
      However, the Mongo <code class="cf">db</code> object provides a command named <code class="cf">eval</code>, which passes the given function to the server. This dramatically reduces chatter between the client and server since the code is executed remotely.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.eval(update_area)​</code>​</div>
</td>
</tr>
</table>
<p id="N162C6" class="calibre5">
      In addition to evaluating JavaScript functions, there are several other prebuilt commands in Mongo, most of which are executed on the server, although some require executing only under the admin database (which you can access by entering <code class="cf">use admin</code>).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; use admin​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.runCommand(<em class="string">"top"</em>)​</code>​</div>
</td>
</tr>
</table>
<p id="N162DE" class="calibre5">
      The <code class="cf">top</code> command will output access details about all collections on the server.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; use book​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.listCommands()​</code>​</div>
</td>
</tr>
</table>
<p id="N162F8" class="calibre5">
      On running <code class="cf">listCommands</code>, you may notice a lot of commands we’ve used. In fact, you can execute many common commands through the <code class="cf">runCommand</code> method, such as counting the number of phones. However, you may notice a slightly different output.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.runCommand({ "count" : <em class="string">"phones"</em> })​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ "n" : 100000, "ok" : 1 }​</code>​</div>
</td>
</tr>
</table>
<p id="N16313" class="calibre5">
      The number (<code class="cf1">n</code>) returned is correct (100,000), but the format is an object with an <code class="cf1">ok</code> field. That’s because <code class="cf">db.phones.count</code> is a wrapper function created for our convenience by the shell’s JavaScript interface, whereas <code class="cf">runCommand</code> is a count executed on the server. Remember that we can play detective on how a function like <code class="cf">count</code> works by leaving off the calling parentheses.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.phones.count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">function</strong> (x) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">return</strong> this.find(x).count();​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1633F" class="calibre5">
      Interesting! <code class="cf">collection.count</code> is just a convenience wrapper for calling <code class="cf">count</code> on the results of <code class="cf">find</code> (which itself is just a wrapper for a native query object that returns a cursor pointing to results). If you run <span class="calibre6">that</span> query...
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.phones.find().count​</code>​</div>
</td>
</tr>
</table>
<p id="N1635A" class="calibre5">
      you will get a much larger function (too much to print here). But look in the code, and after a bunch of setup, you’ll find lines like this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">var</strong> res = this._db.runCommand(cmd);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">if</strong> (res &amp;&amp; res.n != null) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">return</strong> res.n;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N16379" class="calibre5">
      Double interesting! <code class="cf">count</code> executes <code class="cf">runCommand</code> and returns the value from the <code class="cf">n</code> field.
      </p>
<h4 class="calibre21">runCommand</h4>
<p id="N1638F" class="calibre5">
      And while we’re digging into how methods work, let’s take a look at the <code class="cf">runCommand</code> function.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.runCommand​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">function</strong> (obj) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">if</strong> (<strong class="prompt">typeof</strong> obj == <em class="string">"string"</em>) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        <strong class="prompt">var</strong> n = {};​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        n[obj] = 1;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        obj = n;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">return</strong> this.getCollection(<em class="string">"$cmd"</em>).findOne(obj);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N163CD" class="calibre5">
      It turns out that <code class="cf">runCommand</code> is also a helper function that wraps a call to a collection named <code class="cf">$cmd</code>. You can execute any command using a call directly to this collection.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.$cmd.findOne({'count' : <em class="string">'phones'</em>})​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ "n" : 100000, "ok" : 1 }​</code>​</div>
</td>
</tr>
</table>
<p id="N163E8" class="calibre5">
      This is bare-metal and how drivers generally communicate to the Mongo server.
      </p>
<h4 class="calibre21">Diversion</h4>
<p id="N163F5" class="calibre5">
      We took this diversion for two reasons:
    </p>
<ul class="calibre22">
<li class="calibre23">
<p id="N163FB" class="calibre5">
          To drive home the idea that most of the magic you execute on the <code class="cf">mongo</code>  console is executed on the server, not the client, which just provides convenient wrapper functions.
        </p>
</li>
<li class="calibre23">
<p id="N16402" class="calibre5">
          We can leverage the concept of executing server-side code for our own gain to create something in MongoDB that’s similar to the <span class="calibre6">stored procedures</span> we saw in PostgreSQL.
         </p>
</li>
</ul>
<p id="N16408" class="calibre5">
      Any JavaScript function can be stored in a special collection named <code class="cf">system.js</code>. This is a normal collection; you just save the function by setting the name as the <code class="cf">_id</code>, and <code class="cf">value</code> is the function object.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.system.js.save({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    _id:<em class="string">'getLast'</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    value:<strong class="prompt">function</strong>(collection){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      <strong class="prompt">return</strong> collection.find({}).sort({'_id':1}).limit(1)[0]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​})​</code>​</div>
</td>
</tr>
</table>
<p id="N16443" class="calibre5">
      What we normally would do next is execute it on the server directly. The <code class="cf">eval</code> function passes the string to the server, evaluates it as JavaScript code, and returns the results.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.eval(<em class="string">'getLast(db.phones)'</em>)​</code>​</div>
</td>
</tr>
</table>
<p id="N16462" class="calibre5">
      It should return the same values as calling <code class="cf">getLast(collection)</code> locally.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.system.js.findOne({'_id': <em class="string">'getLast'</em>}).value(db.phones)​</code>​</div>
</td>
</tr>
</table>
<p id="N16478" class="calibre5">
      It’s worth mentioning that <code class="cf">eval</code> blocks the <code class="cf">mongod</code> as it runs, so it’s mainly useful for quick one-offs and tests, not common production procedures. You can use this function inside <code class="cf">$where</code> and mapreduce, too. We have the last weapon in our arsenal to begin executing mapreduce in MongoDB.
    </p>
<h3 id="sec.mongo.mapreduce" class="calibre20">Mapreduce (and Finalize)</h3>
<p id="N16489" class="calibre5">
      The Mongo mapreduce pattern is similar to Riak’s, with a few small differences. Rather than the <code class="cf">map</code> function returning a converted value, Mongo requires your mapper to call an <code class="cf">emit</code> function with a key. The benefit here is that you can emit more than once per document. The <code class="cf">reduce</code> function accepts a single key and a list of values that were emitted to that key. Finally, Mongo provides an optional third step called <code class="cf">finalize</code>, which is executed only once per mapped value after the reducers are run. This allows you to perform any final calculations or cleanup you may need.
    </p>
<p id="N164A4" class="calibre5">
      Since we already know the basics of mapreduce, we’ll skip the intro wading-pool example and go right to the high-dive. Let’s generate a report that counts all phone numbers that contain the same digits for each country. First we’ll store a helper function that extracts an array of all distinct numbers (understanding how this helper works is not imperative to understanding the overall mapreduce).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/mongo/distinct_digits.js">mongo/distinct_digits.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​distinctDigits = <strong class="prompt">function</strong>(phone){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">var</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    number = phone.components.number + <em class="string">''</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    seen = [],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    result = [],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    i = number.length;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">while</strong>(i--) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    seen[+number[i]] = 1;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">for</strong> (i=0; i&lt;10; i++) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">if</strong> (seen[i]) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      result[result.length] = i;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> result;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.system.js.save({_id: <em class="string">'distinctDigits'</em>, value: distinctDigits})​</code>​</div>
</td>
</tr>
</table>
<p id="N164FB" class="calibre5">
      Load the file in the <code class="cf">mongo</code> command line. If the file exists in the same directory you launched <code class="cf">mongo</code> from, you  need only the filename; otherwise, a full path is required.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; load(<em class="string">'distinct_digits.js'</em>)​</code>​</div>
</td>
</tr>
</table>
<p id="N16513" class="calibre5">
      With all that in, we can do a quick test (if you have some trouble, don’t feel shy about adding a smattering of <code class="cf">print</code> functions).
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​db.eval(<em class="string">"distinctDigits(db.phones.findOne({ 'components.number' : 5551213 }))"</em>)​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​[ 1, 2, 3, 5 ]​</code>​</div>
</td>
</tr>
</table>
<p id="N16535" class="calibre5">
      Now we can get to work on the mapper. As with any mapreduce function, deciding what fields to map by is a crucial decision, since it dictates the aggregated values that you return. Since our report is finding distinct numbers, the array of distinct values is one field. But since we also need to query by country, that is another field. We add both values as a compound key: <code class="cf">{digits : X, country : Y}</code>.
    </p>
<p id="N1653B" class="calibre5">
      Our goal is to simply count these values, so we emit the value 1 (each document represents one item to count). The reducer’s job is to sum all those 1s together.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/mongo/map_1.js">mongo/map_1.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​map = <strong class="prompt">function</strong>() {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">var</strong> digits = distinctDigits(this);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  emit({digits : digits, country : this.components.country}, {count : 1});​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/mongo/reduce_1.js">mongo/reduce_1.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​reduce = <strong class="prompt">function</strong>(key, values) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">var</strong> total = 0;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">for</strong>(<strong class="prompt">var</strong> i=0; i&lt;values.length; i++) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    total += values[i].count;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> { count : total };​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​results = db.runCommand({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  mapReduce: <em class="string">'phones'</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  map:       map,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  reduce:    reduce,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  out:       <em class="string">'phones.report'</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​})​</code>​</div>
</td>
</tr>
</table>
<p id="N165A8" class="calibre5">
      Since we set the collection name via the <code class="cf">out</code> parameter (<code class="cf">out : ’phones.report’</code>), you can query the results like any other. It’s a materialized view that you can see in the <code class="cf">show tables</code> list.
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​&gt; db.phones.report.find({'_id.country' : 8})​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id" : { "digits" : [ 0, 1, 2, 3, 4, 5, 6 ], "country" : 8 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "value" : { "count" : 19 }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id" : { "digits" : [ 0, 1, 2, 3, 5 ], "country" : 8 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "value" : { "count" : 3 }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id" : { "digits" : [ 0, 1, 2, 3, 5, 6 ], "country" : 8 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "value" : { "count" : 48 }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id" : { "digits" : [ 0, 1, 2, 3, 5, 6, 7 ], "country" : 8 },​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "value" : { "count" : 12 }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​has more​</code>​</div>
</td>
</tr>
</table>
<p id="N165F3" class="calibre5">
      Type <code class="cf">it</code> to continue iterating through the results. Note the unique emitted keys are under the field <code class="cf">_id</code>s, and all of the data returned from the reducers are under the field <code class="cf">value</code>.
    </p>
<p id="N165FF" class="calibre5">
    If you prefer that the mapreducer just output the results, rather than outputting to a collection, you can set the <code class="cf">out</code> value to <code class="cf">{ inline : 1 }</code>, but bear in mind there is a limit to the size of a result you can output. As of Mongo 2.0, that limit is 16MB.
    </p>
<p id="N16608" class="calibre5">
      Recall from the Riak chapter that reducers can have either mapped (emitted) results or other reducer results as inputs.  Why would the output of one reducer feed into the input of another if they are mapped to the same key? Think of how this would look if run on separate servers, as shown in Figure 22, <a href="#fig.mapreduce">​<em class="calibre6">A Mongo map reduce call over two servers</em>​</a>.
    </p>
<div class="figure" id="fig.mapreduce">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/mongo-mapreduce.png" alt="images/mongo-mapreduce.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 22. A Mongo map reduce call over two servers</div>
</div>
<p id="N16639" class="calibre5">
      Each server must run its own <code class="cf">map</code> and <code class="cf">reduce</code> functions and then push those results to be merged with the service that initiated the call, gathering them up. Classic divide and conquer. If we had renamed the output of the reducer to <code class="cf">total</code> instead of <code class="cf">count</code>, we would have needed to handle both cases in the loop, as shown here:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/mongo/reduce_2.js">mongo/reduce_2.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​reduce = <strong class="prompt">function</strong>(key, values) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">var</strong> total = 0;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">for</strong>(<strong class="prompt">var</strong> i=0; i&lt;values.length; i++) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">var</strong> data = values[i];​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">if</strong>(<em class="string">'total'</em> <strong class="prompt">in</strong> data) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      total += data.total;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    } <strong class="prompt">else</strong> {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      total += data.count;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> { total : total };​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1669E" class="calibre5">
      However, Mongo predicted that you might need to perform some final changes, such as rename a field or some other calculations. If we really need the output field to be <code class="cf">total</code>, we can implement a <code class="cf">finalize</code> function, which works the same way as the <code class="cf">finalize</code> function under <code class="cf">group</code>.
      </p>
<h3 class="calibre20">Day 2 Wrap-Up</h3>
<p id="N166BE" class="calibre5">
      On Day 2 we’ve expanded our query power by including several aggregate queries: <code class="cf">count</code>, <code class="cf">distinct</code>, and topped off by <code class="cf">group</code>. To speed up the response time of these queries, we used MongoDB’s indexing options. When more power is required, the ever-present <code class="cf">mapReduce</code> is available.
    </p>
<h4 class="calibre21">Day 2 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N166D8" class="calibre5">A shortcut for admin commands.</p>
</li>
<li class="calibre23">
<p id="N166DC" class="calibre5">The online documentation for queries and cursors.</p>
</li>
<li class="calibre23">
<p id="N166E0" class="calibre5">The MongoDB documentation for mapreduce.</p>
</li>
<li class="calibre23">
<p id="N166E4" class="calibre5">Through the JavaScript interface, investigate the code for three collections functions: <code class="cf">help</code>, <code class="cf">findOne</code>, and <code class="cf">stats</code>.</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N166F7" class="calibre5">Implement a finalize method to output the count as the  total.</p>
</li>
<li class="calibre23">
<p id="N166FB" class="calibre5">Install a Mongo driver for a language of your choice, and connect to the database. Populate a collection through it, and index one of the fields.</p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

