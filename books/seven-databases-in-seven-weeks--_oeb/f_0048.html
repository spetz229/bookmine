---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0047.html
next: f_0049.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N18287" class="calibre18">7.2 Day 1: Graphs, Groovy, and CRUD</h2>
<p id="N1828B" class="calibre5">
      Today we’re really going to jump in with both feet.  In addition to exploring the Neo4j web interface, we’ll get deep into graph database terminology and CRUD.  Much of today will be learning how to query a graph database through a process called <span class="calibre6">walking</span>.  The concepts here differ significantly from other databases we’ve looked at so far, which have largely taken a document- or record-based view of the world.  In Neo4j, it’s all about relationships.
    </p>
<p id="N18296" class="calibre5">
      But before we get to all that, let’s start with the web interface to see how Neo4j represents data in graph form and how to walk around that graph. After you’ve downloaded and unzipped the Neo4j package, <code class="cf">cd</code> into the directory and start up the server with this:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ bin/neo4j start​</code>​</div>
</td>
</tr>
</table>
<p id="N182A7" class="calibre5">
      To make sure you’re up and running, try <code class="cf">curl</code>ing this URL:
    </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ curl http://localhost:7474/db/data/​</code>​</div>
</td>
</tr>
</table>
<p id="N182B8" class="calibre5">
      Like CouchDB, the default Neo4j package comes equipped with a substantial web administration tool and data browser, which is excellent for playing with toy commands. If that weren’t enough, it has one of the coolest graph data browsers we’ve ever seen. This is perfect for getting started, since graph traversal can feel very awkward at first try.
    </p>
<h3 id="sec.webAdmin" class="calibre20">Neo4j’s Web Interface</h3>
<p id="N182C0" class="calibre5">
        Launch a web browser, and navigate to the administration page.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​http://localhost:7474/webadmin/​</code>​</div>
</td>
</tr>
</table>
<div class="figure" id="fig.web.admin.dashboard">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/neo4j-wa-dashboard.png" alt="images/neo4j-wa-dashboard.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 32. The web administration page dashboard</div>
</div>
<p id="N182E2" class="calibre5">
        You’ll be greeted by a colorful yet empty graph like the one pictured in Figure 32, <a href="#fig.web.admin.dashboard">​<em class="calibre6">The web administration page dashboard</em>​</a>. Click the Data Browser  option at the top. A new Neo4j install will have a preexisting reference node: node 0.
      </p>
<p id="N182E8" class="calibre5">
        A <span class="calibre6">node</span> in a graph database is not entirely unlike the nodes we talked about in prior chapters. Previously, when we spoke of a <span class="calibre6">node</span>, we meant a physical server in a network. If you viewed the entire network as a huge interconnected graph, a server node was a point, or <span class="calibre6">vertex</span>, between the server <span class="calibre6">relationships</span>, or <span class="calibre6">edges</span>.
      </p>
<p id="N18309" class="calibre5">
        In Neo4j, a node is conceptually similar; it’s a vertex between edges that may hold data, as a set of key-values. Click the + Property button and set the key to <code class="cf1">name</code> and value to <code class="cf1">Prancing Wolf Ice Wine 2007</code> to represent a specific wine and vintage. Next, click the + Node button pictured below:
        </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/neo4j-wa-buttons.png" alt="images/neo4j-wa-buttons.png" class="calibre27"/>
</div>
<p id="N18330" class="calibre5"> 
        To the new node, add the property <code class="cf">name</code> with a value of <code class="cf1">Wine Expert Monthly</code> (we’ll write it in shorthand like this: <code class="cf">[name : "Wine Expert Monthly"]</code>). The node number will be automatically incremented.
      </p>
<p id="N1833C" class="calibre5">
        Now we have two nodes sitting out there but nothing connecting them. Since Wine Expert reported on the Prancing Wolf wine, we need to relate the two by creating an edge. Click the + Relationship button, and set from node 1 to node 0 with type <code class="cf">reported_on</code>.
      </p>
<p id="N18342" class="calibre5">
        You’ll get a URL to this specific relationship...
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​http://localhost:7474/db/data/relationship/0​</code>​</div>
</td>
</tr>
</table>
<p id="N18350" class="calibre5">
        that shows <code class="cf1">Node 1 reported_on Node 0</code>.
        </p>
<p id="N18359" class="calibre5">
      Just like nodes, relationships can contain properties. Click the + Add Property button and enter the property <code class="cf">[rating : 92]</code> so we can keep track of what score the wine received.
      </p>
<p id="N1835F" class="calibre5">
        This particular ice wine is created from the <span class="calibre6">riesling</span> grape, so let’s add that information too. We could add the property directly to the wine node, but riesling is a general category that could apply to other wines, so let’s create a new node and set its property to <code class="cf">[name : "riesling"]</code>. Next add another relationship from node 0 to 2 as <code class="cf">grape_type</code> and give it the property <code class="cf">[style : "ice wine"]</code>.
      </p>
<p id="N1836E" class="calibre5">
        But what does our graph look like? If you click the “switch view mode” button (the squiggle-looking one beside + Relationship), you’ll see something like Figure 33, <a href="#fig.graph.of.nodes">​<em class="calibre6">A graph of nodes related to the current one</em>​</a>.
      </p>
<div class="figure" id="fig.graph.of.nodes">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/neo4j-wa-graph1.png" alt="images/neo4j-wa-graph1.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 33. A graph of nodes related to the current one</div>
</div>
<p id="N1838F" class="calibre5">
        The Style button brings up a menu where you can choose which profile is used for rendering the graph visualization.  To see more useful information on the diagram, click Style and then New Profile.  This will take you to the “Create new visualization profile” page.  Enter the name <code class="cf1">wines</code> at the top, and then change the label from <code class="cf">{id}</code> to <code class="cf">{id}: {prop.name}</code>.  Click Save to bring you back to the visualization page.  Now you can choose <span class="calibre6">wines</span> from the Style menu, which should produce something like Figure 34, <a href="#fig.graph.of.nodes.with.custom.profile">​<em class="calibre6">A graph of nodes using a custom profile</em>​</a>.
      </p>
<div class="figure" id="fig.graph.of.nodes.with.custom.profile">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/neo4j-wa-graph2.png" alt="images/neo4j-wa-graph2.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 34. A graph of nodes using a custom profile</div>
</div>
<p id="N183BC" class="calibre5">
        Although the web interface is an easy way to make a few edits, we need a more powerful interface for production work.
      </p>
<h3 id="sec.visforVertices" class="calibre20">Neo4j via Gremlin</h3>
<p id="N183C4" class="calibre5">
        There are several languages that interoperate with Neo4j: Java code, REST, Cypher, Ruby console, and others. The one we’ll use today is called Gremlin, which is a graph traversal language written in the Groovy programming language. You needn’t actually know Groovy to use Gremlin, however, so think of it as just another declarative domain-specific language, like SQL.
      </p>
<p id="N183D6" class="calibre5">
        Like other consoles we’ve explored, Gremlin provides access to the underlying language infrastructure on which it’s based.  This means you can use Groovy constructs and Java libraries in Gremlin. We found it a powerful and more natural way of interacting with graphs than Neo4j’s native Java code. And even better, the Gremlin console is available in the Web Admin; just click the Console link at the top, and choose Gremlin.
        </p>
<p id="N183EB" class="calibre5">
        As a matter of convention, <code class="cf">g</code> is a variable that represents the graph object. Graph <span class="calibre6">actions</span> are functions called on it.
      </p>
<p id="N183F5" class="calibre5">
        Since Gremlin is a general-purpose graph traversal language, it uses general mathematic graph terms. Where Neo4j calls a graph data point a <span class="calibre6">node</span>, Gremlin prefers <span class="calibre6">vertex</span>, and rather than <span class="calibre6">relationship</span>, Gremlin calls it an <span class="calibre6">edge</span>.
      </p>
<p id="N18426" class="calibre5">
        To access all of the vertices in this graph, there is a property simply named <code class="cf">V</code> for vertices.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;v[0]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;v[1]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;v[2]​</code>​</div>
</td>
</tr>
</table>
<p id="N18440" class="calibre5">
        along with a sister property named <code class="cf">E</code>, for edges.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.E​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[0][1-reported_on-&gt;0]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[1][0-grape_type-&gt;2]​</code>​</div>
</td>
</tr>
</table>
<p id="N1845C" class="calibre5">
        You can grab a particular vertex by passing a node number into the <code class="cf">v</code> (lowercase) method.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.v(0)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; v[0]​</code>​</div>
</td>
</tr>
</table>
<p id="N18470" class="calibre5">
        To make sure you have the correct vertex, you can list its properties via the <code class="cf">map</code> method. Note that you can chain method calls in Groovy/Gremlin.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.v(0).map()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; name=Prancing Wolf Ice Wine 2007​</code>​</div>
</td>
</tr>
</table>
<p id="N18484" class="calibre5">
        Although using <code class="cf">v(0)</code> will retrieve the exact node, you could also filter out all nodes by some value you want. For example, to retrieve <span class="calibre6">riesling</span> by name, you can use the {…} filter syntax, which in Groovy code is called a <span class="calibre6">closure</span>. All of the code between the curly braces, {…}, define the function that, if it returns true, will walk that vertex. The <code class="cf">it</code> keyword inside the closure represents the current object and is automatically populated for your use.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='riesling'}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; v[2]​</code>​</div>
</td>
</tr>
</table>
<p id="N184AC" class="calibre5">
        Once you have a vertex, you can get the outgoing edges by calling <code class="cf">outE</code> on the returned vertex. Incoming edges are retrieved by <code class="cf">inE</code>, and both incoming and outgoing are called by <code class="cf">bothE</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='Wine Expert Monthly'}.outE()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[0][1-reported_on-&gt;0]​</code>​</div>
</td>
</tr>
</table>
<p id="N184C6" class="calibre5">
        Note that in Groovy, like Ruby, method parentheses are optional for methods, so calling <code class="cf">outE</code> is fine too.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='Wine Expert Monthly'}.outE​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[0][1-reported_on-&gt;0]​</code>​</div>
</td>
</tr>
</table>
<p id="N184DF" class="calibre5">
        From the out edges, you can walk to incoming vertices with <code class="cf">inV</code>—that is, the vertices into which the edges point. The <code class="cf">reported_on</code> edge from Wine Expert points into the <span class="calibre6">Prancing Wolf Ice Wine 2007</span> vertex, so <code class="cf">outE.inV</code> will return it. Then retrieve the <code class="cf">name</code> property by calling it on the vertex.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='Wine Expert Monthly'}.outE.inV.name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Ice Wine 2007​</code>​</div>
</td>
</tr>
</table>
<p id="N184FF" class="calibre5">
        The expression <code class="cf">outE.inV</code> asks for any vertices to which the input vertices have edges.  The reverse operation (asking for all vertices that have edges <span class="calibre6">into</span> the input vertices) is achieved with <code class="cf">inE.outV</code>.  Because these two operations are so common, Gremlin has shorthand versions of both.  The expression <code class="cf">out</code> is short for <code class="cf">outE.inV</code>, and <code class="cf">in</code> is short for <code class="cf">inE.outV</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='Wine Expert Monthly'}.out.name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Ice Wine 2007​</code>​</div>
</td>
</tr>
</table>
<p id="N18525" class="calibre5">
        A winery makes more than one wine, so if we plan to add more, we should add the winery as a joining node and add an edge to the Prancing Wolf.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; pwolf = g.addVertex([name : 'Prancing Wolf Winery'])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; v[3]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.addEdge(pwolf, g.v(0), 'produced')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[2][3-produced-&gt;0]​</code>​</div>
</td>
</tr>
</table>
<p id="N1853C" class="calibre5">
        From here we’ll add a couple more rieslings: Kabinett and Spatlese.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; kabinett = g.addVertex([name : 'Prancing Wolf Kabinett 2002'])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; v[4]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.addEdge(pwolf, kabinett, 'produced')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[3][3-produced-&gt;4]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; spatlese = g.addVertex([name : 'Prancing Wolf Spatlese 2007'])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; v[5]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.addEdge(pwolf, spatlese, 'produced')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[4][3-produced-&gt;5]​</code>​</div>
</td>
</tr>
</table>
<p id="N1855F" class="calibre5">
        Let’s wrap up this little graph by adding some edges from the riesling vertex to the newly added vertices. We’ll set the riesling variable by filtering the riesling node; <code class="cf">next</code> is necessary to grab the first vertex out of the pipeline—something we will go over in more detail shortly.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; riesling = g.V.filter{it.name=='riesling'}.next()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; v[2]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.addEdge([style:'kabinett'], kabinett, riesling, 'grape_type')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; e[5][4-grape_type-&gt;2]​</code>​</div>
</td>
</tr>
</table>
<p id="N18579" class="calibre5">
        The Spatlese can be pointed to riesling in a similar way, but with the <code class="cf">style</code> set to <code class="cf">spatlese</code>.  With all this data added, in the visualizer your graph should look like Figure 35, <a href="#fig.graph.of.nodes.after.gremlin">​<em class="calibre6">A graph of nodes after adding data with Gremlin</em>​</a>.
        </p>
<div class="figure" id="fig.graph.of.nodes.after.gremlin">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/neo4j-wa-graph3.png" alt="images/neo4j-wa-graph3.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 35. A graph of nodes after adding data with Gremlin</div>
</div>
<h3 id="sec.cecinestpasunePipe" class="calibre20">The Power of Pipes</h3>
<p id="N185A5" class="calibre5">
        You can think of Gremlin operations as a series of pipes.  Each pipe takes a collection as input and pushes a collection as output. A collection may have one item, many items, or no items at all.  The items may be vertices, edges, or property values.
      </p>
<p id="N185C3" class="calibre5">
        For example, the <code class="cf">outE</code> pipe takes in a collection of vertices and sends out a collection of edges.  The series of pipes is called a <span class="calibre6">pipeline</span> and expresses <span class="calibre6">declaratively</span> what the problem is. Contrast this with a typical <span class="calibre6">imperative</span> programming approach, which would require you to describe the steps to solve the problem. Using pipes is one of the most concise ways to query a graph database.
      </p>
<p id="N185D2" class="calibre5">
        At its heart, Gremlin is a language to build these pipes. Specifically, it is built on top of a Java project named Pipes.

        To explore the pipe concept, let’s return to our wine graph.  Suppose we want to find wines that are similar to a given wine—that is, they have the same type. We can follow an ice wine that also shares a <code class="cf">grape_type</code> edge with other out nodes (ignoring the initial wine node).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ice_wine = g.v(0)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ice_wine.out('grape_type').in('grape_type').filter{ !it.equals(ice_wine) }​</code>​</div>
</td>
</tr>
</table>
<p id="N185E6" class="calibre5">
        If you’ve worked in Smalltalk or Rails with scopes, this style of method chaining will seem familiar to you. But compare the previous to using the standard Neo4j Java API shown next, where a node’s relationships must be iterated through in order to access the varietal nodes.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">enum</strong> WineRelationshipType <strong class="prompt">implements</strong> RelationshipType {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  grape_type​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">import</strong> static WineRelationshipType.grape_type;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">List</strong>&lt;Node&gt; same_variety( Node wine ) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">List</strong>&lt;Node&gt; wine_list = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;Node&gt;();​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <em class="comment">// walk into all out edges from this vertex</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">for</strong>( Relationship outE : wine.getRelationships( grape_type ) ) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment">// walk into all in edges from this edge's out vertex</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">for</strong>( Edge inE : outE.getEndNode().getRelationships( grape_type ) ) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      <em class="comment">// only add vertices that are not the given vertex</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      <strong class="prompt">if</strong>( !inE.getStartNode().equals( wine ) ) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        wine_list.add( inE.getStartNode() );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> wine_list;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18658" class="calibre5">
      Rather than nesting and iterating as shown earlier, the Pipes project designed a way to declare incoming and outgoing vertices. You create a sequence of in and out pipes, filters, and request values from the pipeline.  Then iteratively call the pipeline’s <code class="cf">hasNext</code> method, which returns the next matching node. In other words, the pipeline walks the tree for you. Until the pipeline is requested, you’re simply declaring how the walk will occur.
      </p>
<div class="xxxsays" id="sb.jqueryvsgremlin">
<div class="heading">
<div class="persons-picture">
<img src="images/headshots/Jim.png" alt="Jim says:" class="calibre27"/>
</div>
<div class="label">Jim says:</div>
<div class="title">jQuery and Gremlin</div>
</div>
<div class="calibre2">
<p id="N18663" class="calibre5">
          Users of the popular jQuery JavaScript library may find Gremlin’s collection-oriented traversal method to be quite familiar.  Consider this HTML snippet:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​<strong class="prompt">&lt;ul</strong> id=<em class="string">"navigation"</em>
<strong class="prompt">&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​  <strong class="prompt">&lt;li&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​    <strong class="prompt">&lt;a</strong> name=<em class="string">"section1"</em>
<strong class="prompt">&gt;</strong>section 1<strong class="prompt">&lt;/a&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​  <strong class="prompt">&lt;/li&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​  <strong class="prompt">&lt;li&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​    <strong class="prompt">&lt;a</strong> name=<em class="string">"section2"</em>
<strong class="prompt">&gt;</strong>section 2<strong class="prompt">&lt;/a&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​  <strong class="prompt">&lt;/li&gt;</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​<strong class="prompt">&lt;/ul&gt;</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N186B4" class="calibre5">
          Now suppose we want to find the text of all tags with the name <code class="cf3">section1</code> that are children of list items (<code class="cf3">&lt;li&gt;</code>) under the navigation element (<code class="cf3">id=navigation</code>).

          One way to do that in jQuery is with code like this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​$('[id=navigation]').children('li').children('[name=section1]').text()​</code>​</div>
</td>
</tr>
</table>
<p id="N186CC" class="calibre5">
          Next, consider what a Gremlin query might look like for a similar data set, imagining that each parent node has an edge pointing to each of its children.  Pretty similar, eh?
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​g.V.filter{it.id=='navigation'}.out.filter{it.tag=='li'}.​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​out.filter{it.name=='section1'}.text​</code>​</div>
</td>
</tr>
</table>
</div>
</div>
<p id="N186DD" class="calibre5">
      To illustrate, here’s another implementation of the <code class="cf">same_variety</code> method, which uses Pipes rather than explicitly looping:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">void</strong> same_variety( Vertex wine ) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">List</strong>&lt;Vertex&gt; wine_list = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;Vertex&gt;();​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">Pipe</strong> inE       = <strong class="prompt">new</strong> InPipe( <em class="string">"grape_type"</em> );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">Pipe</strong> outE      = <strong class="prompt">new</strong> OutPipe( <em class="string">"grape_type"</em> );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">Pipe</strong> not_wine = <strong class="prompt">new</strong> ObjectFilterPipe( wine, true );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">Pipe</strong>&lt;Vertex,Vertex&gt; pipeline =​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">new</strong> Pipeline&lt;Vertex,Vertex&gt;( outE, inE, not_wine );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  pipeline.setStarts( <strong class="prompt">Arrays</strong>.asList( wine ) );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">while</strong>( pipeline.hasNext() ) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    wine_list.add( pipeline.next() );​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> wine_list;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1874B" class="calibre5">
      Deep down Gremlin is a <code class="cf">Pipe</code>-building language. The work of walking the graph is still being done on the Neo4j server, but Gremlin simplifies the effort of building queries that Neo4j can understand.
      </p>
<div class="xxxsays" id="sb.cypherLanguage">
<div class="heading">
<div class="persons-picture">
<img src="images/headshots/Eric.png" alt="Eric says:" class="calibre27"/>
</div>
<div class="label">Eric says:</div>
<div class="title">Cypher Language</div>
</div>
<div class="calibre2">
<p id="N1875C" class="calibre5">
Cypher is the other graph query language supported by Neo4j, based on pattern matching and a SQL-like syntax. The clauses feel familiar, making it easy to understand what’s going on. Particularly, the <code class="cf3">MATCH</code> clause is very intuitive, resulting in ASCII art--like expressions.
  </p>
<p id="N18762" class="calibre5">
  At first I didn’t like Cypher’s verbosity, but over time as my eyes adjusted to reading its grammar, I’ve become a fan.
  </p>
<p id="N18765" class="calibre5">
  Look at this Cypher equivalent of our “similar wines” query:
  </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​START ice_wine=node(0)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​MATCH (ice_wine) -[:grape_type]-&gt; () &lt;-[:grape_type]- (similar)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​RETURN similar​</code>​</div>
</td>
</tr>
</table>
<p id="N18779" class="calibre5">
We’ve started by binding <code class="cf3">ice_wine</code> to node 0. The <code class="cf3">MATCH</code> clause uses identifiers within parentheses to indicate nodes and typed “arrows” like <code class="cf3">-[:grape_type]-&gt;</code> for directional relationships. I actually like this construct, because it’s easy to visualize the node walk.
  </p>
<p id="N18785" class="calibre5">
It can quickly get advanced, however. This is a more real-world style example—every bit as powerful and wordy as SQL.
  </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​START ice_wine=node:wines(name=”Prancing Wolf Ice Wine 2007”)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​MATCH ice_wine -[:grape_type]-&gt; wine_type &lt;-[:grape_type]- similar​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​WHERE wine_type =~ /(?i)riesl.*)/​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​RETURN wine_type.name, collect(similar) as wines, count(*) as wine_count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​ORDER BY wine_count desc​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre25">
​<code class="calibre37">​LIMIT 10​</code>​</div>
</td>
</tr>
</table>
<p id="N187A2" class="calibre5">
While I chose to focus on Gremlin in the main chapter, the two languages are natural complements and happily coexist. In day-to-day work, you’ll find reasons to use either, depending on how you think about the problem at hand.
  </p>
</div>
</div>
<h3 id="sec.pipelineversusVertex" class="calibre20">Pipeline vs. Vertex</h3>
<p id="N187AA" class="calibre5">
        To grab a collection containing just one specific vertex, we can filter it from the list of all nodes.  This is what we have been doing when we call, for example, <code class="cf">g.V.filter{it.name==’reisling’}</code>. The <code class="cf">V</code> property is the list of all nodes, from which we’re culling a sublist. But when we want the vertex itself, we need to call <code class="cf">next</code>.  This method retrieves the first vertex from the pipeline.  It’s akin to the difference between an array of one element and the element itself.
      </p>
<p id="N187C4" class="calibre5">
        If you look at the class constructed by calling the filter’s <code class="cf">class</code> property, notice it returns <code class="cf">GremlinPipeline</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='Prancing Wolf Winery'}.class​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;class com.tinkerpop.gremlin.pipes.GremlinPipeline​</code>​</div>
</td>
</tr>
</table>
<p id="N187DB" class="calibre5">
        Compare that to the class of the next node from the pipeline.  It returns something else, the <code class="cf">Neo4jVertex</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.filter{it.name=='Prancing Wolf Winery'}.next().class​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;class com.tinkerpop.blueprints.pgm.impls.neo4j.Neo4jVertex​</code>​</div>
</td>
</tr>
</table>
<p id="N187F2" class="calibre5">
        Although the console conveniently lists the nodes retrieved from the pipeline, it remains a pipeline until you retrieve something from it.
      </p>
<h3 id="sec.schemaless" class="calibre20">Schemaless Social</h3>
<p id="N187FA" class="calibre5">
        Creating a social aspect to the graph is as easy as adding more nodes. Suppose we want to add three people—two who know each other and one stranger, each with their own wine preferences.
      </p>
<p id="N18802" class="calibre5">
        Alice has a bit of a sweet tooth and so is a big ice wine fan.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice = g.addVertex([name:'Alice'])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ice_wine = g.V.filter{it.name=='Prancing Wolf Ice Wine 2007'}.next()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.addEdge(alice, ice_wine, 'likes')​</code>​</div>
</td>
</tr>
</table>
<p id="N18816" class="calibre5">
        Tom loves Kabinett and ice wine and trusts anything written by <span class="calibre6">Wine Expert Monthly</span>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​tom = g.addVertex([name:'Tom'])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​kabinett = g.V.filter{it.name=='Prancing Wolf Kabinett 2002'}.next()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.addEdge(tom, kabinett, 'likes')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.addEdge(tom, ice_wine, 'likes')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.addEdge(tom, g.V.filter{it.name=='Wine Expert Monthly'}.next(), 'trusts')​</code>​</div>
</td>
</tr>
</table>
<p id="N18833" class="calibre5">
        Patty is friends with both Tom and Alice but is new to wine and has yet to choose any favorites.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​patty = g.addVertex([name:'Patty'])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.addEdge(patty, tom, 'friends')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.addEdge(patty, alice, 'friends')​</code>​</div>
</td>
</tr>
</table>
<p id="N18847" class="calibre5">
        Without changing any fundamental structure of our existing graph, we were able to superimpose behavior beyond our original intent.  The new nodes are related, as visualized in the following:
   </p>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/neo4j-wa-graph4.png" alt="images/neo4j-wa-graph4.png" class="calibre27"/>
</div>
<h3 id="sec.steppingStones" class="calibre20">Stepping Stones</h3>
<p id="N1886C" class="calibre5">
      We’ve looked at a few core Gremlin <span class="calibre6">steps</span>, or Pipe-processing units. Gremlin provides many more. Let’s take a look at more of these building blocks that not only walk the graph but also transform objects, filter steps, and produce side effects like counting nodes grouped by criteria.
      </p>
<p id="N18881" class="calibre5">
      We’ve seen <code class="cf">inE</code>, <code class="cf">outE</code>, <code class="cf">inV</code>, and <code class="cf">outV</code>, which are <span class="calibre6">transform steps</span> for retrieving the incoming and outgoing edges and vertices. Two other types are <code class="cf">bothE</code> and <code class="cf">bothV</code>, which just follow an edge, regardless of whether it is directed <span class="calibre6">in</span> or <span class="calibre6">out</span>.
      </p>
<p id="N1889F" class="calibre5">
      This retrieves both Alice and all of her friends. We’ll tack <code class="cf">name</code> to the end to get each vertice’s <code class="cf">name</code> property. Since we don’t care which direction the <code class="cf">friend</code> edge goes, we’ll use <code class="cf">bothE</code> and <code class="cf">bothV</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.name​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Alice​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Patty​</code>​</div>
</td>
</tr>
</table>
<p id="N188CA" class="calibre5">
      If we don’t want Alice, the <code class="cf">except</code> filter lets us pass in a list of nodes we don’t want, and it walks the rest.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.except([alice]).name​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Patty​</code>​</div>
</td>
</tr>
</table>
<p id="N188E6" class="calibre5">
      The opposite of <code class="cf">except</code> is <code class="cf">retain</code>, which, as you may have guessed,  walks only matching nodes.
      </p>
<p id="N188EF" class="calibre5">
      Another option is to instead filter the last vertex with a code block, where the current step is not equal to the <code class="cf">alice</code> vertex.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.filter{!it.equals(alice)}.name​</code>​</div>
</td>
</tr>
</table>
<p id="N18900" class="calibre5">
      What if you wanted to know friends of Alice’s friends? You could just repeat the steps like so:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.except([alice]).​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bothE('friends').bothV.except([alice])​</code>​</div>
</td>
</tr>
</table>
<p id="N18911" class="calibre5">
        In the same fashion, we could get friends of Alice’s friends’ friends by adding more <code class="cf">bothE</code>/<code class="cf">bothV</code>/<code class="cf">except</code> calls to the chain.  But that’s a lot of typing, and it’s not possible to write this for a variable number of steps in this manner. The <code class="cf">loop</code> method does just that. It repeats some number of previous steps and continues while the given closure is still true.
      </p>
<p id="N18920" class="calibre5">
        The following code will loop the previous three steps by counting periods back from the loop call.  So, <code class="cf">except</code> is one, <code class="cf">bothV</code> is two, and <code class="cf">bothE</code> is three.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.except([alice]).loop(3){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt;= 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.name​</code>​</div>
</td>
</tr>
</table>
<p id="N1893D" class="calibre5">
        After each time through the looped series of steps, <code class="cf">loop</code> invokes the given in the closure—that is, the code between the <code class="cf">{...}</code> brackets.  In here, the <code class="cf">it.loops</code> property keeps track of how many times the current loop has been executed.  In our case, we check and return whether this number is less than or equal to 2, meaning the loop will execute two times and stop.  In effect, the closure is very much like the clause for a <code class="cf">while</code> loop in a typical programming language.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Tom​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Patty​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Patty​</code>​</div>
</td>
</tr>
</table>
<p id="N1895D" class="calibre5">
      The loop worked, correctly finding both Tom and Patty.  But now we have two copies of Patty. That’s because one matches Patty as a friend of Alice, and the other matches because she is friends with Tom. So, now we need a way to filter out duplicate objects, which the <code class="cf">dedup</code> (de-duplicate) filter provides.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.except([alice]).loop(3){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt;= 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.dedup.name​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Tom​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt;Patty​</code>​</div>
</td>
</tr>
</table>
<p id="N1898E" class="calibre5">
        To get more insight into the path taken to arrive at these values, you can follow the friend-&gt;friend path by using the <code class="cf">paths</code> transform.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​alice.bothE('friends').bothV.except([alice]).loop(3){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  it.loops &lt;= 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}.dedup.name.paths​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [v[7], e[12][9-friends-&gt;7], v[9], e[11][9-friends-&gt;8], v[8], Tom]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [v[7], e[12][9-friends-&gt;7], v[9], e[11][9-friends-&gt;8], v[9], Patty]​</code>​</div>
</td>
</tr>
</table>
<p id="N189B3" class="calibre5">
        All traversals you’ve done so far have been to walk forward through a graph. Sometimes you need to take two steps forward and two steps back. Starting with the Alice node, we walk out two steps and then back two, which returns us to the Alice node.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; alice.outE.inV.back(2).name​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Alice​</code>​</div>
</td>
</tr>
</table>
<p id="N189C4" class="calibre5">
        The last commonly used step we’ll investigate is <code class="cf">groupCount</code>, which walks through the nodes and counts duplicate values, capturing them in a map.
      </p>
<p id="N189CA" class="calibre5">
        Consider this example that collects all the <code class="cf">name</code> properties of all vertices in the graph and counts how many of each there are:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; name_map = [:]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.name.groupCount( name_map )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; name_map​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Ice Wine 2007=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Wine Expert Monthly=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; riesling=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Winery=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Kabinett 2002=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Spatlese 2007=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Alice=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Tom=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Patty=1​</code>​</div>
</td>
</tr>
</table>
<p id="N189FC" class="calibre5">
        In Groovy/Gremlin, a map is denoted by the nomenclature <code class="cf">[:]</code> and is pretty much identical to the Ruby/JavaScript object literal <code class="cf">{}</code>.  Notice how all of the values are <code class="cf">1</code>.  This is exactly what we’d expect, since we haven’t repeated any names, and the <code class="cf">V</code> collection has exactly one copy of each node in our graph.
      </p>
<p id="N18A0B" class="calibre5">
        Next, let’s count up the number of wines liked by each person in our system. We can get all of the liked vertices and count up the numbers per name.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; wines_count = [:]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.outE('likes').outV.name.groupCount( wines_count )​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; wines_count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Alice=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Tom=2​</code>​</div>
</td>
</tr>
</table>
<p id="N18A25" class="calibre5">
        As we should expect, Alice liked one wine, and Tom liked two.
      </p>
<h4 id="sec.mapreduceinGroovy" class="calibre21">Getting Groovy</h4>
<p id="N18A2D" class="calibre5">
            Besides the Gremlin steps, we also get the wide array of Groovy language constructs and methods. Groovy has a map function (a la mapreduce) named <code class="cf">collect</code> and a reduce function named <code class="cf">inject</code>. Using these, we can preform mapreduce-like queries.
          </p>
<p id="N18A60" class="calibre5">
            Consider the case where we want to count how many wines have not yet been rated.  We can do this by first mapping out a list of true/false values indicating whether each wine has been rated.  Then, we can run that list through a reducer to count up all the trues and falses.  The mapping part uses <code class="cf">collect</code> and looks like this:
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​rated_list = g.V.in('grape_type').collect{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  !it.inE('reported_on').toList().isEmpty()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18A77" class="calibre5">
            In the previous code, the expression <code class="cf">g.V.in(’grape_type’)</code> returns all the nodes that have an incoming <code class="cf">grape_type</code> relationship.  Only wines will have this type of edge, so we have our list of all wines in the system.  Next, in the <code class="cf">collect</code>closure, we determine whether the wine in question has any incoming <code class="cf">reported_on</code> edges.  The <code class="cf">toList</code> call forces the pipeline to become a true list, which we can then test for emptiness.  The <code class="cf">rated_list</code> produced by this code will be a list of true and false values.
          </p>
<p id="N18A8E" class="calibre5">
            To count how many wines have not been rated, we can run that list through a reducer using the <code class="cf">inject</code> method.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​rated_list.inject(0){ count, is_rated -&gt;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  if (is_rated) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  } else {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    count + 1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18AB1" class="calibre5">
            In Groovy, the arrow operator (<code class="cf">-&gt;</code>) separates the input arguments for a closure from the body of the closure. In our reducer, we need to keep track of the accumulated count and process whether the current wine has been rated or not, which is the reason for <code class="cf">count</code> and <code class="cf">is_rated</code>. The <code class="cf">0</code> part of <code class="cf">inject(0)</code> initialized <code class="cf">count</code> to 0 before the first invocation. Then, within the body of the closure function, we either return the current count if the wine has already been rated or return that value plus 1 if it hasn’t been rated.  The final output will be the number of false values in the list (that is, the count of unrated wines).
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; 2​</code>​</div>
</td>
</tr>
</table>
<p id="N18ADC" class="calibre5">
            So, it turns out that two of our wines are as yet unrated.
          </p>
<p id="N18ADF" class="calibre5">
            With all these tools available, you can craft many powerful combinations of graph traversals and transformations. Suppose we want to find all of the pairs of friends in our graph. To do that, first we need to find all edges with a <code class="cf">friends</code> type and then output the names of both people who share that edge by using the <code class="cf">transform</code> operation.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.V.outE('friends').transform{[it.outV.name.next(), it.inV.name.next()]}​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [Patty, Tom]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [Patty, Alice]​</code>​</div>
</td>
</tr>
</table>
<p id="N18B01" class="calibre5">
            In the previous code, the return value of the <code class="cf">transform</code> closure is an array literal (<code class="cf">[...]</code>) with two elements: the output and input vertices to the <code class="cf">friend</code> edge.
          </p>
<p id="N18B0D" class="calibre5">
            To find all people and the wines they like, we transform our output of people (identified as vertices with friends) into a list with two elements: the name of the person and a list of wines they like.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.V.both('friends').dedup.transform{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [ it.name, it.out('likes').name.toList() ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [Alice, [Prancing Wolf Ice Wine 2007]]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [Patty, []]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; [Tom, [Prancing Wolf Ice Wine 2007, Prancing Wolf Kabinett 2002]]​</code>​</div>
</td>
</tr>
</table>
<p id="N18B35" class="calibre5">
            Gremlin definitely takes a little getting used to, especially if you haven’t done much Groovy programming before. Once you get the hang of it, you’ll find it’s an expressive and powerful way to perform queries against Neo4j.
            </p>
<h3 id="sec.domainSpecificSteps" class="calibre20">Domain-Specific Steps</h3>
<p id="N18B43" class="calibre5">
        Graph traversal is nice, but businesses and organizations tend to converse in domain-specific languages. For example, we wouldn’t normally ask “What is the vertex with the incoming edge of grape_type sharing the outgoing edge of this wine’s vertex?” but rather “What varietal is this wine?”
      </p>
<p id="N18B55" class="calibre5">
        Gremlin is already a language specific to the domain of querying graph databases, but what about making the language even more specific? Gremlin lets us do this by creating new steps that are semantically meaningful to the data stored in the graph.
      </p>
<p id="N18B58" class="calibre5">
        Let’s start by creating a new step named <code class="cf">varietal</code> that seeks to answer the question posed before. When <code class="cf">varietal</code> is called on a vertex, it will look for outgoing edges of type <code class="cf">grape_type</code> and step to those related vertices. 
      </p>
<p id="N18B64" class="calibre5">
        We’re getting into a bit of Groovy-foo here, so we’ll first look at our code to create the step and then describe it line by line.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/neo4j/varietal.groovy">neo4j/varietal.groovy</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Gremlin.defineStep( <em class="string">'varietal'</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [Vertex, <strong class="prompt">Pipe</strong>],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  {_().out(<em class="string">'grape_type'</em>).dedup}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​)​</code>​</div>
</td>
</tr>
</table>
<p id="N18B86" class="calibre5">
      First we tell the Gremlin engine we’re adding a new step called <code class="cf">varietal</code>. The second line tells Gremlin that this new step should attach to both <code class="cf">Vertex</code> and <code class="cf">Pipe</code> classes (when in double, just use both). The last line is where the magic happens. Effectively, this creates a closure that contains the code this step should execute.  The underscore and parentheses represent the current pipeline object. From this object, we walk to any neighbor nodes related by a <code class="cf">grape_type</code> edge—that is, the varietal node. We end with <code class="cf">dedup</code> to remove any possible duplicates.
      </p>
<p id="N18B98" class="calibre5">
        Calling our new step is just like any other step. For example, the following gets the name of the ice wine’s varietal:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.V.filter{it.name=='Prancing Wolf Ice Wine 2007'}.varietal.name​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; riesling​</code>​</div>
</td>
</tr>
</table>
<p id="N18BB1" class="calibre5">
        Let’s try another one. This time we’re making a step for a commonly requested action: get all friends’ favorite wines.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/neo4j/friendsuggest.groovy">neo4j/friendsuggest.groovy</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Gremlin.defineStep( <em class="string">'friendsuggest'</em>,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [Vertex, <strong class="prompt">Pipe</strong>],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    _().sideEffect{start = it}.both(<em class="string">'friends'</em>).​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    except([start]).out(<em class="string">'likes'</em>).dedup​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​)​</code>​</div>
</td>
</tr>
</table>
<p id="N18BDF" class="calibre5">
      Just like last time, we give Gremlin our new <code class="cf">friendsuggest</code> step name and bind it to <code class="cf">Vertex</code> and <code class="cf">Pipe</code>. This time, our code will filter out the current person. We do that by setting the current vertex/pipe to a variable (start) by using the <code class="cf">sideEffect{start = it}</code> function. Then we get all <code class="cf">friends</code> nodes, except for the current person (we don’t want to list Alice as her own friend).
      </p>
<p id="N18BF1" class="calibre5">
        Now we’re cooking with pipes!  We can call this new step as we normally would.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.V.filter{it.name=='Patty'}.friendsuggest.name​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Ice Wine 2007​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Prancing Wolf Kabinett 2002​</code>​</div>
</td>
</tr>
</table>
<p id="N18C0D" class="calibre5">
        Since <code class="cf">varietal</code> and <code class="cf">friendsuggest</code> are just normal <code class="cf">Pipe</code>-building steps, you can chain them together to make more interesting queries. The following finds the varietals that Patty’s friends like best:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.V.filter{it.name=='Patty'}.friendsuggest.varietal.name​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; riesling​</code>​</div>
</td>
</tr>
</table>
<p id="N18C2F" class="calibre5">
        Using Groovy metaprogramming to create new steps is a powerful force for crafting domain-specific languages.  But like Gremlin itself, the practice can take some getting used to.
      </p>
<h3 id="sec.updateDeleteDone" class="calibre20">Update, Delete, Done</h3>
<p id="N18C37" class="calibre5">
        You’ve inserted and stepped through a graph, but what about updating and deleting data? It’s easy enough, once you find the vertex or edge you want to alter. Let’s add a weight to how much Alice likes the Prancing Wolf Ice Wine 2007.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; e=g.V.filter{it.name=='Alice'}.outE('likes').next()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; e.weight = 95​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; e.save​</code>​</div>
</td>
</tr>
</table>
<p id="N18C55" class="calibre5">
        We can remove the value just as easily.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; e.removeProperty('weight')​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; e.save​</code>​</div>
</td>
</tr>
</table>
<p id="N18C66" class="calibre5">
        Before we call it a day and go into some homework, we should cover how to clean up our database.
      </p>
<p id="N18C69" class="calibre5">
<span class="calibre6">Don’t run these commands until you’ve finished the homework for the day!</span>
</p>
<p id="N18C6D" class="calibre5">
      The graph object has functions to remove vertices and edges, <code class="cf">removeVertex</code> and <code class="cf">removeEdge</code>, respectively. We could destroy our graph by removing all vertices and edges.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.each{ g.removeVertex(it) }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.E.each{ g.removeEdge(it) }​</code>​</div>
</td>
</tr>
</table>
<p id="N18C84" class="calibre5">
      You can validate they are gone by calling <code class="cf">g.V</code> and <code class="cf">g.E</code>. Or you can achieve the same thing with the ridiculously dangerous <code class="cf">clear</code> method.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.clear()​</code>​</div>
</td>
</tr>
</table>
<p id="N18C9B" class="calibre5">
      If you’re running your own Gremlin instance (outside of the web interface), it’s a good idea to cleanly shut down the graph connection with the <code class="cf">shutdown</code> method.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.shutdown()​</code>​</div>
</td>
</tr>
</table>
<p id="N18CAC" class="calibre5">
      If you don’t, it may corrupt the database. But usually it will just yell at you the next time you connect to the graph.
      </p>
<h3 class="calibre20">Day 1 Wrap-Up</h3>
<p id="N18CB3" class="calibre5">
        Today we got to peek at the graph database Neo4j—and what a different beast it is. Although we didn’t cover specific design patterns, our brains were buzzing with possibilities when we first began working with Neo4j. If you can draw it on a whiteboard, you can store it in a graph database.
      </p>
<h4 class="calibre21">Day 1 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N18CC1" class="calibre5">Bookmark the Neo4j wiki.</p>
</li>
<li class="calibre23">
<p id="N18CC5" class="calibre5">Bookmark the Gremlin steps from the wiki or API.</p>
</li>
<li class="calibre23">
<p id="N18CC9" class="calibre5">Find two other Neo4j shells (such as the Cypher shell in the admin console).</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N18CD5" class="calibre5">Query all node names with another shell (such as the Cypher query language).</p>
</li>
<li class="calibre23">
<p id="N18CDB" class="calibre5">Delete all the nodes and edges in your database.</p>
</li>
<li class="calibre23">
<p id="N18CDF" class="calibre5">Create a new graph that represents your family.</p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

