---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0053.html
next: f_0055.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N197CA" class="calibre18">8.2 Day 1: CRUD and Datatypes</h2>
<p id="N197CE" class="calibre5">
      Since the command-line interface (CLI) is of such primary importance to the Redis development team—and loved by users everywhere—we’re going to spend Day 1 looking at many of the 124 commands available. Of primary importance is its sophisticated datatypes and how they can query in more ways than simply “retrieve the value of this key.”
    </p>
<h3 id="sec.gettingStarted" class="calibre20">Getting Started</h3>
<p id="N197E0" class="calibre5">
        Redis is available through a few package builders like Homebrew for Mac but is also rather painless to build.<a id="FNPTR-53" href="f_0057.html#FOOTNOTE-53">[53]</a> We’ll be working off version 2.4. Once you have it installed, you can start up the server by calling this:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">redis-server</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N19801" class="calibre5">
        It won’t run in the background by default, but you can make that happen by appending &amp;, or you can just open another terminal. Next run the command-line tool, which should connect to the default port 6379 automatically. 
      </p>
<p id="N19804" class="calibre5">
        After you connect, let’s try to ping the server.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">redis-cli</strong>​</code>​</div>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; PING​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​PONG​</code>​</div>
</td>
</tr>
</table>
<p id="N19828" class="calibre5">
        If you cannot connect, you’ll receive an error message. Typing <code class="cf1">help</code> will display a list of help options. Type <code class="cf1">help</code> followed by a space and then start typing any command. If you don’t know any Redis commands, just start pressing Tab to cycle through your options.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; help​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Type: "help @&lt;group&gt;" to get a list of commands in &lt;group&gt;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "help &lt;command&gt;" for help on &lt;command&gt;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "help &lt;tab&gt;" to get a list of possible help topics​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      "quit" to exit​</code>​</div>
</td>
</tr>
</table>
<p id="N19849" class="calibre5">
      Today we’re going to use Redis to build the back end for a URL shortener, like tinyurl.com or bit.ly. A URL shortener is a service that takes a really long URL and maps it to a shorter version on their own domain—like mapping <code class="cf">http://www.myveryververylongdomain.com/somelongpath.php</code> to <code class="cf">http://bit.ly/VLD</code>.  Visiting that short URL redirects users to the longer mapped URL, saves the visitors from text messaging long strings, and also provides the short URL creator some statistics like a count of visits.
      </p>
<p id="N19861" class="calibre5">
      In Redis we can use <code class="cf">SET</code> to key a short code like <code class="cf">7wks</code> to a value like <code class="cf">http://www.sevenweeks.org</code>. <code class="cf">SET</code> always requires two parameters, a key and a value. Retrieving the value just needs <code class="cf">GET</code> and the key name.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SET 7wks http://www.sevenweeks.org/​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; GET 7wks​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"http://www.sevenweeks.org/"​</code>​</div>
</td>
</tr>
</table>
<p id="N19897" class="calibre5">
        To reduce traffic, we can also set multiple values with <code class="cf">MSET</code>, like any number of key-value pairs. Here we map Google.com to <code class="cf">gog</code> and Yahoo.com to <code class="cf">yah</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; MSET gog http://www.google.com yah http://www.yahoo.com​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
</table>
<p id="N198B2" class="calibre5">
        Correlatively, <code class="cf">MGET</code> grabs multiple keys and returns values as an ordered list.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; MGET gog yah​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "http://www.google.com/"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "http://www.yahoo.com/"​</code>​</div>
</td>
</tr>
</table>
<p id="N198D9" class="calibre5">
        Although Redis stores strings, it recognizes integers and provides some simple operations for them. If we want to keep a running total of how many short keys are in our dataset, we can create a count and then increment it with the <code class="cf">INCR</code> command.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SET count 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; INCR count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 3​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; GET count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"3"​</code>​</div>
</td>
</tr>
</table>
<p id="N19913" class="calibre5">
        Although <code class="cf">GET</code> returns <code class="cf">count</code> as a string, <code class="cf">INCR</code> recognized it as an integer and added one to it. Any attempt to increment a noninteger ends poorly.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SET bad_count "a"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; INCR bad_count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(error) ERR value is not an integer or out of range​</code>​</div>
</td>
</tr>
</table>
<p id="N1994C" class="calibre5">
        If the value can’t be resolved to an integer, Redis rightly complains. You can also increment by any integer (<code class="cf">INCRBY</code>) or decrement (<code class="cf">DECR</code>, <code class="cf">DECRBY</code>).
      </p>
<h3 id="sec.redis.transactions" class="calibre20">Transactions</h3>
<p id="N19963" class="calibre5">
        We’ve seen transactions in previous databases (Postgres and Neo4j), and Redis’ <code class="cf">MULTI</code> block atomic commands are a similar concept. Wrapping two operations like <code class="cf">SET</code> and <code class="cf">INCR</code> in a single block will complete  either successfully or not at all. But you will never end up with a partial operation.
      </p>
<p id="N1997E" class="calibre5">
        Let’s key another short code to a URL and also increment the count all in one transaction. We begin the transaction with the <code class="cf">MULTI</code> command and execute it with <code class="cf">EXEC</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; MULTI​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SET prag http://pragprog.com​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​QUEUED​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; INCR count​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​QUEUED​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; EXEC​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) (integer) 2​</code>​</div>
</td>
</tr>
</table>
<p id="N199AB" class="calibre5">
        When using <code class="cf">MULTI</code>, the commands aren’t actually executed when we define them (similar to Postgres transactions). Instead, they are queued and then executed in sequence.
      </p>
<p id="N199B1" class="calibre5">
        Similar to <code class="cf">ROLLBACK</code> in SQL, you can stop a transaction with the <code class="cf">DISCARD</code> command, which will clear the transaction queue. Unlike <code class="cf">ROLLBACK</code>, it won’t revert the database; it will simply not run the transaction at all. The effect is identical, although the underlying concept is a different mechanism (transaction rollback vs. operation cancellation).
      </p>
<h3 id="sec.complexDatatypes" class="calibre20">Complex Datatypes</h3>
<p id="N199DF" class="calibre5">
        So far, we haven’t seen much complex behavior. Storing string and integer values under keys—even as transactions—is all fine and good, but most programming and data storage problems deal with many types of data. Storing lists, hashes, sets, and sorted sets natively helps explain Redis’ popularity, and after exploring the complex operations you can enact on them, you may find you agree.
      </p>
<p id="N199EE" class="calibre5">
        These collection datatypes can contain a huge number of values (up to 2^32 elements or more than 4 billion) per key. That’s more than enough for all Facebook accounts to live as a list under a single key.
      </p>
<p id="N199F1" class="calibre5">
        While some Redis commands may appear cryptic, they generally follow a good pattern. <code class="cf">SET</code> commands begin with <code class="cf">S</code>, hashes with <code class="cf">H</code>, and sorted sets with <code class="cf">Z</code>. List commands generally start with either an <code class="cf">L</code> (for left) or an <code class="cf">R</code> (for right), depending on the direction of the operation (such as <code class="cf">LPUSH</code>).
      </p>
<h4 id="sec.hash" class="calibre21">Hash</h4>
<p id="N19A0E" class="calibre5">
          Hashes are like nested Redis objects that can take any number of key-value pairs. Let’s use a hash to keep track of users who sign up for our URL-shortening service.
        </p>
<p id="N19A11" class="calibre5">
          Hashes are nice because they help you avoid storing data with artificial key prefixes.
          
          (Note that we used colons [:] within our key. This is a valid character that often logically separates a key into segments. It’s merely a matter of convention, with no deeper meaning in Redis.)
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; MSET user:eric:name "Eric Redmond" user:eric:password s3cret​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; MGET user:eric:name user:eric:password​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "Eric Redmond"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "s3cret"​</code>​</div>
</td>
</tr>
</table>
<p id="N19A2B" class="calibre5">
          Instead of separate keys, we can create a hash that contains its own key-value pairs.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; HMSET user:eric name "Eric Redmond" password s3cret​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
</table>
<p id="N19A3C" class="calibre5">
          We need only keep track of the single Redis key to retrieve all values of the hash.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; HVALS user:eric​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "Eric Redmond"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "s3cret"​</code>​</div>
</td>
</tr>
</table>
<p id="N19A50" class="calibre5">
          Or we can retrieve all hash keys.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; HKEYS user:eric​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "name"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "password"​</code>​</div>
</td>
</tr>
</table>
<p id="N19A64" class="calibre5">
          Or we can get a single value, by passing in the Redis key, followed by the hash key. Here we get just the password.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; HGET user:eric password​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"s3cret"​</code>​</div>
</td>
</tr>
</table>
<p id="N19A75" class="calibre5">
          Unlike the document datastores Mongo and CouchDB, hashes in Redis cannot nest (nor can any other complex datatype such as lists). In other words, hashes can store only  string values.
        </p>
<p id="N19A78" class="calibre5">
          More commands exist to delete hash fields (<code class="cf">HDEL</code>), increment an integer field value by some count (<code class="cf">HINCRBY</code>), or retrieve the number of fields in a hash (<code class="cf">HLEN</code>).
        </p>
<h4 id="sec.list" class="calibre21">List</h4>
<p id="N19A89" class="calibre5">
          Lists contain multiple ordered values that can act both as queues (first value in, first value out) and as stacks (last value in, first value out). They also have more sophisticated actions for inserting somewhere in the middle of a list, constraining list size, and moving values between lists.
        </p>
<p id="N19A92" class="calibre5">
          Since our URL-shortening service can now track users, we want to allow them to keep a wishlist of URLs they’d like to visit. To create a list of short-coded websites we’d like to visit, we set the key to <code class="cf">USERNAME:wishlist</code> and push any number of values to the right (end) of the list.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; RPUSH eric:wishlist 7wks gog prag​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 3​</code>​</div>
</td>
</tr>
</table>
<p id="N19AA7" class="calibre5">
          Like most collection value insertions, the Redis command returns the number of values pushed. In other words, we pushed three values into the list so it returns 3. You can get the list length at any time with <code class="cf">LLEN</code>.
        </p>
<p id="N19AAD" class="calibre5">
          Using the list range command <code class="cf">LRANGE</code>, we can retrieve any part of the list by specifying the first and last positions. All list operations in Redis use a zero-based index. A negative position means the number of steps from the end.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; LRANGE eric:wishlist 0 -1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "7wks"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "gog"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​3) "prag"​</code>​</div>
</td>
</tr>
</table>
<p id="N19AC8" class="calibre5">
          LREM removes from the given key some matching values. It also requires a number to know how many matches to remove. Setting the count  to 0 as we do here just removes them all:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; LREM eric:wishlist 0 gog​</code>​</div>
</td>
</tr>
</table>
<p id="N19AD7" class="calibre5">
          Setting the count greater than 0 will remove only that number of matches, and setting the count to a negative number will remove that number of matches but scan the list from the end (right side).
        </p>
<p id="N19ADA" class="calibre5">
          To remove and retrieve each value in the order we added them (like a queue), we can pop them off from the left (head) of the list.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; LPOP eric:wishlist​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"7wks"​</code>​</div>
</td>
</tr>
</table>
<p id="N19AEC" class="calibre5">
          To act as a stack, after you <code class="cf">RPUSH</code> the values, you would <code class="cf">RPOP</code> from the end of the list. All of these operations are performed in constant time.
        </p>
<p id="N19AF5" class="calibre5">
          On the previous combination of commands, you can use <code class="cf">LPUSH</code> and <code class="cf">RPOP</code> to similar effect (a queue) or <code class="cf">LPUSH</code> and <code class="cf">LPOP</code> to be a stack.
        </p>
<p id="N19B04" class="calibre5">
          Suppose we wanted to remove values from our wishlist and move them to another list of visited sites. To execute this move atomically, we could wrap pop and push actions within a multiblock. In Ruby these steps might look something like this (you can’t use the CLI here because you must save the popped value, so we used the <code class="cf">redis-rb</code> gem):
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis.multi <strong class="prompt">do</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  site = redis.rpop(<em class="string">'eric:wishlist'</em>)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  redis.lpush(<em class="string">'eric:visited'</em>, site)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">end</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N19B28" class="calibre5">
          But Redis provides a single command for popping values from the tail of one list and pushing to the head of another. It’s called <code class="cf">RPOPLPUSH</code> (right pop, left push). 
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; RPOPLPUSH eric:wishlist eric:visited​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"prag"​</code>​</div>
</td>
</tr>
</table>
<p id="N19B3D" class="calibre5">
          If you find the range of the wishlist, <code class="cf">prag</code> will be gone; it now lives under <code class="cf">visited</code>. This is a useful mechanism for queuing commands.
        </p>
<p id="N19B46" class="calibre5">
          If you looked through the Redis docs to find <code class="cf">RPOPRPUSH</code>, <code class="cf">LPOPLPUSH</code>, and <code class="cf">LPOPRPUSH</code> commands, you may be dismayed to learn they don’t exist. <code class="cf">RPOPLPUSH</code> is your only option, and you must build your list accordingly.
          </p>
<p class="calibre5">
<strong id="sec.blockingLists" class="calibre32">Blocking Lists</strong>
</p>
<p id="N19B63" class="calibre5">
            Now that our URL shortener is taking off, let’s add some social activities—like a real-time commenting system—where people can post about the websites they have visited.
          </p>
<p id="N19B70" class="calibre5">
            Let’s write a simple messaging system where multiple clients can push comments and one client (the digester) pops messages from the queue. We’d like the digester to just listen for new comments and pop them as they arrive. Redis provides a few blocking commands for this sort of purpose.
          </p>
<p id="N19B73" class="calibre5">
            First open another terminal and start another <code class="cf">redis-cli</code> client. This will be our digester. The command to block until a value exists to pop is <code class="cf">BRPOP</code>. It requires the key to pop a value from and a timeout in seconds, which we’ll set to five minutes.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; BRPOP comments 300​</code>​</div>
</td>
</tr>
</table>
<p id="N19B88" class="calibre5">
            Then switch back to the first console and push a message to comments.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; LPUSH comments "Prag is great! I buy all my books there."​</code>​</div>
</td>
</tr>
</table>
<p id="N19B97" class="calibre5">
            If you switch back to the digester console, two lines will be returned: the key and the popped value. The console will also output the length of time it spent blocking.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "comments"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "Prag is great! I buy all my books there."​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(50.22s)​</code>​</div>
</td>
</tr>
</table>
<p id="N19BAC" class="calibre5">
            There’s also a blocking version of left pop (<code class="cf">BLPOP</code>) and right pop, left push (<code class="cf">BRPOPLPUSH</code>).
          </p>
<h4 id="sec.set" class="calibre21">Set</h4>
<p id="N19BBA" class="calibre5">
          Our URL shortener is shaping up nicely, but it would be nice to group common URLs in some way.
        </p>
<p id="N19BBD" class="calibre5">
          Sets are unordered collections with no duplicate values and are an excellent choice for performing complex operations between two or more key values, such as unions or intersections.
        </p>
<p id="N19BC5" class="calibre5">
          If we wanted to categorize sets of URLs with a common key, we can add multiple values with <code class="cf">SADD</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SADD news nytimes.com pragprog.com​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 2​</code>​</div>
</td>
</tr>
</table>
<p id="N19BDA" class="calibre5">
          Redis added two values.  We can retrieve the full set, in no particular order, via <code class="cf">SMEMBERS</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SMEMBERS news​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "pragprog.com"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "nytimes.com"​</code>​</div>
</td>
</tr>
</table>
<p id="N19BF2" class="calibre5">
          Let’s add another category called <span class="calibre6">tech</span> for technology-related sites.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SADD tech pragprog.com apple.com​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 2​</code>​</div>
</td>
</tr>
</table>
<p id="N19C07" class="calibre5">
          To find the intersection of websites that both provide news and are technology focused, we use the <code class="cf">SINTER</code> command.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SINTER news tech​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "pragprog.com"​</code>​</div>
</td>
</tr>
</table>
<p id="N19C2B" class="calibre5">
          Just as easily, we can remove any matching values in one set from another. To find all news sites that are not tech sites, use <code class="cf">SDIFF</code>:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SDIFF news tech​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "nytimes.com"​</code>​</div>
</td>
</tr>
</table>
<p id="N19C4F" class="calibre5">
          We can also build a union of websites that are either news or tech. Since it’s a set, any duplicates are dropped.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SUNION news tech​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "apple.com"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "pragprog.com"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​3) "nytimes.com"​</code>​</div>
</td>
</tr>
</table>
<p id="N19C67" class="calibre5">
          That set of values can also be stored directly into a new set (<code class="cf">SUNIONSTORE destination key [key …]</code>).
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SUNIONSTORE websites news tech​</code>​</div>
</td>
</tr>
</table>
<p id="N19C78" class="calibre5">
          This also provides a useful trick for cloning a single key’s values to another key, such as <code class="cf">SUNIONSTORE news_copy news</code>. Similar commands exist for storing intersections (<code class="cf">SINTERSTORE</code>) and diffs (<code class="cf">SDIFFSTORE</code>).
        </p>
<p id="N19C84" class="calibre5">
          Just like <code class="cf">RPOPLPUSH</code> moved values from one list to another, <code class="cf">SMOVE</code> does the same for sets; it’s just easier to remember.
        </p>
<p id="N19C8D" class="calibre5">
          And like <code class="cf">LLEN</code> finds the length of a list, <code class="cf">SCARD</code> (set cardinality) counts the set; it’s just harder to remember.
        </p>
<p id="N19C96" class="calibre5">
          Since sets are not ordered, there are no left, right, or other positional commands. Popping a random value from a set just requires <code class="cf">SPOP key</code>, and removing values is <code class="cf">SREM key value [value …]</code>.
        </p>
<p id="N19C9F" class="calibre5">
          Unlike lists, there are no blocking commands for sets.
        </p>
<h4 id="sec.sortedSets" class="calibre21">Sorted Sets</h4>
<p id="N19CA7" class="calibre5">
          Whereas other Redis datatypes we’ve looked at so far easily map to common programming language constructs, sorted sets take something from each of the previous datatypes. They are ordered like lists and are unique like sets. They have field-value pairs like hashes, but rather than string fields, they are instead numeric scores that denote the order of the values. You can think of sorted sets as like a random access priority queue. This power has a trade-off, however. Internally, sorted sets keep values in order, so inserts can take log(N) time to insert (where N is the size of the set), rather than the constant time complexity of hashes or lists.
        </p>
<p id="N19CB0" class="calibre5">
          Next we want to keep track of the popularity of specific shortcodes. Every time someone visits a URL, the score gets increased. Like a hash, adding a value to a sorted set requires two values after the Redis key name: the score and the member.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZADD visits 500 7wks 9 gog 9999 prag​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 3​</code>​</div>
</td>
</tr>
</table>
<p id="N19CC2" class="calibre5">
          To increment a score, we can either re-add it with the new score, which just updates the score but does not add a new value, or increment by some number, which will return the new value.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZINCRBY visits 1 prag​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"10000"​</code>​</div>
</td>
</tr>
</table>
<p id="N19CD3" class="calibre5">
          You can decrement also by setting a negative number for <code class="cf">ZINCRBY</code>.
        </p>
<p class="calibre5">
<strong class="calibre32">Ranges</strong>
</p>
<p id="N19CDD" class="calibre5">
          To get values from our visits set, we can issue a range command, <code class="cf">ZRANGE</code>, which returns by position, just like the list datatype’s <code class="cf">LRANGE</code> command. Except in the case of a sorted set, the position is ordered by score from lowest to highest. So, to get the top two scoring visited sites (zero-based), use this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZRANGE visits 0 1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "gog"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "7wks"​</code>​</div>
</td>
</tr>
</table>
<p id="N19D1E" class="calibre5">
          To get the scores of each element as well, append <code class="cf">WITHSCORES</code> to the previous code. To get them in reverse, insert the word <code class="cf">REV</code>, as in <code class="cf">ZREVRANGE</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZREVRANGE visits 0 -1 WITHSCORES​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "prag"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "10000"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​3) "7wks"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​4) "500"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​5) "gog"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​6) "9"​</code>​</div>
</td>
</tr>
</table>
<p id="N19D47" class="calibre5">
          But if we’re using a sorted set, it’s more likely we want to range by score, rather than by position. <code class="cf">ZRANGEBYSCORE</code> has a slightly different syntax from <code class="cf">ZRANGE</code>. Since the low and high range numbers are <span class="calibre6">inclusive</span> by default, we can make a score number <span class="calibre6">exclusive</span> by prefixing it with an opening paren: <code class="cf">(</code>. So,  this will return all scores where <code class="cf">9 &lt;= score &lt;= 10,000</code>:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZRANGEBYSCORE visits 9 9999​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "gog"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "7wks"​</code>​</div>
</td>
</tr>
</table>
<p id="N19D6E" class="calibre5">
          But the following will return <code class="cf">9 &lt; score &lt;= 10,000</code>:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZRANGEBYSCORE visits (9 9999​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "7wks"​</code>​</div>
</td>
</tr>
</table>
<p id="N19D83" class="calibre5">
          We can also range by both positive and negative values, including infinities. This returns the entire set.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZRANGEBYSCORE visits -inf inf​</code>​</div>
</td>
</tr>
</table>
<p id="N19D91" class="calibre5">
          You can list them in reverse too, with <code class="cf">ZREVRANGEBYSCORE</code>.
        </p>
<p id="N19D97" class="calibre5">
          Along with retrieving a range of values by rank (index) or score, <code class="cf">ZREMRANGEBYRANK</code> and <code class="cf">ZREMRANGEBYSCORE</code>, respectively, remove values by rank or score.
          </p>
<p class="calibre5">
<strong class="calibre32">Unions</strong>
</p>
<p id="N19DB5" class="calibre5">
          Just like the set datatype, we can create a destination key that contains the union or intersection of one or more keys. This is one of the more complex commands in Redis, since it must not only join the keys—a relatively simple operation—but also merge (possibly) differing scores. The union operation looks like this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ZUNIONSTORE destination numkeys key [key ...]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]​</code>​</div>
</td>
</tr>
</table>
<p id="N19DCC" class="calibre5">
<code class="cf">destination</code> is the key to store into, and <code class="cf">key</code> is one or more keys to union. <code class="cf">numkeys</code> is simply the number of keys you’re about to join, while <code class="cf">weight</code> is the optional number to multiply each score of the relative key by (if you have two keys, you can have two weights, and so on). Finally, <code class="cf">aggregate</code> is the optional rule for resolving each weighted score and summing by default, but you can also choose the min or max between many scores.
        </p>
<p id="N19DDD" class="calibre5">
          Let’s use this command to measure the importance of a sorted set of shortcodes.
        </p>
<p id="N19DE0" class="calibre5">
          First we’ll create another key that scores our short codes by votes. Each visitor to a site can vote if they like the site or not, and each vote adds a point.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZADD votes 2 7wks 0 gog 9001 prag​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 3​</code>​</div>
</td>
</tr>
</table>
<p id="N19DF1" class="calibre5">
          We want to figure out the most important websites in our system, as some combination of votes and visits. Votes are important, but to a lesser extent, website visits also carry some weight (perhaps people are so enchanted by the website, they simply forget to vote). We want to add the two types of scores together to compute a new importance score, while giving votes a weight of double importance—multiplied by two.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ZUNIONSTORE importance 2 visits votes WEIGHTS 1 2 AGGREGATE SUM​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 3​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZRANGEBYSCORE importance -inf inf WITHSCORES​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "gog"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "9"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​3) "7wks"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​4) "504"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​5) "prag"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​6) "28002"​</code>​</div>
</td>
</tr>
</table>
<p id="N19E17" class="calibre5">
          This command is powerful in other ways too. For example, if we need to double all scores of a set, we can union a single key with a weight of 2 and store it back into itself.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZUNIONSTORE votes 1 votes WEIGHTS 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; ZRANGE votes 0 -1 WITHSCORES​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​1) "gog"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​2) "0"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​3) "7wks"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​4) "4"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​5) "prag"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​6) "18002"​</code>​</div>
</td>
</tr>
</table>
<p id="N19E3D" class="calibre5">
          Sorted sets contain a similar command (<code class="cf">ZINTERSTORE</code>)to perform intersections.</p>
<h3 id="sec.expiry" class="calibre20">Expiry</h3>
<p id="N19E50" class="calibre5">
        A common use case for a key-value system like Redis is as a fast-access cache for data that’s more expensive to retrieve or compute. Expiration helps keep the total key set from growing unbounded, by tasking Redis to delete a key-value after a certain time has passed.
      </p>
<p id="N19E65" class="calibre5">
        Marking a key for expiration requires the <code class="cf">EXPIRE</code> command, an existing key, and a time to live in seconds. Here we set a key and set it to expire in ten seconds. We can check whether the key <code class="cf">EXISTS</code> within ten seconds and it returns a 1 (true). If we wait to execute, it will eventually return a 0 (false).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SET ice "I'm melting…"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; EXPIRE ice 10​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; EXISTS ice​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; EXISTS ice​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 0​</code>​</div>
</td>
</tr>
</table>
<p id="N19E8E" class="calibre5">
        Setting and expiring keys is so common that Redis provides a shortcut command called <code class="cf">SETEX</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SETEX ice 10 "I'm melting…"​</code>​</div>
</td>
</tr>
</table>
<p id="N19EAE" class="calibre5">
        You can query the time a key has to live with <code class="cf">TTL</code>. Setting <code class="cf">ice</code> to expire as shown earlier and checking its TTL will return the number of seconds left.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; TTL ice​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 4​</code>​</div>
</td>
</tr>
</table>
<p id="N19EC5" class="calibre5">
        At any moment before the key expires, you can remove the timeout by running <code class="cf">PERSIST key</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; PERSIST ice​</code>​</div>
</td>
</tr>
</table>
<p id="N19EE0" class="calibre5">
        For marking a countdown to a specific time, <code class="cf">EXPIREAT</code> accepts a Unix timestamp (as seconds since January 1, 1970) rather than a number of seconds to count up to. In other words, <code class="cf">EXPIREAT</code> is for absolute timeouts, and <code class="cf">EXPIRE</code> is for relative timeouts.
      </p>
<p id="N19EEC" class="calibre5">
        A common trick for keeping only recently used keys is to update the expire time whenever you retrieve a value. This is the most recently used (MRU) caching algorithm to ensure your most recently used keys will remain in Redis, while the neglected keys will just expire as normal.
        </p>
<h3 id="sec.databaseNamespaces" class="calibre20">Database Namespaces</h3>
<p id="N19EFD" class="calibre5">
        So far, we’ve interacted only with a single namespace. Just like buckets in Riak, sometimes we need to separate keys by namespace. For example, if you wrote an internationalized key-value store, you could store different translated responses in different namespaces. The key <code class="cf">greeting</code> could be set to “guten tag” in a German namespace and “bonjour” in French. When a user selects their language, the application just pulls all values from the namespace assigned.
      </p>
<p id="N19F0F" class="calibre5">
        In Redis nomenclature, a namespace is called a <span class="calibre6">database</span> and is keyed by number. So far, we’ve always interacted with the default namespace 0 (also known as database 0). Here we set <code class="cf">greeting</code> to the English <code class="cf">hello</code>.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SET greeting hello​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; GET greeting​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"hello"​</code>​</div>
</td>
</tr>
</table>
<p id="N19F2F" class="calibre5">
        But if we switch to another database via the <code class="cf">SELECT</code> command, that key is unavailable.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SELECT 1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379[1]&gt; GET greeting​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(nil)​</code>​</div>
</td>
</tr>
</table>
<p id="N19F49" class="calibre5">
        And setting a value to this database’s namespace will not affect the value of the original.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379[1]&gt; SET greeting "guten tag"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379[1]&gt; SELECT 0​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; GET greeting​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"hello"​</code>​</div>
</td>
</tr>
</table>
<p id="N19F66" class="calibre5">
        Since all databases are running in the same server instance, Redis lets us shuffle keys around with the <code class="cf">MOVE</code> command. Here we move <code class="cf">greeting</code> to database 2:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; MOVE greeting 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​(integer) 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379&gt; SELECT 2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​OK​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​redis 127.0.0.1:6379[2]&gt; GET greeting​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"hello"​</code>​</div>
</td>
</tr>
</table>
<p id="N19F8A" class="calibre5">
        This can be useful for running different applications against a single Redis server but still allow these multiple applications to trade data between each other.
        </p>
<h3 id="sec.andTheresMore" class="calibre20">And There’s More</h3>
<p id="N19F98" class="calibre5">
        Redis has plenty of other commands for actions such as renaming keys (<code class="cf">RENAME</code>), determining the type of a key’s value (<code class="cf">TYPE</code>), and deleting a key-value (<code class="cf">DEL</code>). There’s also the painfully dangerous <code class="cf">FLUSHDB</code>, which removes all keys from this Redis database, and its apocalyptic cousin, <code class="cf">FLUSHALL</code>, which  removes all keys from all Redis databases. Check out the online documentation for the full list of Redis commands.
      </p>
<h3 class="calibre20">Day 1 Wrap-Up</h3>
<p id="N1A008" class="calibre5">
        The datatypes of Redis and the complex queries it can perform make it much more than a standard key-value store. It can act as a stack, queue, or priority queue; can be an object store (via hashes); and even can perform complex set operations such as unions, intersections, and subtractions (diff). It provides many atomic commands, and for those multistep commands, it provides a transaction mechanism. It has a built-in ability to expire keys, which is useful as a cache.
      </p>
<h4 class="calibre21">Day 1 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<p id="N1A013" class="calibre5">Find the complete Redis commands documentation, as well as the Big-O notated (O(x)) time complexity under the command details.</p>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N1A01D" class="calibre5">Install your favorite programming language driver and connect to the Redis server. Insert and increment a value within a transaction.</p>
</li>
<li class="calibre23">
<p id="N1A021" class="calibre5">Using your driver of choice, create a program that reads a blocking list and outputs somewhere (console, file, Socket.io, and so on) and another that writes to the same list.</p>
</li>
</ol>
<div xmlns:str="http://exslt.org/strings" class="calibre2">
<img src="images/redis-crud.png" alt="images/redis-crud.png" class="calibre27"/>
</div>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

