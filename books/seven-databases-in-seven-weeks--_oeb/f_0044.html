---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0043.html
next: f_0045.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N178AA" class="calibre18">6.4 Day 3: Advanced Views, Changes API, and Replicating Data</h2>
<p id="N178AE" class="calibre5">
      In Days 1 and 2 we learned how to perform basic CRUD operations and interact with views for finding data.  Building on this experience, today we’ll take a closer look at views, dissecting the reduce part of the mapreduce equation.  After that, we’ll develop some Node.js applications in JavaScript to leverage CouchDB’s unique Changes API.  Lastly, we’ll discuss replication and how CouchDB handles conflicting data.
    </p>
<h3 class="calibre20">Creating Advanced Views with Reducers</h3>
<p id="N178B5" class="calibre5">
        Mapreduce-based views provide the means by which we can harness CouchDB’s indexing and aggregation facilities.  In Day 2, all our views consisted of only mappers.  Now we’re going to add reducers to the mix, developing new capabilities against the Jamendo data we imported in Day 2.
      </p>
<p id="N178D2" class="calibre5">
        One great thing about the Jamendo data is its depth.  Artists have albums, which have tracks.  Tracks, in turn, have attributes including tags.  We’ll now turn our attention to tags to see whether we can write a deep inspecting view to collect and count them.
      </p>
<p id="N178D5" class="calibre5">
        First, return to the Temporary View page, and then enter the following map function:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/couchdb/tags_by_name_mapper.js">couchdb/tags_by_name_mapper.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">function</strong>(doc) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  (doc.albums || []).forEach(<strong class="prompt">function</strong>(album){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    (album.tracks || []).forEach(<strong class="prompt">function</strong>(track){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      (track.tags || []).forEach(<strong class="prompt">function</strong>(tag){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        emit(tag.idstr, 1);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      });​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    });​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  });​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17908" class="calibre5">
        This function digs into the artist document and then down into each album, each track, and finally each tag.  For each tag, it emits a key-value pair consisting of the tag’s <code class="cf">idstr</code> property (a string representation of the tag, like <code class="cf1">"rock"</code>) and the number 1.
      </p>
<p id="N17911" class="calibre5">
        With the map function in place, enter the following under Reduce Function:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/couchdb/simple_count_reducer.js">couchdb/simple_count_reducer.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">function</strong>(key, values, rereduce) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> sum(values);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1792C" class="calibre5">
        This code merely sums the numbers in the <code class="cf">values</code> list—which we’ll talk about momentarily once we’ve run the view.  Finally, click the Run button. The output should resemble the following table:
      </p>
<table class="simpletable1">
<thead class="calibre29">
<tr class="calibre8">
<th class="hlines">
<p class="last-para-in-cell">Key</p>
</th>
<th class="hlines">
<p class="last-para-in-cell">Value</p>
</th>
</tr>
</thead>
<tbody class="calibre7">
<tr class="calibre8">
<td class="calibre30">
<p class="last-para-in-cell">
<code class="cf">"17sonsrecords"</code>
</p>
</td>
<td class="calibre30">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"17sonsrecords"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"17sonsrecords"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"17sonsrecords"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"17sonsrecords"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"acid"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"acousticguitar"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"acousticguitar"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"action"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"action"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
</tbody>
</table>
<p id="N179AD" class="calibre5">
        This shouldn’t be too surprising.  The value is always <code class="cf">1</code> as we indicated in the mapper, and the Key fields exhibit as much repetition as there is in the tracks themselves.

        Notice, however, the Reduce checkbox  in the top-right corner of the output table.  Check that box, and then look at the table again.  It should now look something like this:
      </p>
<table class="simpletable1">
<thead class="calibre29">
<tr class="calibre8">
<th class="hlines">
<p class="last-para-in-cell">Key</p>
</th>
<th class="hlines">
<p class="last-para-in-cell">Value</p>
</th>
</tr>
</thead>
<tbody class="calibre7">
<tr class="calibre8">
<td class="calibre30">
<p class="last-para-in-cell">
<code class="cf">"17sonsrecords"</code>
</p>
</td>
<td class="calibre30">
<p class="last-para-in-cell">
<code class="cf">5</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"acid"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"acousticguitar"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">2</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"action"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">2</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"adventure"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">3</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"aksband"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"alternativ"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">1</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"alternativ"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">3</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"ambient"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">28</code>
</p>
</td>
</tr>
<tr class="calibre8">
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">"autodidacta"</code>
</p>
</td>
<td class="calibre31">
<p class="last-para-in-cell">
<code class="cf">17</code>
</p>
</td>
</tr>
</tbody>
</table>
<p id="N17A2E" class="calibre5">
        What happened?  In short, the reducer <span class="calibre6">reduced</span> the output by combining like mapper rows in accordance with our Reducer Function.  The CouchDB mapreduce engine works conceptually like the other mapreducers we’ve seen before (Riak’s <a href="f_0025.html#sec.introMapreduce">​<em class="calibre6">Introducing Mapreduce</em>​</a>, and MongoDB’s <a href="f_0037.html#sec.mongo.mapreduce">​<em class="calibre6">Mapreduce (and Finalize)</em>​</a>).  Specifically, here’s a high-level outline of the steps CouchDB takes to build a view:
      </p>
<ol class="calibre33">
<li class="calibre23">
<p id="N17A42" class="calibre5">Send documents off to the mapper function.</p>
</li>
<li class="calibre23">
<p id="N17A46" class="calibre5">Collect all the emitted values.</p>
</li>
<li class="calibre23">
<p id="N17A4A" class="calibre5">Sort emitted rows by their keys.</p>
</li>
<li class="calibre23">
<p id="N17A4E" class="calibre5">Send chunks of rows with the same keys to the reduce function.</p>
</li>
<li class="calibre23">
<p id="N17A52" class="calibre5">If there was too much data to handle all reductions in a single call, call the reduce function again but with previously reduced values.</p>
</li>
<li class="calibre23">
<p id="N17A56" class="calibre5">Repeat recursive calls to the reduce function as necessary until no duplicate keys remain.</p>
</li>
</ol>
<p id="N17A59" class="calibre5">
        Reduce functions in CouchDB take three arguments: <code class="cf">key</code>, <code class="cf">values</code>, and <code class="cf">rereduce</code>.  The first argument, <code class="cf">key</code>, is an array of tuples—two element arrays containing the key emitted by the mapper and the <code class="cf">_id</code> of the document that produced it.  The second argument, <code class="cf">values</code>, is an array of values corresponding to the keys.
      </p>
<p id="N17A74" class="calibre5">
        The third argument, <code class="cf">rereduce</code>, is a boolean value that will be true if this invocation is a <span class="calibre6">rereduction</span>.  That is, rather than being sent keys and values that were emitted from mapper calls, this call is sent the products of previous reducer calls.  In this case, the <code class="cf">key</code> parameter will be <code class="cf">null</code>.
        </p>
<h4 class="calibre21">Stepping Through Reducer Calls</h4>
<p id="N17A93" class="calibre5">
          Let’s work through an example based on the output we just saw. 
        </p>
<p id="N17A96" class="calibre5">
          Consider documents (artists) with tracks that have been tagged as “ambient.”  The mappers run on the documents and emit key-value pairs of the form “ambient”/1.</p>
<p id="N17A9B" class="calibre5">
          At some point, enough of these have been emitted that CouchDB invokes a reducer.  That call might look like this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​reduce(​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [[<em class="string">"ambient"</em>, id1], [<em class="string">"ambient"</em>, id2], ...],    <em class="comment">// keys are the same</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [1, 1, ...],                                  <em class="comment">// values are all 1</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  false                                         <em class="comment">// rereduce is false</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​)​</code>​</div>
</td>
</tr>
</table>
<p id="N17AC2" class="calibre5">
          Recall that in our reducer function we take the <code class="cf">sum</code> of <code class="cf">values</code>.  Since they’re all 1, the sum will simply be the length—effectively a count of how many tracks have the “ambient” tag.  CouchDB keeps this return value for later processing.  For the sake of this example, let’s call that number <code class="cf">10</code>.
        </p>
<p id="N17ACE" class="calibre5">
          Some time later, after CouchDB has run these kinds of calls several times, it decides to combine the intermediate reducer results by executing a rereduce:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​reduce(​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  null,                <em class="comment">// key array is null</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  [10, 10, 8],         <em class="comment">// values are outputs from previous reducer calls</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  true                 <em class="comment">// rereduce is true</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​)​</code>​</div>
</td>
</tr>
</table>
<p id="N17AEF" class="calibre5">
          Our reducer function again takes the <code class="cf">sum</code> of <code class="cf">values</code>.  This time, the values add up to <code class="cf">28</code>.  Rereduce calls may be recursive.  They go on as long as there is reduction to be done, until all the intermediate values have been combined into one.
        </p>
<p id="N17AFB" class="calibre5">
        Most mapreduce systems, including the ones used by other databases we’ve covered in this book like Riak and MongoDB, throw away the output of mappers and reducers after the work is done.  In those systems, mapreduce is seen as a means to an end—something to be executed whenever the need arises, each time starting from scratch.  Not so with CouchDB.
      </p>
<p id="N17B03" class="calibre5">
        Once a view is codified into a design document, CouchDB will keep the intermediate mapper and reducer values until a change to a document would invalidate the data.  At that time, CouchDB will incrementally run mappers and reducers to correct for the updated data.  It won’t start from scratch, recalculating everything each time.  This is the genius of CouchDB views.  CouchDB is able to use mapreduce as its primary indexing mechanism by not tossing away intermediate data values.
      </p>
<h3 class="calibre20">Watching CouchDB for Changes</h3>
<p id="N17B0A" class="calibre5">
        CouchDB’s incremental approach to mapreduce is an innovative feature, to be sure; it’s one of many that set CouchDB apart from other databases.  The next feature we’ll investigate is the Changes API.  This interface provides mechanisms for watching a database for changes and getting updates instantly.
      </p>
<p id="N17B1B" class="calibre5">
        The Changes API makes CouchDB a perfect candidate for a system of record.  Imagine a multidatabase system where data is streaming in from several directions and other systems need to be kept up-to-date (we’ll actually do this in the next chapter, Section 8.4, <a href="f_0056.html#sec.riak.day3">​<em class="calibre6">Day 3: Playing with Other Databases</em>​</a>).  Examples might include a search engine backed by Lucene or ElasticSeach or a caching layer implemented on memcached or Redis.  You could have different maintenance scripts kick off in response to changes too—performing tasks such as database compaction and remote backups.  In short, this simple API opens up a world of possibilities.  Today we’ll learn how to harness it.
      </p>
<p id="N17B21" class="calibre5">
        To make use of the API, we’re going to develop some simple client applications using Node.js.<a id="FNPTR-45" href="f_0045.html#FOOTNOTE-45">[45]</a>  Node.js is a server-side JavaScript platform built on the V8 JavaScript engine—the same one used in Google’s Chrome browser.  Because Node.js is event-driven and code for it is written in JavaScript, it’s a natural fit for integrating with CouchDB.  If you don’t already have Node.js, head over to the Node.js site and install the latest stable version (we use version 0.6).
      </p>
<p id="N17B2A" class="calibre5">
        The three flavors of the Changes API are polling, long-polling, and continuous.   We’ll talk about each of these in turn.  As always, we’ll start with cURL to get close to the bare metal and then follow up with a programmatic approach.
      </p>
<h4 class="calibre21">cURLing for Changes</h4>
<p id="N17B31" class="calibre5">
          The first and simplest way to access the Changes API is through the polling interface.  Head to the command line, and try the following (the output was truncated for brevity; yours may differ):
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:5984/music/_changes</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "results":[{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "seq":1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "id":"370255",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "changes":[{"rev":"1-a7b7cc38d4130f0a5f3eae5d2c963d85"}]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "seq":2,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "id":"370254",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "changes":[{"rev":"1-2c7e0deec3ffca959ba0169b0e8bfcef"}]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    ... 97 more records ...​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  },{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "seq":100,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "id":"357995",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "changes":[{"rev":"1-aa649aa53f2858cb609684320c235aee"}]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "last_seq":100​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17B7E" class="calibre5">
          When you send a <code class="cf">GET</code> request for <code class="cf">_changes</code> with no other parameters, CouchDB will respond with everything it has.  Just like accessing views, you can specify a <code class="cf">limit</code> parameter to request just a subset of the data, and adding <code class="cf">include_docs=true</code> will cause full documents to be returned.
        </p>
<p id="N17B97" class="calibre5">
          Typically you won’t want all the changes from the beginning of time.  You’re more likely to want the changes that have occurred since you last checked.  For this, use the <code class="cf">since</code> parameter.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:5984/music/_changes?since=99</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "results":[{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "seq":100,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "id":"357995",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "changes":[{"rev":"1-aa649aa53f2858cb609684320c235aee"}]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "last_seq":100​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17BC4" class="calibre5">
          If you specify a <code class="cf">since</code> value that’s higher than the last sequence number, you’ll get an empty response:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:5984/music/_changes?since=9000</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "results":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "last_seq":9000​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17BE8" class="calibre5">
          Using this method, the client application would check back periodically to find out whether any new changes have occurred, taking application-specific actions accordingly.
        </p>
<p id="N17BEB" class="calibre5">
          Polling is a fine solution if your need for up-to-date changes can suffer delays between updates.  If updates are relatively rare, this would be the case.  For example, if you were pulling blog entries, polling every five minutes might be just fine.
        </p>
<p id="N17BEE" class="calibre5">
          If you want updates quicker, without incurring the overhead of reopening connections, then longpolling is a better option.  When you specify the URL parameter <code class="cf">feed=longpoll</code>, CouchDB will leave the connection open for some time, waiting for changes to happen before finishing the response.  Try this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl 'http://localhost:5984/music/_changes?feed=longpoll&amp;since=9000'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"results":[​</code>​</div>
</td>
</tr>
</table>
<p id="N17C06" class="calibre5">
          You should see the beginning of a JSON response but nothing else.  If you leave the terminal open long enough, CouchDB will eventually close the connection by finishing it:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​"last_seq":9000}​</code>​</div>
</td>
</tr>
</table>
<p id="N17C18" class="calibre5">
          From a development perspective, writing a driver that watches CouchDB for changes using polling is equivalent to writing one for longpolling.  The difference is essentially just how long CouchDB is willing to leave the connection open.  Now let’s turn our attention to writing a Node.js application that watches and uses the change feed.
          </p>
<h4 id="sec.couchdb.polling.with.node" class="calibre21">Polling for Changes with Node.js</h4>
<p id="N17C23" class="calibre5">
          Node.js is a strongly event-driven system, so our CouchDB watcher will adhere to this principle as well.  Our driver will watch the changes feed and emit change events whenever CouchDB reports changed documents.  To get started, we’ll look at a skeletal outline of our driver, talk about the major pieces, and then fill in the feed-specific details.
        </p>
<p id="N17C32" class="calibre5">
          Without further ado, here’s the outline of our watcher program, as well as a brief discussion of what it does:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/couchdb/watch_changes_skeleton.js">couchdb/watch_changes_skeleton.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">var</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  http = require(<em class="string">'http'</em>),​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  events = require(<em class="string">'events'</em>);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">/**</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"> * create a CouchDB watcher based on connection criteria;</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"> * follows node.js EventEmitter pattern, emits 'change' events.</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment"> */</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>① </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​exports.createWatcher = <strong class="prompt">function</strong>(options) { ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>② </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">var</strong> watcher = <strong class="prompt">new</strong> events.EventEmitter(); ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  watcher.host = options.host || <em class="string">'localhost'</em>;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  watcher.port = options.port || 5984;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  watcher.last_seq = options.last_seq || 0;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  watcher.db = options.db || <em class="string">'_users'</em>;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>③ </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  watcher.start = <strong class="prompt">function</strong>() { ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <em class="comment">// ... feed-specific implementation ...</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  };​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> watcher;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​};​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<em class="comment">// start watching CouchDB for changes if running as main script</em>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>④ </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">if</strong> (!module.parent) { ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  exports.createWatcher({​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    db: process.argv[2],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    last_seq: process.argv[3]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  })​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    .on(<em class="string">'change'</em>, console.log)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    .on(<em class="string">'error'</em>, console.error)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    .start();​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<dl class="calibre39">
<dt class="calibre2">①</dt>
<dd class="calibre40">
<p id="N17CDB" class="calibre5">
<code class="cf">exports</code> is a standard object provided by the CommonJS Module API that Node.js implements.  Adding the <code class="cf">createWatcher</code> method to <code class="cf">exports</code> makes it available to other Node.js scripts that might want to use this as a library.  The <code class="cf">options</code> argument allows the caller to specify which database to watch as well as override other connection settings.
            </p>
</dd>
<dt class="calibre2">②</dt>
<dd class="calibre40">
<p id="N17CEF" class="calibre5">
<code class="cf">createWatcher</code> produces an <code class="cf">EventEmitter</code> object that the caller can use to listen for change events.  The relevant capabilities of an <code class="cf">EventEmitter</code> is that you can listen to events by calling its <code class="cf">on</code> method and trigger events by calling its <code class="cf">emit</code> method.
            </p>
</dd>
<dt class="calibre2">③</dt>
<dd class="calibre40">
<p id="N17D06" class="calibre5">
<code class="cf">watcher.start</code> is responsible for issuing HTTP requests to watch CouchDB for changes.  When changes to documents happen, <code class="cf">watcher</code> should emit them as change events.  All of the feed-specific implementation details will be in here.
            </p>
</dd>
<dt class="calibre2">④</dt>
<dd class="calibre40">
<p id="N17D14" class="calibre5">
              The last chunk of code at the bottom specifies what the script should do if it’s called directly from the command line.  In this case, the script will invoke the <code class="cf">createWatcher</code> method and then set up listeners on the returned object that dump results to standard output.  Which database to connect to and what sequence ID number to start from can be set via command-line arguments.
            </p>
</dd>
</dl>
<p id="N17D1A" class="calibre5">
          So far, there’s nothing specific to CouchDB at all in this code.  It’s all just Node.js’s way of doing things.  This code may look foreign to you, especially if you haven’t developed with an event-driven server technology before, but it’s one we’ll be using increasingly in this book going forward.
        </p>
<p id="N17D1D" class="calibre5">
          With the skeleton in place, let’s add the code to connect to CouchDB via longpolling and emit events.  The following is just the code that goes inside the <code class="cf">watcher.start</code> method.  Written inside the previous outline (where the comment says <span class="calibre6">feed-specific implementation</span>), the new complete file should be called <code class="cf">watch_changes_longpolling.js</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td colspan="2" class="calibre34">
<a href="http://media.pragprog.com/titles/rwdata/code/couchdb/watch_changes_longpolling_impl.js">couchdb/watch_changes_longpolling_impl.js</a>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">var</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>① </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  http_options = { ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    host: watcher.host,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    port: watcher.port,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    path:​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      <em class="string">'/'</em> + watcher.db + <em class="string">'/_changes'</em> +​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      <em class="string">'?feed=longpoll&amp;include_docs=true&amp;since='</em> + watcher.last_seq​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  };​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>② </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​http.get(http_options, <strong class="prompt">function</strong>(res) { ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">var</strong> buffer = <em class="string">''</em>;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  res.on(<em class="string">'data'</em>, <strong class="prompt">function</strong> (chunk) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    buffer += chunk;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  });​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  res.on(<em class="string">'end'</em>, <strong class="prompt">function</strong>() {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span>③ </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">var</strong> output = JSON.parse(buffer); ​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    <strong class="prompt">if</strong> (output.results) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      watcher.last_seq = output.last_seq;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      output.results.forEach(<strong class="prompt">function</strong>(change){​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​        watcher.emit(<em class="string">'change'</em>, change);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      });​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      watcher.start();​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    } <strong class="prompt">else</strong> {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​      watcher.emit(<em class="string">'error'</em>, output);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  })​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​})​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​.on(<em class="string">'error'</em>, <strong class="prompt">function</strong>(err) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  watcher.emit(<em class="string">'error'</em>, err);​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​});​</code>​</div>
</td>
</tr>
</table>
<dl class="calibre39">
<dt class="calibre2">①</dt>
<dd class="calibre40">
<p id="N17DD3" class="calibre5">
              The first thing this script does is set up the <code class="cf">http_options</code> configuration object in preparation for the request.  The <code class="cf">path</code> points to the same <code class="cf">_changes</code> URL we’ve been using, with <code class="cf">feed</code> set to <code class="cf">longpoll</code> and <code class="cf">include_docs=true</code>.
            </p>
</dd>
<dt class="calibre2">②</dt>
<dd class="calibre40">
<p id="N17DEE" class="calibre5">
              After that, the script calls <code class="cf">http.get</code>, a Node.js library method that fires off a <code class="cf">GET</code> request according to our settings.  The second parameter to <code class="cf">http.get</code> is a callback that will receive an <code class="cf">HTTPResponse</code>.  The response object emits <code class="cf">data</code> events as the content is streamed back, which we add to the <code class="cf">buffer</code>.
            </p>
</dd>
<dt class="calibre2">③</dt>
<dd class="calibre40">
<p id="N17E09" class="calibre5">
              Finally, when the response object emits an <code class="cf">end</code> event, we parse the buffer (which should contain JSON).  From this we learn the new <code class="cf">last_seq</code> value, emit a <code class="cf">change</code> event, and then reinvoke <code class="cf">watcher.start</code> to wait for the next change.
            </p>
</dd>
</dl>
<p id="N17E18" class="calibre5">
          To run this script in command-line mode, execute it like this (output truncated for brevity):
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">node watch_changes_longpolling.js music</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ seq: 1,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  id: '370255',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  changes: [ { rev: '1-a7b7cc38d4130f0a5f3eae5d2c963d85' } ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  doc:​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   { _id: '370255',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     _rev: '1-a7b7cc38d4130f0a5f3eae5d2c963d85',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     albums: [ [Object] ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     id: '370255',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     name: '""ATTIC""',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     url: 'http://www.jamendo.com/artist/ATTIC_(3)',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     mbgid: '',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     random: 0.4121620435325435 } }​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{ seq: 2,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  id: '370254',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  changes: [ { rev: '1-2c7e0deec3ffca959ba0169b0e8bfcef' } ],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  doc:​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​   { _id: '370254',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​     _rev: '1-2c7e0deec3ffca959ba0169b0e8bfcef',​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ... 98 more entries ...​</code>​</div>
</td>
</tr>
</table>
<p id="N17E63" class="calibre5">
          Hurrah, our app works!  After outputting a record for each document, the process will keep running, polling CouchDB for future changes.
        </p>
<p id="N17E66" class="calibre5">
          Feel free to modify a document in Futon directly or increase the <code class="cf">@max</code> value on <code class="cf">import_from_jamendo.rb</code> and run it again.  You’ll see those changes reflected on the command line.  Next we’ll see how to go full-steam ahead and use the continuous feed to get even snappier updates.
          </p>
<h4 class="calibre21">Watching for Changes Continuously</h4>
<p id="N17E79" class="calibre5">
          The polling and longpolling feeds produced by the <code class="cf">_changes</code> service both produce proper JSON results.  The <span class="calibre6">continuous</span> feed does things a little differently.  Instead of combining all available changes into a <code class="cf">results</code> array and closing the stream afterward, it sends each change separately and keeps the connection open. This way, it’s ready to return more JSON serialized change notification objects as changes become available.
        </p>
<p id="N17E90" class="calibre5">
          To see how this works, try the following (output truncated for readability):
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl 'http://localhost:5984/music/_changes?since=97&amp;feed=continuous'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"seq":98,"id":"357999","changes":[{"rev":"1-0329f5c885...87b39beab0"}]}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"seq":99,"id":"357998","changes":[{"rev":"1-79c3fd2fe6...1e45e4e35f"}]}​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"seq":100,"id":"357995","changes":[{"rev":"1-aa649aa53f...320c235aee"}]}​</code>​</div>
</td>
</tr>
</table>
<p id="N17EAB" class="calibre5">
          Eventually, if no changes have happened for a while, CouchDB will close the connection after outputting a line like this:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"last_seq":100}​</code>​</div>
</td>
</tr>
</table>
<p id="N17EBA" class="calibre5">
          The benefit of this method over polling or longpolling is the reduced overhead that accompanies leaving the connection open.  There’s no time lost reestablishing the HTTP connections.  On the other hand, the output isn’t straight JSON, which means it’s a bit more of a chore to parse.  Also, it’s not a good fit if your client is a web browser.  A browser downloading the feed asynchronously might not receive any of the data until the entire connection finishes (better to use longpolling in this case).
          </p>
<h4 class="calibre21">Filtering Changes</h4>
<p id="N17EC4" class="calibre5">
          As we’ve just seen, the Changes API provides a unique window into the goings on of a CouchDB database.  On the plus side, it provides all the changes in a single stream.  However, sometimes you may want just a subset of changes, rather than the fire hose of everything that has ever changed.  For example, you may be interested only in document deletions or maybe only in documents that have a particular quality.  This is where <span class="calibre6">filter functions</span> come in.
        </p>
<p id="N17ED0" class="calibre5">
          A filter is a function that takes in a document (and request information) and makes a decision as to whether that document ought to be allowed through the filter.  This is gated by the return value.  Let’s explore how this works.  Considering our <code class="cf">music</code> database, most artist documents we’ve been inserting have a <code class="cf">country</code> property that contains a three-letter code.  Say we were  interested only in bands from Russia (RUS).  Our filter function might look like the following:</p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">function</strong>(doc) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> doc.country === <em class="string">"RUS"</em>;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17EFA" class="calibre5">
          If we added this to a design document under the key <code class="cf">filters</code>, we’d be able to specify it when issuing requests for <code class="cf">_changes</code>.  But before we do, let’s expand the example.  Rather than always wanting Russian bands, it’d be better if we could parameterize the input so the country could be specified in the URL.
        </p>
<p id="N17F03" class="calibre5">
          Here’s a parameterized country-based filter function:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">function</strong>(doc, req) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  <strong class="prompt">return</strong> doc.country === req.query.country;​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17F1D" class="calibre5">
          Notice this time how we’re comparing the document’s <code class="cf">country</code> property to a parameter of the same name passed in the request’s query string.  To see this in action, let’s create a new design document just for geography-based filters and add it:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  http://localhost:5984/music/_design/wherabouts \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -d '{"language":"javascript","filters":{"by_country":</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "function(doc,req){return doc.country === req.query.country;}"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }}'​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ok":true,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "id":"_design/wherabouts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "rev":"1-c08b557d676ab861957eaeb85b628d74"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N17F56" class="calibre5">
          Now we can make a country-filtered changes request:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl "http://localhost:5984/music/_changes?\</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">filter=wherabouts/by_country&amp;\</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">country=RUS"</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"results":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"seq":10,"id":"5987","changes":[{"rev":"1-2221be...a3b254"}]},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"seq":57,"id":"349359","changes":[{"rev":"1-548bde...888a83"}]},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{"seq":73,"id":"364718","changes":[{"rev":"1-158d2e...5a7219"}]},​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​...​</code>​</div>
</td>
</tr>
</table>
<p id="N17F7F" class="calibre5">
          Using filters, you have the power to set up a sort of pseudosharding, where only a subset of records are replicated between nodes.  It’s not quite the same as truly sharded systems like MongoDB or HBase, but it does afford a means of splitting the responsibility of servicing certain kinds of requests.  For instance, your main CouchDB server might have separate filters for users, orders, messages, and inventory.  Separate CouchDB servers could replicate changes based on these filters, each supporting a different aspect of the business.
        </p>
<p id="N17F87" class="calibre5">
          Since filter functions may contain arbitrary JavaScript, more sophisticated logic can be put into them.  Testing for deeply nested fields would be similar to what we did for creating views.  You could also use regular expressions for testing properties or compare them mathematically (for example, filtering by a date range).  There’s even a user context property on the request object (<code class="cf">req.userCtx</code>) you can use to find out more about the credentials provided with the request.
        </p>
<p id="N17F8D" class="calibre5">
        We’ll revisit Node.js and the CouchDB Changes API in Chapter 8, <a href="f_0052.html#chp.redis">​<em class="calibre6">Redis</em>​</a> when we build a multidatabase application.  For now, though, it’s time to move on to the last distinguishing feature of CouchDB we’re going to cover: replication.
        </p>
<div class="sidebar">
<div class="sidebar-title">CouchDB or BigCouch?</div>
<div class="calibre2">
<p id="N17FA7" class="calibre5">
        CouchDB’s approach makes sense in a lot of use cases.  It certainly fills a niche that the other databases we’ve discussed largely don’t address.  On the other hand, sometimes it’s nice to selectively replicate data between nodes in order to capitalize on available disk space.  That is, instead of having all nodes have all the data, keep only a certain number of copies.  This is the <span class="calibre6">N</span> in NWR—discussed in <a href="f_0025.html#sec.nwr">​<em class="calibre6">Nodes/​Writes/​Reads</em>​</a>.
      </p>
<p id="N17FB3" class="calibre5">
        This isn’t a feature that CouchDB offers out of the box, but don’t worry! BigCouch has you covered.  Developed and maintained by Cloudant, BigCouch offers a CouchDB-compatible interface (with only a few minor differences<a id="FNPTR-46" href="f_0045.html#FOOTNOTE-46">[46]</a>).  Under the surface, though, it implements the sharding and replication strategy of a Dynamo-inspired database like Riak.
      </p>
<p id="N17FBC" class="calibre5">
        Installing BigCouch is quite a chore—much harder than vanilla CouchDB—but may be worth it if your deployment scenario consists of a big-iron datacenter.
      </p>
</div>
</div>
<h3 class="calibre20">Replicating Data in CouchDB</h3>
<div class="figure" id="fig.couchdb.replicator">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/couchdb-replicator.png" alt="images/couchdb-replicator.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 29. CouchDB Futon: Replicator</div>
</div>
<p id="N17FDD" class="calibre5">
        CouchDB is all about asynchronous environments and data durability.  According to CouchDB, the safest place to store your data is everywhere, and it gives you the tools to do it.  Some other databases we’ve looked at maintain a single master node to guarantee consistency.  Still others ensure it with a quorum of agreeing nodes.  CouchDB does neither of these; instead, it supports something called multi-master or master-master replication.
      </p>
<p id="N17FEA" class="calibre5">
        Each CouchDB server is equally able to receive updates, respond to requests, and delete data, regardless of whether it’s able to connect to any other server.  In this model, changes are selectively replicated in one direction, and all data is subject to replication in the same way.  In other words, there is no sharding.  Servers participating in replication will all have all of the data.
      </p>
<p id="N17FED" class="calibre5">
        Replication is the last major topic in CouchDB that we’ll be discussing.  First we’ll see how to set up ad hoc and continuous replication between databases.  Then we’ll work through the implications of conflicting data and how to make applications capable of handling these cases gracefully.
      </p>
<p id="N17FF0" class="calibre5">
        To begin, click the  Replicator  link in the Tools menu on the right side of the page.  It should open  a page that looks like Figure 29, <a href="#fig.couchdb.replicator">​<em class="calibre6">CouchDB Futon: Replicator</em>​</a>.  In the “Replicate changes from” dialog, choose <code class="cf1">music</code> from the left drop-down menu and enter <code class="cf1">music-repl</code> in the right-side slot.  Leave the Continuous checkbox unchecked, and then click Replicate.  Click OK to create the <code class="cf">music-repl</code> database when prompted.  This should produce an event message in the event log below the form.
      </p>
<p id="N17FFF" class="calibre5">
        To confirm that the replication request worked, go back to the Futon Overview page.  There should now be a new database called <code class="cf">music-repl</code> with the same number of documents as the <code class="cf">music</code> database.  If it has fewer, give it some time and refresh the page—CouchDB may be in the process of catching up.  Don’t be concerned if the Update Seq values don’t match.  That’s because the original <code class="cf">music</code> database had deletions and updates to documents, whereas the <code class="cf">music-repl</code> database had only insertions to bring it up to speed.
      </p>
<h4 class="calibre21">Creating Conflicts</h4>
<p id="N18012" class="calibre5">
          Next we’ll create a conflict and then explore how to deal with it.  Keep the Replicator page handy because we’re going to be triggering ad hoc replication between <code class="cf">music</code> and <code class="cf">music-repl</code> frequently.
        </p>
<p id="N18021" class="calibre5">
          Drop back to the command line, and enter this to create a document in the <code class="cf">music</code> database:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT "http://localhost:5984/music/theconflicts" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt"> -H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt"> -d '{ "name": "The Conflicts" }'</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ok":true,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "id":"theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "rev":"1-e007498c59e95d23912be35545049174"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1804D" class="calibre5">
          On the Replicator page, click Replicate to trigger another synchronization.  We can confirm that the document was successfully replicated by retrieving it from the <code class="cf">music-repl</code> database.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl "http://localhost:5984/music-repl/theconflicts"</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id":"theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_rev":"1-e007498c59e95d23912be35545049174",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "name":"The Conflicts"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18074" class="calibre5">
          Next, let’s update it in <code class="cf">music-repl</code> by adding an album called <code class="cf1">Conflicts of Interest</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT "http://localhost:5984/music-repl/theconflicts" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -d '{</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "_id": "theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "_rev": "1-e007498c59e95d23912be35545049174",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "name": "The Conflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "albums": ["Conflicts of Interest"]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }'​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ok":true,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "id":"theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "rev":"2-0c969fbfa76eb7fcdf6412ef219fcac5"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N180B2" class="calibre5">
          And create a conflicting update in <code class="cf">music</code> proper by adding a different album: <code class="cf1">Conflicting Opinions</code>.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl -X PUT "http://localhost:5984/music/theconflicts" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -H "Content-Type: application/json" \</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​<strong class="prompt">  -d '{</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "_id": "theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "_rev": "1-e007498c59e95d23912be35545049174",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "name": "The Conflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "albums": ["Conflicting Opinions"]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  }'​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "ok":true,​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "id":"theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "rev":"2-cab47bf4444a20d6a2d2204330fdce2a"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N180F0" class="calibre5">
          At this point, both the <code class="cf">music</code> and <code class="cf">music-repl</code> databases have a document with an <code class="cf">_id</code> value of <code class="cf">theconflicts</code>.  Both documents are at version <code class="cf">2</code> and derived from the same base revision (<code class="cf">1-e007498c59e95d23912be35545049174</code>).  Now the question is, what happens when we try to replicate between them?
        </p>
<h4 class="calibre21">Resolving Conflicts</h4>
<p id="N18109" class="calibre5">
          With our document now in a conflicting state between the two databases, head back to the Replicator page and kick off another replication.  If you were expecting this to fail, you may be shocked to learn that the operation succeeds just fine.  So, how did CouchDB deal with the discrepancy?
        </p>
<p id="N1810C" class="calibre5">
          It turns out that CouchDB basically just picks one and calls that one the winner.  Using a deterministic algorithm, all CouchDB nodes will pick the same winner when a conflict is detected.  However, the story doesn’t end there.  CouchDB stores the unselected “loser” documents as well so that a client application can review the situation and resolve it at a later date.
        </p>
<p id="N1810F" class="calibre5">
          To find out which version of our document won during the last replication, we can request it using the normal <code class="cf">GET</code> request channel.  By adding the <code class="cf">conflicts=true</code> URL parameter, CouchDB will also include information about the conflicting revisions.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:5984/music-repl/theconflicts?conflicts=true</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id":"theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_rev":"2-cab47bf4444a20d6a2d2204330fdce2a",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "name":"The Conflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "albums":["Conflicting Opinions"],​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_conflicts":[​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​    "2-0c969fbfa76eb7fcdf6412ef219fcac5"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  ]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N18142" class="calibre5">
          So, we see that the second update won.  Notice the <code class="cf">_conflicts</code> field in the response.  It contains a list of other revisions that conflicted with the chosen one.  By adding a <code class="cf">rev</code> parameter to a <code class="cf">GET</code> request, we can pull down those conflicting revisions and decide what to do about them.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​$ <strong class="prompt">curl http://localhost:5984/music-repl/theconflicts?rev=2-0c969f...</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​{​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_id":"theconflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "_rev":"2-0c969fbfa76eb7fcdf6412ef219fcac5",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "name":"The Conflicts",​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  "albums":["Conflicts of Interest"]​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1816F" class="calibre5">
          The takeaway here is that CouchDB does not try to intelligently merge conflicting changes.  How to merge two documents is highly application-specific, and a general solution isn’t practical.  In our case, combining the two <code class="cf">albums</code> arrays by concatenating them makes sense, but one could easily think of scenarios where the appropriate action is not obvious.
        </p>
<p id="N18175" class="calibre5">
          For example, consider you’re maintaining a database of calendar events.  One copy is on your smartphone; another is on your laptop.  You get a text message from a party planner specifying the venue for the party you’re hosting, so you update your phone database accordingly.  Later, back at the office, you receive another email from the planner specifying a <span class="calibre6">different</span> venue.  So, you update your laptop database and then replicate between them.  CouchDB has no way of knowing which of the two venues is correct.  The best it can do is make them consistent, keeping the old value around so you can verify which of the conflicting values should be kept.  It would be up to the application to determine the right user interface for presenting this situation and asking for a decision.
          </p>
<h3 class="calibre20">Day 3 Wrap-Up</h3>
<p id="N18182" class="calibre5">
        And so ends our tour of CouchDB.  Here in Day 3 we started out by learning how to add reducer functions to our mapreduce-generated views.  After that, we took a deep dive into the Changes API, including a jaunt into the world of event-driven server-side JavaScript development with Node.js.  Lastly, we took a brief look at how CouchDB achieves its master-master replication strategy and how client applications can detect and correct for conflicts.
      </p>
<h4 class="calibre21">Day 3 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N18190" class="calibre5">What native reducers are available in CouchDB? What are the benefits of using native reducers over custom JavaScript reducers?</p>
</li>
<li class="calibre23">
<p id="N18194" class="calibre5">How can you filter the changes coming out of the <code class="cf">_changes</code> API on the server side?</p>
</li>
<li class="calibre23">
<p id="N1819B" class="calibre5">Like everything in CouchDB, the tasks of initializing and canceling replication are controlled by HTTP commands under the hood.  What are the REST commands to set up and remove replication relationships between servers?</p>
</li>
<li class="calibre23">
<p id="N1819F" class="calibre5">How can you use the <code class="cf">_replicator</code> database to persist replication relationships?</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N181AC" class="calibre5">
                Create a new module called <code class="cf">watch_changes_continuous.js</code> based on the skeletal Node.js module described in the section <a href="#sec.couchdb.polling.with.node">​<em class="calibre6">Polling for Changes with Node.js</em>​</a>.
              </p>
</li>
<li class="calibre23">
<p id="N181B6" class="calibre5">
                Implement <code class="cf">watcher.start</code> such that it monitors the continuous <code class="cf">_changes</code> feed.  Confirm that it produces the same output as <code class="cf">watch_changes_longpolling.js</code>.
              </p>
<p id="N181C2" class="calibre5">
<span class="calibre6">Hint: If you get stuck, you can find an example implementation in the downloads that accompany this book.</span>
</p>
</li>
<li class="calibre23">
<p id="N181C7" class="calibre5">
                Documents with conflicting revisions have a <code class="cf">_conflicts</code> property.  Create a view that emits conflicting revisions and maps them to the doc <code class="cf">_id</code>.
              </p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

