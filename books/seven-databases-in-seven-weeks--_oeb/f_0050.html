---
layout: page
title: "Seven Databases in Seven Weeks (for Greg Kennedy)"
prev: f_0049.html
next: f_0051.html
book_path: books/seven-databases-in-seven-weeks--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="N1941F" class="calibre18">7.4 Day 3: Distributed High Availability</h2>
<p id="N19423" class="calibre5">
      We’re going to wrap up our Neo4j investigation by learning how to make Neo4j more attuned to mission-critical uses. We’ll see how Neo4j keeps data stable via ACID-compliant transactions. Then we’ll install and configure a Neo4j high availability (HA) cluster to improve availability when serving high-read traffic. Then we’re going to look into backup strategies to ensure our data remains safe.
    </p>
<h3 id="sec.transactions" class="calibre20">Transactions</h3>
<p id="N1942B" class="calibre5">
      Neo4j is an Atomic, Consistent, Isolated, Durable (ACID) transaction database, similar to PostgreSQL. This makes it a good option for important data you may have otherwise picked a relational database for. Just like transactions we’ve seen before, Neo4j transactions are all-or-nothing operations. When a transaction starts, every following operation will succeed or fail as an atomic unit—failure of one means failure of all.
      </p>
<p id="N1943A" class="calibre5">
      The details of how transactions are handled goes beyond Gremlin into the underlying Neo4j wrapper project called Blueprint. Specific details can change from version to version. We’re using Gremlin 1.3, which uses Blueprints 1.0. If you’re using a different version of either, you can find the specifics in the Blueprint API Javadocs.
      </p>
<p id="N1943D" class="calibre5">
      Just like PostgreSQL, basic one-line functions are automatically wrapped in an implicit transaction. To demonstrate multiline transactions, we need to flag the graph object to turn off automatic transaction mode, letting Neo4j know that we plan to handle transactions manually. You can change the transaction mode through the <code class="cf">setTransactionMode</code> function.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.setTransactionMode(TransactionalGraph.Mode.MANUAL)​</code>​</div>
</td>
</tr>
</table>
<p id="N1944E" class="calibre5">
      You start and stop the transaction on the graph object using <code class="cf">startTransaction</code> and <code class="cf">stopTransaction(conclusion)</code>. When you stop the transaction, you also need to mark whether the transaction was successful. If not, Neo4j can roll back all commands executed since the start. It’s a good idea to wrap the transaction within a <code class="cf">try/catch</code> block to ensure that any exceptions will trigger a rollback.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g.startTransaction()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​try {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  // execute some multi-step graph stuff here...​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  g.stopTransaction(TransactionalGraph.Conclusion.SUCCESS)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​} catch(e) {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  g.stopTransaction(TransactionalGraph.Conclusion.FAILURE)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N19478" class="calibre5">
        If you want to operate outside the Gremlin confines and work directly with the Neo4j <code class="cf">EmbeddedGraphDatabase</code>, you can use the Java API syntax for transactions. You may have to use this style if you write Java code or use a language that is Java under the covers—like JRuby.
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​r = g.getRawGraph()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​tx = r.beginTx()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​try {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  // execute some multistep graph stuff here...​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  tx.success()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​} finally {​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  tx.finish()​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1949E" class="calibre5">
      Both varieties provide you with full ACID transaction guarantees. Even system failure will ensure any writes are rolled back when the server is fired back up. If you don’t need to manually handle transactions, you’re better off keeping the transaction mode on <code class="cf">TransactionalGraph.Mode.AUTOMATIC</code>.
      </p>
<h3 id="sec.highAvailability" class="calibre20">High Availability</h3>
<p id="N194AF" class="calibre5">
        High availability mode is Neo4j’s answer to the question, “Can a graph database scale?” Yes, but with some caveats. A write to one slave is not immediately synchronized with all other slaves, so there is a danger of losing consistency (in the CAP sense) for a brief moment (making it eventually consistent). HA will lose pure ACID-compliant transactions. It’s for this reason that Neo4j HA is touted as a solution largely for increasing capacity for reads.
      </p>
<p id="N194B7" class="calibre5">
        Just like Mongo, the servers in the cluster will elect a master that is the gold copy of data. Unlike Mongo, however, slaves accept writes. Slave writes will synchronize with the master node, which then propagates those changes to the other slaves.
      </p>
<h4 id="sec.hACluster" class="calibre21">HA Cluster</h4>
<p id="N194BF" class="calibre5">
        To use Neo4j HA, we must first set up a cluster. Neo4j uses an external cluster coordinator service called Zookeeper. Zookeeper is yet another excellent project to arise from the Apache Hadoop project. It’s a general-purpose service to coordinate distributed applications. Neo4j HA uses this to manage its life-cycle activities. Each Neo4j server has its own related coordinator—tasked with managing its place in the cluster—as shown in Figure 36, <a href="#fig.neo4j.ha">​<em class="calibre6">A three-server Neo4j cluster and their coordinators</em>​</a>.
        </p>
<div class="figure" id="fig.neo4j.ha">
<div class="calibre2">
<img xmlns:str="http://exslt.org/strings" src="images/neo4j-ha.png" alt="images/neo4j-ha.png" class="calibre27"/>
</div>
<div class="figurecaption">
<hr class="calibre28"/>Figure 36. A three-server Neo4j cluster and their coordinators</div>
</div>
<p id="N194F9" class="calibre5">
        Happily, Neo4j Enterprise comes bundled with Zookeeper as well as some files to help us configure a cluster. We’re going to run three instances of Neo4j Enterprise version 1.7. You can download a copy from the website for your operating system (be sure you select the correct edition)<a id="FNPTR-51" href="f_0051.html#FOOTNOTE-51">[51]</a> and then unzip it and create two more copies of the directory. We suffixed ours with 1, 2, and 3 and will refer to them as such.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​tar fx neo4j-enterprise-1.7-unix.tar​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​mv neo4j-enterprise-1.7 neo4j-enterprise-1.7-1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​cp -R neo4j-enterprise-1.7-1 neo4j-enterprise-1.7-2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​cp -R neo4j-enterprise-1.7-1 neo4j-enterprise-1.7-3​</code>​</div>
</td>
</tr>
</table>
<p id="N19517" class="calibre5">
        Now we have three identical copies of our database.
        </p>
<p id="N1951A" class="calibre5">
        Normally you would unpack one copy per server and configure the cluster to be aware of the other servers. But since we’re running them locally, we’ll instead run them on different directories using different ports.
        </p>
<p id="N1951D" class="calibre5">
        We will follow five steps to create our cluster, starting by configuring the Zookeeper cluster coordinators and then the Neo4j servers.
        </p>
<ol class="calibre33">
<li class="calibre23">
<p id="N19523" class="calibre5">Set unique IDs for each coordinator server.</p>
</li>
<li class="calibre23">
<p id="N19527" class="calibre5">Configure each coordinator server to communicate with the other servers and its hosted Neo4j server.</p>
</li>
<li class="calibre23">
<p id="N1952B" class="calibre5">Start up all three coordinator servers.</p>
</li>
<li class="calibre23">
<p id="N1952F" class="calibre5">Configure each Neo4j server to run in HA mode, give them unique ports, and make them aware of the coordinator cluster.</p>
</li>
<li class="calibre23">
<p id="N19533" class="calibre5">Start up all three Neo4j servers.</p>
</li>
</ol>
<p id="N19536" class="calibre5">
        Zookeeper tracks each server by way of an ID unique to the cluster. This number is the only value in the file <code class="cf">data/coordinator/myid</code>. For server 1 we’ll keep it at the default 1; for server 2 we’ll set it to 2 and set server 3 to contain 3.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​echo "2" &gt; neo4j-enterprise-1.7-2/data/coordinator/myid​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​echo "3" &gt; neo4j-enterprise-1.7-3/data/coordinator/myid​</code>​</div>
</td>
</tr>
</table>
<p id="N1954B" class="calibre5">
        We must also indicate some communication settings internal to the cluster. Each server will have a file named <code class="cf">conf/coord.cfg</code>. By default, notice the <code class="cf">server.1</code> variable has the server as <code class="cf">localhost</code> and two ports set: the quorum election port (<code class="cf">2888</code>) and the master election port (<code class="cf">3888</code>).
        </p>
<p class="calibre5">
<strong class="calibre32">Building the Cluster</strong>
</p>
<p id="N19564" class="calibre5">
        A Zookeeper quorum is a group of servers in the cluster and the ports they communicate through (this should not to be confused with a Riak quorum, which is a minimal majority for enforcing consistency). The master election port is used when the master goes down—this special port is used so the remaining servers can elect a  new master.

         We’ll keep <code class="cf">server.1</code> as is and add <code class="cf">server.2</code> and <code class="cf">server.3</code> to use successive ports. The <code class="cf">coord.cfg</code> files under servers 1, 2, and 3 must all contain the same three lines.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​server.1=localhost:2888:3888​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​server.2=localhost:2889:3889​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​server.3=localhost:2890:3890​</code>​</div>
</td>
</tr>
</table>
<p id="N19589" class="calibre5">
        Finally, we must set the public port to which Neo4j may connect. This <code class="cf">clientPort</code> defaults to 2181, so for server 1 we’ll leave it alone. We set <code class="cf">clientPort=2182</code> for server 2 and <code class="cf">clientPort=2183</code> for server 3. If any of these ports are in use on your machine, feel free to change this as necessary, but we’ll assume the previous ports are in use for the remaining steps.
        </p>
<p class="calibre5">
<strong class="calibre32">Coordinate</strong>
</p>
<p id="N19599" class="calibre5">
        We start up the Zookeeper coordinator with a handy script provided by the Neo4j team. Run the following command in each of the three server directories:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bin/neo4j-coordinator start​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​Starting Neo4j Coordinator...WARNING: not changing user​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​  process [36542]... waiting for coordinator to be ready. OK.​</code>​</div>
</td>
</tr>
</table>
<p id="N195B5" class="calibre5">
        The coordinator is now running, but Neo4j is not.
        </p>
<p class="calibre5">
<strong class="calibre32">Wiring in Neo4j</strong>
</p>
<p id="N195BC" class="calibre5">
          Next we need to set up Neo4j to run in high availability mode and then connect to a coordinator server.  Open <code class="cf">conf/neo4j-server.properties</code>, and add the following line under each server:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​org.neo4j.server.database.mode=HA​</code>​</div>
</td>
</tr>
</table>
<p id="N195D3" class="calibre5">
          This sets Neo4j to run in high availability mode; up until now we’ve been running in SINGLE mode. While we’re in this file, let’s set the web server port to a unique number. Normally the default port 7474 is fine, but since we’re running three neo4j instances on one box, we can’t let them overlap for http/https. We chose ports 7471/7481 for server 1, 7472/7482 for server 3, and 7473/7483 for server 3.
          </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​org.neo4j.server.webserver.port=7471​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​org.neo4j.server.webserver.https.port=7481​</code>​</div>
</td>
</tr>
</table>
<p id="N195E7" class="calibre5">
          Finally, we set each Neo4j instance to connect to one of the coordinator servers. If you open the <code class="cf">conf/neo4j.properties</code> file for server 1, you should see a few commented lines starting with <code class="cf">ha</code>. These are high availability settings that convey three things: the current cluster machine number, the list of zookeeper servers, and the port that the neo4j servers will use to communicate with each other.

          For server 1, add the following fields to <code class="cf">neo4j.properties</code>:
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.server_id=1​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.coordinators=localhost:2181,localhost:2182,localhost:2183​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.server=localhost:6001​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.pull_interval=1​</code>​</div>
</td>
</tr>
</table>
<p id="N19608" class="calibre5">
          These settings will be similar on the other two servers, with two provisos: <code class="cf">ha.server_id=2</code> for server 2 and <code class="cf">ha.server_id=3</code> for server 3. And the <code class="cf">ha.server</code> must use a different port (we chose 6002 for server 2 and 6003 for server 3). Again, the server ports needn’t change when you run them on separate machines. Server 2 will contain the following (and so on for server 3):
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.server_id=2​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.coordinators=localhost:2181,localhost:2182,localhost:2183​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.server=localhost:6002​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​ha.pull_interval=1​</code>​</div>
</td>
</tr>
</table>
<p id="N19628" class="calibre5">
          We set <code class="cf">pull_interval</code> to 1, which means each slave should check the master for updates every second. Generally, you won’t go this low, but it lets us see updates for the example data we’ll soon insert.
        </p>
<p id="N1962E" class="calibre5">
          With our Neo4j HA servers configured, it’s time to start them up. Just like the coordinator server startup script, start the neo4j server in each install directory.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bin/neo4j start​</code>​</div>
</td>
</tr>
</table>
<p id="N19646" class="calibre5">
          You can watch the server output by tailing the log file.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​tail -f data/log/console.log​</code>​</div>
</td>
</tr>
</table>
<p id="N19654" class="calibre5">
          Each server will attach to its configured coordinator.
        </p>
<p class="calibre5">
<strong class="calibre32">Verifying Cluster Status</strong>
</p>
<p id="N1965B" class="calibre5">
          Whatever coordinator was first launched will be the master server—probably server 1. You can verify this by opening the attached Neo4j instance’s web admin (previously we set server 1 to port 7471). Click the  Server Info  link at the top and then  High Availability  on the side menu.<a id="FNPTR-52" href="f_0051.html#FOOTNOTE-52">[52]</a>
</p>
<p id="N19668" class="calibre5">
          The properties under  High Availability  list information about this cluster. If this server is the master server, the property will be true. If not, you can find which server has been elected master by looking under InstancesInCluster. This lists each connected server, its machine ID, whether it is the master server, and other info.
        </p>
<h4 id="sec.verifyingReplication" class="calibre21">Verifying Replication</h4>
<p id="N19670" class="calibre5">
        With our cluster up and running, you can verify that your servers are replicating correctly. If all goes according to plan, any writes to a slave should propagate to the master node and then eventually to the other slave server. If you open the web consoles for each of the three servers, you can use the built-in Gremlin consoles in the web admin. Notice that the Gremlin graph object has changed to wrap a HighlyAvailableGraphDatabase.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​g = neo4jgraph[HighlyAvailableGraphDatabase [/…/neo4j-ent-1.7-2/data/graph.db]]​</code>​</div>
</td>
</tr>
</table>
<p id="N19684" class="calibre5">
        To test our servers, we’re going to populate our new graph with some nodes containing the names of some famous paradoxes. In one of the slave consoles, let’s set the root node to store Zeno’s paradox.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; root = g.v(0)​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; root.paradox = "Zeno's"​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; root.save​</code>​</div>
</td>
</tr>
</table>
<p id="N19698" class="calibre5">
          Now let’s switch to the master server’s console and output the vertex paradox values.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.paradox​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Zeno's​</code>​</div>
</td>
</tr>
</table>
<p id="N196A9" class="calibre5">
          Now if you switch to the other slave server and add Russell’s paradox, a quick look at our list will reveal both nodes exist in the second slave, having  added only one directly to this server.
        </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.addVertex(["paradox" : "Russell's"])​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​gremlin&gt; g.V.paradox​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Zeno's​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​==&gt; Russell's​</code>​</div>
</td>
</tr>
</table>
<p id="N196C0" class="calibre5">
        If one of your slave servers does not yet have the changes propagated to it, you can go back to the Server Info, High Availability screen. Look for all instances of <code class="cf">lastCommittedTransactionId</code>. When these values are equal, the system data is consistent. The lower the number, the older the version of data in that server.
        </p>
<h4 id="sec.masterElection" class="calibre21">Master Election</h4>
<p id="N196CE" class="calibre5">
          If you shut down the master server and refresh the server info in one of the remaining servers, you will see that another server has been elected the new master. Starting the server again will add it back to the cluster, but now the old master will remain a slave (until another server goes down).
        </p>
<p id="N196D6" class="calibre5">
      High availability allows very read-heavy systems to deal with replicating a graph across multiple servers and thus sharing the load. Although the cluster as a whole is only eventually consistent, there are tricks you can apply to reduce the chance of reading stale data in your own applications, such as assigning a session to one server. With the right tools, planning, and a good setup, you can build a graph database large enough to handle billions of nodes and edges and nearly any number of requests you may need. Just add regular backups, and you have the recipe for a solid production system.
      </p>
<h3 id="sec.backups" class="calibre20">Backups</h3>
<p id="N196DE" class="calibre5">
        Backups are a necessary aspect of any professional database use. Although backups are effectively built in when using replication, nightly backups that are stored off-site are always a good idea for disaster recovery. It’s hard to plan for a server room fire or an earthquake shaking a building to rubble. 
      </p>
<p id="N196E7" class="calibre5">
        Neo4j Enterprise offers a simple backup tool named neo4j-backup.
      </p>
<p id="N196EA" class="calibre5">
        The most powerful method when running an HA server is to craft a full backup command to copy the database file from the cluster to a date-stamped file on a mounted drive. Pointing the copy to every server in the cluster will ensure you get the most recent data available. The backup directory created is a fully usable copy. If you need to recover, just replace each installation’s data directory with the backup directory, and you’re ready to go.
      </p>
<p id="N196ED" class="calibre5">
        You must start with a full backup. Here we back up our HA cluster to a directory that ends with today’s date (uses the *nix date command).
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bin/neo4j-backup -full -from ha://localhost:2181,localhost:2182,localhost:2183 \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-to /mnt/backups/neo4j-`date +%Y.%m.%d`.db​</code>​</div>
</td>
</tr>
</table>
<p id="N196FE" class="calibre5">
        If you’re not running in HA mode, just change the mode in the URI to single. Once you have done a full backup, you can choose to do an incremental backup that will store changes only since the last backup. If we want to do a full backup on a single server at midnight and then grab the incremental changes every two hours, you could execute this command:
      </p>
<table class="processedcode">
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​bin/neo4j-backup -incremental -from single://localhost \​</code>​</div>
</td>
</tr>
<tr class="calibre24">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre25">
​<code class="calibre26">​-to /mnt/backups/neo4j-`date +%Y.%m.%d`.db​</code>​</div>
</td>
</tr>
</table>
<p id="N1970F" class="calibre5">
        But keep in mind incremental works only on a fully backed-up directory, so ensure the previous command is run on the same day.
        </p>
<h3 id="sec.day3WrapUp" class="calibre20">Day 3 Wrap-Up</h3>
<p id="N1971A" class="calibre5">
        Today we spent some time keeping Neo4j data stable via ACID-compliant transactions, high availability, and backup tools.
      </p>
<p id="N1971D" class="calibre5">
        It’s important to note that all of the tools we used today require the Neo4j Enterprise edition, and so use a dual license—GPL/AGPL. If you want to keep your server closed source, you should look into switching to the Community edition or getting an OEM from Neo Technology (the company behind Neo4j). Contact the Neo4j team for more information.
      </p>
<h4 class="calibre21">Day 3 Homework</h4>
<p class="calibre5">
<strong class="calibre32">Find</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N1972B" class="calibre5">Find the Neo4j licensing guide.</p>
</li>
<li class="calibre23">
<p id="N1972F" class="calibre5">Answer the question, “What is the maximum number of nodes supported?” (Hint: it’s in Questions &amp; Answers in the website docs.)</p>
</li>
</ol>
<p class="calibre5">
<strong class="calibre32">Do</strong>
</p>
<ol class="calibre33">
<li class="calibre23">
<p id="N19739" class="calibre5">Replicate Neo4j across three physical servers.</p>
</li>
<li class="calibre23">
<p id="N1973D" class="calibre5">Set up a load balancer using a web server like Apache or Nginx, and connect to the cluster using the REST interface. Execute a Gremlin script command.</p>
</li>
</ol>
<script src="scripts/book_local.js" type="text/javascript" class="calibre3"/>
</div>

{% endraw %}

