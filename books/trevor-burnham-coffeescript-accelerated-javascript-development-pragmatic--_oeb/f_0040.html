---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0039.html
next: f_0041.html
book_path: books/trevor-burnham-coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.classes" class="calibre13">4.3 Classes: Functions with Prototypes</h2>
<p id="N12AB7" class="calibre5">
      CoffeeScript’s class declaration syntax looks just like its object declaration syntax. That’s no coincidence; when you’re defining a class, you’re defining an object. Specifically, you’re defining a prototype. The only class property that isn’t part of the prototype is the <code class="cf">constructor</code> function, if you define one.
    </p>
<p id="N12AC1" class="calibre5">
      Let’s look at an example, illustrating the well-known fact that the trouble a tribble makes is directly proportional to the number of existing tribbles:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/Tribble.coffee" class="calibre23">Classes/Tribble.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Tribble</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  constructor: <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @isAlive = <strong class="prompt">true</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    Tribble.count++<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">  # Prototype properties</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  breed: <strong class="prompt">-&gt;</strong> <strong class="prompt">new</strong> Tribble <strong class="prompt">if</strong> @isAlive</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  die: <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    Tribble.count-- <strong class="prompt">if</strong> @isAlive</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @isAlive = <strong class="prompt">false</strong>
<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">  # Class-level properties</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @count: 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @makeTrouble: <strong class="prompt">-&gt;</strong> console.log (<em class="string">'Trouble!'</em> <strong class="prompt">for</strong> i <strong class="prompt">in</strong> [1..@count]).join(<em class="string">' '</em>)</code>
</td>
</tr>
</table>
<p id="N12B20" class="calibre5">
      There’s a lot of new syntax here. Let’s go through this one piece at a time.
    </p>
<p id="N12B23" class="calibre5">
      Each time a new tribble is created, <code class="cf">Tribble.count</code> is increased by one. (We can call it <code class="cf">@count</code> here because the value of <code class="cf">this</code> in the class body is the class itself.) When <code class="cf">Tribble.makeTrouble()</code> is called, it’ll display “Trouble!” <code class="cf">Tribble.count</code> times.
    </p>
<p id="N12B35" class="calibre5">
      Let’s test this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/Tribble.coffee" class="calibre23">Classes/Tribble.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tribble1 = <strong class="prompt">new</strong> Tribble</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tribble2 = <strong class="prompt">new</strong> Tribble</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Tribble.makeTrouble()<em class="comment">   # "Trouble! Trouble!"</em>
</code>
</td>
</tr>
</table>
<p id="N12B52" class="calibre5">
      Notice that <code class="cf">Tribble.count</code> is referred to as <code class="cf">@count</code> in the <code class="cf">Tribble</code> class context but not within <code class="cf">Tribble</code> methods. This is a little baffling at first, but remember that there are three objects we’re dealing with here: the <code class="cf">Tribble</code> object itself (which is actually the <code class="cf">constructor</code> function), <code class="cf">Tribble.prototype</code>, and the <code class="cf">Tribble</code> instance. By default, <code class="cf">Tribble</code> properties (other than <code class="cf">constructor</code>) are attached to the prototype. When we use the <code class="cf">@</code> prefix, we’re insisting that we want to attach the property to the class object itself.
    </p>
<p id="N12B79" class="calibre5">
      Because the functions attached to the prototype are invoked in the context of the individual object (as is the constructor), variables prefixed with <code class="cf">@</code> within those functions are references to instance properties. This is why we define <code class="cf">@isAlive</code> in the constructor: we need to attach a separate <code class="cf">@isAlive</code> property to each instance. That lets us do this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/Tribble.coffee" class="calibre23">Classes/Tribble.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tribble1.die()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Tribble.makeTrouble()<em class="comment">   # "Trouble!"</em>
</code>
</td>
</tr>
</table>
<p id="N12B96" class="calibre5">
      Killing <code class="cf">tribble1</code> off again would have no effect, thanks to the <code class="cf">if @isAlive</code> check. And as we know, tribbles are born pregnant, so it won’t be long before the species repopulates our program:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/Tribble.coffee" class="calibre23">Classes/Tribble.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tribble2.breed().breed().breed()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Tribble.makeTrouble()<em class="comment">   # "Trouble! Trouble! Trouble! Trouble!"</em>
</code>
</td>
</tr>
</table>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

