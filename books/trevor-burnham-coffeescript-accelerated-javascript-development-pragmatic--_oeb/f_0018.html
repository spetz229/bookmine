---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0017.html
next: f_0019.html
book_path: books/trevor-burnham-coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.functions" class="calibre13">2.1 Functions 101</h2>
<p id="N108A6" class="calibre5">
      It’s finally time to declare our first function! Check it out:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">-&gt;</strong> <em class="string">'Hello, functions!'</em>
</code>
</td>
</tr>
</table>
<p id="N108C2" class="calibre5">
      I didn’t say it would be a <span class="emph">useful</span> function, did I? But it does do something: it returns a string.
    </p>
<p id="N108C8" class="calibre5">
      Don’t take my word for it. Punch this into your favorite text editor and hit the Run command:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log <strong class="prompt">do</strong> <strong class="prompt">-&gt;</strong> <em class="string">'Hello, functions!'</em>
</code>
</td>
</tr>
</table>
<p id="N108DE" class="calibre5">
      You’ll be greeted with something cheerful:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Hello, functions!</code>
</td>
</tr>
</table>
<p id="N108EC" class="calibre5">
      What does <code class="cf">do</code> do? (It has nothing to do with JavaScript’s <code class="cf">do...while</code> loop.) It just means “run the following function.” We could have done the same thing using a mess of parentheses:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log (<strong class="prompt">-&gt;</strong> <em class="string">'Hello functions!'</em>)()</code>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Hello, functions!</code>
</td>
</tr>
</table>
<p id="N10915" class="calibre5">“Where’s the <code class="cf">return</code> keyword,” you ask? CoffeeScript takes a cue from Ruby here, implicitly returning the last expression from each function. You can still use <code class="cf">return</code> explicitly, but it’s optional, and the preferred style is to omit it unless you’re breaking the flow of execution. If you <span class="emph">don’t</span> want to return anything, use <code class="cf">return</code> by itself.
    </p>
<p id="N10933" class="calibre5">
      So far, our function has been anonymous. Anonymous functions have their uses, but this one is really aching for a name:

    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">hi = <strong class="prompt">-&gt;</strong> <em class="string">'Hello, functions!'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log hi()</code>
</td>
</tr>
</table>
<p id="N10951" class="calibre5">
      Once again, we get this response:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Hello, functions!</code>
</td>
</tr>
</table>
<p id="N1095F" class="calibre5">
      Naming a function in CoffeeScript just means assigning it to a variable. Note that we could have written <code class="cf">do hi</code> instead of <code class="cf">hi()</code>. But in practice, <code class="cf">do</code> is usually only used to create scope, especially during iteration. More on that in <a href="f_0056.html#sec.scopeInLoops">​<em class="emph">Scope in Loops</em>​</a>.
    </p>
<div class="sidebar" id="sb.jsFunctionSyntaxes">
<div class="sidebar-title">A Tale of Two Function Declaration Syntaxes</div>
<div class="calibre1">
<p id="N1097C" class="calibre5">
        In JavaScript, there are two ways of defining a function. Here’s one:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">
<strong class="prompt">var</strong> cube1 = <strong class="prompt">function</strong>(x) { <strong class="prompt">return</strong> Math.pow(x, 3); };</code>
</td>
</tr>
</table>
<p id="N10997" class="calibre5">
        Here’s another:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">
<strong class="prompt">function</strong> cube2(x) { <strong class="prompt">return</strong> Math.pow(x, 3); }</code>
</td>
</tr>
</table>
<p id="N109AA" class="calibre5">
        The main difference between these two is that if you were to call <code class="cf1">cube1</code> before it’s defined, you would get an error, but if you called <code class="cf1">cube2</code> from earlier within its scope, the interpreter would automatically look ahead to the function definition.
      </p>
<p id="N109B3" class="calibre5">
        Due to a thorny issue in IE, CoffeeScript always generates variable-style function declarations, like <code class="cf1">cube1</code>. (The one exception is that “named” functions are generated by the <code class="cf1">class</code> keyword, as we’ll see in Section 4.3, <a href="f_0040.html#sec.classes">​<em class="emph">Classes: Functions with Prototypes</em>​</a>.) So don’t forget to define your functions before you call them!
      </p>
</div>
</div>
<p id="N109BF" class="calibre5">
      But what’s the use of just returning a constant from a function? Not much. So let’s make this function a bit more versatile:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">greeting = (subject) <strong class="prompt">-&gt;</strong> <em class="string">"Hello, </em>#{subject}<em class="string">!"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log greeting <em class="string">'arguments'</em>
</code>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">'Hello, arguments!'</code>
</td>
</tr>
</table>
<p id="N109E5" class="calibre5">
      We’ve added an argument list, <code class="cf">(subject)</code>, in front of the <code class="cf">-&gt;</code>. (Note that parentheses are optional in function calls but not in argument lists, except when the argument list is empty. For details, see <a href="#sb.implicitParentheses">​<em class="emph">Implicit Parentheses</em>​</a>.) And we’ve used string interpolation to insert an expression into a string.
    </p>
<p id="N109FB" class="calibre5">
      CoffeeScript’s interpolation syntax is similar to Ruby’s: <code class="cf">"A#{<span class="emph">expression</span>}Z"</code> is equivalent to <code class="cf">’A’ + (<span class="emph">expression</span>) + ’Z’</code>. Interpolations only work in <span class="emph">double-quoted</span> strings. (As a matter of style, I prefer to use single-quoted strings whenever I’m not doing an interpolation so as to clearly convey that there’s no funny business going on.)
      </p>
<p id="N10A17" class="calibre5">
      Word to the wise: CoffeeScript’s <code class="cf">+</code> operator is sensitive to whitespace. So string concatenation like this works fine:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">squadron = <em class="string">'Red'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">xWing = squadron + 5<em class="comment">    # 'Red5'</em>
</code>
</td>
</tr>
</table>
<p id="N10A2F" class="calibre5">
      However, this doesn’t:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">squadron = <em class="string">'Red'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">xWing = squadron +5<em class="comment">     # TypeError</em>
</code>
</td>
</tr>
</table>
<p id="N10A44" class="calibre5">
      The problem is that <code class="cf">squadron +5</code> compiles to <code class="cf">squadron(+5)</code>. (The <code class="cf">+</code> prefix is a handy way of converting strings to numbers.) Since <code class="cf">squadron</code> is a string, not a function, this gives us an error. String interpolation prevents this gotcha:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">squadron = <em class="string">'Red'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">xWing = <em class="string">"</em>#{squadron}<em class="string">5"</em>
<em class="comment">  # 'Red5'</em>
</code>
</td>
</tr>
</table>
<div class="sidebar" id="sb.implicitParentheses">
<div class="sidebar-title">Implicit Parentheses</div>
<div class="calibre1">
<p id="N10A6E" class="calibre5">
        The ability to omit parentheses from function calls is a double-edged sword. To use this power wisely, you need to understand one simple rule: <span class="emph">implicit parentheses don’t close until the end of the expression.</span>
</p>
<p id="N10A7B" class="calibre5">
        Expecting CoffeeScript to understand what you’re trying to do is a common rookie mistake. For instance, you might be surprised if you were to write the following:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">console.log(Math.round 3.1, Math.round 5.2)</code>
</td>
</tr>
</table>
<p id="N10A89" class="calibre5">
        The output for this is <code class="cf1">3</code>. What happened to <code class="cf1">Math.round 5.2</code>? The answer is clear when we make the parentheses explicit:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">console.log(Math.round(3.1, Math.round(5.2)))</code>
</td>
</tr>
</table>
<p id="N10A9D" class="calibre5">
<code class="cf1">Math.round(5.2)</code> was evaluated, but then it was passed as an argument to the other <code class="cf1">Math.round</code> (which ignored it), rather than to <code class="cf1">console.log</code> as intended.
      </p>
<p id="N10AA8" class="calibre5">
        To avoid confusion, I like to use parentheses for everything but the outermost function call:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">console.log Math.round(3.1), Math.round(5.2)<em class="comment"> # 3, 5</em>
</code>
</td>
</tr>
</table>
</div>
</div>
<h3 id="sec.argumentsObkect" class="calibre14">Accessing ’arguments’</h3>
<p id="N10ABD" class="calibre5">
        This is as good a time as any to mention that you can access all arguments to a function using JavaScript’s array-like <code class="cf">arguments</code> object, whether they’re declared in the argument list or not. For example, we could’ve written our <code class="cf">greeting</code> function like this:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">greeting = <strong class="prompt">-&gt;</strong> <em class="string">"Hello, </em>#{arguments[0]}<em class="string">!"</em>
</code>
</td>
</tr>
</table>
<p id="N10ADE" class="calibre5">
        The <code class="cf">arguments</code> object is typically used when a function needs to accept a varying number of arguments. Of course, this versatility comes at the price of readability. It’s also a common source of JavaScript headaches, as <code class="cf">arguments</code> acts like an array without supporting many of a normal array’s methods.
      </p>
<p id="N10AE7" class="calibre5">
        Fortunately, you rarely need to work with <code class="cf">arguments</code> directly in CoffeeScript, thanks to a feature we’ll learn about in Section 2.6, <a href="f_0023.html#sec.splats">​<em class="emph">Splats (...)</em>​</a>.
      </p>
<h3 id="sec.conditionals" class="calibre14">Conditionals and Exceptions</h3>
<p id="N10AF5" class="calibre5">
        Now, let’s write a numeric function for a change of pace:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">cube = (num) <strong class="prompt">-&gt;</strong> Math.pow num, 3</code>
</td>
</tr>
</table>
<p id="N10B06" class="calibre5">
        Notice that the <code class="cf">Math</code> object, as part of the JavaScript standard, is identical in CoffeeScript (and, for that matter, across all major browser and server-side environments).
      </p>
<p id="N10B11" class="calibre5">
        How about something a little more complex: a boolean test?
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">odd = (num) <strong class="prompt">-&gt;</strong> num % 2 is 1</code>
</td>
</tr>
</table>
<p id="N10B22" class="calibre5">
<code class="cf">%</code> is the modulus operator; it gives us the remainder after division. The <code class="cf">is</code> keyword compiles to JavaScript’s <code class="cf">===</code>, the strict equality operator. (There is no analog to JavaScript’s <code class="cf">==</code>; see <a href="#sb.looseEquals">​<em class="emph">Strict Equality or Nothing</em>​</a>.) Hence, <code class="cf">odd</code> will return <code class="cf">true</code> if the given number is a positive integer that is not divisible by 2 and <code class="cf">false</code> otherwise. (Because <code class="cf">%</code> coerces its values to numbers, <code class="cf">odd</code> will also return <code class="cf">true</code> for, say, the string <code class="cf">’3’</code>.)
        </p>
<div class="sidebar" id="sb.looseEquals">
<div class="sidebar-title">Strict Equality or Nothing</div>
<div class="calibre1">
<p id="N10B62" class="calibre5">
          CoffeeScript’s <code class="cf1">is</code> and <code class="cf1">==</code> both compile to JavaScript’s <code class="cf1">===</code>; there’s no way to get the loose, type-coercing equality check of JavaScript’s <code class="cf1">==</code>, which is frowned upon by JSLint and others as the source of many “WTF?” moments. Let’s borrow an example from <a href="http://wtfjs.com/2011/02/11/all-your-commas-are-belong-to-Array">http://wtfjs.com/2011/02/11/all-your-commas-are-belong-to-Array</a>:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">
<em class="string">",,,"</em> == <strong class="prompt">new</strong> Array(4)  <em class="comment">// true</em>
</code>
</td>
</tr>
</table>
<p id="N10B97" class="calibre5">
          There are also cases where <code class="cf1">==</code> isn’t transitive:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">
<em class="string">''</em> == <em class="string">'0'</em>           <em class="comment">// false</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">0 == <em class="string">''</em>             <em class="comment">// true</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">0 == <em class="string">'0'</em>            <em class="comment">// true</em>
</code>
</td>
</tr>
</table>
<p id="N10BBF" class="calibre5">
          To avoid these head-scratchers, you should perform type conversions explicitly.
        </p>
</div>
</div>
<p id="N10BC2" class="calibre5">
        Now in most settings this would be considered a perfectly good oddness check. But let’s suppose that you’re writing a math library with very strict specifications that state that if the function is given a value that isn’t strictly a positive integer, then it should throw an exception. We can do that by using conditionals, like so:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/odd.coffee" class="calibre23">Functions/odd.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">odd = (num) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">if</strong> <strong class="prompt">typeof</strong> num is <em class="string">'number'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">if</strong> num is Math.round num</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">if</strong> num &gt; 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        num % 2 is 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        <strong class="prompt">throw</strong> <em class="string">"</em>#{num}<em class="string"> is not positive"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">throw</strong> <em class="string">"</em>#{num}<em class="string"> is not an integer"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">throw</strong> <em class="string">"</em>#{num}<em class="string"> is not a number"</em>
</code>
</td>
</tr>
</table>
<p id="N10C28" class="calibre5">
        Note the use of significant indentation to delimit both the function and each conditional branch, rather than the curly braces of JavaScript. In CoffeeScript, curly braces are used for one thing only: declaring JSON-style objects. (More on that in the next chapter.)
      </p>
<p id="N10C36" class="calibre5">
        Now if you try calling <code class="cf">odd</code> with anything but a positive integer, you’ll get <code class="cf">undefined</code> (since <code class="cf">throw</code> statements have no return value). In order to actually see the error message, you’ll need to use a <code class="cf">try...catch</code> block:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/odd.coffee" class="calibre23">Functions/odd.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">try</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  odd 5.1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">catch</strong> e</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log e</code>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">5.1 is not an integer</code>
</td>
</tr>
</table>
<p id="N10C72" class="calibre5">
        We could improve the style of the <code class="cf">odd</code> function by simply checking each of our three conditions in turn:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/odd.coffee" class="calibre23">Functions/odd.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">odd = (num) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">unless</strong> <strong class="prompt">typeof</strong> num is <em class="string">'number'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">throw</strong> <em class="string">"</em>#{num}<em class="string"> is not a number"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">unless</strong> num is Math.round num</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">throw</strong> <em class="string">"</em>#{num}<em class="string"> is not an integer"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">unless</strong> num &gt; 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">throw</strong> <em class="string">"</em>#{num}<em class="string"> is not positive"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  num % 2 is 1</code>
</td>
</tr>
</table>
<p id="N10CC1" class="calibre5">
        (If those lines weren’t so long, we’d use the postfix style, <code class="cf">throw a unless b</code>, rather than the indented style.) In general, whenever conditions lead to <code class="cf">throw</code> or <code class="cf">return</code>, we can simplify branching logic to a simple series check.
      </p>
<p id="N10CCD" class="calibre5">
        Of course, functions aren’t limited to just returning values and throwing exceptions; they can also do stuff by modifying variables and running other functions. (In functional programming parlance, these are known as <span class="emph">side effects</span>.) These work just as you would expect from JavaScript:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">count = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">incrementCount = <strong class="prompt">-&gt;</strong> count++</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">incrementCount()<em class="comment">   # count is now 1</em>
</code>
</td>
</tr>
</table>
<p id="N10CE9" class="calibre5">
      Now you know the basics of defining and calling functions in CoffeeScript. But the devil’s in the details, so let’s look at one of the most important details: Where are variables visible?
    </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

