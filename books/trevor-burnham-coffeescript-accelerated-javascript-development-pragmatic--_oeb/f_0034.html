---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0033.html
next: f_0035.html
book_path: books/trevor-burnham-coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.collectionsProject" class="calibre13">3.7 Project: 5x5 Solitaire</h2>
<p id="N12285" class="calibre5">
      
      Since we handled input in the last chapter, there are just a few things our app has to do in order to be a full-fledged game. Let’s start with the simplest pieces of the puzzle, then move on to the harder ones.
    </p>
<p id="N12288" class="calibre5">
      First things first: We’ll need some words. Fortunately, the word list used at Scrabble tournaments, the Second Official Tournament and Club Word List (known to die-hard Scrabblers as the OWL2) is publicly available. One version of it is included with the book’s code.<a id="FNPTR-31" href="f_0036.html#FOOTNOTE-31">[31]</a>
</p>
<p id="N12297" class="calibre5">
      We’ll store this word list as an array. (Another data structure, such as a binary tree, would yield more efficient lookups, but I’ll leave such optimizations in the reader’s capable hands.) But first, we need to access it through Node’s file system (<code class="cf">fs</code>) module:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">fs = require <em class="string">'fs'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">owl2 = fs.readFileSync <em class="string">'OWL2.txt'</em>, <em class="string">'utf8'</em>
</code>
</td>
</tr>
</table>
<p id="N122B8" class="calibre5">
<code class="cf">readFileSync</code> simply reads the contents of a file into a string. The <code class="cf">Sync</code> suffix means that, unlike most Node.js I/O functions, this one blocks our program’s execution until it completes. If we had some work to do in the background while the file is being read, then we’d use <code class="cf">readFile</code> with a callback instead, allowing us to continue processing while the operating system loads the file in the background.
      </p>
<p id="N122D3" class="calibre5">
      Each line of our dictionary contains a word along with its definition and sentence part, such as this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">OD a hypothetical force of natural power [n -S]</code>
</td>
</tr>
</table>
<p id="N122E0" class="calibre5">
      As fascinating as this additional information is, we won’t be using it. So let’s use a simple regex to extract just the first word from each line:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">wordList = owl2.match /^(\w+)/mg</code>
</td>
</tr>
</table>
<p id="N122EF" class="calibre5">
      Then we cut the word list down to just those words that could plausibly fit on the grid:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">wordList = (word <strong class="prompt">for</strong> word <strong class="prompt">in</strong> wordList <strong class="prompt">when</strong> word.length &lt;= GRID_SIZE)</code>
</td>
</tr>
</table>
<p id="N12307" class="calibre5">
      where <code class="cf">GRID_SIZE</code> is a constant that we’ve set to 5. (Of course, we could have done this more efficiently by tweaking our regex to only capture short words.)
    </p>
<p id="N1230D" class="calibre5">
      Now we’ll define a function to check whether a given word is valid:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">isWord = (str) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  str <strong class="prompt">in</strong> wordList</code>
</td>
</tr>
</table>
<p id="N12324" class="calibre5">
      Simple, right? Recall that <code class="cf">x in arr</code> just tells us whether the value <code class="cf">x</code> is in the array <code class="cf">arr</code>. (This differs from JavaScript’s <code class="cf">in</code>, whose CoffeeScript analog is  <code class="cf">of</code>.)
    </p>
<p id="N12336" class="calibre5">
      Generating a random grid will be a little bit trickier. First we’ll need a way of generating random letters with the right probability distribution:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"># Probabilities are taken from Scrabble, except that there are no blanks.</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"># See http://www.hasbro.com/scrabble/en_US/faqGeneral.cfm</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tileCounts =</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  A: 9, B: 2, C: 2, D: 4, E: 12, F: 2, G: 3, H: 2, I: 9, J: 1, K: 1, L: 4</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  M: 2, N: 6, O: 8, P: 2, Q: 1, R: 6, S: 4, T: 6, U: 4, V: 2, W: 2, X: 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  Y: 2, Z: 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">totalTiles = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">totalTiles += count <strong class="prompt">for</strong> letter, count <strong class="prompt">of</strong> tileCounts<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"># JavaScript hashes are unordered, so we need to make our own key array:</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">alphabet = (letter <strong class="prompt">for</strong> letter <strong class="prompt">of</strong> tileCounts).sort()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">randomLetter = <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  randomNumber = Math.ceil Math.random() * totalTiles</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  x = 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> letter <strong class="prompt">in</strong> alphabet</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    x += tileCounts[letter]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">return</strong> letter <strong class="prompt">if</strong> x &gt; randomNumber</code>
</td>
</tr>
</table>
<p id="N1239C" class="calibre5">
      And now we generate the grid using a nested array comprehension:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"># grid is a 2D array: grid[col][row], where 0, 0 is the upper-left corner</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">grid = <strong class="prompt">for</strong> x <strong class="prompt">in</strong> [0...GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> y <strong class="prompt">in</strong> [0...GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    randomLetter()</code>
</td>
</tr>
</table>
<p id="N123C1" class="calibre5">
      We’ll also want to pretty-print the grid (this is a word game, not Zork):
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">printGrid = <strong class="prompt">-&gt;</strong>
<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">  # Transpose the grid so we can draw rows</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  rows = <strong class="prompt">for</strong> x <strong class="prompt">in</strong> [0...GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">for</strong> y <strong class="prompt">in</strong> [0...GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      grid[y][x]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  rowStrings = (<em class="string">' '</em> + row.join(<em class="string">' | '</em>) <strong class="prompt">for</strong> row <strong class="prompt">in</strong> rows)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  rowSeparator = (<em class="string">'-'</em> <strong class="prompt">for</strong> i <strong class="prompt">in</strong> [1...GRID_SIZE * 4]).join(<em class="string">''</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">'\n'</em> + rowStrings.join(<em class="string">"\n</em>#{rowSeparator}<em class="string">\n"</em>) + <em class="string">'\n'</em>
</code>
</td>
</tr>
</table>
<p id="N12418" class="calibre5">
      Finally, we get to scoring. We’ll start with a hash of Scrabble letter values and an array for keeping track of words that have already been used:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"># Each letter has the same point value as in Scrabble.</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tileValues =</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  A: 1, B: 3, C: 3, D: 2, E: 1, F: 4, G: 2, H: 4, I: 1, J: 8, K: 5, L: 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  M: 3, N: 1, O: 1, P: 3, Q: 10, R: 1, S: 1, T: 1, U: 1, V: 4, W: 4, X: 8,</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  Y: 4, Z: 10</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">moveCount = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">score = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">usedWords = []</code>
</td>
</tr>
</table>
<p id="N12449" class="calibre5">
      Now for our actual scoring function. It takes a grid and the zero-indexed coordinates of the two tiles that were swapped and relies on a <code class="cf">wordsThroughTile</code> function that returns every word going through a particular tile of the grid:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">scoreMove = (grid, swapCoordinates) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  {x1, x2, y1, y2} = swapCoordinates</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  words = wordsThroughTile(grid, x1, y1).concat wordsThroughTile(grid, x2, y2)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  moveScore = multiplier = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  newWords = []</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> word <strong class="prompt">in</strong> words <strong class="prompt">when</strong> word not <strong class="prompt">in</strong> usedWords and word not <strong class="prompt">in</strong> newWords</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    multiplier++</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    moveScore += tileValues[letter] <strong class="prompt">for</strong> letter <strong class="prompt">in</strong> word</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    newWords.push word</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  usedWords = usedWords.concat newWords</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  moveScore *= multiplier</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  {moveScore, newWords}</code>
</td>
</tr>
</table>
<p id="N12493" class="calibre5">
      The <code class="cf">wordsThroughTile</code> function itself is trickier, since we need to go through a point in a 2-D array in four different directions while ensuring we don’t go out of range. Let’s look at the whole thing, and then I’ll break it down a bit:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">wordsThroughTile = (grid, x, y) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  strings = []</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> length <strong class="prompt">in</strong> [MIN_WORD_LENGTH..GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    range = length - 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    addTiles = (func) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      strings.push (func(i) <strong class="prompt">for</strong> i <strong class="prompt">in</strong> [0..range]).join <em class="string">''</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">for</strong> offset <strong class="prompt">in</strong> [0...length]<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">      # Vertical</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">if</strong> inRange(x - offset, y) and inRange(x - offset + range, y)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        addTiles (i) <strong class="prompt">-&gt;</strong> grid[x - offset + i][y]<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">      # Horizontal</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">if</strong> inRange(x, y - offset) and inRange(x, y - offset + range)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        addTiles (i) <strong class="prompt">-&gt;</strong> grid[x][y - offset + i]<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">      # Diagonal (upper-left to lower-right)</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">if</strong> inRange(x - offset, y - offset) and</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">         inRange(x - offset + range, y - offset + range)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        addTiles (i) <strong class="prompt">-&gt;</strong> grid[x - offset + i][y - offset + i]<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">      # Diagonal (lower-left to upper-right)</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">if</strong> inRange(x - offset, y + offset) and</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">         inRange(x - offset + range, y + offset - range)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        addTiles (i) <strong class="prompt">-&gt;</strong> grid[x - offset + i][y + offset - i]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  str <strong class="prompt">for</strong> str <strong class="prompt">in</strong> strings <strong class="prompt">when</strong> isWord str</code>
</td>
</tr>
</table>
<p id="N12525" class="calibre5">
      The outer loop <code class="cf">for length in [MIN_WORD_LENGTH..GRID_SIZE]</code> iterates through all game-level legal word sizes (in our case, from 2 to 5). We define an <code class="cf">addTiles</code> function that calls a given function with each integer value <code class="cf">i</code> from 0 to <code class="cf">length - 1</code> inclusive and then combines the results (which are characters) as a single string. The argument to <code class="cf">addTiles</code> is a function that, given <code class="cf">i</code>, returns the value of the tile <code class="cf">i</code> steps from the starting point in a certain direction. 
    </p>
<p id="N1253D" class="calibre5">
      The inner loop, <code class="cf">for offset in [0...length]</code>, is there because we want all words <span class="emph">through</span> the given tile, not just those starting at it. For instance, in the vertical direction and when offset is 0, we get all the words going down from the given tile; when offset is 1, we get all the words going down from the tile above the given tile; and so on up to the edge of the grid.
    </p>
<p id="N12546" class="calibre5">
      Speaking of edges, those <code class="cf">inRange</code> checks ensure that both ends of a potential word are within the grid. If those tests pass, we send a callback to <code class="cf">addTiles</code> providing the tile value at each step <code class="cf">i</code>, and <code class="cf">addTiles</code> pushes the potential word to our <code class="cf">strings</code> list. Those items in <code class="cf">strings</code> that pass the <code class="cf">isWord</code> test get returned from the function.
    </p>
<p id="N1255E" class="calibre5">
      (The use of function passing in <code class="cf">addTiles</code> may seem unnecessary, but it actually greatly simplified the <code class="cf">wordsThroughTile</code> function; in an earlier version, the same loop and <code class="cf">join</code> code was repeated four times!)
    </p>
<p id="N1256A" class="calibre5">
      Whew! Now to initialize the game. We’ll want to count words that are already in the grid at the start as used, which we can do by performing <code class="cf">scoreMove</code> on a “swap” of each tile with itself:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log <em class="string">"Welcome to 5x5!"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">for</strong> x <strong class="prompt">in</strong> [0...GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> y <strong class="prompt">in</strong> [0...GRID_SIZE]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    scoreMove grid, {x1: x, x2: x, y1: y, y2: y}</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">unless</strong> usedWords.length is 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"""</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">    Initially used words:</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string"></em>#{usedWords.join(<em class="string">', '</em>)}</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">  """</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log <em class="string">"Please choose a tile in the form (x, y)."</em>
</code>
</td>
</tr>
</table>
<p id="N125BA" class="calibre5">
      Finally, we plug in the input code from the last chapter, modifying our prompts to actually work:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">promptForTile1 = <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  printGrid()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"Please enter coordinates for the first tile."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  inputCallback = (input) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">try</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      {x, y} = strToCoordinates input</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">catch</strong> e</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log e</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">return</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    promptForTile2 x, y</code>
</td>
</tr>
</table>
<table class="figure" id="fig.console5x5">
<tr class="calibre8">
<td class="calibre10">
<img xmlns:str="http://exslt.org/strings" src="images/console5x5.png" alt="images/console5x5.png" class="calibre18"/>
</td>
</tr>
<tr class="calibre8">
<td class="calibre19">
<hr class="calibre20"/>
<b class="calibre21">Figure 4. Playing with our command-line prompt</b>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Collections/5x5/game.coffee" class="calibre23">Collections/5x5/game.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">promptForTile2 = (x1, y1) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"Please enter coordinates for the second tile."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  inputCallback = (input) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">try</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      {x: x2, y: y2} = strToCoordinates input</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">catch</strong> e</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log e</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">return</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">if</strong> x1 is x2 and y1 is y2</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log <em class="string">"The second tile must be different from the first."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log <em class="string">"Swapping (</em>#{x1}<em class="string">, </em>#{y1}<em class="string">) with (</em>#{x2}<em class="string">, </em>#{y2}<em class="string">)..."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      x1--; x2--; y1--; y2--;<em class="comment"> # convert 1-based indices to 0-based</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      [grid[x1][y1], grid[x2][y2]] = [grid[x2][y2], grid[x1][y1]]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      {moveScore, newWords} = scoreMove grid, {x1, y1, x2, y2}</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">unless</strong> moveScore is 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        console.log <em class="string">"""</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">          You formed the following word(s):</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string"></em>#{newWords.join(<em class="string">', '</em>)}</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">        """</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        score += moveScore</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      moveCount++</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log <em class="string">"Your score after </em>#{moveCount}<em class="string"> moves: </em>#{score}<em class="string">"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      promptForTile1()</code>
</td>
</tr>
</table>
<p id="N1268B" class="calibre5">
      That’s it! Run the game (<code class="cf">coffee game.coffee</code>), and you should see something like Figure 4, <a href="#fig.console5x5">​<em class="emph">Playing with our command-line prompt</em>​</a>.
      </p>
<p id="N12697" class="calibre5">
      Of course, this program is far from a masterpiece. On the front end, the interface is a little…classical? And on the programmer side of things, the code is awfully disorganized. We’ll be addressing the latter problem in the next chapter, and then we’ll move on to use jQuery to turn our humble command-line game into a much more sophisticated browser-based experience. Finally, we’ll use a Node server-side app to add multiplayer support.
    </p>
<p id="N1269A" class="calibre5">
      The great thing about CoffeeScript is that we can reuse its code in all of these settings. Whether we’re running the game in a browser or on a server, the code for scoring a move will remain the same. That convergence of client and server has all kinds of practical uses—think of form validation, for one. And with a thorough understanding of objects and loops, you’re well on your way to mastering the language.
    </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

