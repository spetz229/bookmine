---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0031.html
next: f_0033.html
book_path: books/trevor-burnham-coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.comprehensions" class="calibre13">3.5 Comprehensions</h2>
<p id="N1205B" class="calibre5">
      In functional languages like Scheme, Haskell, and OCaml, you rarely need loops. Instead, you iterate over arrays with operations like map, reduce, and compact. Many of these operations can be added to JavaScript through libraries, such as Underscore.js.<a id="FNPTR-30" href="f_0036.html#FOOTNOTE-30">[30]</a> But to gain maximum succinctness and flexibility, a language needs array comprehensions (also known as list comprehensions).
    </p>
<p id="N1206F" class="calibre5">
      Think of all the times you’ve looped over an array just to create another array based on the first. For instance, to negate an array of numbers in JavaScript, you’d write the following:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">positiveNumbers = [1, 2, 3, 4];</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">negativeNumbers = [];</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">for</strong> (i = 0; i &lt; positiveNumbers.length; i++) {</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  negativeNumbers.push(-positiveNumbers[i]);</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">}</code>
</td>
</tr>
</table>
<p id="N1208B" class="calibre5">
      Now here’s the equivalent CoffeeScript, using an array comprehension:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">negativeNumbers = (-num <strong class="prompt">for</strong> num <strong class="prompt">in</strong> [1, 2, 3, 4])</code>
</td>
</tr>
</table>
<p id="N1209F" class="calibre5">
      You can also use the comprehension syntax with a conditional loop:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">keysPressed = (char <strong class="prompt">while</strong> char = handleKeyPress())</code>
</td>
</tr>
</table>
<p id="N120B0" class="calibre5">
      Do you see what’s going on here? Every loop in CoffeeScript returns a value. That value is an array containing the result of every loop iteration (except those skipped by a  <code class="cf">continue</code> or <code class="cf">break</code> or as a result of a <code class="cf">when</code> clause). And it’s not just one-line loops that do this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">code = [<em class="string">'U'</em>, <em class="string">'U'</em>, <em class="string">'D'</em>, <em class="string">'D'</em>, <em class="string">'L'</em>, <em class="string">'R'</em>, <em class="string">'L'</em>, <em class="string">'R'</em>, <em class="string">'B'</em>, <em class="string">'A'</em>]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">codeKeyValues = <strong class="prompt">for</strong> key <strong class="prompt">in</strong> code</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">switch</strong> key</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'L'</em> <strong class="prompt">then</strong> 37</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'U'</em> <strong class="prompt">then</strong> 38</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'R'</em> <strong class="prompt">then</strong> 39</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'D'</em> <strong class="prompt">then</strong> 40</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'A'</em> <strong class="prompt">then</strong> 65</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'B'</em> <strong class="prompt">then</strong> 66</code>
</td>
</tr>
</table>
<p id="N1213C" class="calibre5">
      (Do you see why we needed to use parentheses for the one-liners, but we don’t here? Also, you’re probably wondering about <code class="cf">switch</code>; it’ll become clearer in <a href="f_0041.html#sec.switch">​<em class="emph">Polymorphism and Switching</em>​</a>.)
    </p>
<p id="N12145" class="calibre5">
     Note that you can use comprehensions in conjunction with the <code class="cf">for</code> loop modifiers, <code class="cf">by</code> and <code class="cf">when</code>:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">evens = (x <strong class="prompt">for</strong> x <strong class="prompt">in</strong> [2..10] <strong class="prompt">by</strong> 2)</code>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">isInteger = (num) <strong class="prompt">-&gt;</strong> num is Math.round(num)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">numsThatDivide960 = (num <strong class="prompt">for</strong> num <strong class="prompt">in</strong> [1..960] <strong class="prompt">when</strong> isInteger(960 / num))</code>
</td>
</tr>
</table>
<p id="N1217F" class="calibre5">
      List comprehensions are the consequence of a core part of CoffeeScript’s philosophy: everything in CoffeeScript is an expression. And every expression has a value. So what’s the value of a loop? An array of the loop’s iteration values, naturally.
    </p>
<p id="N12182" class="calibre5">
      Another part of CoffeeScript’s philosophy is DRY: Don’t Repeat Yourself. In the next section, we’ll meet one of my favorite antirepetition features.
      </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

