---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0048.html
next: f_0050.html
book_path: books/trevor-burnham-coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.jqueryEvents" class="calibre13">5.4 Reacting to Events</h2>
<p id="N13434" class="calibre5">
      We’ve seen how jQuery makes it easy to grab, change, and even add elements to the page. But jQuery, in its heart of hearts, has seen fit to bestow still one more miracle upon us mortals: simple event binding.
    </p>
<p id="N13445" class="calibre5">
      How simple? Well, let’s say that we want the big headline on our page to gain an exclamation point every time it gets clicked:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">$(<em class="string">'h1'</em>).click <strong class="prompt">-&gt;</strong> $(<strong class="prompt">this</strong>).html $(<strong class="prompt">this</strong>).html() + <em class="string">'!'</em>
</code>
</td>
</tr>
</table>
<p id="N13461" class="calibre5">
      This code selects all <code class="cf">h1</code> elements on the page, then binds a click event handler to each of them. When that click handler is triggered, it appends <code class="cf">’!’</code> to the clicked element’s contents.
    </p>
<p id="N1346A" class="calibre5">
      Event callbacks are called in the context of the DOM element that triggered the event. Often, we want to jQuerify the context element, as we do in the example above, by writing <code class="cf">$(this)</code>. 
    </p>
<div class="sidebar" id="sb.jquery.chaining">
<div class="sidebar-title">jQuery Chain Gang</div>
<div class="calibre1">
<p id="N13474" class="calibre5">
        Check this out:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">$(<em class="string">'#logo'</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">  .css(fontSize: 64)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">  .hover(<strong class="prompt">-&gt;</strong> $(<strong class="prompt">this</strong>).css(fontWeight: <em class="string">'bold'</em>))</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">  .click(<strong class="prompt">-&gt;</strong> alert <em class="string">'How dare you click the mighty logo!'</em>)</code>
</td>
</tr>
</table>
<p id="N134A2" class="calibre5">
        Here we’re using chaining—nearly all jQuery methods return the object they were called on, so the above is equivalent to this:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">$logo = $(<em class="string">'#logo'</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">$logo.css fontSize: 64</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">$logo.hover <strong class="prompt">-&gt;</strong> $logo.css fontWeight: <em class="string">'bold'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">$logo.click <strong class="prompt">-&gt;</strong> alert <em class="string">'How dare you click the mighty logo!'</em>
</code>
</td>
</tr>
</table>
<p id="N134C6" class="calibre5">
        Generally, chaining is a good thing—it tends to improve readability by reducing repetition, and it lets code minify a tad better. But be warned: some jQueryers go “chain crazy,” turning their entire app into one long, meandering chain. Use it in moderation.
      </p>
</div>
</div>
<p id="N134C9" class="calibre5">
      What happens if we bind multiple event handlers of the same type to the same elements?
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">$(<em class="string">'h1'</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  .click(<strong class="prompt">-&gt;</strong> $(<strong class="prompt">this</strong>).html $(<strong class="prompt">this</strong>).html() + <em class="string">'!'</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  .click(<strong class="prompt">-&gt;</strong> alert $(<strong class="prompt">this</strong>).text())</code>
</td>
</tr>
</table>
<p id="N134F2" class="calibre5">
      Each of those <code class="cf">click</code> calls is made on the same object; see <a href="#sb.jquery.chaining">​<em class="emph">jQuery Chain Gang</em>​</a>. Note that whitespace here is not significant; it’s purely a stylistic convention. We could easily collapse this code into a single line: <code class="cf">$(’h1’).click(-&gt; ...).click(-&gt; ...)</code>. That means that while the parentheses around the callback on the last line are optional, those around <code class="cf">’h1’</code> and the callback on the second line are not.
    </p>
<p id="N13501" class="calibre5">
      All of the event handlers will run in the order in which they were attached. So when we click a heading in this example, <code class="cf">’!’</code> will be added to its contents and the resulting text will be (irritatingly) displayed in an alert box.
    </p>
<p id="N13507" class="calibre5">
      You can unbind events using—wait for it—<code class="cf">unbind</code>. Calling <code class="cf">$elem.unbind()</code> will unbind <span class="emph">everything</span> attached to <code class="cf">$elem</code>, while <code class="cf">$elem.unbind ’click’</code> will just unbind the click events. (What if you want to unbind a specific event? See the exercises at the end of this chapter.)
    </p>
<p id="N1351D" class="calibre5">
      There’s one last thing you’ll need to know before we get to our project. Remember how I said that selectors aren’t “live”? Well, there’s one exception to that rule: when you use the aptly-named <code class="cf">live</code> method to bind an event handler. Let’s do an example:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">$(<em class="string">'#oldSpiceGuy'</em>).live <em class="string">'click'</em>, <strong class="prompt">-&gt;</strong> alert <em class="string">"I'm on a horse."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">$(<em class="string">'body'</em>).html <em class="string">'&lt;p id="oldSpiceGuy"&gt;The man your man could smell like&lt;/p&gt;'</em>
</code>
</td>
</tr>
</table>
<p id="N13549" class="calibre5">
      Even though <code class="cf">$(’#oldSpiceGuy’)</code> doesn’t match anything in the first line, the event handler will work. You see, unlike all other jQuery methods, <code class="cf">live</code> doesn’t care about the elements that were matched when you made the selection: it only cares about the selector string itself. (jQuery makes this string available via the <code class="cf">.selector</code> property.)
    </p>
<p id="N13555" class="calibre5">
      A full explanation of how <code class="cf">live</code> works is beyond the scope of this book, but it has to do with “event bubbling.”<a id="FNPTR-41" href="f_0052.html#FOOTNOTE-41">[41]</a>
</p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

