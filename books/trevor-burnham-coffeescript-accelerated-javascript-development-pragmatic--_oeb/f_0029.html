---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0028.html
next: f_0030.html
book_path: books/trevor-burnham-coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.arrays" class="calibre13">3.2 Arrays</h2>
<p id="N11AAF" class="calibre5">
      While you could use any old object to store an ordered list of values, arrays (which inherit the properties of the <code class="cf">Array</code> prototype) offer you several nice features.<a id="FNPTR-29" href="f_0036.html#FOOTNOTE-29">[29]</a>
</p>
<p id="N11ABA" class="calibre5">
      Arrays can be defined using JSON-style syntax:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">mcFlys = [<em class="string">'George'</em>, <em class="string">'Lorraine'</em>, <em class="string">'Marty'</em>]</code>
</td>
</tr>
</table>
<p id="N11AD6" class="calibre5">
      This is equivalent to the following:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">mcFlys = <strong class="prompt">new</strong> Array()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">mcFlys[0] = <em class="string">'George'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">mcFlys[1] = <em class="string">'Lorraine'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">mcFlys[2] = <em class="string">'Marty'</em>
</code>
</td>
</tr>
</table>
<p id="N11AF6" class="calibre5">
      Remember that all object keys are converted to strings, so <code class="cf">arr[1]</code>, <code class="cf">arr[’1’]</code>, and even <code class="cf">arr[{toString: -&gt; ’1’}]</code> are synonymous. (When an object has a <code class="cf">toString</code> method, its return value is used when the object is converted to a string.)
    </p>
<p id="N11B05" class="calibre5">
      Because arrays are objects, you can freely add all kinds of properties to an array, though it’s not a common practice. It’s more common to modify the <code class="cf">Array</code> prototype, adding special methods to all arrays. For instance, the Prototype.js framework does this to make arrays more Ruby-like, adding methods like <code class="cf">flatten</code> and <code class="cf">each</code>.
      </p>
<h3 id="sec.ranges" class="calibre14">Ranges</h3>
<p id="N11B19" class="calibre5">
        Fire up the REPL, because the best way to get acquainted with CoffeeScript range syntax—and its close friends, the slice and splice syntaxes, introduced in the next section—is <code class="cf">(’practice’ for i in [1..3]).join(’, ’)</code>.
      </p>
<p id="N11B23" class="calibre5">
        CoffeeScript adds a Ruby-esque syntax for defining arrays of consecutive integers:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> [1..5]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">[1, 2, 3, 4, 5]</code>
</td>
</tr>
</table>
<p id="N11B41" class="calibre5">
        The <code class="cf">..</code> defines an <span class="emph">inclusive range</span>. But often, we want to omit the last value; in those cases, we add an extra <code class="cf">.</code> to create an <span class="emph">exclusive range</span>:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> [1...5]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">[1, 2, 3, 4]</code>
</td>
</tr>
</table>
<p id="N11B6B" class="calibre5">
        (As a mnemonic, picture the extra <code class="cf">.</code> replacing the end value.) Ranges can also go backward:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> [5..1]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">[5, 4, 3, 2, 1]</code>
</td>
</tr>
</table>
<p id="N11B82" class="calibre5">
        No matter which direction the range goes in, an exclusive range omits the end value:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> [5...1]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">[5, 4, 3, 2]</code>
</td>
</tr>
</table>
<p id="N11B96" class="calibre5">
        This syntax is rarely used on its own, but as we’ll soon see, it’s essential to CoffeeScript’s <code class="cf">for</code> loops.
        </p>
<h3 id="sec.sliceSplice" class="calibre14">Slicing and Splicing</h3>
<p id="N11BA4" class="calibre5">
        When you want to tear a chunk out of a JavaScript array, you turn to the violent-sounding <code class="cf">slice</code> method:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ['a', 'b', 'c', 'd'].slice 0, 3</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['a', 'b', 'c']</code>
</td>
</tr>
</table>
<p id="N11BC4" class="calibre5">
        The two numbers given to <code class="cf">slice</code> are indices; everything from the first index up to <span class="emph">but not including</span> the second index is copied to the result. You might look at that and say, “That sounds kind of like an exclusive range.” And you’d be right:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ['a', 'b', 'c', 'd'][0...3]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['a', 'b', 'c']</code>
</td>
</tr>
</table>
<p id="N11BDE" class="calibre5">
        And you can use an inclusive range, too:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ['a', 'b', 'c', 'd'][0..3]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['a', 'b', 'c', 'd']</code>
</td>
</tr>
</table>
<p id="N11BF2" class="calibre5">
        The rules here are <span class="emph">slightly</span> different than they were for standalone ranges, though, due to the nature of <code class="cf">slice</code>. Notably, if the first index comes after the second, the result is an empty array rather than a reversal:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ['a', 'b', 'c', 'd'][3...0]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">[]</code>
</td>
</tr>
</table>
<p id="N11C0C" class="calibre5">
        Also, negative indices count backward from the end of the array. While <code class="cf">arr[-1]</code> merely looks for a property named <code class="cf">’-1’</code>, <code class="cf">arr[0...-1]</code> means “Give me a slice from the start of the array up to, but not including, its last element.” In other words, when slicing <code class="cf">arr</code>, <code class="cf">-1</code> means the same thing as <code class="cf">arr.length - 1</code>.
      </p>
<p id="N11C22" class="calibre5">
        If you omit the second index, then the slice goes all the way to the end, whether you use two dots or three:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ['this', 'that', 'the other'][1..]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['that', 'the other']</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ['this', 'that', 'the other'][1...]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['that', 'the other']</code>
</td>
</tr>
</table>
<div class="sidebar" id="sb.sliceForStrings">
<div class="sidebar-title">Slicing Strings</div>
<div class="calibre1">
<p id="N11C43" class="calibre5">
          Curiously, JavaScript provides strings with a <code class="cf1">slice</code> method, even though its behavior is identical to <code class="cf1">substring</code>. This is handy, because it means you can use CoffeeScript’s slicing syntax to get substrings:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">coffee&gt;<strong class="prompt"> 'The year is 3022'[-4..]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">3022</code>
</td>
</tr>
</table>
<p id="N11C62" class="calibre5">
          However, don’t get too carried away—while slicing works fine on strings, splicing doesn’t. Once a JavaScript string is defined, it can never be altered.
        </p>
</div>
</div>
<p id="N11C65" class="calibre5">
        CoffeeScript also provides a shorthand for <code class="cf">splice</code>, the value-inserting cousin of <code class="cf">slice</code>. It looks like you’re making an assignment to the slice:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr = ['a', 'c']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr[1...2] = ['b']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['a', 'b']</code>
</td>
</tr>
</table>
<p id="N11C8E" class="calibre5">
        The range defines the part of the array to be replaced. If the range is empty, a pure insertion occurs at the first index:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr = ['a', 'c']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr[1...1] = ['b']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['a', 'b', 'c']</code>
</td>
</tr>
</table>
<p id="N11CAE" class="calibre5">
        One important caveat: While negative indices work great for slicing, they fail completely when splicing. The trick of omitting the last index works fine, though:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> steveAustin = ['regular', 'guy']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> replacementParts = ['better', 'stronger', 'faster']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> steveAustin[0..] = replacementParts</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> steveAustin</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">['better', 'stronger', 'faster']</code>
</td>
</tr>
</table>
<p id="N11CD4" class="calibre5">
      That does it for slicing and splicing. You should now consider yourself a wizard when it comes to extracting substrings and subarrays using ranges! But ranges have another, even more fantastical use in the <code class="cf">for...in</code> syntax, as we’ll see in the next section.
      </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

