---
layout: page
title: "Learning GNU Emacs, 3rd Edition"
prev: OEBPS/ch11s02.html
next: OEBPS/ch11s04.html
book_path: books/learning-gnu-emacs--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="gnu3-CHP-11-SECT-3" class="calibre1"></a>Useful Built-in Emacs Functions</h1></div></div></div><p class="copyright">Many of the Emacs functions that
<a id="gnu3-CHP-11-ITERM-2782" class="calibre2"></a>
            <a id="gnu3-CHP-11-ITERM-2783" class="calibre2"></a>exist and that you may write involve
searching and manipulating the text in a buffer. Such functions are
particularly useful in specialized modes, like the programming
language modes described in <a class="calibre2" href="ch09.html" title="Chapter 9. Computer Language Support">Chapter 9</a>. Many
built-in Emacs functions relate to text in strings and buffers; the
most interesting ones take advantage of Emacs's
regular expression facility, which we introduced in <a class="calibre2" href="ch03.html" title="Chapter 3. Search and Replace">Chapter 3</a>.</p><p class="copyright">We first describe the basic functions relating to buffers and strings
that don't use regular expressions. Afterwards, we
discuss regular expressions in more depth than was the case in <a class="calibre2" href="ch03.html" title="Chapter 3. Search and Replace">Chapter 3</a>, concentrating on the features that are
most useful to Lisp programmers, and we describe the functions that
Emacs makes available for dealing with regular expressions.</p><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="gnu3-CHP-11-SECT-3.1" class="calibre1"></a>Buffers, Text, and Regions</h2></div></div></div><p class="copyright">
               <a class="calibre2" href="ch11s03.html#gnu3-CHP-11-TABLE-4" title="Table 11-4. Buffer and text functions">Table 11-4</a> shows some basic
<a id="gnu3-CHP-11-ITERM-2784" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2785" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2786" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2787" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2788" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2789" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2790" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2791" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2792" class="calibre2"></a>Emacs functions relating to buffers,
text, and strings that are only useful to Lisp programmers and thus
aren't bound to keystrokes. We already saw a couple
of them in the <span><strong class="calibre5">count-words-buffer</strong></span>
example. Notice that some of these are predicates, and their names
reflect this.</p><div class="book"><a id="gnu3-CHP-11-TABLE-4" class="calibre2"></a><p class="title2"><b class="calibre25">Table 11-4. Buffer and text functions</b></p><div class="table-contents"><table summary="Buffer and text functions" class="calibre8"><colgroup class="calibre9"><col class="calibre10"/><col class="calibre10"/></colgroup><thead class="calibre11"><tr class="calibre12"><th class="calibre26">
                           <p class="copyright">
                              <span><strong class="calibre5">Function</strong></span>
                           </p>
                        </th><th class="calibre27">
                           <p class="copyright">
                              <span><strong class="calibre5">Value or action</strong></span>
                           </p>
                        </th></tr></thead><tbody class="calibre15"><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">point</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Character position of point.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">mark</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Character position of mark.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">point-min</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Minimum character position (usually 1).</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">point-max</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Maximum character position (usually size of buffer).</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">bolp</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Whether point is at the beginning of the line (<span><strong class="calibre5">t</strong></span> or <strong class="calibre5"><code class="calibre21">nil</code></strong>).</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">eolp</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Whether point is at the end of the line.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">bobp</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Whether point is at the beginning of the buffer.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">eobp</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Whether point is at the end of the buffer.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">insert</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Insert any number of arguments (strings or characters) into the
buffer after point.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">number-to-string</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Convert a numerical argument to a string.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">string-to-number</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Convert a string argument to a number (integer or floating point).</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">char-to-string</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Convert a character argument to a string.</p>
                        </td></tr><tr class="calibre12"><td class="calibre28">
                           <p class="copyright">
                              <span><strong class="calibre5">substring</strong></span>
                           </p>
                        </td><td class="calibre29">
                           <p class="copyright">Given a string and two integer indices <span><em class="calibre7">start</em></span> and
<span><em class="calibre7">end</em></span>, return the substring starting after
<span><em class="calibre7">start</em></span> and ending before
<span><em class="calibre7">end</em></span>. Indices start at 0. For example,
<code class="calibre21">(substring "appropriate" 2 5)</code> returns
"<code class="calibre21">pro</code>".</p>
                        </td></tr><tr class="calibre12"><td class="calibre30">
                           <p class="copyright">
                              <span><strong class="calibre5">aref</strong></span>
                           </p>
                        </td><td class="calibre31">
                           <p class="copyright">Array indexing function that can be used to return individual
characters from strings; takes an integer argument and returns the
character as an integer, using the ASCII code (on most machines). For
example, <code class="calibre21">(aref</code> "<code class="calibre21">appropriate" 3)</code>
returns 114, the ASCII code for <code class="calibre21">r</code>.</p>
                        </td></tr></tbody></table></div></div><br class="book"/><p class="copyright">Many functions not included in the previous table deal with buffers
and text, including some that you should be familiar with as user
commands. Several commonly used Emacs functions use
<span><em class="calibre7">regions</em></span>, which are areas of text within a
buffer. When you are using Emacs, you delineate regions by setting
the mark and moving the cursor. However, region-oriented functions
(such as <span><strong class="calibre5">kill-region</strong></span>, <span><strong class="calibre5">indent-region</strong></span>, and <span><strong class="calibre5">shell-command-on-region</strong></span>—really, any
function with <span><em class="calibre7">region</em></span> in its name) are actually
more flexible when used within Emacs Lisp code. They typically take
two integer arguments that are used as the character positions of the
boundaries for the region on which they operate. These arguments
default to the values of point and mark when the functions are called
interactively.</p><p class="copyright">Obviously, allowing point and mark as interactive defaults is a more
general (and thus more desirable) approach than one in which only
point and mark can be used to delineate regions. The <span><strong class="calibre5">r</strong></span> option to the <span><strong class="calibre5">interactive</strong></span> function makes it possible. For
example, if we wanted to write the function <span><strong class="calibre5">translate-region-into-German</strong></span>, here is how we
would start:</p><a id="I_11_tt601" class="calibre2"></a><pre class="programlisting">(defun translate-region-into-German (start end)
  (interactive "r")
  ...</pre><p class="copyright">The <span><strong class="calibre5">r</strong></span> option to <span><strong class="calibre5">interactive</strong></span> fills in the two arguments
<span><strong class="calibre5">start</strong></span> and <span><strong class="calibre5">end</strong></span> when the function is called interactively,
but if it is called from other Lisp code, both arguments must be
supplied. The usual way to do this is like this:</p><a id="I_11_tt602" class="calibre2"></a><pre class="programlisting">(translate-region-into-German (point) (mark))</pre><p class="copyright">But you need not call it in this way. If you wanted to use this
function to write another function called <span><strong class="calibre5">translate-buffer-into-German</strong></span>, you would only
need to write the following as a
"wrapper":</p><a id="I_11_tt603" class="calibre2"></a><pre class="programlisting">(defun translate-buffer-into-German ( )
  (translate-region-into-German (point-min) (point-max)))</pre><p class="copyright">In fact, it is best to <span><em class="calibre7">avoid</em></span> using point and
mark within Lisp code unless doing so is really necessary; use local
variables instead. Try not to write Lisp functions as lists of
commands a user would invoke; that sort of behavior is better suited
to macros (see <a class="calibre2" href="ch06.html" title="Chapter 6. Writing Macros">Chapter 6</a>).</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="gnu3-CHP-11-SECT-3.2" class="calibre1"></a>Regular Expressions</h2></div></div></div><p class="copyright">Regular expressions (regexps) provide <a id="gnu3-CHP-11-ITERM-2793" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2794" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2795" class="calibre2"></a>much more powerful ways of dealing
with text. Although most beginning Emacs users tend to avoid commands
that use regexps, like <span><strong class="calibre5">replace-regexp</strong></span> and <span><strong class="calibre5">re-search-forward</strong></span>, regular expressions are
widely used within Lisp code. Such modes as Dired and the programming
language modes would be unthinkable without them. Regular expressions
require time and patience to become comfortable with, but doing so is
well worth the effort for Lisp programmers, because they are one of
the most powerful features of Emacs, and many things are not
practical to implement in any other way.</p><p class="copyright">One trick that can be useful when you are experimenting with regular
expressions and trying to get the hang of them is to type some text
into a scratch buffer that corresponds to what
you're trying to match, and then use <span><strong class="calibre5">isearch-forward-regexp</strong></span> (<span><strong class="calibre5">C-M-s</strong></span>) to build up the regular expression. The
interactive, immediate feedback of an incremental search can show you
the pieces of the regular expression in action in a way that is
completely unique to Emacs.</p><p class="copyright">We introduce the various features of regular expressions by way of a
few examples of search-and-replace situations; such examples are easy
to explain without introducing lots of extraneous details. Afterward,
we describe Lisp functions that go beyond simple search-and-replace
capabilities with regular expressions. The following are examples of
searching and replacing tasks that the normal search/replace commands
can't handle or handle poorly:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="copyright">You are developing code in C, and you want to combine the
functionality of the functions <code class="calibre21">read</code> and
<code class="calibre21">readfile</code> into a new function called
<code class="calibre21">get</code>. You want to replace all references to these
functions with references to the new one.</p></li><li class="listitem"><p class="copyright">You are writing a <span><em class="calibre7">troff</em></span> document using outline
mode, as described in <a class="calibre2" href="ch07.html" title="Chapter 7. Simple Text Formatting and Specialized Editing">Chapter 7</a>. In outline
mode, headers of document sections have lines that start with one or
more asterisks. You want to write a function called <span><strong class="calibre5">remove-outline-marks</strong></span> to get rid of these
asterisks so that you can run <span><em class="calibre7">troff</em></span> on your
file.</p></li><li class="listitem"><p class="copyright">You want to change all occurrences of <span><em class="calibre7">program</em></span> in
a document, including <span><em class="calibre7">programs</em></span> and
<span><em class="calibre7">program's</em></span>, to
<span><em class="calibre7">module</em></span>/<span><em class="calibre7">modules</em></span>/<span><em class="calibre7">module's</em></span>,
without changing <span><em class="calibre7">programming</em></span> to
<span><em class="calibre7">moduleming</em></span> or <span><em class="calibre7">programmer</em></span> to
<span><em class="calibre7">modulemer</em></span>.</p></li><li class="listitem"><p class="copyright">You are working on documentation for some C software that is being
rewritten in Java. You want to change all the filenames in the
documentation from <span><em class="calibre7">&lt;filename&gt;.c</em></span> to
<span><em class="calibre7">&lt;filename&gt;.java</em></span>, since
<span><em class="calibre7">.java</em></span> is the extension the
<span><em class="calibre7">javac</em></span> compiler uses.</p></li><li class="listitem"><p class="copyright">You just installed a new C++ compiler that prints error messages in
German. You want to modify the Emacs <span><strong class="calibre5">compile</strong></span> package so that it can parse the error
messages correctly (see the end of <a class="calibre2" href="ch09.html" title="Chapter 9. Computer Language Support">Chapter 9</a>).</p></li></ul></div><p class="copyright">We will soon show how to use regular expressions to deal with these
examples, which we refer to by number. Note that this discussion of
regular expressions, although more comprehensive than that in <a class="calibre2" href="ch03.html" title="Chapter 3. Search and Replace">Chapter 3</a>, does not cover every feature; those that
it doesn't cover are redundant with other features
or relate to concepts that are beyond the scope of this book. It is
also important to note that the regular expression syntax described
here is for use with Lisp strings only; there is an important
difference between the regexp syntax for Lisp strings and the regexp
syntax for user commands (like <span><strong class="calibre5">replace-regexp</strong></span>), as we will see.</p><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="gnu3-CHP-11-SECT-3.2.1" class="calibre1"></a>Basic operators</h3></div></div></div><p class="copyright">Regular expressions <a id="gnu3-CHP-11-ITERM-2796" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2797" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2798" class="calibre2"></a>began
as an idea in theoretical computer science, but they have found their
way into many nooks and crannies of everyday, practical computing.
The syntax used to represent them may vary, but the concepts are much
the same everywhere. You probably already know a subset of regular
expression notation: the wildcard characters used by the Unix shell
or Windows command prompt to match filenames. The Emacs notation is a
bit different; it is similar to those used by the language Perl,
editors like <code class="calibre21">ed </code>and <code class="calibre21">vi</code> and
Unix software tools like <code class="calibre21">lex</code> and
<code class="calibre21">grep</code>. So let's start with the
Emacs regular expression operators that resemble Unix shell wildcard
character, which are listed in <a class="calibre2" href="ch11s03.html#gnu3-CHP-11-TABLE-5" title="Table 11-5. Basic regular expression operators">Table 11-5</a>.</p><div class="book"><a id="gnu3-CHP-11-TABLE-5" class="calibre2"></a><p class="title2"><b class="calibre25">Table 11-5. Basic regular expression operators</b></p><div class="table-contents"><table summary="Basic regular expression operators" class="calibre8"><colgroup class="calibre9"><col class="calibre10"/><col class="calibre10"/><col class="calibre10"/></colgroup><thead class="calibre11"><tr class="calibre12"><th class="calibre26">
                              <p class="copyright">Emacs operator</p>
                           </th><th class="calibre26">
                              <p class="copyright">Equivalent</p>
                           </th><th class="calibre27">
                              <p class="copyright">Function</p>
                           </th></tr></thead><tbody class="calibre15"><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">.</p>
                           </td><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">?</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Matches any character.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">.*</code>
                              </p>
                           </td><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">*</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Matches any string.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">[abc]</code>
                              </p>
                           </td><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">[abc]</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Matches <code class="calibre21">a</code>, <code class="calibre21">b</code>, or
<code class="calibre21">c</code>.</p>
                           </td></tr><tr class="calibre12"><td class="calibre30">
                              <p class="copyright">
                                 <code class="calibre21">[a-z]</code>
                              </p>
                           </td><td class="calibre30">
                              <p class="copyright">
                                 <code class="calibre21">[a-z]</code>
                              </p>
                           </td><td class="calibre31">
                              <p class="copyright">Matches any lowercase letter.</p>
                           </td></tr></tbody></table></div></div><br class="book"/><p class="copyright">For example, to match all filenames beginning with
<span><em class="calibre7">program</em></span> in the Unix shell, you would specify
<code class="calibre21">program*</code>. In Emacs, you would say
<code class="calibre21">program.*</code>. To match all filenames beginning with
<span><em class="calibre7">a</em></span> through <span><em class="calibre7">e</em></span> in the shell,
you would use <code class="calibre21">[a-e]*</code> or
<code class="calibre21">[abcde]*</code>; in Emacs, it's
<code class="calibre21">[a-e].*</code> or <code class="calibre21">[abcde].*</code>. In other
words, the dash within the brackets specifies a
<span><em class="calibre7">range</em></span> of characters.<sup class="calibre6">[<a id="gnu3-CHP-11-FNOTE-6" href="#ftn.gnu3-CHP-11-FNOTE-6" class="calibre2">6</a>]</sup> We will provide more on ranges and
bracketed character sets shortly.</p><p class="copyright">To specify a character that is used as a regular expression operator,
you need to precede it with a double-backslash, as in
<code class="calibre21">\\*</code> to match an asterisk. Why a double backslash?
The reason has to do with the way Emacs Lisp reads and decodes
strings. When Emacs reads a string in a Lisp program, it decodes the
backslash-escaped characters and thus turns double backslashes into
single backslashes. If the string is being used as a regular
expression—that is, if it is being passed to a function that
expects a regular expression argument—that function uses the
single backslash as part of the regular expression syntax. For
example, given the following line of Lisp:</p><a id="I_11_tt604" class="calibre2"></a><pre class="programlisting">(replace-regexp "fred\\*" "bob*")</pre><p class="copyright">the Lisp interpreter decodes the string <code class="calibre21">fred\\*</code> as
<code class="calibre21">fred\*</code> and passes it to the <span><strong class="calibre5">replace-regexp</strong></span> command. The <span><strong class="calibre5">replace-regexp</strong></span> command understands
<code class="calibre21">fred\*</code> to mean <code class="calibre21">fred</code> followed by
a (literal) asterisk. Notice, however, that the second argument to
<span><strong class="calibre5">replace-regexp</strong></span> is not a regular
expression, so there is no need to backslash-escape the asterisk in
<code class="calibre21">bob*</code> at all. Also notice that if you were to
invoke the this as a user command, you would not need to double the
backslash, that is, you would type <span><strong class="calibre5">M-x
replace-regexp Enter</strong></span> followed by <span><strong class="calibre5">fred\*</strong></span> and <span><strong class="calibre5">bob*</strong></span>. Emacs decodes strings read from the
minibuffer differently.</p><p class="copyright">The <code class="calibre21">*</code> regular expression operator in Emacs (by
itself) actually means something different from the
<code class="calibre21">*</code> in the Unix shell: it means
"zero or more occurrences of whatever is before the
<code class="calibre21">*</code>." Thus, because
. matches any character, <code class="calibre21">.*</code>
means "zero or more occurrences of any
character," that is, any string at all, including
the empty string. Anything can precede a <code class="calibre21">*</code>: for
example, <code class="calibre21">read*</code> matches
"rea" followed by zero or more
d's; <code class="calibre21">file[0-9]*</code> matches
"file" followed by zero or more
digits.</p><p class="copyright">Two operators are closely related to <code class="calibre21">*</code>. The first
is <code class="calibre21">+</code>, which matches one or more occurrences of
whatever precedes it. Thus, <code class="calibre21">read+</code> matches
"read" and
"readdddd" but not
"rea," and
<code class="calibre21">file[0-9]+</code> requires that there be at least one
digit after "file." The second is
<code class="calibre21">?</code>, which matches zero or one occurrence of
whatever precedes it (i.e., makes it optional).
<code class="calibre21">html?</code> matches
"htm" or
"html," and
<code class="calibre21">file[0-9]?</code> matches
"file" followed by one optional
digit.</p><p class="copyright">Before we move on to other operators, a few more comments about
character sets and ranges are in order. First, you can specify more
than one range within a single character set. The set
<code class="calibre21">[A-Za-z]</code> can thus be used to specify all
alphabetic characters; this is better than the nonportable
<code class="calibre21">[A-z]</code>. Combining ranges with lists of characters
in sets is also possible; for example, <code class="calibre21">[A-Za-z_]</code>
means all alphabetic characters plus underscore, that is, all
characters allowed in the names of identifiers in C. If you give
<code class="calibre21">^</code> as the first character in a set, it acts as a
"not" operator; the set matches all
characters that aren't the characters after the
<code class="calibre21">^</code>. For example, <code class="calibre21">[^A-Za-z]</code>
matches all nonalphabetic characters.</p><p class="copyright">A <code class="calibre21">^</code> anywhere other than first in a character set
has no special meaning; it's just the caret
character. Conversely, <code class="calibre21">-</code> has no special meaning if
it is given first in the set; the same is true for
<code class="calibre21">]</code>. However, we don't recommend
that you use this shortcut; instead, you should
double-backslash-escape these characters just to be on the safe side.
A double backslash preceding a nonspecial character usually means
just that character—but watch it! A few letters and punctuation
characters are used as regular expression operators, some of which
are covered in the following section. We list "booby
trap" characters that become operators when
double-backslash-escaped later. The <code class="calibre21">^</code> character
has a different meaning when used outside of ranges, as
we'll see soon.</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="gnu3-CHP-11-SECT-3.2.2" class="calibre1"></a>Grouping and alternation</h3></div></div></div><p class="copyright">If you want to get <code class="calibre21">*</code>, <code class="calibre21">+</code>, or
<code class="calibre21">?</code> to <a id="gnu3-CHP-11-ITERM-2799" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2800" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2801" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2802" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2803" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2804" class="calibre2"></a>operate on more than one character,
you can use the <code class="calibre21">\\(</code> and <code class="calibre21">\\)</code>
operators for grouping. Notice that, in this case (and others to
follow), the backslashes are part of the operator. (All of the
nonbasic regular expression operators include backslashes so as to
avoid making too many characters
"special." This is the most
profound way in which Emacs regular expressions differ from those
used in other environments, like Perl, so it's
something to which you'll need to pay careful
attention.) As we saw before, these characters need to be
double-backslash-escaped so that Emacs decodes them properly. If one
of the basic operators immediately follows <code class="calibre21">\\)</code>, it
works on the entire group inside the <code class="calibre21">\\(</code> and
<code class="calibre21">\\)</code>. For example, <code class="calibre21">\\(read\\)*</code>
matches the empty string, "read,"
"readread," and so on, and
<code class="calibre21">read\\(file\\)?</code> matches
"read" or
"readfile." Now we can handle
Example 1, the first of the examples given at the beginning of this
section, with the following Lisp code:</p><a id="I_11_tt605" class="calibre2"></a><pre class="programlisting">(replace-regexp "read\\(file\\)?" "get")</pre><p class="copyright">The alternation operator <code class="calibre21">\\|</code> is a
"one or the other" operator; it
matches either whatever precedes it or whatever comes after it.
<code class="calibre21">\\|</code> treats parenthesized groups differently from
the basic operators. Instead of requiring parenthesized groups to
work with subexpressions of more than one character, its
"power" goes out to the left and
right as far as possible, until it reaches the beginning or end of
the regexp, a <code class="calibre21">\\(</code>, a <code class="calibre21">\\)</code>, or
another <code class="calibre21">\\|</code>. Some examples should make this
clearer:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="copyright">
                        <code class="calibre21">read\\|get</code> matches
"read" or
"get"</p></li><li class="listitem"><p class="copyright">
                        <code class="calibre21">readfile\\|read\\|get</code> matches
"readfile",
"read," or
"get"</p></li><li class="listitem"><p class="copyright">
                        <code class="calibre21">\\(read\\|get\\)file</code> matches
"readfile" or
"getfile"</p></li></ul></div><p class="copyright">In the first example, the effect of the <code class="calibre21">\\|</code>
extends to both ends of the regular expression. In the second, the
effect of the first <code class="calibre21">\\|</code> extends to the beginning
of the regexp on the left and to the second <code class="calibre21">\\|</code> on
the right. In the third, it extends to the backslash-parentheses.</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="gnu3-CHP-11-SECT-3.2.3" class="calibre1"></a>Context</h3></div></div></div><p class="copyright">Another important category of regular <a id="gnu3-CHP-11-ITERM-2805" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2806" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2807" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2808" class="calibre2"></a>expression operators has to do with
specifying the <span><em class="calibre7">context</em></span> of a string, that is, the
text around it. In <a class="calibre2" href="ch03.html" title="Chapter 3. Search and Replace">Chapter 3</a> we saw the
<span><strong class="calibre5">word-search</strong></span> commands, which are
invoked as options within incremental search. These are special cases
of context specification; in this case, the context is
word-separation characters, for example, spaces or punctuation, on
both sides of the string.</p><p class="copyright">The simplest context operators for regular expressions are
<code class="calibre21">^</code> and <code class="calibre21">$</code>, two more basic
operators that are used at the beginning and end of regular
expressions respectively. The <code class="calibre21">^</code> operator causes
the rest of the regular expression to match only if it is at the
beginning of a line; <code class="calibre21">$</code> causes the regular
expression preceding it to match only if it is at the end of a line.
In Example 2, we need a function that matches occurrences of one or
more asterisks at the beginning of a line; this will do it:</p><a id="I_11_tt606" class="calibre2"></a><pre class="programlisting">(defun remove-outline-marks ( )
  "Remove section header marks created in outline-mode."
  (interactive)
  (replace-regexp "^\\*+" ""))</pre><p class="copyright">This function finds lines that begin with one or more asterisks (the
<code class="calibre21">\\*</code> is a literal asterisk and the
<code class="calibre21">+</code> means "one or
more"), and it replaces the asterisk(s) with the
empty string "", thus deleting them.</p><p class="copyright">Note that <code class="calibre21">^</code> and <code class="calibre21">$</code>
can't be used in the middle of regular expressions
that are intended to match strings that span more than one line.
Instead, you can put <code class="calibre21">\n</code> (for Newline) in your
regular expressions to match such strings. Another such character you
may want to use is <code class="calibre21">\t</code> for Tab. When
<code class="calibre21">^</code> and <code class="calibre21">$</code> are used with regular
expression searches on strings instead of buffers, they match
beginning- and end-of-string, respectively; the function <span><strong class="calibre5">string-match</strong></span>, described later in this chapter,
can be used to do regular expression search on strings.</p><p class="copyright">Here is a real-life example of a complex regular expression that
covers the operators we have seen so far: <span><strong class="calibre5">sentence-end</strong></span>, a variable Emacs uses to
recognize the ends of sentences for sentence motion commands like
<span><strong class="calibre5">forward-sentence</strong></span> (<span><strong class="calibre5">M-e</strong></span>). Its value is:</p><a id="I_11_tt607" class="calibre2"></a><pre class="programlisting">"[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*"</pre><p class="copyright">Let's look at this piece by piece. The first
character set, <code class="calibre21">[.?!]</code>, matches a period, question
mark, or exclamation mark (the first two of these are regular
expression operators, but they have no special meaning within
character sets). The next part, <code class="calibre21">[]\"')}]*</code>,
consists of a character set containing right bracket, double quote,
single quote, right parenthesis, and right curly brace. A
<code class="calibre21">*</code> follows the set, meaning that zero or more
occurrences of any of the characters in the set matches. So far,
then, this regexp matches a sentence-ending punctuation mark followed
by zero or more ending quotes, parentheses, or curly braces. Next,
there is the group <code class="calibre21">\\($\\|\t\\| \\)</code>, which matches
any of the three alternatives <code class="calibre21">$</code> (end of line),
<code class="calibre21">Tab</code>, or two spaces. Finally, <code class="calibre21">[
\t\n]*</code> matches zero or more spaces, tabs, or newlines. Thus
the sentence-ending characters can be followed by end-of-line or a
combination of spaces (at least two), tabs, and newlines.</p><p class="copyright">There are other context operators besides <code class="calibre21">^</code> and
<code class="calibre21">$</code>; two of them can be used to make regular
expression search act like word search. The operators
<code class="calibre21">\\&lt;</code> and <code class="calibre21">\\&gt;</code> match the
beginning and end of a word, respectively. With these we can go part
of the way toward solving Example 3. The regular expression
<code class="calibre21">\\&lt;program\\&gt;</code> matches
"program" but not
"programmer" or
"programming" (it also
won't match
"microprogram"). So far so good;
however, it won't match
"program's" or
"programs." For this, we need a
more complex regular expression:</p><a id="I_11_tt608" class="calibre2"></a><pre class="programlisting">\\&lt;program\\('s\\|s\\)?\\&gt;</pre><p class="copyright">This expression means, "a word beginning with
<span><em class="calibre7">program</em></span> followed optionally by apostrophe s or
just s." This does the trick as far as matching the
right words goes.</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="gnu3-CHP-11-SECT-3.2.4" class="calibre1"></a>Retrieving portions of matches</h3></div></div></div><p class="copyright">There is still one piece <a id="gnu3-CHP-11-ITERM-2809" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2810" class="calibre2"></a>missing: the ability to replace
"program" with
"module" while leaving any
<code class="calibre21">s</code> or '<code class="calibre21">s</code> untouched. This leads
to the final regular expression feature we will cover here: the
ability to retrieve portions of the matched string for later use. The
preceding regular expression is indeed the correct one to give as the
search string for <span><strong class="calibre5">replace-regexp</strong></span>. As
for the replace string, the answer is <code class="calibre21">module\\1</code>;
in other words, the required Lisp code is:</p><a id="I_11_tt609" class="calibre2"></a><pre class="programlisting">(replace-regexp "\\&lt;program\\('s\\|s\\)?\\&gt;" "module\\1")</pre><p class="copyright">The <code class="calibre21">\\1</code> means, in effect,
"substitute the portion of the matched string that
matched the subexpression inside the <code class="calibre21">\\(</code> and
<code class="calibre21">\\)</code>." It is the only
regular-expression-related operator that can be used in replacements.
In this case, it means to use '<code class="calibre21">s</code> in the replace
string if the match was
"program's,"
<code class="calibre21">s</code> if the match was
"programs," or nothing if the match
was just "program." The result is
the correct substitution of
"module" for
"program,"
"modules" for
"programs," and
"module's" for
"program's."</p><p class="copyright">Another example of this feature solves Example 4. To match filenames
<span><em class="calibre7">&lt;filename&gt;.c</em></span> and replace them with
<span><em class="calibre7">&lt;filename&gt;.java</em></span>, use the Lisp code:</p><a id="I_11_tt610" class="calibre2"></a><pre class="programlisting">(replace-regexp "\\([a-zA-Z0-9_]+\\)\\.c" "\\1.java")</pre><p class="copyright">Remember that <code class="calibre21">\\</code>. means a literal dot
(.). Note also that the filename pattern (which
matches a series of one or more alphanumerics or underscores) was
surrounded by <code class="calibre21">\\(</code> and <code class="calibre21">\\)</code> in
the search string for the sole purpose of retrieving it later with
<code class="calibre21">\\1</code>.</p><p class="copyright">Actually, the <code class="calibre21">\\1</code> operator is only a special case
of a more powerful facility (as you may have guessed). In general, if
you surround a portion of a regular expression with
<code class="calibre21">\\(</code> and <code class="calibre21">\\)</code>, the string
matching the parenthesized subexpression is saved. When you specify
the replace string, you can retrieve the saved substrings with
<code class="calibre21">\\</code>
                  <em class="calibre7"><code class="calibre21">n</code></em>, where
<em class="calibre7"><code class="calibre21">n</code></em> is the number of the parenthesized
subexpression from left to right, starting with 1. Parenthesized
expressions can be nested; their corresponding
<code class="calibre21">\\</code>
                  <em class="calibre7"><code class="calibre21">n</code></em> numbers are
assigned in order of their <code class="calibre21">\\(</code> delimiter from left
to right.</p><p class="copyright">Lisp code that takes full advantage of this feature tends to contain
complicated regular expressions. The best example of this in
Emacs's own Lisp code is <span><strong class="calibre5">compilation-error-regexp-alist</strong></span>, the list of
regular expressions the <span><strong class="calibre5">compile</strong></span>
package (discussed in <a class="calibre2" href="ch09.html" title="Chapter 9. Computer Language Support">Chapter 9</a>) uses to parse
error messages from compilers. Here is an excerpt, adapted from the
Emacs source code (it's become much too long to
reproduce in its entirety; see below for some hints on how to find
the actual file to study in its full glory):</p><a id="I_11_tt611" class="calibre2"></a><pre class="programlisting">(defvar compilation-error-regexp-alist
  '(
    ;; NOTE!  See also grep-regexp-alist, below.
 
    ;; 4.3BSD grep, cc, lint pass 1:
    ;;  /usr/src/foo/foo.c(8): warning: w may be used before set
    ;; or GNU utilities:
    ;;  foo.c:8: error message
    ;; or HP-UX 7.0 fc:
    ;;  foo.f          :16    some horrible error message
    ;; or GNU utilities with column (GNAT 1.82):
    ;;   foo.adb:2:1: Unit name does not match file name
    ;; or with column and program name:
    ;;   jade:dbcommon.dsl:133:17:E: missing argument for function call
    ;;
    ;; We'll insist that the number be followed by a colon or closing
    ;; paren, because otherwise this matches just about anything
    ;; containing a number with spaces around it.

    ;; We insist on a non-digit in the file name
    ;; so that we don't mistake the file name for a command name
    ;; and take the line number as the file name.
    ("\\([a-zA-Z][-a-zA-Z._0-9]+: ?\\)?\
\\([a-zA-Z]?:?[^:( \t\n]*[^:( \t\n0-9][^:( \t\n]*\\)[:(][ \t]*\\([0-9]+\\)\
\\([) \t]\\|:\\(\\([0-9]+:\\)\\|[0-9]*[^:0-9]\\)\\)" 2 3 6)

;; Microsoft C/C++:
    ;;  keyboard.c(537) : warning C4005: 'min' : macro redefinition
    ;;  d:\tmp\test.c(23) : error C2143: syntax error : missing ';' before 
        'if'
    ;; This used to be less selective and allow characters other than
    ;; parens around the line number, but that caused confusion for
    ;; GNU-style error messages.
    ;; This used to reject spaces and dashes in file names,
    ;; but they are valid now; so I made it more strict about the error
    ;; message that follows.
    ("\\(\\([a-zA-Z]:\\)?[^:(\t\n]+\\)(\\([0-9]+\\)) \
: \\(error\\|warning\\) C[0-9]+:" 1 3)

;; Caml compiler:
    ;;  File "foobar.ml", lines 5-8, characters 20-155: blah blah
   ("^File \"\\([^,\" \n\t]+\\)\", lines? \\([0-9]+\\)[-0-9]*, characters? \
\\([0-9]+\\)" 1 2 3)

;; Cray C compiler error messages
    ("\\(cc\\| cft\\)-[0-9]+ c\\(c\\|f77\\): ERROR \\([^,\n]+, \\)* File = \
\\([^,\n]+\\), Line = \\([0-9]+\\)" 4 5)

;; Perl -w:
    ;; syntax error at automake line 922, near "':'"
    ;; Perl debugging traces
    ;; store::odrecall('File_A', 'x2') called at store.pm line 90
    (".* at \\([^ \n]+\\) line \\([0-9]+\\)[,.\n]" 1 2)

    ;; See http://ant.apache.org/faq.html
    ;; Ant Java: works for jikes
    ("^\\s-*\\[[^]]*\\]\\s-*\\(.+\\):\\([0-9]+\\):\\([0-9]+\\):[0-9]+:[0-9]\
+:" 1 2 3)

    ;; Ant Java: works for javac
    ("^\\s-*\\[[^]]*\\]\\s-*\\(.+\\):\\([0-9]+\\):" 1 2)
)</pre><p class="copyright">This is a list of elements that have at least three parts each: a
regular expression and two numbers. The regular expression matches
error messages in the format used by a particular compiler or tool.
The first number tells Emacs which of the matched subexpressions
contains the filename in the error message; the second number
designates which of the subexpressions contains the line number.
(There can also be additional parts at the end: a third number giving
the position of the column number of the error, if any, and any
number of format strings used to generate the true filename from the
piece found in the error message, if needed. For more details about
these, look at the actual file, as described below.)</p><p class="copyright">For example, the element in the list dealing with Perl contains the
regular expression:</p><a id="I_11_tt612" class="calibre2"></a><pre class="programlisting">".* at \\([^ \n]+\\) line \\([0-9]+\\)[,.\n]"</pre><p class="copyright">followed by 1 and 2, meaning that the first parenthesized
subexpression contains the filename and the second contains the line
number. So if you have Perl's warnings turned
on—you always do, of course—you might get an error
message such as this:</p><a id="I_11_tt613" class="calibre2"></a><pre class="programlisting">syntax error at monthly_orders.pl line 1822, near "$"</pre><p class="copyright">The regular expression ignores everything up to
<span><em class="calibre7">at</em></span>. Then it finds
<span><em class="calibre7">monthly_orders.pl</em></span>, the filename, as the match to
the first subexpression "<code class="calibre21">[^
\n]+</code>" (one or more nonblank, nonnewline
characters), and it finds 1822, the line number, as the match to the
second subexpression
"<code class="calibre21">[0-9]+</code>" (one or
more digits).</p><p class="copyright">For the most part, these regular expressions are documented pretty
well in their definitions. Understanding them in depth can still be a
challenge, and writing them even more so! Suppose we want to tackle
Example 5 by adding an element to this list for our new C++ compiler
that prints error messages in German. In particular, it prints error
messages like this:</p><a id="I_11_tt614" class="calibre2"></a><pre class="programlisting">Fehler auf Zeile <em class="calibre7"><code class="calibre32">linenum</code></em> in <em class="calibre7"><code class="calibre32">filename</code></em>: <em class="calibre7"><code class="calibre32">text of error message</code></em></pre><p class="copyright">Here is the element we would add to <span><strong class="calibre5">compilation-error-regexp-alist</strong></span>:</p><a id="I_11_tt615" class="calibre2"></a><pre class="programlisting">("Fehler auf Zeile \\([0-9]+\\) in \\([^: \t]+\\):" 2 1)</pre><p class="copyright">In this case, the second parenthesized subexpression matches the
filename, and the first matches the line number.</p><p class="copyright">To add this to <span><strong class="calibre5">compilation-error-regexp-alist</strong></span>, we need to put
this line in <span><em class="calibre7">.emacs</em></span>:</p><a id="I_11_tt616" class="calibre2"></a><pre class="programlisting">(setq compilation-error-regexp-alist
  (cons '("Fehler auf Zeile \\([0-9]+\\) in \\([^: \t]+\\):" 2 1)
    compilation-error-regexp-alist))</pre><p class="copyright">Notice how this example resembles our example (from <a class="calibre2" href="ch09.html" title="Chapter 9. Computer Language Support">Chapter 9</a>) of adding support for a new language mode
to <span><strong class="calibre5">auto-mode-alist</strong></span>.</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h3 class="title4"><a id="gnu3-CHP-11-SECT-3.2.5" class="calibre1"></a>Regular expression operator summary</h3></div></div></div><p class="copyright">
                  <a class="calibre2" href="ch11s03.html#gnu3-CHP-11-TABLE-6" title="Table 11-6. Regular expression operators">Table 11-6</a> concludes <a id="gnu3-CHP-11-ITERM-2811" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2812" class="calibre2"></a>
                  <a id="gnu3-CHP-11-ITERM-2813" class="calibre2"></a>our discussion of regular
expression operators with a reference list of all the operators
covered.</p><div class="book"><a id="gnu3-CHP-11-TABLE-6" class="calibre2"></a><p class="title2"><b class="calibre25">Table 11-6. Regular expression operators</b></p><div class="table-contents"><table summary="Regular expression operators" class="calibre8"><colgroup class="calibre9"><col class="calibre10"/><col class="calibre10"/></colgroup><thead class="calibre11"><tr class="calibre12"><th class="calibre26">
                              <p class="copyright">
                                 <span><strong class="calibre5">Operator</strong></span>
                              </p>
                           </th><th class="calibre27">
                              <p class="copyright">
                                 <span><strong class="calibre5">Function</strong></span>
                              </p>
                           </th></tr></thead><tbody class="calibre15"><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">.</p>
                           </td><td class="calibre29">
                              <p class="copyright">Match any character.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">*</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match 0 or more occurrences of preceding char or group.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">+</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match 1 or more occurrences of preceding char or group.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">?</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match 0 or 1 occurrences of preceding char or group.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">[...]</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Set of characters; see below.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\\(</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Begin a group.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\\)</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">End a group.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\\|</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match the subexpression before or after \\|.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">^</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">At beginning of regexp, match beginning of line or string.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">$</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">At end of regexp, match end of line or string.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\n</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match Newline within a regexp.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\t</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match Tab within a regexp.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\\&lt;</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match beginning of word.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">\\&gt;</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Match end of word.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <span><em class="calibre7">The following operators are meaningful within character
sets</em></span>:</p>
                           </td><td class="calibre29">
</td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">^</code>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">At beginning of set, treat set as chars not to match.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <code class="calibre21">-</code> 
                                 <span><em class="calibre7">(dash)</em></span>
                              </p>
                           </td><td class="calibre29">
                              <p class="copyright">Specify range of characters.</p>
                           </td></tr><tr class="calibre12"><td class="calibre28">
                              <p class="copyright">
                                 <span><em class="calibre7">The following is also meaningful in regexp replace
strings</em></span>:</p>
                           </td><td class="calibre29">
</td></tr><tr class="calibre12"><td class="calibre30">
                              <p class="copyright">
                                 <code class="calibre21">\\</code>
                                 <em class="calibre7"><code class="calibre21">n</code></em>
                              </p>
                           </td><td class="calibre31">
                              <p class="copyright">Substitute portion of match within the <em class="calibre7"><code class="calibre21">n</code></em>th
<code class="calibre21">\\(</code> and <code class="calibre21">\\)</code>, counting from left
<code class="calibre21">\\(</code> to right, starting with 1.</p>
                           </td></tr></tbody></table></div></div><br class="book"/><p class="copyright">Finally, the following characters are operators (not discussed here)
when double-backslash-escaped: <code class="calibre21">b</code>,
<code class="calibre21">B</code>, <code class="calibre21">c</code>, <code class="calibre21">C</code>,
<code class="calibre21">w</code>, <code class="calibre21">W</code>, <code class="calibre21">s</code>,
<code class="calibre21">S</code>, <code class="calibre21">=</code>, <code class="calibre21">_</code>,
', and <code class="calibre21">`</code>. Thus, these are
"booby traps" when
double-backslash-escaped. Some of these behave similarly to the
character class aliases you may have encountered in Perl and Java
regular expressions.</p></div></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="gnu3-CHP-11-SECT-3.3" class="calibre1"></a>A Treasure Trove of Examples</h2></div></div></div><p class="copyright">As mentioned above, the full <span><strong class="calibre5">auto-mode-alist</strong></span> has a lot more entries and
documentation than fit in this book. The
<code class="calibre21">compile.el</code> module in which it is defined also
contains functions that use it. One of the best ways to learn how to
use Emacs Lisp (as well as discovering things you might not have even
realized you can do) is to browse through the implementations of
standard modules that are similar to what you're
trying to achieve, or that are simply interesting. But how do you
find them?</p><p class="copyright">The manual way is to look at the value of the variable <span><strong class="calibre5">load-path</strong></span>. This is the variable Emacs consults
when it needs to load a library file itself, so any library
you're looking for must be in one of these
directories. (This variable is discussed further in the final section
of this chapter.) The problem, as you will see if you look at the
current value of the variable, is that it contains a large number of
directories for you to wade through, which would be pretty tedious
each time you're curious about a library. (An easy
way to see the variable's value is through
Help's "Describe
variable" feature, <span><strong class="calibre5">C-h
v</strong></span>.)</p><p class="copyright">One of the authors wrote the command listed in <a class="calibre2" href="ch11s03.html#gnu3-CHP-11-EX-1" title="Example 11-1. find-library-file">Example 11-1</a> to address this problem and uses it regularly
to easily snoop on the source files that make much of Emacs run. If
you don't want to type this entire function into
your <span><em class="calibre7">.emacs</em></span> by hand, you can download it from
this book's web <a id="gnu3-CHP-11-ITERM-2814" class="calibre2"></a>site, <a class="calibre2" href="http://www.oreilly.com/catalog/gnu3">http://www.oreilly.com/catalog/gnu3</a>.</p><div class="book"><a id="gnu3-CHP-11-EX-1" class="calibre2"></a><p class="title2"><b class="calibre25">Example 11-1. find-library-file</b></p><div class="book"><pre class="programlisting">(defun find-library-file (library)
  "Takes a single argument LIBRARY, being a library file to search for.
Searches for LIBRARY directly (in case relative to current directory,
or absolute) and then searches directories in load-path in order.  It
will test LIBRARY with no added extension, then with .el, and finally
with .elc.  If a file is found in the search, it is visited.  If none
is found, an error is signaled.  Note that order of extension searching
is reversed from that of the load function."
  (interactive "sFind library file: ")
  (let ((path (cons "" load-path)) exact match elc test found)
    (while (and (not match) path)
      (setq test (concat (car path) "/" library)
            match (if (condition-case nil
                          (file-readable-p test)
                        (error nil))
                      test)
            path (cdr path)))
    (setq path (cons "" load-path))
    (or match
        (while (and (not elc) path)
          (setq test (concat (car path) "/" library ".elc")
                elc (if (condition-case nil
                            (file-readable-p test)
                          (error nil))
                        test)
                path (cdr path))))
    (setq path (cons "" load-path))
    (while (and (not match) path)
      (setq test (concat (car path) "/" library ".el")
            match (if (condition-case nil
                          (file-readable-p test)
                        (error nil))
                      test)
            path (cdr path)))
    (setq found (or match elc))
    (if found
        (progn
          (find-file found)
          (and match elc
               (message "(library file %s exists)" elc)
               (sit-for 1))
          (message "Found library file %s" found))
      (error "Library file \"%s\" not found." library))))</pre></div></div><br class="book"/><p class="copyright">Once this command is defined, you can visit any
library's implementation by typing <span><strong class="calibre5">M-x find-library file Enter</strong></span>
               <em class="calibre7"><code class="calibre21">libraryname</code></em> 
               <span><strong class="calibre5">Enter</strong></span>. If you use it as often as this author
does, you too may find it worth binding to a key sequence. We
won't present a detailed discussion of how this
function works because it goes a bit deeper than this chapter, but if
you're curious about what some of the functions do,
you can put your cursor in the function name in a Lisp buffer and use
the Help system's "Describe
function" (<span><strong class="calibre5">C-h f</strong></span>)
feature to get more information about it.</p><p class="copyright">If you find that most of the time when you ask for a library, you end
up with a file containing a lot of cryptic numeric codes and no
comments, check if the filename ends in <code class="calibre21">.elc</code>. If
that is usually what you end up with, it means that only the
byte-compiled versions of the libraries (see the discussion at the
end of this chapter) have been installed on your system. Ask your
system administrator if you can get the source installed;
that's an important part of being able to learn and
tweak the Emacs Lisp environment.</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="gnu3-CHP-11-SECT-3.4" class="calibre1"></a>Functions That Use Regular Expressions</h2></div></div></div><p class="copyright">The functions <span><strong class="calibre5">re-search-forward</strong></span>,
<span><strong class="calibre5">re-search-backward</strong></span>, <span><strong class="calibre5">replace-regexp</strong></span>, <span><strong class="calibre5">query-replace-regexp</strong></span>, <span><strong class="calibre5">highlight-regexp</strong></span>, <span><strong class="calibre5">isearch-forward-regexp</strong></span>, and <span><strong class="calibre5">isearch-backward-regexp</strong></span> are all user
<a id="gnu3-CHP-11-ITERM-2815" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2816" class="calibre2"></a>commands
that use regular expressions, and they can all be used within Lisp
code (though it is hard to imagine incremental search being used
within Lisp code). The section on customizing major modes later in
this chapter contains an example function that uses <span><strong class="calibre5">re-search-forward</strong></span>. To find other commands that
use regexps you can use the
"apropos" help feature (<span><strong class="calibre5">C-h a regexp Enter</strong></span>).</p><p class="copyright">Other such functions aren't available as user
commands. Perhaps the most widely used one is <span><strong class="calibre5">looking-at</strong></span>. This function takes a regular
expression argument and does the following: it returns
<code class="calibre21">t</code> if the text after point matches the regular
expression (<code class="calibre21">nil</code> otherwise); if there was a match,
it saves the pieces surrounded by <code class="calibre21">\\(</code> and
<code class="calibre21">\\)</code> for future use, as seen earlier. The function
<span><strong class="calibre5">string-match</strong></span> is similar: it takes
two arguments, a regexp and a string. It returns the starting index
of the portion of the string that matches the regexp, or
<code class="calibre21">nil</code> if there is no match.</p><p class="copyright">The functions <span><strong class="calibre5">match-beginning</strong></span> and
<span><strong class="calibre5">match-end</strong></span> can be used to retrieve
the saved portions of the matched string. Each takes as an argument
the number of the matched expression (as in
<code class="calibre21">\\</code>
               <em class="calibre7"><code class="calibre21">n</code></em> in <span><strong class="calibre5">replace-regexp</strong></span> replace strings) and returns
the character position in the buffer that marks the beginning (for
<span><strong class="calibre5">match-beginning</strong></span>) or end (for
<span><strong class="calibre5">match-end</strong></span>) of the matched string.
With the argument <code class="calibre21">0</code>, the character position that
marks the beginning/end of the entire string matched by the regular
expression is returned.</p><p class="copyright">Two more functions are needed to make the above useful: we need to
know how to convert the text in a buffer to a string. No problem:
<span><strong class="calibre5">buffer-string</strong></span> returns the entire
buffer as a string; <span><strong class="calibre5">buffer-substring</strong></span>
takes two integer arguments, marking the beginning and end positions
of the substring desired, and returns the substring.</p><p class="copyright">With these functions, we can write a bit of Lisp code that returns a
string containing the portion of the buffer that matches the
<span><em class="calibre7">n</em></span>th parenthesized subexpression:</p><a id="I_11_tt617" class="calibre2"></a><pre class="programlisting">(buffer-substring (match-beginning <em class="calibre7"><code class="calibre32">n</code></em> (match-end <em class="calibre7"><code class="calibre32">n</code></em>)))</pre><p class="copyright">In fact, this construct is used so often that Emacs has a built-in
function, <span><strong class="calibre5">match-string</strong></span>, that acts as
a shorthand; <code class="calibre21">(match-string</code>
               <em class="calibre7"><code class="calibre21">n</code></em>
               <code class="calibre21">)</code> returns the same
result as in the previous example.</p><p class="copyright">An example should show how this capability works. Assume you are
writing the Lisp code that parses compiler error messages, as in our
previous example. Your code goes through each element in <span><strong class="calibre5">compilation-error-regexp-alist</strong></span>, checking if
the text in a buffer matches the regular expression. If it matches,
your code needs to extract the filename and the line number, visit
the file, and go to the line number.</p><p class="copyright">Although the code for going down each element in the list is beyond
what we have learned so far, the routine basically looks like this:</p><a id="I_11_tt618" class="calibre2"></a><pre class="programlisting">               <em class="calibre7"><code class="calibre32">for each element in</code></em> compilation-error-regexp-alist
  (let ((regexp <em class="calibre7"><code class="calibre32">the regexp in the element</code></em>
               <span><strong class="calibre5">)</strong></span>
        (file-subexp <em class="calibre7"><code class="calibre32">the number of the filename subexpression</code></em>)
        (line-subexp <em class="calibre7"><code class="calibre32">the number of the line number subexpression</code></em>))
    (if (looking-at regexp)
        (let ((filename (match-string file-subexp))
              (linenum (match-string line-subexp)))
          (find-file-other-window filename)
          (goto-line linenum))
      (<em class="calibre7"><code class="calibre32">otherwise, try the next element in the list</code></em>)))</pre><p class="copyright">The second <span><strong class="calibre5">let</strong></span> extracts the filename
from the buffer from the beginning to the end of the match to the
<code class="calibre21">file-subexp</code>-th subexpression, and it extracts the
line number similarly from the <code class="calibre21">line-subexp</code>-th
subexpression (and converts it from a string to a number). Then the
code visits the file (in another window, not the same one as the
error message buffer) and goes to the line number where the error
occurred.</p><p class="copyright">The code for the calculator mode later in this chapter contains a few
other examples of <span><strong class="calibre5">looking-at</strong></span>,
<span><strong class="calibre5">match-beginning</strong></span>, and <span><strong class="calibre5">match-end</strong></span>.</p></div><div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="gnu3-CHP-11-SECT-3.5" class="calibre1"></a>Finding Other Built-in Functions</h2></div></div></div><p class="copyright">Emacs contains <a id="gnu3-CHP-11-ITERM-2817" class="calibre2"></a>
               <a id="gnu3-CHP-11-ITERM-2818" class="calibre2"></a>hundreds
of built-in functions that may be of use to you in writing Lisp code.
Yet finding which one to use for a given purpose is not so hard.</p><p class="copyright">The first thing to realize is that you will often need to use
functions that are already accessible as keyboard commands. You can
use these by finding out what their function names are via the
<span><strong class="calibre5">C-h k</strong></span> (for <span><strong class="calibre5">describe-key</strong></span>) command (see <a class="calibre2" href="ch14.html" title="Chapter 14. The Help System">Chapter 14</a>). This gives the
command's full documentation, as opposed to
<span><strong class="calibre5">C-h c</strong></span> (for <span><strong class="calibre5">describe-key-briefly</strong></span>), which gives only the
command's name. Be careful: in a few cases, some
common keyboard commands require an argument when used as Lisp
functions. An example is <span><strong class="calibre5">forward-word</strong></span>; to get the equivalent of typing
<span><strong class="calibre5">M-f</strong></span>, you have to use
<code class="calibre21">(forward-word 1)</code>.</p><p class="copyright">Another powerful tool for getting the right function for the job is
the <span><strong class="calibre5">command-apropos</strong></span> (<span><strong class="calibre5">C-h a</strong></span>) help function. Given a regular
expression, this help function searches for all commands that match
it and display their key bindings (if any) and documentation in a
<code class="calibre21">*Help*</code> window. This can be a great help if you are
trying to find a command that does a certain
"basic" thing. For example, if you
want to know about commands that operate on words, type <span><strong class="calibre5">C-h</strong></span> 
               <strong class="calibre5"><code class="calibre21">a</code></strong> followed by
<em class="calibre7"><code class="calibre21">word</code></em>, and you will see documentation on
about a dozen and a half commands having to do with words.</p><p class="copyright">The limitation with <span><strong class="calibre5">command-apropos</strong></span>
is that it gives information only on functions that can be used as
keyboard commands. Even more powerful is <span><strong class="calibre5">apropos</strong></span>, which is not accessible via any of
the help keys (you must type <span><strong class="calibre5">M-x apropos
Enter</strong></span>). Given a regular expression, <span><strong class="calibre5">apropos</strong></span> displays all functions, variables, and
other symbols that match it. Be warned, though: <span><strong class="calibre5">apropos</strong></span> can take a long time to run and can
generate very long lists if you use it with a general enough concept
(such as <code class="calibre21">buffer</code>).</p><p class="copyright">You should be able to use the <span><strong class="calibre5">apropos</strong></span> commands on a small number of
well-chosen keywords and find the function(s) you need. Because, if a
function seems general and basic enough, the chances are excellent
that Emacs has it built-in.</p><p class="copyright">After you find the function you are interested in, you may find that
the documentation that <span><strong class="calibre5">apropos</strong></span>
prints does not give you enough information about what the function
does, its arguments, how to use it, or whatever. The best thing to do
at this point is to search Emacs's Lisp source code
for examples of the function's use.
"A Treasure Trove of Examples"
earlier in this chapter provides ways of finding out the names of
directories Emacs loads libraries from and an easy way of looking at
a library once you know its name. To search the contents of the
library files you'll need to use
<code class="calibre21">grep</code> or some other search facility to find
examples, then edit the files found to look at the surrounding
context. If you're ambitious you could put together
the examples and concepts we've discussed so far to
write an extension of the <span><strong class="calibre5">find-library-file</strong></span> command that searches the
<span><em class="calibre7">contents</em></span> of the library files in each directory
on the load path! Although most of Emacs's built-in
Lisp code is not profusely documented, the examples of function use
that it provides should be helpful—and may even give you ideas
for your own functions.</p><p class="copyright">By now, you should have a framework of Emacs Lisp that should be
sufficient for writing many useful Emacs commands. We have covered
examples of various kinds of functions, both Lisp primitives and
built-in Emacs functions. You should be able to extrapolate many
others from the ones given in this chapter along with help techniques
such as those just provided. In other words, you are well on your way
to becoming a fluent Emacs Lisp programmer. To test yourself, start
with the code for <span><strong class="calibre5">count-words-buffer</strong></span>
and try writing the following functions:</p><div class="book"><dl class="copyright"><dt class="book"><span>
                     <span><strong class="calibre5">count-lines-buffer</strong></span>
                  </span></dt><dd class="calibre20"><p class="copyright">Print the number of lines in the buffer.</p></dd><dt class="book"><span>
                     <span><strong class="calibre5">count-words-region</strong></span>
                  </span></dt><dd class="calibre20"><p class="copyright">Print the number of words in a region.</p></dd><dt class="book"><span>
                     <span><strong class="calibre5">what-line</strong></span>
                  </span></dt><dd class="calibre20"><p class="copyright">Print the number of the line point is currently on.</p></dd></dl></div></div><div class="book"><br class="book"/><hr class="calibre4"/><div class="book"><p class="copyright"><sup class="calibre6">[<a id="ftn.gnu3-CHP-11-FNOTE-6" href="#gnu3-CHP-11-FNOTE-6" class="calibre2">6</a>] </sup>Emacs uses
ASCII codes (on most machines) to build ranges, but you
shouldn't depend on this fact; it is better to stick
to dependable things, like all-lowercase or all-uppercase alphabet
subsets or <span><strong class="calibre5">[0-9]</strong></span> for digits, and
avoid potentially nonportable items, like <span><strong class="calibre5">[A-z]</strong></span> and ranges involving punctuation
characters.</p></div></div></div></div>

{% endraw %}

