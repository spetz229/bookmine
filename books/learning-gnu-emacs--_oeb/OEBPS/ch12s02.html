---
layout: page
title: "Learning GNU Emacs, 3rd Edition"
prev: OEBPS/ch12.html
next: OEBPS/ch12s03.html
book_path: books/learning-gnu-emacs--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" xml:lang="en"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="gnu3-CHP-12-SECT-2" class="calibre1"></a>Version Control Concepts</h1></div></div></div><p class="copyright">Each file under version control has a change history that consists of
an <span><em class="calibre7">initial version</em></span> and a series (or sometimes a
branching tree) of subsequent <span><em class="calibre7">revisions</em></span>.</p><p class="copyright">To make a file version-controlled, you
<a id="gnu3-CHP-12-ITERM-2859" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2860" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2861" class="calibre2"></a>must
<span><em class="calibre7">register</em></span> it; that is, you must tell the version
control system to treat the file contents you're
starting with as an initial version and begin maintaining a change
history for it.<sup class="calibre6">[<a id="gnu3-CHP-12-FNOTE-1" href="#ftn.gnu3-CHP-12-FNOTE-1" class="calibre2">1</a>]</sup>
         </p><p class="copyright">To change a registered file, in the old days you'd
have to <span><em class="calibre7">check out</em></span> the file. Doing so notifies
the version control system that you're modifying it.
Under SCCS and RCS, this would lock the file so that no one else
could check it out until you were done (anyone else could still look
at it, though). This limitation was one of the major motivations for
the development of CVS, the Concurrent Versions System, which
doesn't make locks. Instead, it tries to reconcile
any concurrent changes at the time that they are committed, as
described below. Even so, some developers prefer to configure CVS to
keep files locked at the OS level until they consciously decide they
want to make changes to one of them; this largely mimics the RCS
experience, albeit on a voluntary basis.</p><p class="copyright">In a system like SCCS or RCS that uses locking, you may sometimes
find that you can't check out a file because someone
else has <a id="gnu3-CHP-12-ITERM-2862" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2863" class="calibre2"></a>it
locked already. Perhaps that person checked it out and wandered away,
so that the lock is stale. You may want to <span><em class="calibre7">steal the
lock—</em></span>that is, seize control of the work file with
whatever changes the other person has made and take responsibility
for checking in a clean set of changes yourself.
(It's bad practice to do this casually!) Again, this
hasn't generally been an issue since CVS made
concurrent edits a practical option—recall that the
"C" in CVS stands for
"concurrent."</p><p class="copyright">While making changes to <a id="gnu3-CHP-12-ITERM-2864" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2865" class="calibre2"></a>your
<span><em class="calibre7">work file</em></span> (the working copy
you've checked out) and experimenting with them, you
may decide at any time to <span><em class="calibre7">revert</em></span> the work
file—that is, to throw away your changes and undo the check-out
operation. After you've made changes to your file
that you want to keep, you must <span><em class="calibre7">check in</em></span> those
changes. Doing so adds them permanently to the saved change history
as a new revision of the file. Under RCS and SCCS, it also removes
the lock on your work file, so that other people can check it out and
edit it. Under CVS and Subversion, the file was never locked;
instead, the version control system tries to reconcile your changes
with any other changes that might have been made since check-out time
and yells for help (manual intervention) if it finds conflicts.
Because you never really checked the file out in a concurrent system,
the standard term for integrating your changes back into such a
repository is <span><em class="calibre7">commit</em></span> rather than <span><em class="calibre7">check
in</em></span>. The CVS interface also allows you to call it checking
in, to accommodate people who are used to older systems, and
that's what Emacs calls it too.</p><p class="copyright">The register, check-out, revert, and check-in operations are the
basic ones. But you may want to do other things as well. You can also
retrieve any saved revision, get a difference report between any two
saved versions or any saved version and your (possibly modified) work
file, or even completely remove saved revisions that you want to
throw away (though this is rare).</p><p class="copyright">If conflicts are reported during a check-in operation, Emacs offers
to help you resolve them by launching an Ediff session (described at
the end of this chapter). If you decide against Ediff, you will see
the conflicts as represented within the file by the version control
system and you can address them manually or use whatever other tools
you find convenient. If you later decide you do want help from Ediff
after all, you can use <span><strong class="calibre5">M-x</strong></span> 
            <span><strong class="calibre5">vc-resolve-conflicts</strong></span> 
            <span><strong class="calibre5">Enter</strong></span> while you're editing
the conflicted file.</p><p class="copyright">Most version control systems (and all the ones we're
talking about here) associate <span><em class="calibre7">change comments</em></span>
with <a id="gnu3-CHP-12-ITERM-2866" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2867" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2868" class="calibre2"></a>each revision. So
each time you check in a registered file, you can add an explanation
of the change to the change history, which won't be
part of the file itself. Each revision <a id="gnu3-CHP-12-ITERM-2869" class="calibre2"></a>
            <a id="gnu3-CHP-12-ITERM-2870" class="calibre2"></a>has a <span><em class="calibre7">revision
number</em></span>, which identifies its place in the history. The
base revision in SCCS, RCS, and CVS is 1.1. If the history is a
linear sequence of changes (which is typical for small projects),
sequence numbers are two numeric fields separated by a dot.
Subversion uses a simpler revision numbering scheme with which
you're undoubtedly familiar: The first revision is
numbered 1, the one that comes after it is 2 . . . subtle, eh?</p><p class="copyright">It is possible to start branches so that variant versions of files
can be maintained in parallel. In such cases, the main trunk still
has two-field revision numbers, but branches have more fields. The
exact naming conventions for branches are arcane and different
between SCCS and RCS or CVS; if you need to know about them in
detail, consult the documentation for your version control system.
Once again, this is a whole lot simpler in Subversion, which versions
the entire source tree as a unit and supports efficient copies of
parts of the tree. In Subversion, a branch is just another directory.
There is a lot more to know about version control systems than we go
into here, and two excellent O'Reilly books on the
topic are: <span><em class="calibre7">Essential CVS</em></span> by Jennifer Vesperman
and <span><em class="calibre7">Version Control with Subversion</em></span> by Ben
Collins-Sussman, Brian W. Fitzpatrick, and C. Michael Pilato.</p><div class="book"><br class="book"/><hr class="calibre4"/><div class="book"><p class="copyright"><sup class="calibre6">[<a id="ftn.gnu3-CHP-12-FNOTE-1" href="#gnu3-CHP-12-FNOTE-1" class="calibre2">1</a>] </sup>You don't need to
have registered a file from VC to use VC on it. VC works just fine on
a preexisting tree of version-controlled files.</p></div></div></div></div>

{% endraw %}

