---
layout: page
title: "Unknown"
prev: r23528.htm
next: r23882.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="r23528.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4"/><td width="10%" valign="bottom" class="calibre5"><a href="r23882.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><h1 class="calibre7"><a name="SQL-CREATEAGGREGATE" class="calibre8">CREATE AGGREGATE</a></h1><div class="NAVHEADER"><a name="AEN23737"></a><h2 class="SECT">Name</h2>CREATE AGGREGATE -- Defines a new aggregate function within the database.</div><div class="NAVHEADER"><a name="AEN23740"></a><h2 class="SECT">Synopsis</h2><pre class="SCREEN">CREATE AGGREGATE <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( BASETYPE = <tt class="REPLACEABLE"><i class="EMPHASIS">input_type</i></tt>
    [ , SFUNC = <tt class="REPLACEABLE"><i class="EMPHASIS">sfunc</i></tt>, STYPE = <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt> ]
    [ , FINALFUNC = <tt class="REPLACEABLE"><i class="EMPHASIS">ffunc</i></tt> ]
    [ , INITCOND = <tt class="REPLACEABLE"><i class="EMPHASIS">initial_condition</i></tt> ] )</pre><div class="NAVHEADER"><a name="R2-SQL-CREATEAGGREGATE-1"></a><h3 class="AUTHOR">Parameters</h3><p class="calibre9"> </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the aggregate function you are creating.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">input_type</i></tt></dt><dd class="calibre16"><p class="calibre9">The input data type on which the new function will operate.  If the aggregate function ignores input values (as the <tt class="REPLACEABLE">count()</tt> function does), you can use the <tt class="REPLACEABLE">ANY</tt> string constant as the data type.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">sfunc</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the function you wish to be called to handle all non-<tt class="REPLACEABLE">NULL</tt> input data values. These functions usually follow the same format, having two arguments. The first argument is of the <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt> data type, and the second of the <tt class="REPLACEABLE"><i class="EMPHASIS">input_type</i></tt> data type.  If the aggregate does not examine input values, it will take only one argument of type <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt>. Either way, the function must return a value of type <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt>.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt></dt><dd class="calibre16"><p class="calibre9">The data type for the state value of the aggregate.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">ffunc</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the final function called upon to compute the aggregate's result after all input has been examined. This function is required to accept a single argument of type <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt>.</p><p class="calibre9">The output data type of the aggregate function is defined as the return type of <span><i class="EMPHASIS">this</i></span> function.
        If you do not specify <tt class="REPLACEABLE"><i class="EMPHASIS">ffunc</i></tt>, the ending state value is used as the aggregate's result, and the
        output data type is determined by <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt>.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">initial_condition</i></tt></dt><dd class="calibre16"><p class="calibre9">The initial value of the aggregate function's state value. This is a literal constant of the the same data type as <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt>. The state value will be initialized to <tt class="REPLACEABLE">NULL</tt> if <tt class="REPLACEABLE"><i class="EMPHASIS">initial_condition</i></tt> is not specified.</p></dd></dl></div>
</div><div class="NAVHEADER"><a name="R2-SQL-CREATEAGGREGATE-2"></a><h3 class="AUTHOR">Results</h3><p class="calibre9"> </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE">CREATE</tt></dt><dd class="calibre16"><p class="calibre9">The message returned when an aggregate is created successfully.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">ERROR: AggregateCreate: function "</tt><tt class="REPLACEABLE"><i class="EMPHASIS">sfunc(state_type, input_type)</i></tt><tt class="REPLACEABLE">" does not exist</tt></dt><dd class="calibre16"><p class="calibre9">The error returned if the specified state function <tt class="REPLACEABLE"><i class="EMPHASIS">sfunc</i></tt>, accepting arguments of types <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt> and <tt class="REPLACEABLE"><i class="EMPHASIS">input_type</i></tt>, does not exist.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">ERROR:  AggregateCreate: function "</tt><tt class="REPLACEABLE"><i class="EMPHASIS">sfunc(state_type)</i></tt><tt class="REPLACEABLE">" does not exist</tt></dt><dd class="calibre16"><p class="calibre9">The error returned if the specified <tt class="REPLACEABLE"><i class="EMPHASIS">sfunc</i></tt>, accepting one argument of type <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt>, does not exist. This error should only be displayed if the <tt class="REPLACEABLE"><i class="EMPHASIS">input_type</i></tt> is set to <span><i class="EMPHASIS">ANY</i></span>.</p></dd></dl></div>
</div></div><div class="NAVHEADER"><a name="R1-SQL-CREATEAGGREGATE-1"></a><h2 class="SECT">Description</h2><p class="calibre9">Use the <tt class="REPLACEABLE">CREATE AGGREGATE</tt> command to define new aggregate functions in PostgreSQL. Some commonly used aggregate functions are already included with PostgreSQL, such as <tt class="REPLACEABLE">min()</tt>, <tt class="REPLACEABLE">avg()</tt>, and <tt class="REPLACEABLE">max()</tt>. See <a href="c7547.htm">Chapter 5</a>, for more on PostgreSQL's built-in functions.</p><p class="calibre9">Aggregate functions are characterized primarily by their input data type.  It is possible for two or more aggregate functions to exist with the same name, as long as they accept different data types. This is called function overloading.</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">In order to avoid confusion, do not try to create normal functions with the same name and input type as an aggregate. If you do, aggregate functions will receive precedence.</p></td></tr></table></div><p class="calibre9">An aggregate function is comprised of either one or two normal functions. The required function is the state transition function (the <tt class="REPLACEABLE"><i class="EMPHASIS">sfunc</i></tt>), and the optional function is the finalization function (<tt class="REPLACEABLE"><i class="EMPHASIS">ffunc</i></tt>).</p><p class="calibre9">PostgreSQL uses a temporary <tt class="REPLACEABLE"><i class="EMPHASIS">stype</i></tt> variable that is updated by the state transition function for every input row it receives. If you have defined a finalization function for your aggregate, it will be called to calculate the output value after all data has been processed; otherwise, the ending state value is returned without further processing.</p><p class="calibre9">Aggregate functions can also set an initial value for the internal state value; this is known as an <span><i class="EMPHASIS">initial condition</i></span>, and is specified with the <tt class="REPLACEABLE">INITCOND</tt> keyword. PostgreSQL stores this value in the database as a value of type <tt class="REPLACEABLE">text</tt>, but it must represent a constant of the same data type as the state value defined by the <tt class="REPLACEABLE">STYPE</tt> keyword. This value will be initialized to <tt class="REPLACEABLE">NULL</tt> if nothing is supplied.</p><p class="calibre9">If the state transition function was created with the <tt class="REPLACEABLE">isstrict</tt> attribute (see <a href="r24039.htm">CREATE FUNCTION</a>"), it cannot be called with <tt class="REPLACEABLE">NULL</tt> parameters.  Transition functions declared in this manner cause aggregate execution to behave differently then normal; specifically, all <tt class="REPLACEABLE">NULL</tt> input parameters are ignored, and the function is not called. The previous state value is retained, and the aggregate function continues to process input values.</p><p class="calibre9">Furthermore, if the initial state value is set to <tt class="REPLACEABLE">NULL</tt>, it will be replaced by the first non-<tt class="REPLACEABLE">NULL</tt> parameter value, and the transition function is called with the second non-<tt class="REPLACEABLE">NULL</tt> parameter value.  This can be useful for creating aggregates such as <tt class="REPLACEABLE">max()</tt>. Note that this behavior will only occur when <tt class="REPLACEABLE"><i class="EMPHASIS">state_type</i></tt> is the same as <tt class="REPLACEABLE"><i class="EMPHASIS">input_type</i></tt>.  If these types are different, you must either provide a non-<tt class="REPLACEABLE">NULL</tt> initial condition, or use a non-strict transition function.</p><p class="calibre9">When the state transition function is not declared as strict, it will be called unconditionally for each input value. This causes it to handle <tt class="REPLACEABLE">NULL</tt> values and <tt class="REPLACEABLE">NULL</tt> transition values by itself, which allows the aggregate author to have more control over the aggregate's handling of <tt class="REPLACEABLE">NULL</tt> input.</p><p class="calibre9">If the finalization function of an aggregate is declared <tt class="REPLACEABLE">strict</tt>, it will not be called if the ending state value is a <tt class="REPLACEABLE">NULL</tt> value; instead, it will output a <tt class="REPLACEABLE">NULL</tt> result automatically.</p></div><div class="NAVHEADER"><a name="R1-SQL-CREATEAGGREGATE-2"></a><h2 class="SECT">Examples</h2><p class="calibre9">The following example defines an aggregate function named <tt class="REPLACEABLE">sum()</tt>, for use with the <tt class="REPLACEABLE">text</tt> data type. This aggregate calls the <tt class="REPLACEABLE">textcat(text,text)</tt> function built into PostgreSQL to return a concatenated "sum" of all the text found in its input values:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE AGGREGATE sum ( BASETYPE = text,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                       SFUNC = textcat,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                       STYPE = text,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                       INITCOND = '' );</b></tt>
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT sum(title || ' ') FROM books WHERE title ~ '^L';</b></tt>
              sum
-------------------------------
 Little Women Learning Python
(1 row)</pre></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="r23528.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="r23882.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">COPY</td><td width="34%" valign="top" class="calibre4"><a href="c22759.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">CREATE DATABASE</td></tr></table></div></div>

{% endraw %}

