---
layout: page
title: "Unknown"
prev: x14316.htm
next: x15284.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="x14316.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4">Chapter 7. Advanced Features</td><td width="10%" valign="bottom" class="calibre5"><a href="x15284.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><h1 class="calibre7"><a name="AEN15040" class="calibre8">Transactions and Cursors</a></h1><p class="calibre9">PostgreSQL uses a multi-version approach to transactions within the database. A <span><i class="EMPHASIS">transaction</i></span> is a
    formal term for a SQL statement's effects being synchronized with the "current" data in the database. This doesn't
    necessarily mean that the data is written to disk, but it becomes part of the "current" set of information stored in the
    database. When a statement's results have effectively been processed in the current state of the database, the transaction is
    considered to be <span><i class="EMPHASIS">committed</i></span>.</p><p class="calibre9">The issue of two users attempting to commit changes to the same database object is obviously a potential concern, as
    their modifications may be exclusive to one another. Some relational database systems rely on automatic
    <span><i class="EMPHASIS">locking</i></span> to prevent such conflicts.</p><p class="calibre9">Locking is a mechanism that disallows selecting from a database object while it is being modified, and vice versa.
    Locking presents several obvious performance concerns. For example, data which is being updated will not be selectable until
    the update transaction has completed.</p><p class="calibre9"> PostgreSQL's Multi-Version Concurrency Control (MVCC), however, allows for SQL statements to be performed within
    transaction-deferred <span><i class="EMPHASIS">blocks</i></span>. This means that each connection to PostgreSQL essentially maintains a
    temporary snapshot of the database for objects modified within a transaction block, before the modifications are
    committed.</p><p class="calibre9">Without explicitly opening a transaction block, all SQL statements issued to PostgreSQL are
    <span><i class="EMPHASIS">auto-committed</i></span>, meaning that the database is synchronized with the results of the statement immediately
    upon execution. When a transaction block is used, however, changes made to the database will not be visible to other users
    until the block is committed. This allows for several changes to various objects within a database to be made tentatively.
    They can then be either committed all at once, or rolled back.</p><p class="calibre9">Rolling back a transaction returns the state of any affected objects to the condition they were in before the
    transaction block began. This can be useful when recovering from a partially failed operation, in
    that any modifications made part-way into a process can be undone. Rolled back transactions are never actually
    committed; while the process appears to undo modifications to the user who performed the rollback, other users connected to
    the same database never know the difference.</p><p class="calibre9">PostgreSQL also supports <span><i class="EMPHASIS">cursors</i></span>, which are flexible references to fully executed SQL queries. A
    cursor is able to traverse up and down a result set, and only retrieve those rows which are explicitly requested. Used
    properly, a cursor can aid an application in efficiently use a static result set. A cursor may only be executed within a
    transaction block.</p><p class="calibre9">The following sections cover the basic use of transactions and cursors. They show how to begin, commit, and roll
    back transactions, and also how to declare, move, and fetch data from a cursor.</p><div class="NAVHEADER"><h2 class="SECT"><a name="USINGTRANSACTIONBLOCKS" class="calibre8">Using Transaction Blocks</a></h2><p class="calibre9">Transaction blocks are explicitly started with the <tt class="REPLACEABLE">BEGIN</tt> SQL command. This keyword may
      optionally be followed by either of the noise terms <tt class="REPLACEABLE">WORK</tt> or
      <tt class="REPLACEABLE">TRANSACTION</tt>, though they have no effect on the statement, or the transaction block.</p><p class="calibre9"><a href="x15040.htm#BEGINNINGATRANSACTION">Example 7-38</a> begins a transaction block within the
      <tt class="REPLACEABLE">booktown</tt> database.</p><div class="NAVHEADER"><a name="BEGINNINGATRANSACTION"></a><p class="calibre9"><b class="calibre10">Example 7-38. Beginning a transaction</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">BEGIN;</b></tt>
BEGIN</pre></div><p class="calibre9">Any SQL statement made after the <tt class="REPLACEABLE">BEGIN</tt> SQL command will appear to take effect as
      normal to the user making the modifications. As stated earlier, however, other users connected to the database will be
      oblivious to the modifications that appear to have been made from within your transaction block until it is committed.</p><p class="calibre9">Transaction blocks are closed with the <tt class="REPLACEABLE">COMMIT</tt> SQL command, which may be
      followed by either of the optional noise terms <tt class="REPLACEABLE">WORK</tt> or
      <tt class="REPLACEABLE">TRANSACTION</tt>. <a href="x15040.htm#COMMITTINGATRANSACTION">Example 7-39</a> uses the
      <tt class="REPLACEABLE">COMMIT</tt> SQL command to synchronize the database system with the result of an
      <tt class="REPLACEABLE">UPDATE</tt> statement.</p><div class="NAVHEADER"><a name="COMMITTINGATRANSACTION"></a><p class="calibre9"><b class="calibre10">Example 7-39. Committing a transaction</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">BEGIN;</b></tt>
BEGIN
booktown=# <tt class="REPLACEABLE"><b class="calibre10">UPDATE subjects SET location = NULL</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                WHERE id = 12;</b></tt>
UPDATE 1
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT location FROM subjects WHERE id = 12;</b></tt>
 location
----------

(1 row)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">COMMIT;</b></tt>
COMMIT</pre></div><p class="calibre9">Again, even though the <tt class="REPLACEABLE">SELECT</tt> statement immediately reflects the result of the
      <tt class="REPLACEABLE">UPDATE</tt> statement in <a href="x15040.htm#COMMITTINGATRANSACTION">Example 7-39</a>, other users connected to the
      same database will not be aware of that modification until after the <tt class="REPLACEABLE">COMMIT</tt> statement is
      executed.</p><p class="calibre9">To roll back a transaction, the <tt class="REPLACEABLE">ROLLBACK</tt> SQL command is used. Again, either
      of the optional noise terms <tt class="REPLACEABLE">WORK</tt> or <tt class="REPLACEABLE">TRANSACTION</tt> may follow
      the <tt class="REPLACEABLE">ROLLBACK</tt> command.</p><p class="calibre9"><a href="x15040.htm#ROLLINGBACKATRANSACTION">Example 7-40</a> begins a transaction block, makes a modification to the
      <tt class="REPLACEABLE">subjects</tt> table, and verifies the modification within the block. The transaction is then rolled back,
      returning the <tt class="REPLACEABLE">subjects</tt> table to the state that it was in before the transaction block began.</p><div class="NAVHEADER"><a name="ROLLINGBACKATRANSACTION"></a><p class="calibre9"><b class="calibre10">Example 7-40. Rolling back a transaction</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">BEGIN;</b></tt>
BEGIN
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM subjects WHERE id = 12;</b></tt>
 id | subject  | location
----+----------+----------
 12 | Religion |
(1 row)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">UPDATE subjects SET location = 'Sunset Dr'</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                WHERE id = 12;</b></tt>
UPDATE 1
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM subjects WHERE id = 12;</b></tt>
 id | subject  | location
----+----------+-----------
 12 | Religion | Sunset Dr
(1 row)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">ROLLBACK;</b></tt>
ROLLBACK
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM subjects WHERE id = 12;</b></tt>
 id | subject  | location
----+----------+----------
 12 | Religion |
(1 row)</pre></div><p class="calibre9">      PostgreSQL is very strict about errors in SQL statements inside of transaction blocks.
      Even an innocuous parse error, such as that
      shown in <a href="x15040.htm#RECOVERINGFROMTHEABORTSTATE">Example 7-41</a>, will cause the transaction to enter into the
      <tt class="REPLACEABLE">ABORT STATE</tt>. This means that no further statements may be executed until either the
      <tt class="REPLACEABLE">COMMIT</tt> or <tt class="REPLACEABLE">ROLLBACK</tt> command is used to end the transaction
      block.</p><div class="NAVHEADER"><a name="RECOVERINGFROMTHEABORTSTATE"></a><p class="calibre9"><b class="calibre10">Example 7-41. Recovering from the abort state</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">BEGIN;</b></tt>
BEGIN
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM;</b></tt>
ERROR:  parser: parse error at or near ";"
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM books;</b></tt>
NOTICE:  current transaction is aborted, queries ignored until end of transaction block
*ABORT STATE*
booktown=# <tt class="REPLACEABLE"><b class="calibre10">COMMIT;</b></tt></pre></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="USINGCURSORS" class="calibre8">Using Cursors</a></h2><p class="calibre9">A SQL cursor in PostgreSQL is a read-only pointer to a fully executed <tt class="REPLACEABLE">SELECT</tt>
      statement's result set. Cursors are typically used within applications that maintain a persistent connection to the
      PostgreSQL backend. By executing a cursor, and maintaining a reference to its returned result set, an application can more
      efficiently manage which rows to retrieve from a result set at different times, without having to re-execute the query with
      different <tt class="REPLACEABLE">LIMIT</tt> and <tt class="REPLACEABLE">OFFSET</tt> clauses.</p><p class="calibre9">Used within a programming Application Programming Interface (API), cursors are often used to
      allow multiple queries to be executed to a single database backend, which are then tracked and managed separately by the
      application through references to the cursor. This prevents having to store all of the results in memory within the
      application.</p><p class="calibre9">Cursors are often abstracted within a programming API (such as <span><i class="EMPHASIS">libpq++</i></span>'s <tt class="REPLACEABLE">PgCursor</tt>
      class), though they can also be directly created and manipulated through standard SQL commands. For the sake of generality,
      this section uses <span><i class="EMPHASIS">psql</i></span> to demonstrate the fundamental concepts of cursors with SQL. The four SQL
      commands involved with PostgreSQL cursors are <tt class="REPLACEABLE">DECLARE</tt>,
      <tt class="REPLACEABLE">FETCH</tt>, <tt class="REPLACEABLE">MOVE</tt> and
      <tt class="REPLACEABLE">CLOSE</tt>.</p><p class="calibre9">The <tt class="REPLACEABLE">DECLARE</tt> command both defines and opens a cursor, in effect defining the cursor
      in memory, and then populating the cursor with information about the result set returned from the executed query. The
      <tt class="REPLACEABLE">FETCH</tt> command lets you pull rows from an open cursor. The
      <tt class="REPLACEABLE">MOVE</tt> command moves the "current" location of the cursor within the result set, and the
      <tt class="REPLACEABLE">CLOSE</tt> command closes the cursor, freeing up any associated memory.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>If you are interested in learning how to use cursors within a particular API, consult that API's
        documentation.</p></blockquote></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15144" class="calibre8">Declaring a cursor</a></h3><p class="calibre9">A cursor is both created and executed with the <tt class="REPLACEABLE">DECLARE</tt> SQL command. This process is also
        referred to as "opening" a cursor. A cursor may be declared only within an existing transaction block, so you
        must execute a <tt class="REPLACEABLE">BEGIN</tt> command prior to declaring a cursor. Here is the
        syntax for <tt class="REPLACEABLE">DECLARE</tt>:</p><pre class="SCREEN">  DECLARE <tt class="REPLACEABLE"><i class="EMPHASIS">cursorname</i></tt> [ BINARY ] [ INSENSITIVE ] [ SCROLL ]
                     CURSOR FOR <tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt>
                     [ FOR { READ ONLY | UPDATE [ OF <tt class="REPLACEABLE"><i class="EMPHASIS">column</i></tt> [, ...] ] } ]</pre><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE">DECLARE </tt><tt class="REPLACEABLE"><i class="EMPHASIS">cursorname</i></tt></dt><dd class="calibre16"><p class="calibre9"> <tt class="REPLACEABLE"><i class="EMPHASIS">cursorname</i></tt> is the name of the cursor to create.
            </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">[ BINARY ]</tt></dt><dd class="calibre16"><p class="calibre9">              The optional <tt class="REPLACEABLE">BINARY</tt> keyword causes output to be retrieved in binary format instead
              of standard ASCII; this can be more efficient, though it is only relevant to custom applications, as clients such
              as <span><i class="EMPHASIS">psql</i></span> are not built to handle anything but text output.
            </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">[ INSENSITIVE ] [ SCROLL ]</tt></dt><dd class="calibre16"><p class="calibre9">              The <tt class="REPLACEABLE">INSENSITIVE</tt> and <tt class="REPLACEABLE">SCROLL</tt> keywords exist for
              compliance with the SQL standard, though they each define PostgreSQL's default behavior and are never necessary.
              The <tt class="REPLACEABLE">INSENSITIVE</tt> SQL keyword exists to ensure that all data retrieved from the
              cursor remains unchanged from other cursors or connections. Since PostgreSQL requires that cursors be defined
              within transaction blocks, this behavior is already implied. The <tt class="REPLACEABLE">SCROLL</tt> SQL
              keyword exists to specify that multiple rows can be selected at a time from the cursor. This is the default in
              PostgreSQL, even if unspecified.
            </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">CURSOR FOR </tt><tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt></dt><dd class="calibre16"><p class="calibre9"> <tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt> is the complete query whose result set will be accessible by the cursor, when executed.
            </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">[ FOR { READ ONLY | UPDATE [ OF </tt><tt class="REPLACEABLE"><i class="EMPHASIS">column</i></tt> [, ...] ] } ]</dt><dd class="calibre16"><p class="calibre9">              As of PostgreSQL 7.1.x, cursors may only be defined as <tt class="REPLACEABLE">READ ONLY</tt>, and the
              <tt class="REPLACEABLE">FOR</tt> clause is therefore superfluous.
            </p></dd></dl></div><p class="calibre9"><a href="x15040.htm#DECLARINGACURSOR">Example 7-42</a> begins a transaction block with the <tt class="REPLACEABLE">BEGIN</tt>
        keyword, and opens a cursor named <tt class="REPLACEABLE">all_books</tt> with
        
        <tt class="REPLACEABLE">SELECT * FROM books</tt> as its executed SQL statement.</p><div class="NAVHEADER"><a name="DECLARINGACURSOR"></a><p class="calibre9"><b class="calibre10">Example 7-42. Declaring a cursor</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">BEGIN;</b></tt>
BEGIN
booktown=# <tt class="REPLACEABLE"><b class="calibre10">DECLARE all_books CURSOR</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">        FOR SELECT * FROM books;</b></tt>
SELECT</pre></div><p class="calibre9">The <tt class="REPLACEABLE">SELECT</tt> message returned from <a href="x15040.htm#DECLARINGACURSOR">Example 7-42</a> indicates that
        the statement was executed successfully. This means that the rows retrieved by the query are now accessible from the
        <tt class="REPLACEABLE">all_books</tt> cursor.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="FETCHINGFROMACURSOR" class="calibre8">Fetching from a cursor</a></h3><p class="calibre9">You may retrieve rows from a cursor with the <tt class="REPLACEABLE">FETCH</tt> SQL command.
        Here is the syntax for the <tt class="REPLACEABLE">FETCH</tt> SQL command:</p><pre class="SCREEN">  FETCH [ FORWARD | BACKWARD | RELATIVE ]
        [ # | ALL | NEXT | PRIOR ]
        { IN | FROM } <tt class="REPLACEABLE"><i class="EMPHASIS">cursor</i></tt></pre><p class="calibre9">In this syntax diagram, <tt class="REPLACEABLE"><i class="EMPHASIS">cursor</i></tt> is the name of the cursor from which to retrieve row data. A cursor
        always points to a "current" position in the executed statement's result set, and rows can be retrieved either ahead or
        behind of the current location. The <tt class="REPLACEABLE">FORWARD</tt> and
        <tt class="REPLACEABLE">BACKWARD</tt> keywords may be used to specify the direction, though the default is forward.
        The <tt class="REPLACEABLE">RELATIVE</tt> keyword is a noise term made available for SQL92 compliance.</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">The <tt class="REPLACEABLE">ABSOLUTE</tt> keyword can be used, but absolute cursor positioning and fetching are not supported as of PostgreSQL 7.1.x; the cursor will still use relative positioning and provide a notice
          regarding the state of absolute positioning being unsupported.</p></td></tr></table></div><p class="calibre9">Following the direction you may optionally specify a quantity. This quantity may either be a literal number of
        rows to be returned (in the form of an integer constant) or one of several keywords. The
        <tt class="REPLACEABLE">ALL</tt> keyword causes returns all rows from the current cursor position. The
        <tt class="REPLACEABLE">NEXT</tt> keyword (the default) returns the next single row from the current cursor position. The <tt class="REPLACEABLE">PRIOR</tt> keyword causes the single row preceding the current cursor
        position to be returned.</p><p class="calibre9">There is no functional difference between the <tt class="REPLACEABLE">IN</tt> and
        <tt class="REPLACEABLE">FROM</tt> keywords, but one of these must be specified.</p><p class="calibre9"><a href="x15040.htm#FETCHINGROWSFROMACURSOR">Example 7-43</a> fetches the first four rows stored in the result set pointed to by the
        <tt class="REPLACEABLE">all_books</tt> cursor. As a direction is not specified,
        <tt class="REPLACEABLE">FORWARD</tt> is implied. It then uses a <tt class="REPLACEABLE">FETCH</tt> statement with
        the <tt class="REPLACEABLE">NEXT</tt> keyword to select the fifth row, and then another
        <tt class="REPLACEABLE">FETCH</tt> statement with the <tt class="REPLACEABLE">PRIOR</tt> keyword to again select
        the fourth retrieved row.</p><div class="NAVHEADER"><a name="FETCHINGROWSFROMACURSOR"></a><p class="calibre9"><b class="calibre10">Example 7-43. Fetching rows from a cursor</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">FETCH 4 FROM all_books;</b></tt>
  id  |         title         | author_id | subject_id
------+-----------------------+-----------+------------
 7808 | The Shining           |      4156 |          9
 4513 | Dune                  |      1866 |         15
 4267 | 2001: A Space Odyssey |      2001 |         15
 1608 | The Cat in the Hat    |      1809 |          2
(4 rows)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">FETCH NEXT FROM all_books;</b></tt>
  id  |            title            | author_id | subject_id
------+-----------------------------+-----------+------------
 1590 | Bartholomew and the Oobleck |      1809 |          2
(1 row)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">FETCH PRIOR FROM all_books;</b></tt>
  id  |       title        | author_id | subject_id
------+--------------------+-----------+------------
 1608 | The Cat in the Hat |      1809 |          2
(1 row)</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15244" class="calibre8">Moving a cursor</a></h3><p class="calibre9">A cursor maintains a position in the result set of its referenced <tt class="REPLACEABLE">SELECT</tt> statement. You can use the
        <tt class="REPLACEABLE">MOVE</tt> command to move the cursor to a specified row position in that result
        set. Here is the syntax for the <tt class="REPLACEABLE">MOVE</tt> command:</p><pre class="SCREEN">  MOVE [ FORWARD | BACKWARD | RELATIVE ]
       [ # | ALL | NEXT | PRIOR ]
       { IN | FROM } <tt class="REPLACEABLE"><i class="EMPHASIS">cursor</i></tt></pre><p class="calibre9">As you can see, the syntax is very similar to <tt class="REPLACEABLE">FETCH</tt>. However, the
        <tt class="REPLACEABLE">MOVE</tt> command does not retrieve any rows and only moves the current position of the specified 
        <tt class="REPLACEABLE"><i class="EMPHASIS">cursor</i></tt>. The amount is specified by either an integer constant, the <tt class="REPLACEABLE">ALL</tt> keyword (to move
        as far as can be moved in the specified direction), <tt class="REPLACEABLE">NEXT</tt>, or
        <tt class="REPLACEABLE">PRIOR</tt>. <a href="x15040.htm#MOVINGACURSOR">Example 7-44</a> moves the cursor forward 10 rows from its current
        position in the result set.</p><div class="NAVHEADER"><a name="MOVINGACURSOR"></a><p class="calibre9"><b class="calibre10">Example 7-44. Moving a cursor</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">MOVE FORWARD 10</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">     IN all_books;</b></tt>
MOVE</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15265" class="calibre8">Closing a cursor</a></h3><p class="calibre9">        Use the <tt class="REPLACEABLE">CLOSE</tt> command to explicitly close an open cursor. A cursor is also
        implicitly closed if the transaction block that it resides within is committed with the
        <tt class="REPLACEABLE">COMMIT</tt> command, or rolled back with the <tt class="REPLACEABLE">ROLLBACK</tt>
        command.</p><p class="calibre9">Here is the syntax for <tt class="REPLACEABLE">CLOSE</tt>, where <tt class="REPLACEABLE"><i class="EMPHASIS">cursorname</i></tt> is the name of
        the cursor intended to be closed:</p><pre class="SCREEN">  CLOSE <tt class="REPLACEABLE"><i class="EMPHASIS">cursorname</i></tt></pre><p class="calibre9"><a href="x15040.htm#CLOSINGACURSOR">Example 7-45</a> closes the <tt class="REPLACEABLE">all_books</tt> cursor, freeing the
        associated memory, and rendering the cursor's results inaccessible.</p><div class="NAVHEADER"><a name="CLOSINGACURSOR"></a><p class="calibre9"><b class="calibre10">Example 7-45. Closing a cursor</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CLOSE all_books;</b></tt>
CLOSE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">COMMIT;</b></tt>
COMMIT</pre></div></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="x14316.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="x15284.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">Automating Common Routines</td><td width="34%" valign="top" class="calibre4"><a href="c13329.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Extending PostgreSQL</td></tr></table></div></div>

{% endraw %}

