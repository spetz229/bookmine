---
layout: page
title: "Unknown"
prev: c4890.htm
next: x5504.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="c4890.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4">Chapter 4. Using SQL with PostgreSQL</td><td width="10%" valign="bottom" class="calibre5"><a href="x5504.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><h1 class="calibre7"><a name="USINGTABLES" class="calibre8">Using Tables</a></h1><p class="calibre9">Tables are the fundamental building blocks with which to store data within your database. Before you can begin to add,
    retrieve, or modify data within your database, you will first have to construct your tables to house that data.</p><p class="calibre9">This section covers how to create, modify and destroy tables, using the <tt class="REPLACEABLE">CREATE TABLE</tt>,
    <tt class="REPLACEABLE">ALTER TABLE</tt>, and <tt class="REPLACEABLE">DROP TABLE</tt> SQL commands. (If you need
    information about creating a database within which to work, see <a href="c16573.htm">Chapter 9</a>.)</p><div class="NAVHEADER"><h2 class="SECT"><a name="CREATINGTABLES" class="calibre8">Creating Tables with CREATE TABLE</a></h2><p class="calibre9">The SQL command to create a table is <tt class="REPLACEABLE">CREATE TABLE</tt>.  This command requires, at
      a minimum, the name for the new table and a description for each column, which consists of the column name and
      data type. The <tt class="REPLACEABLE">CREATE TABLE</tt> command accepts several optional parameters: <span><i class="EMPHASIS">column constraints</i></span>
      (rules on what data is or is not allowed within a column), and <span><i class="EMPHASIS">table constraints</i></span>
      (general limitations and relationships defined on the table itself).</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5042" class="calibre8">CREATE TABLE syntax</a></h3><p class="calibre9">          The following is the syntax for <tt class="REPLACEABLE">CREATE TABLE</tt> with a detailed
          explanation of the terms used:
        </p><pre class="SCREEN">  CREATE [ TEMPORARY | TEMP ] TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table_name</i></tt> (
         { <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt> <tt class="REPLACEABLE"><i class="EMPHASIS">type</i></tt> [ <tt class="REPLACEABLE"><i class="EMPHASIS">column_constraint</i></tt> [ ... ] ] | <tt class="REPLACEABLE"><i class="EMPHASIS">table_constraint</i></tt> }
         [, ... ]
         ) [ INHERITS ( <tt class="REPLACEABLE"><i class="EMPHASIS">inherited_table</i></tt> [, ... ] ) ]</pre><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE">TEMPORARY | TEMP</tt></dt><dd class="calibre16"><p class="calibre9">The <tt class="REPLACEABLE">TEMPORARY</tt> or <tt class="REPLACEABLE">TEMP</tt> SQL keyword
               causes the created table to be automatically destroyed at the end of the active session to PostgreSQL. A temporary
               table may have the same name as an existing table, and until the temporary table is destroyed, any references to that
               table name will utilize the temporary table. Any indices placed on this table are temporary and will be destroyed
               in the same fashion at the end of the session.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">table_name</i></tt></dt><dd class="calibre16"><p class="calibre9"> <tt class="REPLACEABLE"><i class="EMPHASIS">table_name</i></tt> identifies your table's name (once created).
              </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"/><tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt> <tt class="REPLACEABLE"><i class="EMPHASIS">type</i></tt> [ <tt class="REPLACEABLE"><i class="EMPHASIS">column_constraint</i></tt> ] | <tt class="REPLACEABLE"><i class="EMPHASIS">table_constraint</i></tt></dt><dd class="calibre16"><p class="calibre9">Each table column and table constraint is defined within the parentheses following the table name,
                separated by commas. Column definitions must contain a valid identifier for a
                <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt>, followed by a valid data <tt class="REPLACEABLE"><i class="EMPHASIS">type</i></tt>, and may optionally include a <tt class="REPLACEABLE"><i class="EMPHASIS">column_constraint</i></tt>.
                The requirements of column constraint definitions are dependent on the constraints,
                described in <a href="x13546.htm#CONSTRAINTS">the Section called <i class="EMPHASIS">Using Constraints</i> in Chapter 7</a>" in <a href="c13329.htm">Chapter 7</a>. Table constraints and columns may be mixed in this
                grouped list, though it is common practice to list columns first, followed by any table
                constraints.
              </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">[, ... ]</tt></dt><dd class="calibre16"><p class="calibre9">Each column definition may be followed by a comma in order to define a subsequent column after it.
                The ellipses denote that you may enter as many columns as you wish (up to the limit of 1,600). Be sure that you do
                not follow the last column or constraint in the list with a comma, as is allowed in languages like Perl; this will
                cause a parsing error.
              </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">INHERITS ( </tt><tt class="REPLACEABLE"><i class="EMPHASIS">inherited_table</i></tt> [, ...] )</dt><dd class="calibre16"><p class="calibre9">The object-relational capabilities of PostgreSQL allow you to specify one or more tables (in a
                grouped, comma-delimited list) from which your table will <span><i class="EMPHASIS">inherit</i></span>. This optional specification
                creates an implied parent-child relationship between tables. This relatively new technique to RDBMSs is discussed
                in more detail in <a href="x13546.htm#INHERITANCE">the Section called <i class="EMPHASIS">Inheritance</i> in Chapter 7</a>" within <a href="c13329.htm">Chapter 7</a>.
              </p></dd></dl></div><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>The terms <tt class="REPLACEABLE"><i class="EMPHASIS">column_constraint</i></tt> and
          <tt class="REPLACEABLE"><i class="EMPHASIS">table_constraint</i></tt> in the above syntax definition refer to sets of potentially complex
          constraint definitions. The syntax for these various constraints is listed in detail in <a href="x13546.htm#CONSTRAINTS">the Section called <i class="EMPHASIS">Using Constraints</i> in Chapter 7</a>" within <a href="c13329.htm">Chapter 7</a>.</p></blockquote></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="CREATINGANEXAMPLETABLE" class="calibre8">Creating an example table</a></h3><p class="calibre9"><a href="x5021.htm#CREATINGTHEBOOKSTABLE">Example 4-6</a> demonstrates the syntax to create Book Town's
        <tt class="REPLACEABLE">books</tt> table.</p><div class="NAVHEADER"><a name="CREATINGTHEBOOKSTABLE"></a><p class="calibre9"><b class="calibre10">Example 4-6. Creating the books table</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE books (</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">             id integer UNIQUE,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">             title text NOT NULL,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">             author_id integer,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">             subject_id integer,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">             CONSTRAINT books_id_pkey PRIMARY KEY (id));</b></tt>
NOTICE:  CREATE TABLE/PRIMARY KEY will create implicit index 'books_id_pkey' 
for table 'books'
CREATE</pre></div><p class="calibre9">The <tt class="REPLACEABLE">CREATE</tt> output following the execution of the statement indicates that the table
        was successfully created. If you receive an error message, check your punctuation and spelling to make sure you have
        entered the correct syntax. Receiving no message at all means that you probably left open a quote, parenthesis, or other
        special character symbol.</p><p class="calibre9">Additionally, the <tt class="REPLACEABLE">NOTICE</tt> statement serves to inform you that in order to properly
        complete the creation of this table as described, an implicit index called <tt class="REPLACEABLE">books_ id_ pkey</tt> will
        be created.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="EXAMININGACREATEDTABLE" class="calibre8">Examining a created table</a></h3><p class="calibre9">Once created, you may use the <tt class="REPLACEABLE">\d</tt> describe command (followed by the table name)
        within <span><i class="EMPHASIS">psql</i></span> to display the structure of the table and its constraints (if any).  <a href="x5021.htm#SLASHDCOMMANDOUTPUT">Example 4-7</a>
        shows the output of <tt class="REPLACEABLE">\d</tt> when it is used to describe the <tt class="REPLACEABLE">books</tt> table
        created in the last section. </p><p class="calibre9">Notice that this format does not show actual row data, but instead places each column and its
        attributes in its own <span><i class="EMPHASIS">row</i></span>, essentially turning the table on its side. This is done for the sake of
        clarity, as many tables can grow too large to fit on a screen (or on a page) horizontally. We'll use this format throughout the book when examining table structure without data.</p><div class="NAVHEADER"><a name="SLASHDCOMMANDOUTPUT"></a><p class="calibre9"><b class="calibre10">Example 4-7. The \d command's output</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10"> \d books</b></tt>
          Table "books"
 Attribute  |  Type   | Modifier
------------+---------+----------
 id         | integer | not null
 title      | text    | not null
 author_id  | integer |
 subject_id | integer |
Index: books_id_pkey</pre></div><p class="calibre9">          The following list provides a more detailed explanation of the fields and terms shown in <a href="x5021.htm#SLASHDCOMMANDOUTPUT">Example 4-7</a>:
        </p><p class="calibre9"> </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE">id</tt></dt><dd class="calibre16"><p class="calibre9">The <tt class="REPLACEABLE">id</tt> column is a numeric identifier unique to each book.
              It is defined as being of the data type <tt class="REPLACEABLE">integer</tt>, and has on it the following
              constraints:
              
              </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre17"><dt class="NAVHEADER"><tt class="REPLACEABLE">UNIQUE</tt></dt><dd class="calibre16"><p class="calibre9">This constraint ensures that the column always has a unique value.
                    A column with the <tt class="REPLACEABLE">UNIQUE</tt> constraint set may ordinarily contain empty
                    (<tt class="REPLACEABLE">NULL</tt> values, but any attempt to insert duplicate values will fail.
                    The <tt class="REPLACEABLE">id</tt> column is also designed to be used as the
                    <tt class="REPLACEABLE">PRIMARY KEY</tt>.
                    </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">PRIMARY KEY</tt></dt><dd class="calibre16"><p class="calibre9">While not displayed in the
                    <tt class="REPLACEABLE">\d</tt> breakdown, you can see in our original <tt class="REPLACEABLE">CREATE TABLE</tt>
                    statement that this table's primary key is defined on the <tt class="REPLACEABLE">id</tt> column. Placing
                    the constraint of <tt class="REPLACEABLE">PRIMARY KEY</tt> on a column implicitly sets both the
                    <tt class="REPLACEABLE">NOT NULL</tt> and <tt class="REPLACEABLE">UNIQUE</tt> constraints as well.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">NOT NULL</tt></dt><dd class="calibre16"><p class="calibre9">                      This constraint is set automatically by setting the <tt class="REPLACEABLE">PRIMARY KEY</tt> constraint.
                      It ensures that the ID column always has a value. Data for this column can never be empty, and any attempt
                      to insert <tt class="REPLACEABLE">NULL</tt> values will fail.
                    </p></dd></dl></div>
</dd><dt class="NAVHEADER"><tt class="REPLACEABLE">title</tt></dt><dd class="calibre16"><p class="calibre9">The <tt class="REPLACEABLE">title</tt> column of the table must contain character strings of type
              <tt class="REPLACEABLE">text</tt>. The <tt class="REPLACEABLE">text</tt> type is more flexible than <tt class="REPLACEABLE">varchar</tt>,
              and is a good choice for this column as it does not require that you specify the maximum number of characters allowed.
              This column has the <tt class="REPLACEABLE">NOT NULL</tt> constraint set, indicating that a row's title column cannot ever
              be set to <tt class="REPLACEABLE">NULL</tt>.
              </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">author_id</tt></dt><dd class="calibre16"><p class="calibre9">The <tt class="REPLACEABLE">author_id</tt> column must contain values of type
              <tt class="REPLACEABLE">integer</tt>, and relates to the <tt class="REPLACEABLE">authors</tt> table.
              There are no constraints placed on this column, as sometimes an author may not be known for a title (making
              <tt class="REPLACEABLE">NOT NULL</tt> inappropriate), and an author may show up more than once
              (making <tt class="REPLACEABLE">UNIQUE</tt> inappropriate as well).</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">subject_id</tt></dt><dd class="calibre16"><p class="calibre9">The <tt class="REPLACEABLE">subject_id</tt> is similar to the <tt class="REPLACEABLE">author_id</tt>
              column, as it may contain values of type <tt class="REPLACEABLE">integer</tt>, and relates to the
              <tt class="REPLACEABLE">subjects</tt> table. Again, there are no constraints on the contents of this column, as
              many books may be uncategorized, or fall under the same subject.</p></dd></dl></div>
<p class="calibre9">While a table's structure can be modified after it has been created, the available modifications are
        limited. These include, for example, renaming the table, renaming its columns, and adding new columns. PostgreSQL
        7.1.x does not support dropping columns from a table. It is therefore good practice to thoughtfully and carefully plan
        your table structures before creating them.</p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="ALTERINGTABLES" class="calibre8">Altering Tables with ALTER TABLE</a></h2><p class="calibre9">Most mature RDBMSs allow you to alter the properties of existing tables via the
      <tt class="REPLACEABLE">ALTER TABLE</tt> command. The PostgreSQL implementation of
      <tt class="REPLACEABLE">ALTER TABLE</tt> allows for six total types of table modifications as of version 7.1.x:
      
      </p><p class="calibre9"></p><ul class="calibre21"><li class="calibre22"><p class="calibre9">Adding columns</p></li><li class="calibre22"><p class="calibre9">Setting and removing default column values</p></li><li class="calibre22"><p class="calibre9">Renaming the table</p></li><li class="calibre22"><p class="calibre9">Renaming columns</p></li><li class="calibre22"><p class="calibre9">Adding constraints</p></li><li class="calibre22"><p class="calibre9">Changing ownership</p></li></ul>
<div class="NAVHEADER"><h3 class="AUTHOR"><a name="ADDINGCOLUMNS" class="calibre8">Adding columns</a></h3><p class="calibre9">            You can add a new column to a table using the <tt class="REPLACEABLE">ALTER TABLE</tt> command's <tt class="REPLACEABLE">ADD COLUMN</tt> clause.
            Here is the syntax for the <tt class="REPLACEABLE">ALTER TABLE</tt> command's <tt class="REPLACEABLE">ADD COLUMN</tt> clause:
          </p><pre class="SCREEN">  ALTER TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
        ADD [ COLUMN ] <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt> <tt class="REPLACEABLE"><i class="EMPHASIS">column_type</i></tt></pre><p class="calibre9"> </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">table_name</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the table to modify.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the column to add.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">column_type</i></tt></dt><dd class="calibre16"><p class="calibre9">The data type of the new column.</p></dd></dl></div>
<p class="calibre9">Technically, the <tt class="REPLACEABLE">COLUMN</tt> keyword may be omitted; it is considered a noise
          term and is only useful for your own readability.</p><p class="calibre9">As an example of adding a column, imagine that an industrious employee at Book Town decides that the
          <tt class="REPLACEABLE">books</tt> table requires another column, specifically, a date column to represent
          the publication date. <a href="x5021.htm#ADDINGACOLUMN">Example 4-8</a> demonstrates such a procedure.
          </p><div class="NAVHEADER"><a name="ADDINGACOLUMN"></a><p class="calibre9"><b class="calibre10">Example 4-8. Adding a column</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE books</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      ADD publication date;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
          Table "books"
  Attribute  |  Type   | Modifier
-------------+---------+----------
 id          | integer | not null
 title       | text    | not null
 author_id   | integer |
 subject_id  | integer |
 publication | date    |
Index: books_id_pkey</pre></div><p class="calibre9"><a href="x5021.htm#ADDINGACOLUMN">Example 4-8</a> successfully adds a new column to Book Town's
          <tt class="REPLACEABLE">books</tt> table with the name of <tt class="REPLACEABLE">publication</tt>, and a data type of
          <tt class="REPLACEABLE">date</tt>.  It also demonstrates a pitfall of uncoordinated table design among developers:
          in our examples, the Book Town <tt class="REPLACEABLE">editions</tt> table already stores the publication date, so
          the column should not have been added to the <tt class="REPLACEABLE">books</tt> table. See <a href="x5021.htm#RESTRUCTURINGTABLES">the Section called <i class="EMPHASIS">Restructuring Existing Tables</i></a>" for information on how to restructure a table after such a mistake has been made.
          </p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5278" class="calibre8">Setting and removing default values</a></h3><p class="calibre9">The most flexible table modification pertains to the default values of columns. These values may be both set
        and removed from a column with relative ease via the <tt class="REPLACEABLE">ALTER TABLE</tt> command's
        <tt class="REPLACEABLE">ALTER COLUMN</tt> clause.</p><p class="calibre9">The following syntax passed to PostgreSQL describes how to use <tt class="REPLACEABLE">ALTER TABLE</tt> in
        order to either set, or remove a default value of <tt class="REPLACEABLE"><i class="EMPHASIS">value</i></tt> from a column named
        <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt> :</p><pre class="SCREEN">  ALTER TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
        ALTER [ COLUMN ] <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt>
        { SET DEFAULT <tt class="REPLACEABLE"><i class="EMPHASIS">value</i></tt> | DROP DEFAULT }</pre><p class="calibre9">Again, the <tt class="REPLACEABLE">COLUMN</tt> keyword is considered noise, and is an optional term used only for
        improved readability of the statement. <a href="x5021.htm#ALTERINGCOLUMNDEFAULTS">Example 4-9</a> demonstrates setting and dropping a
        simple default sequence value on the <tt class="REPLACEABLE">books</tt> table's <tt class="REPLACEABLE">id</tt>
        column.</p><div class="NAVHEADER"><a name="ALTERINGCOLUMNDEFAULTS"></a><p class="calibre9"><b class="calibre10">Example 4-9. Altering column defaults</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE books</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      ALTER COLUMN id</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      SET DEFAULT nextval('book_ids');</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
                           Table "books"
 Attribute  |  Type   |                  Modifier
------------+---------+--------------------------------------------
 id         | integer | not null default nextval('book_ids'::text)
 title      | text    | not null
 author_id  | integer |
 subject_id | integer |
Index: books_id_pkey

booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE books</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      ALTER id</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      DROP DEFAULT;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
          Table "books"
 Attribute  |  Type   | Modifier
------------+---------+----------
 id         | integer | not null
 title      | text    | not null
 author_id  | integer |
 subject_id | integer |
Index: books_id_pkey</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5307" class="calibre8">Renaming a table</a></h3><p class="calibre9">         A table may be safely renamed by passing the <tt class="REPLACEABLE">RENAME</tt> clause with the
         <tt class="REPLACEABLE">ALTER TABLE</tt> command. The following is the syntax to rename a table:
        </p><pre class="SCREEN">  ALTER TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
        RENAME TO <tt class="REPLACEABLE"><i class="EMPHASIS">new_table</i></tt></pre><p class="calibre9">A table may be arbitrarily renamed as many times as you like without affecting the data. This could, of course, be a
        dangerous thing to do if you are dealing with a table on which an external application relies.</p><div class="NAVHEADER"><a name="RENAMINGATABLE"></a><p class="calibre9"><b class="calibre10">Example 4-10. Renaming a table</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE books RENAME TO literature;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE literature RENAME TO books;</b></tt>
ALTER</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5321" class="calibre8">Renaming columns</a></h3><p class="calibre9">A table's columns may be safely renamed in PostgreSQL without modifying the data contained in the
        table. Renaming a column is a dangerous thing to do because existing applications may use explicit references
        to column names.  If an existing program references a column by name and the column is renamed, the program could cease
        functioning correctly.</p><p class="calibre9">The following syntax describes how to rename a column:</p><pre class="SCREEN">  ALTER TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
        RENAME [ COLUMN ] <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt> TO <tt class="REPLACEABLE"><i class="EMPHASIS">new_column_name</i></tt>;</pre><p class="calibre9">As with the other <tt class="REPLACEABLE">ALTER TABLE</tt> commands, the
        <tt class="REPLACEABLE">COLUMN</tt> keyword is considered noise, and may be optionally omitted. The existence of two
        identifiers separated by the <tt class="REPLACEABLE">TO</tt> keyword provides enough information for PostgreSQL to determine
        that you are renaming a column, and not a table, as demonstrated in <a href="x5021.htm#RENAMINGACOLUMN">Example 4-11</a>.</p><div class="NAVHEADER"><a name="RENAMINGACOLUMN"></a><p class="calibre9"><b class="calibre10">Example 4-11. Renaming a column</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d daily_inventory</b></tt>
    Table "daily_inventory"
 Attribute |  Type   | Modifier
-----------+---------+----------
 isbn      | text    |
 in_stock  | boolean |

booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE daily_inventory</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      RENAME COLUMN in_stock TO is_in_stock;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE daily_inventory</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      RENAME is_in_stock TO is_stocked;</b></tt>
ALTER</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5342" class="calibre8">Adding constraints</a></h3><p class="calibre9">Constraints may be added in a limited fashion after a table has been created. As of PostgreSQL 7.1.x, only foreign
        key and check constraints may be added to an existing table column with <tt class="REPLACEABLE">ALTER TABLE</tt>. The following is
        the syntax to add a constraint to a table:</p><pre class="SCREEN">  ALTER TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
        ADD CONSTRAINT <tt class="REPLACEABLE"><i class="EMPHASIS">constraint_name</i></tt> <tt class="REPLACEABLE"><i class="EMPHASIS">constraint_definition</i></tt></pre><p class="calibre9">The syntax of the <tt class="REPLACEABLE"><i class="EMPHASIS">constraint_definition</i></tt> is dependent on the type of constraint you wish to
        add. As foreign keys and checks are the only supported constraints with the <tt class="REPLACEABLE">ADD CONSTRAINT</tt> clause (as of
        PostgreSQL 7.1.x), the syntax for adding a foreign key to the <tt class="REPLACEABLE">editions</tt> table
        (which references the <tt class="REPLACEABLE">books</tt> table's <tt class="REPLACEABLE">id</tt> column) and a check condition on the
        <tt class="REPLACEABLE">type</tt> column is demonstrated in <a href="x5021.htm#ADDINGACONSTRAINTTOATABLE">Example 4-12</a>.</p><div class="NAVHEADER"><a name="ADDINGACONSTRAINTTOATABLE"></a><p class="calibre9"><b class="calibre10">Example 4-12. Adding constraints to a table</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE editions</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      ADD CONSTRAINT foreign_book</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      FOREIGN KEY (book_id) REFERENCES books (id);</b></tt>
NOTICE: ALTER TABLE ... ADD CONSTRAINT will create implicit trigger(s)
for FOREIGN KEY check(s)
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE editions</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      ADD CONSTRAINT hard_or_paper_back</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      CHECK (type = 'p' OR type = 'h');</b></tt>
ALTER</pre></div><p class="calibre9">Due to the foreign key constraint, any <tt class="REPLACEABLE">book_id</tt> value in the <tt class="REPLACEABLE">editions</tt> table
        will now also have to exist in the <tt class="REPLACEABLE">books</tt> table. Additionally, due to the check constraint, the
        <tt class="REPLACEABLE">type</tt> values within the <tt class="REPLACEABLE">editions</tt> table may only be set to either
        <span><i class="EMPHASIS">p</i></span> or <span><i class="EMPHASIS">h</i></span>.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>To implicitly add a unique constraint, a workaround is to create a unique index
          using the <tt class="REPLACEABLE">CREATE INDEX</tt> command (see <a href="c13329.htm#INDICES">the Section called <i class="EMPHASIS">Indices</i> in Chapter 7</a>" in <a href="c13329.htm">Chapter 7</a>).</p></blockquote></div><p class="calibre9">See <a href="x13546.htm#CONSTRAINTS">the Section called <i class="EMPHASIS">Using Constraints</i> in Chapter 7</a>" in <a href="c13329.htm">Chapter 7</a> for more detailed
        information about constraints, their purpose, and their syntax.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5383" class="calibre8">Changing ownership</a></h3><p class="calibre9">By default, the creator of a table is automatically its <span><i class="EMPHASIS">owner</i></span>. The owner has all rights that
        can be associated with a table, in addition to the ability to <span><i class="EMPHASIS">grant</i></span> and <span><i class="EMPHASIS">revoke</i></span>
        rights with the <tt class="REPLACEABLE">GRANT</tt> and <tt class="REPLACEABLE">REVOKE</tt> commands (for more information see <a href="c18591.htm">Chapter 10</a>). If ownership must be changed, you can use the <tt class="REPLACEABLE">ALTER TABLE</tt>
        command's <tt class="REPLACEABLE">OWNER</tt> clause.  The syntax to change the ownership of a table from one user
        to another is:</p><pre class="SCREEN">  ALTER TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
        OWNER TO <tt class="REPLACEABLE"><i class="EMPHASIS">new_owner</i></tt></pre><p class="calibre9"> <a href="x5021.htm#CHANGINGTABLEOWNERSHIP">Example 4-13</a> demonstrates altering a table's ownership with the
        <tt class="REPLACEABLE">ALTER TABLE</tt> command's <tt class="REPLACEABLE">OWNER</tt> clause.  In it,
        <tt class="REPLACEABLE">corwin</tt> is set as the owner of the <tt class="REPLACEABLE">employees</tt>
        table.</p><div class="NAVHEADER"><a name="CHANGINGTABLEOWNERSHIP"></a><p class="calibre9"><b class="calibre10">Example 4-13. Changing table ownership</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE employees</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      OWNER TO corwin;</b></tt>
ALTER</pre></div><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>In order to change the ownership of a table, you must either be the owner of that table or a PostgreSQL
          superuser.
          </p></blockquote></div></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="RESTRUCTURINGTABLES" class="calibre8">Restructuring Existing Tables</a></h2><p class="calibre9">While you have the ability to arbitrarily add new columns to existing tables, remember that (as of PostgreSQL
      7.1.x) <span><i class="EMPHASIS">you cannot drop columns from existing tables</i></span>. There are two fairly painless
      workarounds for restructuring existing tables. The first involves the <tt class="REPLACEABLE">CREATE TABLE AS</tt>
      command, while the second combines the <tt class="REPLACEABLE">CREATE TABLE</tt> command with the
      <tt class="REPLACEABLE">INSERT INTO</tt> command.</p><p class="calibre9">Each of these methods, in essence, involves creating a new table with your desired structure, filling it up with the
      data from your existing table, and renaming the tables so that the new table takes the place of your old table.</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">When "restructuring" a table in this fashion, it is important to notice that old indices placed on the original
        table will not automatically be applied to the newly created table, nor will the OIDs (object identifiers) be the same.
        Any indices must be dropped and recreated.</p></td></tr></table></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5420" class="calibre8">Restructuring with CREATE TABLE AS</a></h3><p class="calibre9">One common technique of restructuring a table is to use the <tt class="REPLACEABLE">CREATE TABLE</tt> command in
        conjunction with the <tt class="REPLACEABLE">AS</tt> clause and a valid SQL query. This allows you to restructure your
        existing table into a temporary table, which can then be renamed. Doing this also allows you to both remove and
        re-arrange columns to a table by physically re-creating it, and simultaneously re-populating it with data from the
        original table.</p><p class="calibre9">The following syntax describes this limited version of <tt class="REPLACEABLE">CREATE TABLE</tt>, where
        <tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt> is the valid <tt class="REPLACEABLE">SELECT</tt> statement that selects the data
        to populate the new table with. The data type of each created column is implied by the type of each corresponding column selected
        by <tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt>:</p><pre class="SCREEN">  CREATE [ TEMPORARY | TEMP ] TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
         [ ( <tt class="REPLACEABLE"><i class="EMPHASIS">column_name</i></tt> [, ...] ) ]
         AS <tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt></pre><p class="calibre9">The advantage to this technique is that you may create the new table and populate it in a single SQL
        command. The most notable limitation of this technique is that there is no comprehensive way to set constraints
        on the newly created table; the only constraints that may be added to the table after is has been created are the foreign
        key and check constraints. Once the new table has been created, the old one can be renamed (or destroyed), and the new one can be
        renamed to the name of the original table.</p><p class="calibre9">Suppose, for example, that you wanted to modify the <tt class="REPLACEABLE">books</tt> table in order to drop
        the superfluous <tt class="REPLACEABLE">publication</tt> column which was created in <a href="x5021.htm#ADDINGCOLUMNS">the Section called <i class="EMPHASIS">Adding columns</i></a>."
        You can create a limited copy of the table (designating only the desired columns) by passing a valid
        <tt class="REPLACEABLE">SELECT</tt> statement to the <tt class="REPLACEABLE">AS</tt> clause of
        <tt class="REPLACEABLE">CREATE TABLE</tt>, and dropping the old table with <tt class="REPLACEABLE">DROP TABLE</tt>,
        as shown in <a href="x5021.htm#RESTRUCTURINGATABLEWITHCREATETABLEAS">Example 4-14</a>.</p><div class="NAVHEADER"><a name="RESTRUCTURINGATABLEWITHCREATETABLEAS"></a><p class="calibre9"><b class="calibre10">Example 4-14. Restructuring a table with CREATE TABLE AS</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
          Table "books"
  Attribute  |  Type   | Modifier
-------------+---------+----------
 id          | integer | not null
 title       | text    | not null
 author_id   | integer |
 subject_id  | integer |
 publication | date    |
Index: books_id_pkey

booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE new_books</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">       (id, title, author_id, subject_id)</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">       AS SELECT id, title, author_id, subject_id</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                 FROM books;</b></tt>
SELECT
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE books RENAME TO old_books;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE new_books RENAME TO books;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
        Table "books"
 Attribute  |  Type   | Modifier
------------+---------+----------
 id         | integer |
 title      | text    |
 author_id  | integer |
 subject_id | integer |

booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP TABLE books;</b></tt>
DROP</pre></div><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">As of PostgreSQL 7.1.x, if you specify the optional column list within parentheses, you cannot use the 
          asterisk (<tt class="REPLACEABLE">*</tt>) in the <tt class="REPLACEABLE"><i class="EMPHASIS">query</i></tt> statement. This behavior is scheduled to be
          corrected in PostgreSQL 7.2.</p></td></tr></table></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN5463" class="calibre8">Restructuring with CREATE TABLE and INSERT INTO</a></h3><p class="calibre9">If you require a more specifically defined table than that created by <tt class="REPLACEABLE">CREATE TABLE AS</tt>
        (e.g., one with column constraints), you can replicate the effect of the <tt class="REPLACEABLE">CREATE TABLE AS</tt>
        technique by issuing two SQL statements rather than one. You can achieve this by first creating the new table as you ordinarily
        would with <tt class="REPLACEABLE">CREATE TABLE</tt>, and then populating the table with data via the
        <tt class="REPLACEABLE">INSERT INTO</tt> command and a valid <tt class="REPLACEABLE">SELECT</tt> statement.</p><div class="NAVHEADER"><a name="RESTRUCTURINGATABLEWITHCREATETABLE"></a><p class="calibre9"><b class="calibre10">Example 4-15. Restructuring a table with CREATE TABLE and INSERT INTO</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE new_books (</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">  id integer UNIQUE,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">  title text NOT NULL,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">  author_id integer,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">  subject_id integer,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">  CONSTRAINT books_ id_ pkey PRIMARY KEY (id)</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">);</b></tt>
NOTICE:  CREATE TABLE/PRIMARY KEY will create implicit index 'books_id_pkey'
for table 'new_books'
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">INSERT INTO new_books</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">            SELECT id, title, author_id, subject_id</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                   FROM books;</b></tt>
INSERT 0 12
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE books RENAME TO old_books;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">ALTER TABLE new_books RENAME TO books;</b></tt>
ALTER
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
          Table "books"
 Attribute  |  Type   | Modifier
------------+---------+----------
 id         | integer | not null
 title      | text    | not null
 author_id  | integer |
 subject_id | integer |
Index: books_id_pkey</pre></div><p class="calibre9">See <a href="x5504.htm#INSERTINGVALUESFROMOTHERTABLESWITHSELECT">the Section called <i class="EMPHASIS">Inserting Values from Other Tables with SELECT</i></a>" for more information about using
        the <tt class="REPLACEABLE">INSERT INTO</tt> command with a <tt class="REPLACEABLE">SELECT</tt> statement,
        and <a href="x5802.htm">the Section called <i class="EMPHASIS">Retrieving Rows with SELECT</i></a>" for more information about valid <tt class="REPLACEABLE">SELECT</tt> statements.
        </p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="DROPPINGTABLES" class="calibre8">Destroying Tables with DROP TABLE</a></h2><p class="calibre9">The SQL command to permanently destroy a table is <tt class="REPLACEABLE">DROP TABLE</tt>. The following is
      the syntax for <tt class="REPLACEABLE">DROP TABLE</tt>, where <tt class="REPLACEABLE"><i class="EMPHASIS">tablename</i></tt> is the table that you
      wish to destroy:</p><pre class="SCREEN">  DROP TABLE <tt class="REPLACEABLE"><i class="EMPHASIS">tablename</i></tt></pre><p class="calibre9">Use caution when dropping a table, as doing so destroys all data associated with the table.</p><div class="NAVHEADER"><blockquote class="NOTE"><a name="IMPLICITINDICES"></a><p class="calibre9"><b class="calibre10">Note: </b>Destroying a table with an implicitly-created index will destroy any associated indices.</p></blockquote></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="c4890.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="x5504.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">Using SQL with PostgreSQL</td><td width="34%" valign="top" class="calibre4"><a href="c4890.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Adding Data with INSERT and COPY</td></tr></table></div></div>

{% endraw %}

