---
layout: page
title: "Unknown"
prev: r24435.htm
next: r24734.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="r24435.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4"/><td width="10%" valign="bottom" class="calibre5"><a href="r24734.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><h1 class="calibre7"><a name="SQL-CREATEOPERATOR" class="calibre8">CREATE OPERATOR</a></h1><div class="NAVHEADER"><a name="AEN24540"></a><h2 class="SECT">Name</h2>CREATE OPERATOR -- Defines a new operator within the database.</div><div class="NAVHEADER"><a name="AEN24543"></a><h2 class="SECT">Synopsis</h2><pre class="SCREEN">CREATE OPERATOR <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( PROCEDURE = <tt class="REPLACEABLE"><i class="EMPHASIS">func_name</i></tt>
      [, LEFTARG = <tt class="REPLACEABLE"><i class="EMPHASIS">type1</i></tt> ] [, RIGHTARG = <tt class="REPLACEABLE"><i class="EMPHASIS">type2</i></tt> ]
      [, COMMUTATOR = <tt class="REPLACEABLE"><i class="EMPHASIS">com_op</i></tt> ] [, NEGATOR = <tt class="REPLACEABLE"><i class="EMPHASIS">neg_op</i></tt> ]
      [, RESTRICT = <tt class="REPLACEABLE"><i class="EMPHASIS">res_proc</i></tt> ] [, JOIN = <tt class="REPLACEABLE"><i class="EMPHASIS">join_proc</i></tt> ]
      [, HASHES ] [, SORT1 = <tt class="REPLACEABLE"><i class="EMPHASIS">left_sort_op</i></tt> ] [, SORT2 = <tt class="REPLACEABLE"><i class="EMPHASIS">right_sort_op</i></tt> ] )</pre><div class="NAVHEADER"><a name="R2-SQL-CREATEOPERATOR-1"></a><h3 class="AUTHOR">Parameters</h3><p class="calibre9">
</p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt></dt><dd class="calibre16"><p class="calibre9">The character sequence of the new operator.  Read further for a list of valid characters to use in names and symbols.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">func_name</i></tt></dt><dd class="calibre16"><p class="calibre9">The function that implements the the new operator.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">type1</i></tt></dt><dd class="calibre16"><p class="calibre9">The type of the left-hand argument. Do not use this option with a unary operator that always appears to the left of the value on which it operates.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">type2</i></tt></dt><dd class="calibre16"><p class="calibre9">The data type of the right-hand argument. Do not use this option with a unary operator that always appears to the right of the value on which it operates.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">com_op</i></tt></dt><dd class="calibre16"><p class="calibre9">The commutator operator for the new operator. A commutator is another existing operator which executes the commutation (order reversal) of the procedure defined for the new operator, e.g., with the left argument treated as the right argument, and the right argument treated as the left argument.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">neg_op</i></tt></dt><dd class="calibre16"><p class="calibre9">The negator operator for the new operator. A negator is another existing operator which executes the literal
        inversion of the procedure define for the new operator. A negator should only be defined if the result of applying the
        <tt class="REPLACEABLE">NOT</tt> keyword to the new operator always results in the same output that the negator would
        return on the same condition.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">res_proc</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the restriction selectivity estimator function for the new operator. This function must already exist, must accept arguments of the same data types as defined for this new operator, and return a floating point value.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">join_proc</i></tt></dt><dd class="calibre16"><p class="calibre9">The name of the join selectivity estimator function for the new operator. This function must already exist, and must be defined to accept arguments of the same data types as defined for this new operator, and return a floating point value.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">HASHES</tt></dt><dd class="calibre16"><p class="calibre9">The <tt class="REPLACEABLE">HASHES</tt> keyword, which indicates that the new operator can support a hash join.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">left_sort_op</i></tt></dt><dd class="calibre16"><p class="calibre9">The operator that sorts left-hand values, if the new operator can support a merge join.</p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE"><i class="EMPHASIS">right_sort_op</i></tt></dt><dd class="calibre16"><p class="calibre9">The operator that sorts right-hand values, if the new operator can support a merge join.</p></dd></dl></div>
</div><div class="NAVHEADER"><a name="R2-SQL-CREATEOPERATOR-2"></a><h3 class="AUTHOR">Results</h3><p class="calibre9"> </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE">CREATE</tt></dt><dd class="calibre16"><p class="calibre9">The message returned when a new operator is created successfully.</p></dd></dl></div>
</div></div><div class="NAVHEADER"><a name="R1-SQL-CREATEOPERATOR-1"></a><h2 class="SECT">Description</h2><p class="calibre9">Use the <tt class="REPLACEABLE">CREATE OPERATOR</tt> command to define a new operator.  The PostgreSQL user that creates the operator becomes the operator owner when creation is successful.</p><p class="calibre9">The operator <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> is a character sequence up to 31 characters in length.  Characters in the operator name must be within the following list of accepted characters:</p><pre class="SCREEN"> + - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ? $</pre><p class="calibre9">There are some restrictions on allowed character sequences for the name:</p><p class="calibre9"> </p><p class="calibre9"></p><ul class="calibre21"><li class="calibre22"><p class="calibre9">The dollar sign (<tt class="REPLACEABLE">$</tt>) is only allowed within an operator name consisting of multiple characters.  It cannot be specified as single-character operator name.</p></li><li class="calibre22"><p class="calibre9">The double-dash (<tt class="REPLACEABLE">- -</tt>) and the forward slash and star (<tt class="REPLACEABLE">/*</tt>) character combinations cannot appear anywhere in an operator name, as they will be interpreted as the start of a comment.</p></li><li class="calibre22"><p class="calibre9">A multiple character operator cannot end with a plus sign (<tt class="REPLACEABLE">+</tt>) or dash (<tt class="REPLACEABLE">-</tt>), unless the name also contains at least one of the following characters:
          </p><p class="calibre9"></p><ul class="calibre28"><li class="calibre22"><p class="calibre9">Tilde (<tt class="REPLACEABLE">~</tt>)</p></li><li class="calibre22"><p class="calibre9">Exclamation mark (<tt class="REPLACEABLE">!</tt>)</p></li><li class="calibre22"><p class="calibre9">At symbol (<tt class="REPLACEABLE">@</tt>)</p></li><li class="calibre22"><p class="calibre9">Number symbol (<tt class="REPLACEABLE">#</tt>)</p></li><li class="calibre22"><p class="calibre9">Percent sign (<tt class="REPLACEABLE">%</tt>)</p></li><li class="calibre22"><p class="calibre9">Caret (<tt class="REPLACEABLE">^</tt>)</p></li><li class="calibre22"><p class="calibre9">Ampersand (<tt class="REPLACEABLE">&amp;</tt>)</p></li><li class="calibre22"><p class="calibre9">Pipe (<tt class="REPLACEABLE">|</tt>)</p></li><li class="calibre22"><p class="calibre9">Backtick (<tt class="REPLACEABLE">`</tt>)</p></li><li class="calibre22"><p class="calibre9">Question mark (<tt class="REPLACEABLE">?</tt>)</p></li><li class="calibre22"><p class="calibre9">Dollar sign (<tt class="REPLACEABLE">$</tt>)</p></li></ul>
<p class="calibre9">These restrictions on operator names let PostgreSQL parse syntactically valid queries without requiring the user to separate tokens with spaces (or other characters).</p></li></ul>
<div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>When using non-SQL standard (i.e., user-defined) operator names, you should make it a habit to separate adjacent operators with a space to clearly define your intended meaning.</p></blockquote></div><p class="calibre9">When you create an operator , you must include at least one <tt class="REPLACEABLE">LEFTARG</tt> or one
    <tt class="REPLACEABLE">RIGHTARG</tt> (as the operator must take an argument). If you are defining a binary operator (one which
    operators on a value to the left <span><i class="EMPHASIS">and</i></span> right of the operator), <span><i class="EMPHASIS">both</i></span> the
    <tt class="REPLACEABLE">LEFTARG</tt> and <tt class="REPLACEABLE">RIGHTARG</tt> must be specified. If you are creating a right unary operator, you
    will only need to define <tt class="REPLACEABLE">LEFTARG</tt>; likewise, when creating a left unary operator, you will only need to
    define <tt class="REPLACEABLE">RIGHTARG</tt>.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>The function you specify as the <tt class="REPLACEABLE"><i class="EMPHASIS">func_name</i></tt> parameter when creating an operator must have been defined to accept the correct number of arguments for that operator.</p></blockquote></div><p class="calibre9"> For the query optimizer to correctly reverse the order of operands, it needs to know what the commutator operator is (if it exists).  For some operators, a commutator should exist (or at least, the existence of one would make sense).  For example, the commutator of the greater-than symbol (<tt class="REPLACEABLE">&gt;</tt>) is the less-than (<tt class="REPLACEABLE">&lt;</tt>) symbol, and it makes sense that both of these should exist, and be related to one another in this fashion. With this information, your operator order can easily be reversed, changing something like <tt class="REPLACEABLE">x &lt; y</tt> to <tt class="REPLACEABLE">y &gt; x</tt> if the query optimizer finds it to be more efficient.</p><p class="calibre9"> In the same way that specifying the commutator operator can help the optimizer, so can specifying a negator operator (if one exists).  The negator to the equals sign (<tt class="REPLACEABLE">=</tt>) is <tt class="REPLACEABLE">!=</tt>, signifying <span><i class="EMPHASIS">not-equals</i></span> or <span><i class="EMPHASIS">not-equivalent</i></span>.  When a negator is specified, the query optimizer can simplify statements like this:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM employees WHERE NOT name = 'John';</b></tt></pre><p class="calibre9">This simplified form of this query, using the negator operator, is:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM employees WHERE name != 'John';</b></tt></pre><p class="calibre9">Note that you may technically specify an operator's commutator or negator operator to PostgreSQL before that operator actually exists. This is to allow you to create two operators which reference one another. Exercise care, however, in remembering to create the appropriate operator to fit the definition of your commutator or negator if it does not yet exist.</p><p class="calibre9"> Use the <tt class="REPLACEABLE">HASH</tt> option to indicate to the query optimizer that an operator can support the use of a hash-join algorithm (usable only if the operator represents equality tests where equality of the type also means bitwise equality of the representation of the type).  Likewise, use <tt class="REPLACEABLE">SORT1</tt> and <tt class="REPLACEABLE">SORT2</tt> to inform the optimizer that, respectively, the left and right side operators can support a merge-sort.  These sorting operators should only be given for an equality operator, and when they are given they should be represented by less-than and greater-than symbols for the left- and right-hand data types, respectively.</p><p class="calibre9">The <tt class="REPLACEABLE">RESTRICT</tt> and <tt class="REPLACEABLE">JOIN</tt> parameters provide functions that assist the query optimizer with estimation of result set sizes.  With some query conditions, it may be necessary for PostgreSQL to estimate the number of results an action with operators may produce; in these situations, the query optimizer will call the <tt class="REPLACEABLE">res_proc</tt> function with the same arguments passed to the operator, then use the number returned by that function to estimate how many results there will be.  Because of this, the <tt class="REPLACEABLE">res_proc</tt> function must already be defined using <tt class="REPLACEABLE">CREATE_FUNCTION</tt> and must accept the correct arguments.</p><p class="calibre9">The function specified with <tt class="REPLACEABLE">JOIN</tt> is used to help with estimation of the size of a join when the operands of an operator are not constant values. The query optimizer uses the floating point number returned from <tt class="REPLACEABLE">join_proc</tt> to compute the estimated size of the result.</p></div><div class="NAVHEADER"><a name="R1-SQL-CREATEOPERATOR-2"></a><h2 class="SECT">Examples</h2><p class="calibre9">The following example defines a non-zero boolean operator for the <tt class="REPLACEABLE">integer</tt> type, using the <tt class="REPLACEABLE">is_zero</tt> function (see <a href="c13329.htm">Chapter 7</a> for more on this function and its definition):</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE OPERATOR !# (PROCEDURE = is_zero,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                    LEFTARG = integer,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                    RIGHTARG = integer);</b></tt>
CREATE</pre></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="r24435.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="r24734.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">CREATE LANGUAGE</td><td width="34%" valign="top" class="calibre4"><a href="c22759.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">CREATE RULE</td></tr></table></div></div>

{% endraw %}

