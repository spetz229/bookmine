---
layout: page
title: "Unknown"
prev: x13128.htm
next: x13546.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="x13128.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4"/><td width="10%" valign="bottom" class="calibre5"><a href="x13546.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><div class="calibre18"></div><h1 id="calibre_toc_9" class="calibre7"><a name="ADVANCEDPOSTGRESQL" class="calibre8">Chapter 7. Advanced Features</a></h1><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><b class="calibre10">Table of Contents</b></dt><dt class="NAVHEADER"><a href="c13329.htm#INDICES">Indices</a></dt><dt class="NAVHEADER"><a href="x13546.htm">Advanced Table Techniques</a></dt><dt class="NAVHEADER"><a href="x14110.htm">Arrays</a></dt><dt class="NAVHEADER"><a href="x14316.htm">Automating Common Routines</a></dt><dt class="NAVHEADER"><a href="x15040.htm">Transactions and Cursors</a></dt><dt class="NAVHEADER"><a href="x15284.htm">Extending PostgreSQL</a></dt></dl></div><p class="calibre9">This chapter covers more advanced PostgreSQL subjects including optimizing table access with indices, advanced
  table concepts such as inheritance and constraints, the practical use of non-atomic array values, and explicit use of
  transactions and cursors. These sophisticated features greatly set PostgreSQL apart from many other relational
  database management systems.</p><p class="calibre9">This chapter also documents programmatic concepts such as triggers and sequences. Finally, for programmers wanting to add
  customized routines to the database, we document how to extend PostgreSQL through the addition of user-defined functions and
  operators.</p><div class="NAVHEADER"><h1 class="calibre7"><a name="INDICES" class="calibre8">Indices</a></h1><p class="calibre9">Indices are database objects that can greatly increase database performance, enabling faster
    execution of statements involving comparative criteria. An index tracks the data on one or more columns in a table, allowing
    conditional clauses (such as the <tt class="REPLACEABLE">WHERE</tt> clause) to find their targeted rows more
    efficiently.</p><p class="calibre9">The internal workings of indices vary, and there are several implementations to choose from. This section describes the
    different types of indices available, and explains when you should use one type over the other.</p><p class="calibre9">While indices exist to enhance performance, they also contribute to system overhead. Indices must be updated as data
    in the column that they are applied to fluctuates. Maintaining infrequently used indices decreases performance when the amount of time spent maintaining them outweighs the time saved through using them. In general, indices
    should be applied only to columns that you expect to use frequently in comparative expressions.</p><div class="NAVHEADER"><h2 class="SECT"><a name="AEN13344" class="calibre8">Creating an Index</a></h2><p class="calibre9">Indices are created with the <tt class="REPLACEABLE">CREATE INDEX</tt> SQL command. Here is the syntax for
      <tt class="REPLACEABLE">CREATE INDEX</tt>:</p><pre class="SCREEN">  CREATE [ UNIQUE ] INDEX <tt class="REPLACEABLE"><i class="EMPHASIS">indexname</i></tt> ON <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
         [ USING <tt class="REPLACEABLE"><i class="EMPHASIS">indextype</i></tt> ] ( <tt class="REPLACEABLE"><i class="EMPHASIS">column</i></tt> [ <tt class="REPLACEABLE"><i class="EMPHASIS">opclass</i></tt> ] [, ...] )</pre><p class="calibre9">In this syntax, <tt class="REPLACEABLE"><i class="EMPHASIS">indexname</i></tt> is the name of the new index to be created, <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
      is the name of the table to be indexed, and <tt class="REPLACEABLE"><i class="EMPHASIS">column</i></tt> is the name of a specific column to be indexed.
      Optionally, the <tt class="REPLACEABLE"><i class="EMPHASIS">indextype</i></tt> parameter may be set to specify index implementation, and
      the <tt class="REPLACEABLE"><i class="EMPHASIS">opclass</i></tt> parameter may be set to indicate what operator class should be used in sorting input
      values.</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">Operator classes are stored in PostgreSQL's <tt class="REPLACEABLE">pg_opclass</tt> column. Unless you are
        especially knowledgeable of the technical inner workings of PostgreSQL's operator classes, you shouldn't use this option.</p></td></tr></table></div><p class="calibre9">Regarding the <tt class="REPLACEABLE"><i class="EMPHASIS">column</i></tt> to index, multiple names may be specified, separated by commas; doing so
      creates an index across <span><i class="EMPHASIS">both</i></span> specified columns. Such an index will only be used by PostgreSQL when
      executing SQL statements that search all indexed columns in the <tt class="REPLACEABLE">WHERE</tt> clause through the
      <tt class="REPLACEABLE">AND</tt> keyword. Multicolumn indices are limited to a maximum of 16 columns in a default
      PostgreSQL installation, and may not use an index type other than B-tree.</p><p class="calibre9">In determining upon which columns to create an index, consider which columns will be most frequently accessed for search
      conditions. For example, while the <tt class="REPLACEABLE">books</tt> table keeps an index on its
      <tt class="REPLACEABLE">id</tt> column (the primary key), the <tt class="REPLACEABLE">title</tt> column is also
      frequently checked for in <tt class="REPLACEABLE">WHERE</tt> conditions. Adding a secondary index to the
      <tt class="REPLACEABLE">title</tt> column will greatly increase the performance of SQL statements making comparisons
      against values in that column.</p><p class="calibre9"><a href="c13329.htm#CREATINGANINDEX">Example 7-1</a> shows how to create such an index and uses the <tt class="REPLACEABLE">\d</tt>
<span><i class="EMPHASIS">psql</i></span> slash command to view the <tt class="REPLACEABLE">books</tt> table. In addition to showing
      the table's column types, this command also shows the indices that have been created on it.</p><div class="NAVHEADER"><a name="CREATINGANINDEX"></a><p class="calibre9"><b class="calibre10">Example 7-1. Creating an index</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE INDEX books_title_idx</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">             ON books (title);</b></tt>
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d books</b></tt>
          Table "books"
 Attribute  |  Type   | Modifier
------------+---------+----------
 id         | integer | not null
 title      | text    | not null
 author_id  | integer |
 subject_id | integer |
Indices: books_id_pkey,
         books_title_idx</pre></div><p class="calibre9">Certain types of table constraints, notably the <tt class="REPLACEABLE">PRIMARY KEY</tt> and
      <tt class="REPLACEABLE">UNIQUE</tt> constraints, result in the implicit creation of an index for use in enforcing the
      constraint. In <a href="c13329.htm#IMPLICITINDEXCREATION">Example 7-2</a> you see the creation of the Book Town
      <tt class="REPLACEABLE">authors</tt> table with the <tt class="REPLACEABLE">PRIMARY KEY</tt> constraint placed on
      its <tt class="REPLACEABLE">id</tt> column. This use of <tt class="REPLACEABLE">PRIMARY KEY</tt> causes an index
      called <tt class="REPLACEABLE">authors_ pkey</tt> to be implicitly created.</p><div class="NAVHEADER"><a name="IMPLICITINDEXCREATION"></a><p class="calibre9"><b class="calibre10">Example 7-2. Implicit index creation</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE authors (id integer PRIMARY KEY,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                      last_name text,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                      first_name text);</b></tt>
NOTICE:  CREATE TABLE/PRIMARY KEY will create implicit index 'authors_pkey' for 
table 'authors'
CREATE
example=# <tt class="REPLACEABLE"><b class="calibre10">\d authors</b></tt>
         Table "authors"
 Attribute  |  Type   | Modifier
------------+---------+----------
 id         | integer | not null
 last_name  | text    |
 first_name | text    |
Index: authors_pkey</pre></div><p class="calibre9">The index created in <a href="c13329.htm#IMPLICITINDEXCREATION">Example 7-2</a> enables PostgreSQL to quickly verify that the primary key
      is unique for any new row inserted into the table, as well as enhances the performance of queries which use the
      <tt class="REPLACEABLE">id</tt> column as a search condition.</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="UNIQUEINDICES" class="calibre8">Unique indices</a></h3><p class="calibre9">Specifying the <tt class="REPLACEABLE">UNIQUE</tt> keyword causes the index to disallow duplicate values within
        the column (or set of columns) it indexes. Creating a <tt class="REPLACEABLE">UNIQUE</tt> index on a table is functionally identical to
        creating a table with the <tt class="REPLACEABLE">UNIQUE</tt> constraint (see <a href="x13546.htm#CONSTRAINTS">the Section called <i class="EMPHASIS">Using Constraints</i></a>" later in
        this chapter).</p><p class="calibre9"><a href="c13329.htm#CREATINGAUNIQUEINDEX">Example 7-3</a> creates a unique index called
        <tt class="REPLACEABLE">unique_ publisher_idx</tt> on the <tt class="REPLACEABLE">publishers</tt> table's
        <tt class="REPLACEABLE">name</tt> column. This will disallow two publishers from having the same name in this
        table.</p><div class="NAVHEADER"><a name="CREATINGAUNIQUEINDEX"></a><p class="calibre9"><b class="calibre10">Example 7-3. Creating a unique index</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE UNIQUE INDEX unique_publisher_idx</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                    ON publishers (name);</b></tt>
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">\d publishers</b></tt>
       Table "publishers"
 Attribute |  Type   | Modifier
-----------+---------+----------
 id        | integer | not null
 name      | text    |
 address   | text    |
Indices: publishers_pkey,
         unique_publisher_idx</pre></div><p class="calibre9">As the <tt class="REPLACEABLE">NULL</tt> value does not technically match any value, duplicate instances of
        <tt class="REPLACEABLE">NULL</tt> can be inserted into a column with a unique index placed on it. This is the main
        practical difference between a unique index and an index implicitly created by the
        
        <tt class="REPLACEABLE">PRIMARY KEY</tt> constraint, which does not allow <tt class="REPLACEABLE">NULL</tt>
        values at all.</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">Note that the <tt class="REPLACEABLE">UNIQUE</tt> clause may not be used in conjunction with the
          <tt class="REPLACEABLE">USING</tt> clause for any index type other than B-tree.</p></td></tr></table></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN13440" class="calibre8">Index types</a></h3><p class="calibre9">The optional <tt class="REPLACEABLE">USING</tt> clause can be used to specify the type of index to
        implement. PostgreSQL 7.1.x supports three types of indices including:</p><p class="calibre9"> </p><p class="calibre9"></p><ul class="calibre21"><li class="calibre22"><p class="calibre9">B-tree</p></li><li class="calibre22"><p class="calibre9">R-tree</p></li><li class="calibre22"><p class="calibre9">Hash</p></li></ul>
<p class="calibre9">PostgreSQL's B-tree implementation uses Lehman-Yao high-concurrency B-tree algorithms and is both the most
        capable, and most commonly used indexing method. For this reason, it is the default index type.</p><p class="calibre9">The R-tree implementation is primarily useful for spacial data type operations (i.e., operations on geometric
        types) and utilizes Guttman's quadratic split algorithm. The Hash implementation utilizes Litwin's linear
        hashing routines, which have been traditionally used for indices that involve frequent direct equal-to comparisons (e.g.,
        with the <tt class="REPLACEABLE">=</tt> operator).</p><p class="calibre9">At the time of this writing, for PostgreSQL 7.1.x, the B-tree index implementation is by far the most capable and
        flexible of the available index types. At this time, it is recommended that you use the B-tree index type over the Hash
        implementation, even for direct <tt class="REPLACEABLE">=</tt> comparisons. The Hash index exists mostly for legacy
        reasons, though it may still be used if you are sure your system would benefit from a Hash index over a B-tree
        index.</p><p class="calibre9">As stated, the R-tree index implementation is recommended for indexing geometric types; be aware, however, that
        several limitations exist. For example, you cannot create a unique R-tree index, nor can you
        create an R-tree index on more than one column. In these cases, it makes more sense to rely on the capable B-tree index
        type.</p><p class="calibre9">The <tt class="REPLACEABLE">USING</tt> clause can be used with the keywords
        <tt class="REPLACEABLE">BTREE</tt>, <tt class="REPLACEABLE">RTREE</tt>, and <tt class="REPLACEABLE">HASH</tt>
        in order to explicitly choose the type of index you want to create. Specifying <tt class="REPLACEABLE">BTREE</tt>
        explicitly chooses the default index type.</p><p class="calibre9"><a href="c13329.htm#SPECIFYINGANINDEXTYPE">Example 7-4</a> creates a table called <tt class="REPLACEABLE">polygons</tt>, which
        stores spacial data of the type <tt class="REPLACEABLE">polygon</tt>. An index named
        <tt class="REPLACEABLE">spacial_idx</tt> is then applied to its <tt class="REPLACEABLE">shape</tt> column with
        the R-tree implementation.</p><div class="NAVHEADER"><a name="SPECIFYINGANINDEXTYPE"></a><p class="calibre9"><b class="calibre10">Example 7-4. Specifying an index type</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE polygons (shape polygon);</b></tt>
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE INDEX spacial_idx ON polygons USING RTREE (shape);</b></tt>
CREATE</pre></div><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">Again, unless you have a solid conceptual understanding of why one index type might be preferable in your system
          over another, we advise you to use the default B-tree type.</p></td></tr></table></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN13492" class="calibre8">Functional indices</a></h3><p class="calibre9">A slightly modified form of the <tt class="REPLACEABLE">CREATE INDEX</tt> command can be used to index
        the results of a function on a column value, rather than the column value itself. This is called a
        <span><i class="EMPHASIS">functional index</i></span>.</p><p class="calibre9">Use the following syntax to create a functional index:</p><pre class="SCREEN">  CREATE [ UNIQUE ] INDEX <tt class="REPLACEABLE"><i class="EMPHASIS">indexname</i></tt> ON <tt class="REPLACEABLE"><i class="EMPHASIS">table</i></tt>
         [ USING <tt class="REPLACEABLE"><i class="EMPHASIS">indextype</i></tt> ] ( <tt class="REPLACEABLE"><i class="EMPHASIS">functionname</i></tt> ( <tt class="REPLACEABLE"><i class="EMPHASIS">column</i></tt> [, ...] ) [ <tt class="REPLACEABLE"><i class="EMPHASIS">opclass</i></tt> ] )</pre><p class="calibre9">The only difference in this syntax is that the index is created on the results of the specified function
        applied to each column value. All other clauses have the same effect as the functional index.</p><p class="calibre9">Functional indices are useful on table columns that commonly have their values prepared through a function before
        being compared against values in a SQL statement. For example, the <tt class="REPLACEABLE">upper()</tt> function is
        commonly used to make case-insensitive comparisons.  Creating an index using the <tt class="REPLACEABLE">upper()</tt>
        function enables such case-insensitive comparisons to be carried out efficiently.</p><p class="calibre9"><a href="c13329.htm#CREATINGAFUNCTIONALINDEX">Example 7-5</a> creates a functional index named
        <tt class="REPLACEABLE">upper_title_idx</tt> on the <tt class="REPLACEABLE">books</tt> table. It uses the
        <tt class="REPLACEABLE">upper()</tt> function on the <tt class="REPLACEABLE">title</tt> column as the basis to
        create the index. Then it performs an example SQL query that is more efficiently executed as a result of the newly created
        functional index.</p><div class="NAVHEADER"><a name="CREATINGAFUNCTIONALINDEX"></a><p class="calibre9"><b class="calibre10">Example 7-5. Creating a functional index</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE INDEX upper_title_idx ON books</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">             (upper(title));</b></tt>
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT title FROM books WHERE upper(title) = 'DUNE';</b></tt>
 title
-------
 Dune
(1 row)</pre></div></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="DESTROYINGANINDEX" class="calibre8">Destroying an Index</a></h2><p class="calibre9">The SQL command to permanently destroy an existing index from a table is <tt class="REPLACEABLE">DROP INDEX</tt>. Here
      is the syntax for <tt class="REPLACEABLE">DROP INDEX</tt>:</p><pre class="SCREEN">  DROP INDEX <tt class="REPLACEABLE"><i class="EMPHASIS">indexname</i></tt> [, ...]</pre><p class="calibre9">In this syntax, <tt class="REPLACEABLE"><i class="EMPHASIS">indexname</i></tt> is the name of the index that you wish to permanently remove. Multiple
      indices to drop may be specified, separated by commas.</p><p class="calibre9"><a href="c13329.htm#DROPPINGANINDEXEXAMPLE">Example 7-6</a> drops the <tt class="REPLACEABLE">upper_title_idx</tt> index created
      in <a href="c13329.htm#CREATINGAFUNCTIONALINDEX">Example 7-5</a>.</p><div class="NAVHEADER"><a name="DROPPINGANINDEXEXAMPLE"></a><p class="calibre9"><b class="calibre10">Example 7-6. Dropping an index</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP INDEX upper_title_idx;</b></tt>
DROP</pre></div></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="x13128.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="x13546.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">PgAccess: A Graphical Client</td><td width="34%" valign="top" class="calibre4"><a href="p1162.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Advanced Table Techniques</td></tr></table></div></div>

{% endraw %}

