---
layout: page
title: "Unknown"
prev: c19610.htm
next: x19832.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="c19610.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4">Chapter 11. PL/pgSQL</td><td width="10%" valign="bottom" class="calibre5"><a href="x19832.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><h1 class="calibre7"><a name="LANGUAGESTRUCTURE" class="calibre8">Language Structure</a></h1><p class="calibre9">The structure of PL/pgSQL is fairly simple, mainly due to the fact that each portion of code is designed to exist as a
    function. While it may not look immediately similar to other languages, PL/pgSQL's structure is similar to other programming
    languages such as C, in which each portion of code acts (and is created) as a function, all variables must be declared before
    being used, and code segments accept arguments when called and return arguments at their end.</p><p class="calibre9">Regarding its syntax, PL/pgSQL functions are case insensitive. You can use mixed, upper-, or lowercase for keywords and
    identifiers. Additionally, you will notice the use of pairs of apostrophes (single quotes) in many places within this
    chapter. These are required whenever a single apostrophe would ordinarily be used. The pair of apostrophes is a means to
    escape an apostrophe within the function definition to PostgreSQL, since a function definition is actually a large string
    constant within a <tt class="REPLACEABLE">CREATE FUNCTION</tt> statement.</p><p class="calibre9">This section will discuss the block organization of PL/pgSQL code, how to use comments, how PL/pgSQL expressions are
    organized, and the usage of statements.</p><div class="NAVHEADER"><h2 class="SECT"><a name="AEN19721" class="calibre8">Code Blocks</a></h2><p class="calibre9">PL/pgSQL code is organized in blocks of code.  This method of organization is known as <span><i class="EMPHASIS">block structured code</i></span>.
      Code blocks are entered within a SQL <tt class="REPLACEABLE">CREATE FUNCTION</tt> call that creates
      the PL/pgSQL function in the PostgreSQL database.  This <tt class="REPLACEABLE">CREATE FUNCTION</tt> command names the
      new function, states its argument types, and states the return type. The function's main code block then starts with a
      declaration section.</p><p class="calibre9">All variables are declared and optionally initialized to a default value in the declaration section of a code block.
      A variable declaration specifies the variable's name and type.  The declaration section is denoted by the
      <tt class="REPLACEABLE">DECLARE</tt> keyword.  Each variable declaration is ended with a semicolon.  </p><p class="calibre9">After declaring variables, the main body of the code block is started with the <tt class="REPLACEABLE">BEGIN</tt>
      keyword. The code block's statements should appear after the <tt class="REPLACEABLE">BEGIN</tt> keyword.  </p><p class="calibre9">The <tt class="REPLACEABLE">END</tt> keyword designates the end of the code block. The main block of a PL/pgSQL
      function should return a value of its specified return type and end any sub-blocks (code blocks started within another code
      block) before its <tt class="REPLACEABLE">END</tt> keyword is reached.</p><p class="calibre9"><a href="x19712.htm#CODEBLOCKEXAMPLE">Example 11-5</a> shows the structure of a PL/pgSQL code block.</p><div class="NAVHEADER"><a name="CODEBLOCKEXAMPLE"></a><p class="calibre9"><b class="calibre10">Example 11-5. Structure of a PL/pgSQL code block</b></p><pre class="SCREEN">CREATE FUNCTION <tt class="REPLACEABLE"><i class="EMPHASIS">identifier</i></tt> (<tt class="REPLACEABLE"><i class="EMPHASIS">arguments</i></tt>) RETURNS <tt class="REPLACEABLE"><i class="EMPHASIS">type</i></tt> AS '
  DECLARE
    <tt class="REPLACEABLE"><i class="EMPHASIS">declaration;</i></tt>
    [...]
  BEGIN
    <tt class="REPLACEABLE"><i class="EMPHASIS">statement;</i></tt>
    [...]
  END;
' LANGUAGE 'plpgsql';</pre></div><p class="calibre9">A block of PL/pgSQL code can contain an unlimited amount of <span><i class="EMPHASIS">sub-blocks</i></span>, which are code blocks
      nested within other code blocks.  Sub-blocks are read and interpreted in the same manner as normal blocks; hence, they may
      also contain sub-blocks of their own.</p><p class="calibre9">Sub-blocks can be useful for the organization of code within a large PL/pgSQL function.  All sub-blocks must follow
      normal block structure, meaning they must start with the <tt class="REPLACEABLE">DECLARE</tt> keyword, followed by the
      <tt class="REPLACEABLE">BEGIN</tt> keyword and a body of statements, then end with the
      <tt class="REPLACEABLE">END</tt> keyword.  </p></div><div class="NAVHEADER"><h2 class="SECT"><a name="AEN19754" class="calibre8">Comments</a></h2><p class="calibre9">There are two methods of commenting in PL/pgSQL, both similar to the comment structure of other programming
      languages. The two methods are single-line comments, and block comments (multiple line comments).  </p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN19760" class="calibre8">Comment syntax</a></h3><p class="calibre9">The first method of commenting is single line commenting.  Single line comments begin with two dashes (- -)
        and have no end-character. The parser interprets all characters on the same line after the two dashes as part of the
        comment. <a href="x19712.htm#USINGSINGLELINECOMMENTS">Example 11-6</a> demonstrates the use of single line comments.</p><div class="NAVHEADER"><a name="USINGSINGLELINECOMMENTS"></a><p class="calibre9"><b class="calibre10">Example 11-6. Using single-line comments</b></p><pre class="SCREEN">-- This will be interpreted as a single-line comment.</pre></div><p class="calibre9">The second type of comment is the multiline or <span><i class="EMPHASIS">block</i></span> comment, which should be familiar to
         most anyone who has worked with programming languages before.  Block comments begin with the forward slash and asterisk
         characters (<tt class="REPLACEABLE">/*</tt>) and end with the asterisk and forward slash characters (<tt class="REPLACEABLE">*/</tt>). 
         Block comments can span multiple lines, and any text between the opening <tt class="REPLACEABLE">/*</tt> and closing
         <tt class="REPLACEABLE">*/</tt> is considered a comment. <a href="x19712.htm#USINGBLOCKCOMMENTS">Example 11-7</a> shows the correct usage
         of a block comment.</p><div class="NAVHEADER"><a name="USINGBLOCKCOMMENTS"></a><p class="calibre9"><b class="calibre10">Example 11-7. Using block comments</b></p><pre class="SCREEN">/*
 *  This is a
 *  block
 *  comment.
 */</pre></div><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>While single-line comments can be nested within block comments, block comments cannot be nested within other block comments.</p></blockquote></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN19779" class="calibre8">Good commenting style</a></h3><p class="calibre9">In any programming language, it is helpful to write useful comments.  A comment is considered useful if it can
        express to the user why a certain section of code was designed a certain way, or why syntax was used in an abnormal or
        creative manner.  Comments that restate what is happening programmatically can be helpful at times, but you must remain
        aware of what is happening in your program and be sure to express <span><i class="EMPHASIS">why</i></span> certain things are being done
        (instead of just <span><i class="EMPHASIS">how</i></span>).</p><p class="calibre9">In our PL/pgSQL code examples we will use comments to explain how and why we do certain things within a particular
        section of code.  This is to help you, as a new PL/pgSQL user, learn more about the language and its uses.</p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="AEN19785" class="calibre8">Statements and Expressions</a></h2><p class="calibre9">PL/pgSQL code is composed of statements and expressions (as most programming languages are).  Most of your code will
      be made of statements, and you will probably find yourself using expressions often, as they are essential to certain types
      of data manipulation.  The concept of statements and expressions is generally applicable to all programming languages in
      alike (or at least very similar) ways, and if you have worked with programming languages before, you may already have a
      general understanding of them.</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN19788" class="calibre8">Statements</a></h3><p class="calibre9">A statement performs an action within PL/pgSQL code, such as assignment of a value to a variable or the execution
        of a query.  The organization of statements within a PL/pgSQL code block controls the order in which operations are
        executed within that code block.  The bulk of your statements will be placed in the main operation section of a code
        block, which is located after the <tt class="REPLACEABLE">BEGIN</tt> keyword and before the
        <tt class="REPLACEABLE">END</tt> keyword.  Some declarative statements should appear in the declaration section
        (after the <tt class="REPLACEABLE">DECLARE</tt> keyword), but these should only declare and/or initialize the
        variables that will be referenced within the code block.</p><p class="calibre9">Every statement should end with a semicolon character ( <tt class="REPLACEABLE">;</tt>).  This is similar to
        SQL, which also requires each statement to be ended with a semicolon.  Types of statements (and their uses) are discussed
        throughout the rest of this chapter, as most everything you will do within PL/pgSQL will be done with statements.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN19796" class="calibre8">Expressions</a></h3><p class="calibre9">Expressions are calculations or operations that return their results as one of PostgreSQL's base data types. An
        example expression is <tt class="REPLACEABLE">x := a + b</tt>, which adds the variables
        <tt class="REPLACEABLE">a</tt> and <tt class="REPLACEABLE">b</tt>, then assigns the result to the variable
        <tt class="REPLACEABLE">x</tt>. <a href="x19712.htm#USINGEXPRESSIONS">Example 11-8</a> shows a simple PL/pgSQL function that assigns the
        returned result of a multiplication expression to the variable <tt class="REPLACEABLE">x</tt>, and <a href="x19712.htm#USINGEXPRESSIONS2">Example 11-9</a> shows the output when selecting the function in <span><i class="EMPHASIS">psql</i></span>.  </p><div class="NAVHEADER"><a name="USINGEXPRESSIONS"></a><p class="calibre9"><b class="calibre10">Example 11-8. Using expressions</b></p><pre class="SCREEN">CREATE FUNCTION a_function () RETURNS int4 AS '
DECLARE
   an_integer int4;
BEGIN
   an_integer := 10 * 10;
   return an_integer;
END;
' LANGUAGE 'plpgsql';</pre></div><div class="NAVHEADER"><a name="USINGEXPRESSIONS2"></a><p class="calibre9"><b class="calibre10">Example 11-9. Output of a_ function( )</b></p><pre class="SCREEN">booktown=# SELECT a_function() AS output;
 output
--------
    100
(1 row)</pre></div><p class="calibre9">With the exception of <span><i class="EMPHASIS">dynamic queries</i></span> (SQL queries run with the
        <tt class="REPLACEABLE">EXECUTE</tt> keyword), all PL/pgSQL expressions in a function are only prepared once during
        the lifetime of the PostgreSQL backend process.  Since expressions are only prepared once, constant values (not constant
        variables, but values such as the <span><i class="EMPHASIS">now</i></span> and <span><i class="EMPHASIS">current</i></span>
        timestamp values) used in PL/pgSQL expressions are only prepared once, causing code with constant values that require
        run-time interpretation to break. <a href="x19712.htm#USINGNOWANDCURRENTCORRECTLY">Example 11-10</a> shows how to force PL/pgSQL to evaluate
        constant timestamp values at a function's run-time, instead of once per creation.</p><p class="calibre9"> The <tt class="REPLACEABLE">add_shipment</tt> function in <a href="x19712.htm#USINGNOWANDCURRENTCORRECTLY">Example 11-10</a> is a
        fairly advanced function that uses techniques and aspects of the language covered later in this chapter.  Essentially,
        <tt class="REPLACEABLE">add_shipment</tt> accepts a customer ID number and book ISBN, calculates the next shipment ID
        by adding one to the current highest shipment ID, then inserts the values with a <span><i class="EMPHASIS">now</i></span>
        timestamp into the <tt class="REPLACEABLE">shipments</tt> table.</p><p class="calibre9">If we had used <span><i class="EMPHASIS">now</i></span> directly in the <tt class="REPLACEABLE">INSERT INTO</tt>
        statement, the <span><i class="EMPHASIS">now</i></span> string would have been cast into a timestamp at the time the function
        was created, and the timestamp created would be used in all future calls of the function.</p><div class="NAVHEADER"><a name="USINGNOWANDCURRENTCORRECTLY"></a><p class="calibre9"><b class="calibre10">Example 11-10. Using timestamp values correctly</b></p><pre class="SCREEN">CREATE FUNCTION add_shipment (integer, text) RETURNS timestamp AS '
  DECLARE
     
     -- Declare aliases for function arguments.
    customer_id ALIAS FOR $1;
    isbn ALIAS FOR $2;
     
     -- Declare a variable to hold the shipment ID number and
     -- the current time.
    shipment_id INTEGER;
    right_now timestamp;
  
  BEGIN
     
     -- Set the current time variable to the string ''now''.
    right_now := ''now'';
     
     -- Order the existing shipments by their ID numbers, beginning
     -- with the highest number, then insert the first ID number into
     -- the shipment_id variable.
    SELECT INTO shipment_id id FROM shipments ORDER BY id DESC;
     
     -- Add one to the shipment_id variable.
    shipment_id := shipment_id + 1;
     
     -- Insert a shipment record into the shipments table.  The
     -- right_now variable will be typecast to a timestamp at
     -- run-time, causing constant value now to be interpreted as
     -- the timestamp each time the function is run.
    INSERT INTO shipments VALUES ( shipment_id, customer_id, isbn, right_now );
     
     -- Return a timestamp using the constant value now.
    RETURN right_now;
  END;
' LANGUAGE 'plpgsql';</pre></div></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="c19610.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="x19832.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">PL/pgSQL</td><td width="34%" valign="top" class="calibre4"><a href="c19610.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Using Variables</td></tr></table></div></div>

{% endraw %}

