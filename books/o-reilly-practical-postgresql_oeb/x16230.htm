---
layout: page
title: "Unknown"
prev: p15677.htm
next: c16573.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="c15679.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4">Chapter 8. Authentication and Encryption</td><td width="10%" valign="bottom" class="calibre5"><a href="c16573.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><h1 class="calibre7"><a name="ENCRYPTINGSESSIONS" class="calibre8">Encrypting sessions</a></h1><p class="calibre9">In the digital age, privacy and data integrity have become two of the most talked about areas of computing. It seems
    that almost every day someone else has been cracked, or a new security hole has been found in an application
    you once trusted.</p><p class="calibre9">At the same time, the encrypting of data sessions has become veritably common place amongst computer users.  Every
    reputable e-commerce site uses <span><i class="EMPHASIS">SSL</i></span> (the Secure Sockets Layer) to protect user data while transmitting
    personal information such as credit cards and home addresses across the Internet.</p><p class="calibre9">The most common type of crack executed on a machine is not really a "crack" at all. It is usually an unsuspecting
    user trusting a protocol such as POP or FTP to transfer information over the Internet. By using these protocols, the user
    can unknowingly transmit their login and password in <span><i class="EMPHASIS">clear text</i></span> (in an unencrypted form) over the
    Internet.</p><p class="calibre9">The transmission of data such as login names and passwords in clear text over the Internet means that anybody using a
    <span><i class="EMPHASIS">sniffer</i></span> program (an application that listens to network traffic between two parties) could potentially
    gain access to your most personal information. In the world of databases, this scenario is no different.</p><p class="calibre9">If you connect remotely to PostgreSQL without the use of an encryption technology, there is a potential for misuse by
    crackers on the Internet. If a cracker uses a sniffer on your network, or on a network between your client and the database
    server that you are connecting to, they can gain complete access to the information that is stored within PostgreSQL.</p><p class="calibre9">We will cover three general methods of encrypting your data between PostgreSQL and client connections: </p><p class="calibre9"> </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER">Built-in SSL</dt><dd class="calibre16"><p class="calibre9">The built-in PostgreSQL SSL support, enabled with the <span><i class="EMPHASIS">- -with-ssl</i></span>
        flag at compilation, allows <span><i class="EMPHASIS">psql</i></span> (or any client written specifically to connect to
        PostgreSQL through SSL) to connect securely to PostgreSQL.</p></dd><dt class="NAVHEADER">SSH/OpenSSH</dt><dd class="calibre16"><p class="calibre9">An <span><i class="EMPHASIS">SSH</i></span> (Secure SHell) session may be used to create a <span><i class="EMPHASIS">tunnel</i></span> to
        a remote server, provided that an SSH daemon (e.g., <span><i class="EMPHASIS">sshd</i></span> ) is installed and accessible by the connecting
        user. This requires shell access to the system running PostgreSQL for each user who wishes to connect.</p></dd><dt class="NAVHEADER">Stunnel</dt><dd class="calibre16"><p class="calibre9">Stunnel is an application which creates an encrypted tunnel between a client and the
        PostgreSQL server. The Stunnel method requires shell access to set up, but may be configured to run on a client
        system for a user who does not have direct shell access to the remote server.</p></dd></dl></div>
<div class="NAVHEADER"><h2 class="SECT"><a name="AEN16260" class="calibre8">Built-in SSL</a></h2><p class="calibre9">PostgreSQL provides the option to compile with support for SSL with the <span><i class="EMPHASIS">- -with-ssl</i></span>
      configuration parameter. This option is a good choice if you are going to be doing the majority of your work with PostgreSQL in
      <span><i class="EMPHASIS">psql</i></span>, as it natively supports this method of connection.</p><p class="calibre9">Most people choose to use PostgreSQL as a backend to a variety of client applications. If this is the
      case, you will either need to develop your own client to understand SSL connections to PostgreSQL, or choose an external
      method of encrypting sessions between your client or application and the PostgreSQL server (such as with SSH, or Stunnel).</p></div><div class="NAVHEADER"><h2 class="SECT"><a name="SSHOPENSSH" class="calibre8">SSH/OpenSSH</a></h2><p class="calibre9">OpenSSH provides an excellent method for using external encryption between a client and server. OpenSSH is a commonly
      implemented standard among security professionals and system administrators.  It is most commonly used for terminal or file transfer applications.
      The SSH protocol is a <span><i class="EMPHASIS">general</i></span> method of encryption, and it can be applied in a general fashion for just about any application.</p><p class="calibre9">Provided that you have access to a system account on the remote server, you may authenticate to that
      system and open a tunnel between the remote and local hosts with the <span><i class="EMPHASIS">-L</i></span>  flag. Such a
      tunnel will listen to a specified port on the local machine, encrypt incoming packet data, and forward it to the remote
      server in an encrypted form. The data will then be decrypted and forwarded to another specified port on the remote
      server.</p><p class="calibre9">In this fashion, you can easily create a generalized encrypted tunnel of data between the client and server. Further,
      the entire process is invisible to PostgreSQL, which believes it is accepting packet input from the same machine it is
      running on, from the user which authenticated the creation of the tunnel. Make careful note of this, as your
      <span><i class="EMPHASIS">pg_hba.conf</i></span> will need to reflect the appropriate host.</p><p class="calibre9">The SSH executable is usually called <span><i class="EMPHASIS">ssh</i></span>, and can be used to create a tunnel with the following
      syntax:</p><pre class="SCREEN">ssh -L <tt class="REPLACEABLE"><i class="EMPHASIS">localport:remotehost:remoteport</i></tt> <tt class="REPLACEABLE"><i class="EMPHASIS">username@remotehost</i></tt></pre><p class="calibre9">The <tt class="REPLACEABLE"><i class="EMPHASIS">localport</i></tt> is any arbitrary port that you wish to locally listen on. This port must be
      above 1024, unless you are logged in as the <span><i class="EMPHASIS">root</i></span> user, which is not advisable. This number will be
      the local port that your client believes it is connecting to PostgreSQL on. In actuality, the data received on this port
      will be forwarded to <tt class="REPLACEABLE"><i class="EMPHASIS">remotehost</i></tt> on its listening SSH port (usually 22),
      decrypted, and then forwarded again from the remote server to itself, on the specified <tt class="REPLACEABLE"><i class="EMPHASIS">remoteport</i></tt> number.</p><p class="calibre9">The phrase <tt class="REPLACEABLE"><i class="EMPHASIS">username@remotehost</i></tt> must be provided in order to authenticate a valid system
      user. Without a valid system account an SSH tunnel cannot be created. This entire process is demonstrated in <a href="x16230.htm#MAKINGANSSHTUNNELTOPOSTGRESQL">Example 8-14</a>, in which the ellipses separate a pair of terminal sessions. The first terminal
      connection creates the SSH tunnel, and must remain active in order for the tunnel to exist. The second terminal connection actually takes
      advantage of the tunnel to make a connection to the local tunnel port, which is then forwarded to the remote host,
      decrypted, and passed through to the PostgreSQL server.</p><div class="NAVHEADER"><a name="MAKINGANSSHTUNNELTOPOSTGRESQL"></a><p class="calibre9"><b class="calibre10">Example 8-14. Making an SSH tunnel to PostgreSQL</b></p><pre class="SCREEN">[user@local ~]$ <tt class="REPLACEABLE"><b class="calibre10">ssh -L 4001:remotehost:5432 user@remotehost</b></tt>
user@remotehost's password:
[user@remote ~]$

...

[user@local ~]$ <tt class="REPLACEABLE"><b class="calibre10">psql -h localhost -p 4001 template1</b></tt>
Welcome to psql, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help on internal slash commands
       \g or terminate with semicolon to execute query
       \q to quit

template1=#</pre></div><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>When issuing the ssh command, you may specify the <span><i class="EMPHASIS">-T</i></span>  flag if you don't need to be provided
        with a command line after creating the SSH tunnel, which is the default behavior. This will cause the terminal to appear to hang after
        authentication. Such a session may be terminated with CTRL-C when finished.</p></blockquote></div><p class="calibre9">The only drawback to the use of an SSH tunnel is that it <span><i class="EMPHASIS">requires</i></span> a system account from the
      user who is connecting to PostgreSQL. SSH does not provide completely transparent access to encrypted data streams until
      you initiate a connection and authenticate against the ssh daemon service, which is typically called <span><i class="EMPHASIS">sshd</i></span> service.
      Depending on your needs this could be a positive or negative restriction.</p><p class="calibre9">If you wish to set up an even more generalized encryption tunnel, read through the next section for information on
      Stunnel.</p></div><div class="NAVHEADER"><h2 class="SECT"><a name="STUNNEL" class="calibre8">Configuring and Using Stunnel</a></h2><p class="calibre9">While both the built-in SSL and OpenSSH encryption methods provide robust,
      secure connections to PostgreSQL, they each have their own idiosyncrasies and usage restrictions. Many users of
      PostgreSQL will therefore be interested to know that there is another dependable encryption method available for use with
      totally transparent remote access to the server. If you wish to encrypt database sessions transparently for any client,
      without needing to bind to SSH, this is possible using two easily available tools: OpenSSL and Stunnel.</p><p class="calibre9">If you are a UNIX or Linux system administrator, you are most likely familiar with one or both of these, as
      they are quite useful beyond the scope of this context (in so much as encryption <span><i class="EMPHASIS">in general</i></span> is useful
      beyond the scope of this context). If you are a system administrator who is not familiar with encryption, it is advisable
      that you become familiar with the subject.</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN16308" class="calibre8">OpenSSL</a></h3><p class="calibre9">The OpenSSL software package is a software project developed by members of the Open Source
        community. It is a robust set of tools provided to help your system implement the Secure
        Sockets Layer (SSL), as well as other security-related protocols, such as Transport Layer
        Security (TLS). It also includes a cryptography library. This software package is important
        to anyone who is planning on using a fair amount of security on their Linux machine (not
        limited to PostgreSQL, though that will be our focus). Please note that because it is open-source software, you are able to download it for free, unlike commercial SSL packages that
        require you to purchase the software and/or licensing.</p><p class="calibre9">To download the newest version of OpenSSL, point your web browser to the OpenSSL web page at
        <span><i class="EMPHASIS">http://www.openssl.org</i></span>.  There should be a list of available versions along with links to download
        them. There are two types of versions available: major releases and beta copies. There are a couple of older
        listings for bug fixes. Most likely you will be interested in the newest major release, or a subsequent bug-fix.</p><p class="calibre9">A major release should be listed in a fashion similar to this:</p><pre class="SCREEN">09-Jul-2001: OpenSSL 0.9.6b is now available, a major release</pre><p class="calibre9">Open the source page through the "available" link. Once there, you can download the most up-to-date version, which
        will logically be listed with the text "[LATEST]" printed next to it.</p><p class="calibre9">Download the file for the version you want, and save it into your home directory (or whichever directory you normally save files to).
         After it completes downloading, open a console window and <span><i class="EMPHASIS">cd</i></span> into the directory in which you just saved
        the file. The file will be tarred and gzipped, so you will need to extract it with the following command (note that
        <tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt> represents the version number of the software, e.g., <span><i class="EMPHASIS">0.9.6b</i></span>):</p><pre class="SCREEN">gzip -d openssl-<tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt>.tar.gz</pre><p class="calibre9">Then type:</p><pre class="SCREEN">tar xf openssl-<tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt>.tar</pre><p class="calibre9">These commands extract the OpenSSL files into a directory named <span><i class="EMPHASIS">openssl-<tt class="REPLACEABLE"/></i><i class="EMPHASIS">[version]</i></span>
        where <tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt> is whatever version number you downloaded.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>If you are running the GNU version of <span><i class="EMPHASIS">tar</i></span>, you can simply type
          <span><i class="EMPHASIS">tar -xzf openssl-<tt class="REPLACEABLE"/></i><i class="EMPHASIS">[version]</i>.tar.gz</span> instead of issuing separate <span><i class="EMPHASIS">gzip</i></span> and <span><i class="EMPHASIS">tar</i></span> commands.</p></blockquote></div><p class="calibre9">To complete installation of OpenSSL, <span><i class="EMPHASIS">cd</i></span> into the installation directory. OpenSSL is a
        source distribution, so a bit of compiling is in order.  Before we begin to delve into compilation, there are a
        few requirements you need to be aware of:
        
        </p><p class="calibre9"></p><ul class="calibre21"><li class="calibre22"><p class="calibre9">The <span><i class="EMPHASIS">gmake</i></span> (or <span><i class="EMPHASIS">make</i></span>) program</p></li><li class="calibre22"><p class="calibre9">Perl 5, or higher</p></li><li class="calibre22"><p class="calibre9">An ANSI C compiler</p></li><li class="calibre22"><p class="calibre9">A development environment (development libraries, and C header files)</p></li><li class="calibre22"><p class="calibre9">A supported UNIX-compatible operating system</p></li></ul>
<p class="calibre9">If you have all of these things, you are ready to proceed. Otherwise you will need to acquire them (e.g., download
        and install them) before you will be able to complete the installation of OpenSSL.</p><p class="calibre9">To finish installation, complete the following steps. If you have trouble, consult the <span><i class="EMPHASIS">INSTALL</i></span>
        file (from which these steps were taken).
        
        </p><p class="calibre9"></p><ol type="1" class="calibre27"><li class="calibre22"><p class="calibre9">Execute the configuration script:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">./config</b></tt></pre><p class="calibre9">This step will gather information about your system and configure the OpenSSL installation
            scripts. It shouldn't take incredibly long, though the time will depend on the speed of your system.</p></li><li class="calibre22"><p class="calibre9">Next, compile the OpenSSL software:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">make</b></tt></pre><p class="calibre9">This is the primary <span><i class="EMPHASIS">make</i></span> command. After configuration, this command begins
            compilation of the source code. Even on a fairly high-end machine, this process can take a bit of time.</p></li><li class="calibre22"><p class="calibre9">After compiling, run the test:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">make test</b></tt></pre><p class="calibre9">This command tests the validity of the compilation; if there are any errors, refer to the
            <span><i class="EMPHASIS">INSTALL</i></span> file.</p></li><li class="calibre22"><p class="calibre9">If the test is successful, you can install the OpenSSL binaries:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">make install</b></tt></pre><p class="calibre9">After this step is finished, you should be done with the installation of
            OpenSSL. If you experience any errors, refer to the documentation (specifically the <span><i class="EMPHASIS">INSTALL</i></span>
            and <span><i class="EMPHASIS">README</i></span> files).</p></li></ol>
</div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN16379" class="calibre8">Stunnel</a></h3><p class="calibre9">Stunnel is an SSL <span><i class="EMPHASIS">wrapper</i></span>, which means it allows you to add SSL functionality to a daemon
        that is not normally designed to handle a secure layer. This is useful, because you can use it to create a secure
        connection with a PostgreSQL database, thus encrypting your database connections, thus tightening general system security,
        and protecting your data.</p><p class="calibre9">Stunnel can be found at <span><i class="EMPHASIS">http://www.stunnel.org</i></span>. After opening the page in your web browser,
        open the download page, and click the "get the source code" link. From here you are able to download the newest version. Save the file
        into your home directory, or wherever you wish to place it in your filesystem. Once you have downloaded Stunnel, open a console
        window and <span><i class="EMPHASIS">cd</i></span> into the directory where you saved it. Then unzip and untar the file with the
        following commands:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">gzip -d stunnel-</b></tt><tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt> .tar.gz
$ <tt class="REPLACEABLE"><b class="calibre10">tar xf stunnel-</b></tt><tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt> .tar</pre><p class="calibre9">You should now have the stunnel files extracted into a directory named
        <span><i class="EMPHASIS">stunnel-<tt class="REPLACEABLE"/></i><i class="EMPHASIS">[version]</i></span> (where <tt class="REPLACEABLE"><i class="EMPHASIS">[version]</i></tt> is the version number that you downloaded).
        Fortunately, the installation process of Stunnel is normally quicker than that of OpenSSL. Once everything is
        extracted, <span><i class="EMPHASIS">cd</i></span> into the directory. Remember that you must have already installed OpenSSL
        before this point or the installation of Stunnel will <span><i class="EMPHASIS">not</i></span> work. Use the following process to make
        and install Stunnel:
        
        </p><p class="calibre9"></p><ol type="1" class="calibre27"><li class="calibre22"><p class="calibre9">Run the configuration script:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">./configure</b></tt></pre><p class="calibre9">This command will gather information about your system and configure Stunnel's installation scripts.</p></li><li class="calibre22"><p class="calibre9">Next, compile the Stunnel sources:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">make</b></tt></pre><p class="calibre9">This command compiles the binary files from Stunnel's source code. The program will prompt you with some
            questions regarding your locality and domain name. It will use your input to help build the PEM file (which will be
            called <span><i class="EMPHASIS">stunnel.pem</i></span>). This file is the certificate with which your data is encrypted.</p></li><li class="calibre22"><p class="calibre9">After successfully compiling Stunnel, go ahead and install it:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">make install</b></tt></pre><p class="calibre9">This step will install the compiled files. </p></li></ol>
</div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN16414" class="calibre8">Knowing how to start Stunnel</a></h3><p class="calibre9">You have two options available when deciding how to run Stunnel on your system: using <span><i class="EMPHASIS">inetd</i></span>, or
        running the Stunnel binary as a daemon. Running it as a daemon is preferred over the former, as using <span><i class="EMPHASIS">inetd</i></span>
        can place limitations on the software due to various issues related to SSL. These limitations include:</p><p class="calibre9"> </p><p class="calibre9"></p><ul class="calibre21"><li class="calibre22"><p class="calibre9">Stunnel must be initialized for every connection with <span><i class="EMPHASIS">inetd</i></span></p></li><li class="calibre22"><p class="calibre9">No session cache is possible</p></li><li class="calibre22"><p class="calibre9"><span><i class="EMPHASIS">inetd</i></span> requires forking (which causes extra processor overhead)</p></li></ul>
<p class="calibre9">It is possible to use Stunnel to provide a secure connection for both remote and local databases.
        If you host a database on a computer other than the one the <span><i class="EMPHASIS">psql</i></span> client is located on, it is possible to provide a secure connection from
        <span><i class="EMPHASIS">psql</i></span> to that database. If your database is hosted
        on the same computer as the <span><i class="EMPHASIS">psql</i></span> client, you can provide an equally secure connection between the
        two local programs (in case you are concerned about other users on the machine observing local connections over TCP/IP
        sockets).</p><p class="calibre9">There should be a file named <span><i class="EMPHASIS">stunnel</i></span> in your Stunnel directory; this is the executable for the
        program. The instructions included assume you are using the executable from this directory, but you may copy it out to
        <span><i class="EMPHASIS">/usr/local/sbin</i></span>, or another preferred path. Also, you may wish to put links to this
        file in your start-up scripts so that it is automatically started (as one process or two, depending on how you wish to run
        it) when the system boots.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>If you use Stunnel with <span><i class="EMPHASIS">inetd</i></span>, you will not need to call it from a startup script.</p></blockquote></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN16439" class="calibre8">Running Stunnel in daemon mode</a></h3><p class="calibre9">Running Stunnel as a daemon is fairly simple, whether you are connecting to a local or remote database. To use
        Stunnel to connect to a local database, you must start it as a client and as a server (two different processes of the
        same program, each running on a different port). You then instruct <span><i class="EMPHASIS">psql</i></span> to connect to the port
        number that the stunnel client is running on.</p><p class="calibre9">After <span><i class="EMPHASIS">psql</i></span> has connected to the client, any data will be encrypted and then sent to the
        Stunnel server (located on another port, which is given to the client when you start it) where it is decrypted and sent
        to the actual PostgreSQL server. The client has to be told a specific port to run on, along with the port number that the
        server process is running on (so it knows where to connect to once it is given something to do).</p><p class="calibre9">The most common use of Stunnel is to send data from a local client to a remote server. The way to do this is
        to start the client Stunnel process locally, either by calling it during a start-up script (such as <span><i class="EMPHASIS">/etc/rc.d/rc.local</i></span>) or by calling it directly from
        the installed directory. You then must run the Stunnel process remotely on the machine on which PostgreSQL is running.
        As with the client, you may want to start the server automatically during system startup.</p><p class="calibre9">Both the client and server executions of an example Stunnel scenario are demonstrated in <a href="x16230.htm#USINGSTUNNELREMOTELY">Example 8-15</a>. The ellipses separate the remote server from the local client. Remember that
        if you do not copy the <span><i class="EMPHASIS">stunnel</i></span> executable into <span><i class="EMPHASIS">/usr/sbin</i></span>, Stunnel
        will have to be run from the directory where it is located.</p><div class="NAVHEADER"><a name="USINGSTUNNELREMOTELY"></a><p class="calibre9"><b class="calibre10">Example 8-15. Using Stunnel remotely</b></p><pre class="SCREEN">[user@remote ~]$ <tt class="REPLACEABLE"><b class="calibre10"># This command starts the server on the remote machine.</b></tt>
[user@remote ~]$ <tt class="REPLACEABLE"><b class="calibre10">stunnel -P/tmp/ -p ~/stunnel.pem -d 9000 -r</b></tt>
localhost:5432

...

[user@local ~]$ <tt class="REPLACEABLE"><b class="calibre10"># This command starts the client on the local machine.</b></tt>
[user@local ~]$ <tt class="REPLACEABLE"><b class="calibre10">stunnel -P/tmp/ -c -d 5432 -r 192.168.1.2:9000</b></tt></pre></div><p class="calibre9">The remote host command (the first command) in <a href="x16230.htm#USINGSTUNNELREMOTELY">Example 8-15</a> tells the server to use
        <span><i class="EMPHASIS">~/stunnel.pem</i></span> as the certificate for encryption, and to open a Stunnel process as a daemon. The 
        <span><i class="EMPHASIS">-d 9000</i></span> parameter causes the daemon to listen for encrypted data on port 9000. The
        <span><i class="EMPHASIS">-r localhost:5432</i></span> parameter tells the daemon process that when it receives encrypted data on its
        listening port (9000, in this case), it should decrypt it and send it to
        localhost on port 5432 (which is the PostgreSQL port number, meaning the decrypted data will be sent along to the 
        database server on the local host).</p><p class="calibre9">The second command in <a href="x16230.htm#USINGSTUNNELREMOTELY">Example 8-15</a> opens an instance of Stunnel on a client machine, in
        client mode (as dictated by the <span><i class="EMPHASIS">-c</i></span> flag), listening on port 5432. The
        <span><i class="EMPHASIS">-r 192.168.1.2:9000</i></span> parameter instructs the process that the server computer is located at
        192.168.1.2, and that it is listening on port 9000 for encrypted packets.</p><p class="calibre9">Both modes require the <span><i class="EMPHASIS">-P/tmp/</i></span> flag to provide a temporary path for the PID file, which is the
        file storing the system ID of the Stunnel process. You do not need to specify the PID filename, as a path is
        sufficient (the filename will default to something akin to <span><i class="EMPHASIS">stunnel.localhost.9000.pid</i></span> ), though you
        may specify the complete filename if you wish.</p><p class="calibre9">Once each of these Stunnel processes are running on their respective machines, the <span><i class="EMPHASIS">psql</i></span> client
        may be pointed to port 5432 on the client machine. Packets sent to this port will be transparently
        encrypted, forwarded to port 9000 on the server machine, decrypted, and sent to PostgreSQL on port
        5432. This is similar to the SSH tunnel discussed in <a href="x16230.htm#SSHOPENSSH">the Section called <i class="EMPHASIS">SSH/OpenSSH</i></a>," with one notable
        distinction: the client Stunnel process may be created without any kind of authentication to the remote server.  Thus,
        any user may create a secure "sender" to the database server, though it still requires that a secure "receiver" be
        configured to accept that incoming encrypted data.</p><p class="calibre9">This encryption occurs completely separately from PostgreSQL's normal authentication procedures; as far as the
        <span><i class="EMPHASIS">postmaster</i></span> backend process is concerned, the data is coming through to it in plain text, because it
        is decrypted before being forwarded to the <span><i class="EMPHASIS">postmaster</i></span>. Using Stunnel in conjunction with password
        authentication can be ideal, as it uses a password-based restriction policy, and also encrypts those passwords over the
        network connection.</p><p class="calibre9">Additionally, as mentioned, you have the option to run the two Stunnel processes locally to encrypt packets between
        two local TCP/IP ports. Starting both the client and server processes on the same machine is demonstrated in <a href="x16230.htm#USINGSTUNNELLOCALLY">Example 8-16</a>.</p><div class="NAVHEADER"><a name="USINGSTUNNELLOCALLY"></a><p class="calibre9"><b class="calibre10">Example 8-16. Using Stunnel locally</b></p><pre class="SCREEN">[user@local ~]$ <tt class="REPLACEABLE"><b class="calibre10">stunnel -P/tmp/ -p ~/stunnel-3.15/stunnel.pem -d 9000 -r 5432</b></tt>
[user@local ~]$ <tt class="REPLACEABLE"><b class="calibre10">stunnel -P/tmp/ -c -d 5433 -r localhost:9000</b></tt></pre></div><p class="calibre9">The first use of <span><i class="EMPHASIS">stunnel</i></span> in <a href="x16230.htm#USINGSTUNNELLOCALLY">Example 8-16</a> opens the server process,
        and tells it to use <span><i class="EMPHASIS">~/stunnel-3.15/stunnel.pem</i></span> as the certificate file. It also instructs the
        daemon to listen for connections on port 9000, and to send the unencrypted data from that port
        to port 5432. The example uses 5432 because the PostgreSQL server is running on that port.</p><p class="calibre9">The second use of <span><i class="EMPHASIS">stunnel</i></span> in <a href="x16230.htm#USINGSTUNNELLOCALLY">Example 8-16</a> opens the Stunnel client
        process on port 5433 (chosen arbitrarily to resemble the PostgreSQL port, in this case). That daemon
        is instructed to encrypt incoming data, and to forward it to the server process listening
        on the localhost to port 9000.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN16490" class="calibre8">Running with inetd</a></h3><p class="calibre9">If you wish to configure your system to invoke only the server-side Stunnel instance when requested, you may
        configure it for use with <span><i class="EMPHASIS">inetd</i></span> (or <span><i class="EMPHASIS">xinetd</i></span>, on newer systems), rather than in
        daemon mode. As has been stated previously, this can lead to negative performance effects. If you wish to use this
        feature in spite of this, it is fairly easy to accomplish. First, you must edit the <span><i class="EMPHASIS">/etc/services</i></span>
        file, and add an entry for the server process. Something like the following will suffice:</p><pre class="SCREEN">pgssl		9000/tcp	# PostgreSQL stunnel wrapper</pre><p class="calibre9">Depending on whether or not your system uses <span><i class="EMPHASIS">inetd</i></span> or <span><i class="EMPHASIS">xinetd</i></span>, you
        will either need to add a new service file called <span><i class="EMPHASIS">pgssl</i></span> into the <span><i class="EMPHASIS">/etc/xinetd.d/</i></span>
        path, or add the service into <span><i class="EMPHASIS">/etc/inetd.conf</i></span>. Both of these configurations require that you
        enter the complete command to be executed (including any arguments to the program). The command should follow this format:</p><pre class="SCREEN">stunnel -P/tmp/ -p <tt class="REPLACEABLE"><i class="EMPHASIS">path</i></tt>/stunnel.pem -r <tt class="REPLACEABLE"><i class="EMPHASIS">port</i></tt></pre><p class="calibre9">In this format, <tt class="REPLACEABLE"><i class="EMPHASIS">path</i></tt> is the location of the certificate file (this is originally placed in
        the directory you compiled Stunnel in), and <tt class="REPLACEABLE"><i class="EMPHASIS">port</i></tt> is the port  which PostgreSQL is
        listening on (usually 5432). Note that the primary difference between invoking
        <span><i class="EMPHASIS">stunnel</i></span> through an <span><i class="EMPHASIS">inetd</i></span>-style service versus as a daemon is that the
        <span><i class="EMPHASIS">-d</i></span> flag is not passed.</p><p class="calibre9">An example <span><i class="EMPHASIS">inetd.conf</i></span> entry (which must be placed entirely on a single line) might look as it
        does in <a href="x16230.htm#ANEXAMPLEINETDENTRY">Example 8-17</a>. The location of the PEM file must of course be configured to point to your
        certificate file, and must be readable by the user specified in the <span><i class="EMPHASIS">inetd.conf</i></span> file. Note that
        <span><i class="EMPHASIS">/usr/sbin/stunnel</i></span> is the full path to the Stunnel binary.</p><div class="NAVHEADER"><a name="ANEXAMPLEINETDENTRY"></a><p class="calibre9"><b class="calibre10">Example 8-17. An example inetd entry</b></p><pre class="SCREEN">pgssl stream tcp nowait root /usr/sbin/stunnel -P/tmp/ -p /root/my.pem -r 5432</pre></div><p class="calibre9">The user specified in <a href="x16230.htm#ANEXAMPLEINETDENTRY">Example 8-17</a> is <span><i class="EMPHASIS">root</i></span>, but you may wish to
        specify a more restricted user as a security concern. Any user with read access to the certificate file and execute
        access to the <span><i class="EMPHASIS">stunnel</i></span> binary (e.g., <span><i class="EMPHASIS">nobody</i></span>), may be used for non-reserved
        ports.</p><p class="calibre9">An example <span><i class="EMPHASIS">xinetd</i></span> configuration entry is displayed in <a href="x16230.htm#ANEXAMPLEXINETDENTRY">Example 8-18</a>.
        On a machine using <span><i class="EMPHASIS">xinetd</i></span>, this data would reside in <span><i class="EMPHASIS">/etc/xinetd.d/pgssl</i></span>.
        Again, be sure that the certificate pointed to by the <span><i class="EMPHASIS">-p</i></span> parameter is where your certificate file is
        located. Additionally, as with <span><i class="EMPHASIS">inetd</i></span>, you may not want to run <span><i class="EMPHASIS">stunnel</i></span> as
        <span><i class="EMPHASIS">root</i></span>.</p><div class="NAVHEADER"><a name="ANEXAMPLEXINETDENTRY"></a><p class="calibre9"><b class="calibre10">Example 8-18. An example xinetd entry</b></p><pre class="SCREEN"># xinetd configuration for pgssl.

service pgssl
{
  disable      = no
  socket_type  = stream
  protocol     = tcp
  wait         = no
  user         = root
  server       = /usr/sbin/stunnel
  server_args  = -P/tmp/ -p /root/stunnel.pem -r 5432
}</pre></div><p class="calibre9">After adding either an <span><i class="EMPHASIS">inetd</i></span> or <span><i class="EMPHASIS">xinetd</i></span> entry to your configuration, you
        must re-start the relevant service (on Red Hat systems, this is usually done with a call to
        <span><i class="EMPHASIS">service</i></span>):</p><pre class="SCREEN">[root@host ~]# <tt class="REPLACEABLE"><b class="calibre10">service xinetd restart</b></tt>
Stopping xinetd:                                           [  OK  ]
Starting xinetd:                                           [  OK  ]
[root@host ~]#</pre><p class="calibre9">If the <span><i class="EMPHASIS">service</i></span> command is unavailable, you may usually achieve the same net effect by
        invoking the <span><i class="EMPHASIS">killall</i></span> command with the parameters <span><i class="EMPHASIS">-HUP</i></span>, and the name of
        the process (e.g., <span><i class="EMPHASIS">killall -HUP xinetd</i></span>).</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">To preserve the integrity of your data encryption, be sure that your certificate file is configured to only be
          readable by the user which initiates the <span><i class="EMPHASIS">stunnel</i></span> server process.</p></td></tr></table></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN16551" class="calibre8">Wrapping up</a></h3><p class="calibre9">Once these steps are completed, you should be able to make a secure connection to your PostgreSQL database with any
        valid PostgreSQL client. To test this with <span><i class="EMPHASIS">psql</i></span>, you may use the following syntax:</p><pre class="SCREEN">psql -p <tt class="REPLACEABLE"><i class="EMPHASIS">port</i></tt> -h <tt class="REPLACEABLE"><i class="EMPHASIS">host</i></tt> -U <tt class="REPLACEABLE"><i class="EMPHASIS">username</i></tt> <tt class="REPLACEABLE"><i class="EMPHASIS">database_name</i></tt></pre><p class="calibre9">Enter the port number that the Stunnel client is listening on for <tt class="REPLACEABLE"><i class="EMPHASIS">port</i></tt>, then the host that
        the client is listening on for <tt class="REPLACEABLE"><i class="EMPHASIS">host</i></tt> (<span><i class="EMPHASIS">localhost</i></span>, in this case), followed
        by your <tt class="REPLACEABLE"><i class="EMPHASIS">username</i></tt>, and the <tt class="REPLACEABLE"><i class="EMPHASIS">database_name</i></tt> to connect to. This should connect
        you to the database just as if you had opened it normally with <span><i class="EMPHASIS">psql</i></span> locally.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>Notice that you will need to start <span><i class="EMPHASIS">postmaster</i></span> with the <span><i class="EMPHASIS">-i</i></span> flag to be
          able to connect to it with Stunnel. The <span><i class="EMPHASIS">-i</i></span> flag tells <span><i class="EMPHASIS">postmaster</i></span> to enable
          TCP/IP connections, which are required for Stunnel to work.</p></blockquote></div></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="c15679.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="c16573.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">Authentication and Encryption</td><td width="34%" valign="top" class="calibre4"><a href="c15679.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Database Management</td></tr></table></div></div>

{% endraw %}

