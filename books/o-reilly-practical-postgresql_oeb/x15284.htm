---
layout: page
title: "Unknown"
prev: x15040.htm
next: p15677.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="x15040.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4">Chapter 7. Advanced Features</td><td width="10%" valign="bottom" class="calibre5"><a href="p15677.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><h1 class="calibre7"><a name="EXTENDINGPOSTGRESQL" class="calibre8">Extending PostgreSQL</a></h1><p class="calibre9">PostgreSQL users have the option of extending the set of functions and operators available. If you have a common SQL or programmatic
    routine, custom functions can be an effective way to more succinctly and efficiently accomplish your tasks.  Likewise, custom
    operators can be created to call these functions (or existing built-in functions) in order to make more efficient and legible
    SQL statements.</p><p class="calibre9">Functions and operators each exist as database objects, and are thus tied to a specific database. Creating a function
    while connected to the <tt class="REPLACEABLE">booktown</tt> database, for example, creates a function object available
    only to users connected to <tt class="REPLACEABLE">booktown</tt>.</p><p class="calibre9">If you intend to re-use some general functions or operators in multiple databases, you should create them in the
    <tt class="REPLACEABLE">template1</tt> database.  This will clone the function and operator objects from
    <tt class="REPLACEABLE">template1</tt> when a new database is created.</p><p class="calibre9">The following sections cover the creation, use, and removal of custom functions and operators.</p><div class="NAVHEADER"><h2 class="SECT"><a name="AEN15294" class="calibre8">Creating New Functions</a></h2><p class="calibre9">PostgreSQL supports a variation of the SQL99 <tt class="REPLACEABLE">CREATE FUNCTION</tt> command. It is not
      directly compatible with the standard, but it does allow for a variety of means to extend PostgreSQL by creating your own
      customized functions (see <a href="c7547.htm">Chapter 5</a> for more on functions in general).</p><p class="calibre9">Here is the syntax for <tt class="REPLACEABLE">CREATE FUNCTION</tt>:</p><pre class="SCREEN">  CREATE FUNCTION <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( [ <tt class="REPLACEABLE"><i class="EMPHASIS">argumenttype</i></tt> [, ...] ] )
                  RETURNS <tt class="REPLACEABLE"><i class="EMPHASIS">returntype</i></tt>
                  AS '<tt class="REPLACEABLE"><i class="EMPHASIS">definition</i></tt>'
                  LANGUAGE '<tt class="REPLACEABLE"><i class="EMPHASIS">languagename</i></tt>'
                  [ WITH ( <tt class="REPLACEABLE"><i class="EMPHASIS">attribute</i></tt> [, ...] ) ]</pre><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre9"><dt class="NAVHEADER"><tt class="REPLACEABLE">CREATE FUNCTION </tt><tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( [ <tt class="REPLACEABLE"><i class="EMPHASIS">argumenttype</i></tt> [, ...] ] )</dt><dd class="calibre16"><p class="calibre9"> <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> is the name of the new function to be created. The parenthetically grouped
            <tt class="REPLACEABLE"><i class="EMPHASIS">argumenttype</i></tt> expression defines the data types of the arguments that the function requires when
            called, separated by commas. Leaving this expression blank results in a function which accepts no arguments (though
            the parentheses are still required in both definition and usage).
          </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">RETURNS </tt><tt class="REPLACEABLE"><i class="EMPHASIS">returntype</i></tt></dt><dd class="calibre16"><p class="calibre9">            The <tt class="REPLACEABLE"><i class="EMPHASIS">returntype</i></tt> is the single data type of the value which is returned by the function.
          </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">AS '</tt><tt class="REPLACEABLE"><i class="EMPHASIS">definition</i></tt>'</dt><dd class="calibre16"><p class="calibre9"> <tt class="REPLACEABLE"><i class="EMPHASIS">definition</i></tt> is the programmatic definition of the function itself. For procedural languages,
            such as PL/pgSQL, this is the literal code used to define the function. For compiled C functions, this is the
            absolute system path which to links the file containing the object code.
          </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">LANGUAGE '</tt><tt class="REPLACEABLE"><i class="EMPHASIS">languagename</i></tt>'</dt><dd class="calibre16"><p class="calibre9"> <tt class="REPLACEABLE"><i class="EMPHASIS">languagename</i></tt> is the name of the language which the function is written in. The language may be
            any supported procedural language (such as <span><i class="EMPHASIS">plpgsql</i></span>, or <span><i class="EMPHASIS">plperl</i></span>, assuming it
            has been added to the database), <span><i class="EMPHASIS">C</i></span>, or <span><i class="EMPHASIS">SQL</i></span>.
          </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">[ WITH ( </tt><tt class="REPLACEABLE"><i class="EMPHASIS">attribute</i></tt> [, ...] ) ]</dt><dd class="calibre16"><p class="calibre9">            
            As of PostgreSQL 7.1.x, two possible values exist for <tt class="REPLACEABLE"><i class="EMPHASIS">attribute</i></tt>â€‰;
            <tt class="REPLACEABLE">iscachable</tt>, and <tt class="REPLACEABLE">isstrict</tt>:
            
            </p><p class="calibre9"></p><div class="NAVHEADER"><dl class="calibre17"><dt class="NAVHEADER"><tt class="REPLACEABLE">iscachable</tt></dt><dd class="calibre16"><p class="calibre9">                  This attribute lets the optimizer know if it is acceptable to pre-evaluate a call to a function with arguments
                  that have already been evaluated once. This can be useful for functions which are programmatically expensive,
                  but not terribly dynamic (e.g., functions with which the same input arguments will invariably return the same
                  results).
                </p></dd><dt class="NAVHEADER"><tt class="REPLACEABLE">isstrict</tt></dt><dd class="calibre16"><p class="calibre9">                  Causes the function to always return a <tt class="REPLACEABLE">NULL</tt> value whenever
                  <span><i class="EMPHASIS">any</i></span> of its arguments are <tt class="REPLACEABLE">NULL</tt> values. The function is
                  actually not executed in such a case, when <tt class="REPLACEABLE">isstrict</tt> is defined.
                </p></dd></dl></div>
</dd></dl></div><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>Functions may be <span><i class="EMPHASIS">overloaded</i></span> (i.e., share the same name as an existing function) by defining
        them as accepting different arguments. In this way you can have a single function name that can perform several
        operations, depending on the number and type of the input arguments.</p></blockquote></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15377" class="calibre8">Creating SQL functions</a></h3><p class="calibre9">The simplest kind of function to add to PostgreSQL is a pure SQL function, as it requires no
        external programming knowledge or experience. A SQL function is merely defined as a standard SQL statement with support
        for inline arguments passed as <span><i class="EMPHASIS">positional parameters</i></span>.</p><p class="calibre9">A positional parameter is a reference used in a SQL function definition to one of the calling arguments.  It is
        called <span><i class="EMPHASIS">positional</i></span> because it is referenced by the order in which the arguments are passed to the
        function. The syntax of a positional parameter is a dollar sign followed by a number (e.g.,
        <tt class="REPLACEABLE">$1</tt>). The number represents the ordered position in the arguments passed to the function,
        starting with 1.</p><p class="calibre9"><a href="x15284.htm#CREATINGASQLFUNCTION">Example 7-46</a> creates a function named <tt class="REPLACEABLE">isbn_to_title</tt>, which
        returns the title of a book when passed the ISBN number of the book. It accepts a single argument of type
        <tt class="REPLACEABLE">text</tt>, and returns its result as the same type.</p><div class="NAVHEADER"><a name="CREATINGASQLFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-46. Creating a SQL function</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE FUNCTION isbn_to_title(text) RETURNS text</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                AS 'SELECT title FROM books</b></tt>
booktown'# <tt class="REPLACEABLE"><b class="calibre10">                                 JOIN editions AS e (isbn, id)</b></tt>
booktown'# <tt class="REPLACEABLE"><b class="calibre10">                                 USING (id)</b></tt>
booktown'# <tt class="REPLACEABLE"><b class="calibre10">                                 WHERE isbn = $1'</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                LANGUAGE 'SQL';</b></tt>
CREATE</pre></div><p class="calibre9">Notice the <tt class="REPLACEABLE">$1</tt> in <a href="x15284.htm#CREATINGASQLFUNCTION">Example 7-46</a>;
        when the select statement executes, the complete value of the first argument to <tt class="REPLACEABLE">isbn_to_title</tt> replaces this positional parameter. Notice that
        the positional parameter does not need to be bound by single quotes, as the quotes are part of the argument passed. Each other element of the
        function definition is either a standard SQL keyword or identifier.</p><p class="calibre9">The <tt class="REPLACEABLE">CREATE</tt> message indicates that the function was successfully created. <a href="x15284.htm#USINGASQLFUNCTION">Example 7-47</a> calls the <tt class="REPLACEABLE">isbn_to_title</tt> function with a single text
        parameter of <span><i class="EMPHASIS">0929605942</i></span>. The title, from the <tt class="REPLACEABLE">books</tt> table, returns that ISBN number as per the SQL defined in <a href="x15284.htm#CREATINGASQLFUNCTION">Example 7-46</a>.</p><div class="NAVHEADER"><a name="USINGASQLFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-47. Using a SQL function</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT isbn_to_title('0929605942');</b></tt>
    isbn_to_title
---------------------
 The Tell-Tale Heart
(1 row)</pre></div><p class="calibre9">Once created, any user may access the function, presuming that they have the permission to execute the SQL
        involved.  For example, the <tt class="REPLACEABLE">isbn_to_title</tt> function requires read access to the
        <tt class="REPLACEABLE">editions</tt> and <tt class="REPLACEABLE">books</tt> tables (see <a href="c18591.htm">Chapter 10</a> for more information on user privileges).</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="CREATINGCFUNCTIONS" class="calibre8">Creating C functions</a></h3><p class="calibre9">PostgreSQL is written in C and can dynamically load compiled C code for use on the fly, without recompilation of
        the base software. Only superusers are allowed to use <tt class="REPLACEABLE">CREATE FUNCTION</tt> to link to a C function, as
        functions can make system-level calls and potentially provide a security hole.</p><p class="calibre9">Documenting the entire PostgreSQL API is outside the scope of this book, but for an experienced programmer, some
        basic C functions can very easily be developed, compiled and linked through loadable <span><i class="EMPHASIS">shared object</i></span>
        code.</p><p class="calibre9">The GNU C Compiler, <span><i class="EMPHASIS">gcc</i></span>, supports a flag called <span><i class="EMPHASIS">-shared</i></span>, which creates a
        dynamically loadable piece of object code. The most basic syntax to create such a function with <span><i class="EMPHASIS">gcc</i></span>
        is:</p><pre class="SCREEN">$ <tt class="REPLACEABLE"><b class="calibre10">gcc -shared input.c -o output.so</b></tt></pre><p class="calibre9">In this syntax, <span><i class="EMPHASIS">input.c</i></span> is the name of the file containing the C code to be compiled, and
        <span><i class="EMPHASIS">output.so</i></span> is the shared object file to build.</p><p class="calibre9"><a href="x15284.htm#ISZEROCASIMPLECFUNCTION">Example 7-48</a> is an extremely simple pair of C functions. They define two C functions
        called <tt class="REPLACEABLE">is_zero(int)</tt> and <tt class="REPLACEABLE">is_zero_two(int, int)</tt>. The
        first function returns true (1) if the passed argument to it is 0; otherwise,
        it returns false (0). The second function returns true if at least one of the passed arguments is 0.</p><div class="NAVHEADER"><a name="ISZEROCASIMPLECFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-48. is_zero.c, a simple C function</b></p><pre class="SCREEN">/* is_zero.c
 * A pair of simple zero-checking functions.
 */

int is_zero(int);
int is_zero_two(int, int);

int is_zero(int incoming) {
  /* Return true only if the incoming value is 0. */
  if (incoming == 0) return 1;
  else return 0;
}

int is_zero_two(int left, int right) {
  /* Return true only if either of the values are 0. */
  if (left == 0 || right == 0) return 1;
  else return 0;
}</pre></div><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">No PostgreSQL-specific headers are included in this extremely basic example. They are not required in this case
          because of the obvious parallels between the example C and SQL data types. For more advanced examples of the internal
          PostgreSQL API and data structures, check the <span><i class="EMPHASIS">contrib</i></span> directory within the
          PostgreSQL source path.</p></td></tr></table></div><p class="calibre9"><a href="x15284.htm#CREATINGACFUNCTION">Example 7-49</a> compiles the file <span><i class="EMPHASIS">is_zero.c</i></span>, with the
        <tt class="REPLACEABLE">-shared</tt> flag, and outputs the shared object code to a file called <span><i class="EMPHASIS">is_zero.so</i></span>.
        The location of that file is then passed as the <span><i class="EMPHASIS">definition</i></span> of the function to the
        <tt class="REPLACEABLE">CREATE FUNCTION</tt> command, and the function type is defined as
        <span><i class="EMPHASIS">C</i></span>.</p><div class="NAVHEADER"><a name="CREATINGACFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-49. Creating a C function</b></p><pre class="SCREEN">[jworsley@cmd ~]$ <tt class="REPLACEABLE"><b class="calibre10">gcc -shared is_zero.c -o is_zero.so</b></tt>
[jworsley@cmd ~]$ <tt class="REPLACEABLE"><b class="calibre10">psql -U manager booktown</b></tt>
Welcome to psql, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help on internal slash commands
       \g or terminate with semicolon to execute query
       \q to quit

booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE FUNCTION is_zero(int4) RETURNS Boolean </b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                AS '/home/jworsley/is_zero.so' LANGUAGE 'C';</b></tt>
CREATE</pre></div><p class="calibre9">The <tt class="REPLACEABLE">CREATE FUNCTION</tt> command in <a href="x15284.htm#CREATINGACFUNCTION">Example 7-49</a> creates a
        function named <tt class="REPLACEABLE">is_zero()</tt>, which accepts a single argument of type
        <tt class="REPLACEABLE">int4</tt> and returns a value of type <tt class="REPLACEABLE">boolean</tt>. This
        function references the C function <tt class="REPLACEABLE">is_zero(int)</tt> implemented in the object code located
        at <span><i class="EMPHASIS">/home/jworsley/is_zero.so</i></span> (since C has no Boolean type, PostgreSQL must transform the
        integer value returned by the function to a Boolean value).  In this case, 0 is translated to false,
        and 1 is translated to true.</p><p class="calibre9">By default, PostgreSQL looks for a function in the shared object code with the same name as the function being
        created within PostgreSQL. This works well for the <tt class="REPLACEABLE">is_zero(integer)</tt> function, as its
        names matches the compiled symbol name of the <tt class="REPLACEABLE">is_zero(int)</tt> function within the file
        <span><i class="EMPHASIS">is_zero.so</i></span>.
        In order to avoid a C name-collision with <tt class="REPLACEABLE">is_zero(int)</tt>, the second function in the shared
        object is defined as <tt class="REPLACEABLE">is_zero_two(int, int)</tt>. To load this function
        into PostgreSQL with the same name (as an overloaded function, with two arguments instead of one), pass the literal
        C function name (also called the link symbol) as a second string constant following the location of the shared object
        filename.</p><p class="calibre9">This name should not contain parentheses or arguments, and should be separated from the filename
        <span><i class="EMPHASIS">definition</i></span> by a comma, as in this syntax:</p><pre class="SCREEN">CREATE FUNCTION <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( [ <tt class="REPLACEABLE"><i class="EMPHASIS">argumenttype</i></tt> [, ...] ] )
                RETURNS <tt class="REPLACEABLE"><i class="EMPHASIS">returntype</i></tt>
                AS '<tt class="REPLACEABLE"><i class="EMPHASIS">definition</i></tt>', '<tt class="REPLACEABLE"><i class="EMPHASIS">link_symbol</i></tt>'
                LANGUAGE 'C'
                [ WITH ( <tt class="REPLACEABLE"><i class="EMPHASIS">attribute</i></tt> [, ...] ) ]</pre><p class="calibre9"><a href="x15284.htm#OVERLOADINGACFUNCTION">Example 7-50</a> loads the same shared object code, but specifies the function symbol name as
        <tt class="REPLACEABLE">is_zero_two</tt> so that it knows which function to use for this overloaded function.</p><div class="NAVHEADER"><a name="OVERLOADINGACFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-50. Overloading a C function</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE FUNCTION is_zero(int4, int4) RETURNS Boolean</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                AS '/home/jworsley/is_zero.so', 'is_zero_two'</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                LANGUAGE 'C';</b></tt>
CREATE</pre></div><p class="calibre9">Like a SQL function, any user may call the C function once it has been created. As C functions can make direct
        modifications to the filesystem (where permissions allow) and affect other system level events, care must be taken in
        designing functions free from potential misuse. <a href="x15284.htm#USINGACFUNCTION">Example 7-51</a> makes several calls to the
        <tt class="REPLACEABLE">is_zero</tt> function defined in <a href="x15284.htm#CREATINGACFUNCTION">Example 7-49</a>, and to its overloaded
        function, created in <a href="x15284.htm#OVERLOADINGACFUNCTION">Example 7-50</a>.</p><div class="NAVHEADER"><a name="USINGACFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-51. Using a C function</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT is_zero(0) AS zero, is_zero(1) AS one,</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">       is_zero(6, 0) AS one_zero, is_zero(11,12) AS neither;</b></tt>
 zero | one | one_zero | neither
------+-----+----------+---------
 t    | f   | t        | f
(1 row)</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15512" class="calibre8">Destroying functions</a></h3><p class="calibre9">Functions may be destroyed either by their owner or by a superuser with the
        <tt class="REPLACEABLE">DROP FUNCTION</tt> SQL command. Here is the syntax for
        <tt class="REPLACEABLE">DROP FUNCTION</tt>:</p><pre class="SCREEN">  DELETE FUNCTION <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( [ <tt class="REPLACEABLE"><i class="EMPHASIS">argumenttype</i></tt> [, ...] ] );</pre><p class="calibre9">For example, <a href="x15284.htm#DROPPINGAFUNCTION">Example 7-52</a> drops the <tt class="REPLACEABLE">isbn_to_title(text)</tt>
        function. Note that the argument types are <span><i class="EMPHASIS">required</i></span> to be specified, even though the function itself
        is not overloaded.</p><div class="NAVHEADER"><a name="DROPPINGAFUNCTION"></a><p class="calibre9"><b class="calibre10">Example 7-52. Dropping a function</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP FUNCTION isbn_to_title(text);</b></tt>
DROP</pre></div><p class="calibre9">The <tt class="REPLACEABLE">DROP</tt> server message indicates that the function was successfully dropped.
        Like most <tt class="REPLACEABLE">DROP</tt> SQL commands, this action is permanent, so be sure that you wish to drop
        your function before you execute this command.</p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="AEN15531" class="calibre8">Creating New Operators</a></h2><p class="calibre9">PostgreSQL allows the creation of custom operators in addition to custom functions. Operators are sometimes
      called <span><i class="EMPHASIS">syntactic sugar</i></span> for functions. This is because, technically, an operator is just an alternate
      syntax for an existing function. For example, the addition operator (<tt class="REPLACEABLE">+</tt>) actually calls one
      of several built-in functions, including <tt class="REPLACEABLE">numeric_add()</tt>. For example:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 1 + 2 AS by_operator, numeric_add(1,2) AS by_function;</b></tt>
 by_operator | by_function
-------------+-------------
           3 |           3
(1 row)</pre><p class="calibre9">An operator definition defines what data types it operates on, and which side of the operator to expect a value of
      the given data type to be found on (left, right, or both). It also defines the function that is called, passing the values that are being
      operated on as arguments to that function.</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15546" class="calibre8">Creating an operator</a></h3><p class="calibre9">The <tt class="REPLACEABLE">CREATE OPERATOR</tt> SQL command creates a new operator. Here is the syntax for
        <tt class="REPLACEABLE">CREATE OPERATOR</tt>:</p><pre class="SCREEN">  CREATE OPERATOR <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( PROCEDURE = <tt class="REPLACEABLE"><i class="EMPHASIS">functionname</i></tt>
                  [, LEFTARG = <tt class="REPLACEABLE"><i class="EMPHASIS">type1</i></tt> ]
                  [, RIGHTARG = <tt class="REPLACEABLE"><i class="EMPHASIS">type2</i></tt> ]
                  [, COMMUTATOR = <tt class="REPLACEABLE"><i class="EMPHASIS">commutatorop</i></tt> ]
                  [, NEGATOR = <tt class="REPLACEABLE"><i class="EMPHASIS">negatorop</i></tt> ]
                  [, RESTRICT = <tt class="REPLACEABLE"><i class="EMPHASIS">restrictproc</i></tt> ]
                  [, JOIN = <tt class="REPLACEABLE"><i class="EMPHASIS">joinproc</i></tt> ]
                  [, HASHES ]
                  [, SORT1 = <tt class="REPLACEABLE"><i class="EMPHASIS">leftsortop</i></tt> ]
                  [, SORT2 = <tt class="REPLACEABLE"><i class="EMPHASIS">rightsortop</i></tt> ] )</pre><p class="calibre9">In this syntax, <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> is the name of the new operator, and <tt class="REPLACEABLE"><i class="EMPHASIS">functionname</i></tt> is
        the name of the function to be called by the operator. The remaining clauses are all optional, though at least one of the
        <tt class="REPLACEABLE">LEFTARG</tt> or <tt class="REPLACEABLE">RIGHTARG</tt> clauses must be applied. Note that
        the operator <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> may only consist of the following accepted characters:</p><pre class="SCREEN"> + - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ? $</pre><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>See the reference entry on <tt class="REPLACEABLE">CREATE OPERATOR</tt> for more information on the remaining
          optional clauses, and further restrictions on the operator name.</p></blockquote></div><p class="calibre9">Specifying only the <tt class="REPLACEABLE">LEFTARG</tt> data type creates an operator that operates only on a
        value (e.g., a constant or identifier) to its left. Conversely, specifying only the
        <tt class="REPLACEABLE">RIGHTARG</tt> data type creates an operator that operates only on a value to its right.
        Specifying both a <tt class="REPLACEABLE">LEFTARG</tt> and <tt class="REPLACEABLE">RIGHTARG</tt> type results in
        an operator that operates on a value to both the left <span><i class="EMPHASIS">and</i></span> right.</p><p class="calibre9"> The factorial operator (<tt class="REPLACEABLE">!</tt>) is an example of a built-in operator that affects
        values to its left, while the addition operator (<tt class="REPLACEABLE">+</tt>) is a good example of an operator
        that affects values both on the left and right of the operator. Note that the <tt class="REPLACEABLE"><i class="EMPHASIS">functionname</i></tt>
        must accept the appropriate number of arguments as implied by the use of the <tt class="REPLACEABLE">LEFTARG</tt> and
        <tt class="REPLACEABLE">RIGHTARG</tt> keywords (either one or two arguments). Furthermore, the function's accepted
        argument types should match the relevant operator types defined by <tt class="REPLACEABLE">CREATE OPERATOR</tt> for
        each respective value to be operated on.</p><p class="calibre9"><a href="x15284.htm#CREATINGANOPERATOR">Example 7-53</a> creates an operator named <tt class="REPLACEABLE">!#</tt>, which passes the
        value to its left to the <tt class="REPLACEABLE">is_zero()</tt> function (defined in <a href="x15284.htm#CREATINGACFUNCTION">Example 7-49</a>). This means that the syntax of <tt class="REPLACEABLE">value !#</tt> will be
        effectively identical to using the functional syntax of <tt class="REPLACEABLE">is_zero(value)</tt>.</p><div class="NAVHEADER"><a name="CREATINGANOPERATOR"></a><p class="calibre9"><b class="calibre10">Example 7-53. Creating a user-defined operator</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE OPERATOR !# (PROCEDURE = is_zero,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                   LEFTARG = integer);</b></tt>
CREATE</pre></div><p class="calibre9">The <tt class="REPLACEABLE">CREATE</tt> message returned by <a href="x15284.htm#CREATINGANOPERATOR">Example 7-53</a> indicates that
        the operator was successfully created. As with functions, any user connected to the database will be able to use the new
        operator. The operator is owned by the user who creates it, meaning that no other user may remove it (unless they have
        superuser rights). <a href="x15284.htm#USINGANOPERATOR">Example 7-54</a> demonstrates the use of the new <tt class="REPLACEABLE">!#</tt>
        operator to check for books that are out of stock in Book Town's <tt class="REPLACEABLE">stock</tt> table.</p><div class="NAVHEADER"><a name="USINGANOPERATOR"></a><p class="calibre9"><b class="calibre10">Example 7-54. Using a user-defined operator</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM stock WHERE stock !#;</b></tt>
    isbn    | cost  | retail | stock
------------+-------+--------+-------
 0394900014 | 23.00 |  23.95 |     0
 0451198492 | 36.00 |  46.95 |     0
 0451457994 | 17.00 |  22.95 |     0
(3 rows)</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15607" class="calibre8">Overloading an operator</a></h3><p class="calibre9">Operators may become overloaded in much the same way as functions. This means that an operator is created with
        the same name as an existing operator, but affects a different set of defined types. More than one operator may have the
        same name, although two operators may not share the same name if they accept the same argument definitions. As
        long as a function exists to accept the number and type of arguments implied by the type of operator defined, though, the
        operator may be overloaded.</p><p class="calibre9"><a href="x15284.htm#CREATINGANOPERATOR">Example 7-53</a> overloads the <tt class="REPLACEABLE">!#</tt> operator. The first
        <tt class="REPLACEABLE">CREATE OPERATOR</tt> statement creates a similar operator to the one created in
        <a href="x15284.htm#CREATINGANOPERATOR">Example 7-53</a>. However, it specifies a <tt class="REPLACEABLE">RIGHTARG</tt> clause rather
        than a <tt class="REPLACEABLE">LEFTARG</tt> clause, resulting in a version of the operator with
        the same name which operates on an argument of type <tt class="REPLACEABLE">integer</tt> to the
        <span><i class="EMPHASIS">right</i></span> of the operator, rather than the left. The second statement creates a third variant of
        the <tt class="REPLACEABLE">!#</tt> operator, which operates on both an argument to the left <span><i class="EMPHASIS">and</i></span>
        right of the operator, simultaneously.</p><div class="NAVHEADER"><a name="OVERLOADINGANOPERATOR"></a><p class="calibre9"><b class="calibre10">Example 7-55. Overloading a user-defined operator</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE OPERATOR !# (PROCEDURE = is_zero,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                    RIGHTARG = integer);</b></tt>
CREATE
booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE OPERATOR !# (PROCEDURE = is_zero,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                    LEFTARG = integer,</b></tt>
booktown(# <tt class="REPLACEABLE"><b class="calibre10">                    RIGHTARG = integer);</b></tt>
CREATE</pre></div><p class="calibre9"><a href="x15284.htm#OVERLOADINGANOPERATOR">Example 7-55</a> overloads the <tt class="REPLACEABLE">!#</tt> operator with
        the same <tt class="REPLACEABLE">is_zero()</tt> function because the function itself was overloaded in <a href="x15284.htm#OVERLOADINGACFUNCTION">Example 7-50</a> in <a href="x15284.htm#CREATINGCFUNCTIONS">the Section called <i class="EMPHASIS">Creating C functions</i></a>," earlier in this chapter. As there are two
        copies of the <tt class="REPLACEABLE">is_zero()</tt> function--one that accepts one argument, and one that
        accepts two--the <tt class="REPLACEABLE">!#</tt> operator can be safely overloaded to accept both a single
        argument (on either the left or right side), as well as to accept parameters from both sides.</p><p class="calibre9">Once overloaded, PostgreSQL's parser can correctly interpret each defined operator in your
        SQL statements. <a href="x15284.htm#USINGANOVERLOADEDOPERATORS">Example 7-56</a> demonstrates three uses of the same operator, with different
        left and right arguments. Each use is valid, as the operator was overloaded in <a href="x15284.htm#OVERLOADINGANOPERATOR">Example 7-55</a>.</p><div class="NAVHEADER"><a name="USINGANOVERLOADEDOPERATORS"></a><p class="calibre9"><b class="calibre10">Example 7-56. Using an overloaded operator</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT isbn, stock FROM stock</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                   WHERE stock !#</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                   AND !# stock</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">                   AND stock !# stock;</b></tt>
    isbn    | stock
------------+-------
 0394900014 |     0
 0451198492 |     0
 0451457994 |     0
(3 rows)</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="AEN15647" class="calibre8">Dropping an operator</a></h3><p class="calibre9">An operator can be dropped with the <tt class="REPLACEABLE">DROP OPERATOR</tt> command. An operator may only be
        dropped by the user who created it, or by a PostgreSQL superuser.</p><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">The <tt class="REPLACEABLE">DROP OPERATOR</tt> command applies to built-in operators as well as user-defined
          operators, so take care with this command if executing it as a superuser!</p></td></tr></table></div><p class="calibre9">As operators are defined by their arguments as well as their name, <tt class="REPLACEABLE">DROP OPERATOR</tt>
        requires that you specify the left and right argument types of the operator. If there is no type for a given side, specify
        the <tt class="REPLACEABLE">NONE</tt> keyword.</p><p class="calibre9">Here is the syntax for <tt class="REPLACEABLE">DROP OPERATOR</tt>:</p><pre class="SCREEN">  DROP OPERATOR <tt class="REPLACEABLE"><i class="EMPHASIS">name</i></tt> ( { <tt class="REPLACEABLE"><i class="EMPHASIS">lefttype</i></tt> | NONE } , { <tt class="REPLACEABLE"><i class="EMPHASIS">righttype</i></tt> | NONE } )</pre><p class="calibre9"><a href="x15284.htm#DROPPINGANOPERATOR">Example 7-57</a> drops the variant of the <tt class="REPLACEABLE">!#</tt> operator that affects both
        left and right arguments.</p><div class="NAVHEADER"><a name="DROPPINGANOPERATOR"></a><p class="calibre9"><b class="calibre10">Example 7-57. Dropping an operator</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP OPERATOR !# (integer, integer);</b></tt>
DROP</pre></div><p class="calibre9"><a href="x15284.htm#DROPPINGANOVERLOADEDOPERATOR">Example 7-58</a> uses very similar syntax to <a href="x15284.htm#DROPPINGANOPERATOR">Example 7-57</a>, but
        drops the overloaded operator that affects only arguments to the right of the operator.</p><div class="NAVHEADER"><a name="DROPPINGANOVERLOADEDOPERATOR"></a><p class="calibre9"><b class="calibre10">Example 7-58. Dropping an overloaded operator</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP OPERATOR !# (NONE, integer);</b></tt>
DROP</pre></div></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="x15040.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="p15677.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">Transactions and Cursors</td><td width="34%" valign="top" class="calibre4"><a href="c13329.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Administrating PostgreSQL</td></tr></table></div></div>

{% endraw %}

