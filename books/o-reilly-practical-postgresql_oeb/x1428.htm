---
layout: page
title: "Unknown"
prev: x1277.htm
next: x2632.htm
book_path: books/o-reilly-practical-postgresql_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><th colspan="3" class="calibre2">Practical PostgreSQL</th></tr><tr class="calibre1"><td width="10%" valign="bottom" class="calibre3"><a href="x1277.htm" accesskey="P">Prev</a></td><td width="80%" valign="bottom" class="calibre4">Chapter 3. Understanding SQL</td><td width="10%" valign="bottom" class="calibre5"><a href="x2632.htm" accesskey="N">Next</a></td></tr></table><hr width="100%" class="calibre6"/></div><div class="NAVHEADER"><h1 class="calibre7"><a name="SQLSTATEMENTS" class="calibre8">SQL Statements</a></h1><p class="calibre9">Conceptual information on relational databases and tables is of course entirely moot if you don't have any idea of
    how to directly interact with your data. From a general perspective, SQL consists entirely of structured
    <span><i class="EMPHASIS">statements</i></span>, with which all data in the database is added, modified, and removed. These statements form
    the basis for your communication with the PostgreSQL server.</p><p class="calibre9">The following sections dissect the anatomy of a SQL statement into its structural pieces, explaining the significance of each, and their relation to one another. The standard PostgreSQL command-line client, <span><i class="EMPHASIS">psql</i></span>, provides output to display example PostgreSQL statements.</p><p class="calibre9">Our SQL examples commonly take place within an example database called
    <tt class="REPLACEABLE">booktown</tt>, the database for our imaginary bookstore, Book Town. The output from
    <span><i class="EMPHASIS">psql</i></span> is consistently prefixed with a default prompt style, which looks like this:</p><pre class="SCREEN">booktown=#</pre><p class="calibre9">Some simpler examples may use our generic test database, <tt class="REPLACEABLE">testdb</tt>, if
    not specific to the Book Town examples. By default, the <span><i class="EMPHASIS">psql</i></span> prompt displays only the name
    of the connected database and the <tt class="REPLACEABLE">=#</tt> characters indicating that the system is ready for a
    new command (though you will see that the <tt class="REPLACEABLE">=</tt> symbol will change dynamically as
    <span><i class="EMPHASIS">psql</i></span> tracks the status of SQL input). We display this prompt along with the SQL input and
    output in order to help familiarize you with the <span><i class="EMPHASIS">psql</i></span> output.</p><p class="calibre9"><a href="c4890.htm">Chapter 4</a> documents <span><i class="EMPHASIS">psql</i></span> in more detail, and it is only mentioned
    here to explain the source and style of this book's SQL examples using PostgreSQL.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>The schema (with sample data) for the <tt class="REPLACEABLE">booktown</tt> database can be found in the
      <span><i class="EMPHASIS"><a href="http://www.commandprompt.com/ppbook/booktown.sql">booktown.sql</a> </i></span> file, on the CD-ROM. To install this database, type
      <span><i class="EMPHASIS">psql -U postgres template1 -f /mnt/cdrom/booktown.sql</i></span> from the command line (where 
      <span><i class="EMPHASIS">/mnt/cdrom</i></span> is the path to your mounted CD, and <span><i class="EMPHASIS">postgres</i></span> is your
      PostgreSQL superuser).</p></blockquote></div><div class="NAVHEADER"><h2 class="SECT"><a name="AEN1467" class="calibre8">The Anatomy of a SQL Statement</a></h2><p class="calibre9">SQL statements always begin with a <span><i class="EMPHASIS">command</i></span> (a word, or group of words, that describes
      <span><i class="EMPHASIS">what</i></span> action the statement will initiate). The command can be called the <span><i class="EMPHASIS">verb</i></span>
      of the SQL statement, as it always describes an action to be taken. Statements typically contain one or more
      <span><i class="EMPHASIS">clauses</i></span>, which are formal modifiers that further describe the function of the SQL statement.</p><p class="calibre9"><a href="x1428.htm#COMMONPOSTGRESQLCOMMANDS">Table 3-2</a> contains a list of some of the most commonly used PostgreSQL commands.</p><div class="NAVHEADER"><a name="COMMONPOSTGRESQLCOMMANDS"></a><p class="calibre9"><b class="calibre10">Table 3-2. Fundamental PostgreSQL commands</b></p><table border="1" width="100%" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="8" valign="TOP" class="calibre13"><p class="calibre9">Command</p></th><th width="21" valign="TOP" class="calibre13"><p class="calibre9">Description</p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE DATABASE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE INDEX</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new index on a table column</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE SEQUENCE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new sequence in an existing database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE TABLE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new table in an existing database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE TRIGGER</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new trigger definition</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE VIEW</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new view on an existing table</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">SELECT</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Retrieves records from a table</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">INSERT</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Adds one or more new records into a table</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">UPDATE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Modifies the data in existing table records</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DELETE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Removes existing records from a table</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP DATABASE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Destroys an existing database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP INDEX</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Removes a column index from an existing table</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP SEQUENCE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Destroys an existing sequence generator</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP TABLE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Destroys an existing table</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP TRIGGER</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Destroys an existing trigger definition</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP VIEW</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Destroys an existing table view</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE USER</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Adds a new PostgreSQL user account to the system</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">ALTER USER</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Modifies an existing PostgreSQL user account</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">DROP USER</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Removes an existing PostgreSQL user account</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">GRANT</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Grant rights on a database object to a user</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">REVOKE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Deny rights on a database object from a user</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE FUNCTION</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new SQL function within a database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE LANGUAGE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new language definition within a database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE OPERATOR</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new SQL operator within a database</p></td></tr><tr class="calibre12"><td width="8" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">CREATE TYPE</tt></p></td><td width="21" valign="TOP" class="calibre15"><p class="calibre9">Creates a new SQL data type within a database</p></td></tr></tbody></table></div><p class="calibre9">While obviously code-like in nature, SQL was designed with ease of use and readability in mind. As a result, SQL
      statements often bear a strong resemblance to simple, instructional English sentences. A strong feature of SQL is that its
      statements are designed to instruct the server <span><i class="EMPHASIS">what</i></span> data to find, not literally
      <span><i class="EMPHASIS">how</i></span> to find it, as you would be forced to do in an ordinary programming language.  Reading a
      well-designed SQL query should be nearly as easy as reading an ordinary sentence.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>In SQL texts, the word <span><i class="EMPHASIS">query</i></span> is frequently used interchangeably with
        <span><i class="EMPHASIS">statement</i></span>. In order to be clear, within this book the term <span><i class="EMPHASIS">query</i></span> is used
        only to refer to statements which <span><i class="EMPHASIS">return data</i></span> (e.g., <tt class="REPLACEABLE">SELECT</tt> statements),
        rather than general SQL statements, which may instead create, add, or modify data.</p></blockquote></div><p class="calibre9">Internally, PostgreSQL interprets structured SQL statements as a sequence of <span><i class="EMPHASIS">tokens</i></span>, usually
      delimited by whitespace (spaces or newlines, outside of quotes), though some tokens may be placed adjacently if there is no
      chance of ambiguity (such as when operators are placed directly next to identifiers). A token in this context is a
      word or character that can be identified meaningfully by the server when the SQL statement is <span><i class="EMPHASIS">parsed</i></span>,
      or interpreted.</p><p class="calibre9">        Technically, each token can either be considered a
        <span><i class="EMPHASIS">keyword</i></span>, an <span><i class="EMPHASIS">identifier</i></span>, a
        <span><i class="EMPHASIS">quoted identifier</i></span>, a
        <span><i class="EMPHASIS">constant</i></span> (also called a
        <span><i class="EMPHASIS">literal</i></span> ), or one of several special character
        symbols. Keywords are words PostgreSQL recognizes as words with pre-defined SQL or PostgreSQL-specific meanings; these include SQL
        commands, clauses, function names, and special
        <span><i class="EMPHASIS">noise</i></span> terms, which are often accompanied
        optionally with SQL commands (e.g., the noise term
        <tt class="REPLACEABLE">WORK</tt> in the <tt class="REPLACEABLE">COMMIT</tt> command). In contrast, identifiers represent
        variable names for tables, columns, and any other database object.
      </p><p class="calibre9">Both keywords and identifiers reference internally defined functions, values, or records, as far as
      PostgreSQL is concerned. Constants, on the other hand, describe pieces of data that are interpreted literally, such as a number or character
      string.</p><p class="calibre9">Finally, a SQL statement contains special character symbols. These are reserved characters (such as parentheses, the semicolon, and square brackets) that logically affect the meaning and arrangement of your keywords,
      identifiers, and literals. You can think of these characters as the punctuation for your SQL statements.</p><p class="calibre9"><span><i class="EMPHASIS">Operators</i></span> fall under the category of special character symbols; they can be used to imply
      logical operations or evaluations between data values (either literals, or represented by identifiers), and are generally
      between one and four characters in length.</p><p class="calibre9">The following sections explain and expand upon the nature of these elementary components of SQL.</p></div><div class="NAVHEADER"><h2 class="SECT"><a name="AEN1670" class="calibre8">Token Formatting Considerations</a></h2><p class="calibre9">As described in the preceding section, each sequential element of a SQL statement is considered a token.  What may
      not be immediately clear, however, is that tokens may be kept all on the same line, or they may be split across several
      lines, as extra whitespace is ignored by PostgreSQL's parser.</p><p class="calibre9">Consider the SQL statement in <a href="x1428.htm#SPACESANDNEWLINES">Example 3-1</a>, which is executed first on a single line, and then
      executed again, split across two separate lines. Both <tt class="REPLACEABLE">SELECT</tt> statements instruct the
      database to display the entire contents of the <tt class="REPLACEABLE">my_list</tt> table:</p><div class="NAVHEADER"><a name="SPACESANDNEWLINES"></a><p class="calibre9"><b class="calibre10">Example 3-1. Spaces and newlines</b></p><pre class="SCREEN">testdb=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM my_list;</b></tt>
                     todos
------------------------------------------------
 Pick up laundry.
 Send out bills.
 Wrap up Grand Unifying Theory for publication.
(3 rows)

testdb=# <tt class="REPLACEABLE"><b class="calibre10">SELECT *</b></tt>
testdb-# <tt class="REPLACEABLE"><b class="calibre10">       FROM</b></tt>
testdb-# <tt class="REPLACEABLE"><b class="calibre10">       my_list;</b></tt>
                     todos
------------------------------------------------
 Pick up laundry.
 Send out bills.
 Wrap up Grand Unifying Theory for publication.
(3 rows)</pre></div><p class="calibre9">        In <a href="x1428.htm#SPACESANDNEWLINES">Example 3-1</a> there are several
        newlines and spaces between the second statement's tokens. As you
        can see by the identical output, PostgreSQL ignores the extra
        newlines and spaces, making both statements semantically equivalent.
        You can take advantage of this behavior by splitting a long string
        of tokens across numerous lines for improved readability of your SQL
        statement.  This probably isn't necessary for statements as simple
        as those in <a href="x1428.htm#SPACESANDNEWLINES">Example 3-1</a>, but it can be quite
        helpful when dealing with complex SQL statements with numerous
        clauses, expressions, and conditions. Throughout this book we will
        periodically split some statements over several lines to help show
        what each part of the statement is intended to accomplish.
      </p></div><div class="NAVHEADER"><h2 class="SECT"><a name="KEYWORDSANDIDENTIFIERS" class="calibre8">Keywords and Identifiers</a></h2><p class="calibre9">Keywords are any reserved SQL terms which have a reserved syntactic meaning to the server. Some common keywords are <tt class="REPLACEABLE">INSERT</tt>, <tt class="REPLACEABLE">UPDATE</tt>,
      <tt class="REPLACEABLE">SELECT</tt>, and <tt class="REPLACEABLE">DELETE</tt>.</p><p class="calibre9">All SQL commands are keywords, though many keywords themselves are not complete commands. For instance, the command
      <tt class="REPLACEABLE">INSERT INTO</tt> is a valid SQL command, and the word <tt class="REPLACEABLE">INTO</tt> is
      a reserved keyword. As you might guess, however, the word <tt class="REPLACEABLE">INTO</tt> has no particular
      significance when used out of context.</p><p class="calibre9">Identifiers, as described earlier, are variable names that reference database objects. These names are arbitrarily
      designated by the creator of the database object upon creation. The objects which can be referred to by identifiers in
      PostgreSQL may be databases, tables, columns, indices, views, sequences, rules, triggers, or functions.</p><p class="calibre9"><a href="x1428.htm#KEYWORDSANDCOMMANDS">Example 3-2</a> adds three pieces of information about Oregon into a simple table called
      <tt class="REPLACEABLE">states</tt>.</p><div class="NAVHEADER"><a name="KEYWORDSANDCOMMANDS"></a><p class="calibre9"><b class="calibre10">Example 3-2. Keywords and commands</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">INSERT INTO states VALUES (33, 'Oregon', 'OR');</b></tt>
INSERT 3389701 1</pre></div><p class="calibre9">In <a href="x1428.htm#KEYWORDSANDCOMMANDS">Example 3-2</a>, the <tt class="REPLACEABLE">INSERT INTO</tt> SQL
      command makes use of the SQL keywords
      <tt class="REPLACEABLE">INSERT</tt>, <tt class="REPLACEABLE">INTO</tt>, and
      <tt class="REPLACEABLE">VALUES</tt>.</p><p class="calibre9">The <tt class="REPLACEABLE">INSERT INTO</tt> command modifies the table referenced by the <tt class="REPLACEABLE">states</tt> identifier. The modification in this case is the insertion of a new
      record.</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="QUOTEDIDENTIFIERS" class="calibre8">Quoted identifiers</a></h3><p class="calibre9">While not normally required, quotes can be used around identifiers, meaning they should be interpreted literally.
        For example, if we want to view each of the columns from a table called <tt class="REPLACEABLE">states</tt>, a simple
        statement to achieve this would ordinarily read:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM states;</b></tt>
 id |    name    | abbreviation
----+------------+--------------
 33 | Oregon     | OR
 42 | Washington | WA
(2 rows)</pre><p class="calibre9">The keywords in this statement are <tt class="REPLACEABLE">SELECT</tt> and
        <tt class="REPLACEABLE">FROM</tt>, while the identifiers are the asterisk <tt class="REPLACEABLE">*</tt>
        (indicating all columns), and <tt class="REPLACEABLE">states</tt> (the table name). With this command, we are
        selecting all columns from a table named <tt class="REPLACEABLE">states</tt> and thereby viewing its contents.</p><p class="calibre9">You can accomplish the same thing by putting quotes around the identifier, with the following
        statement:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM "states";</b></tt>
 id |    name    | abbreviation
----+------------+--------------
 33 | Oregon     | OR
 42 | Washington | WA
(2 rows)</pre><p class="calibre9">As you can see, the output is identical when applying quotes to a lowercase identifier.
        However, the following statement, which uses quotes around the <tt class="REPLACEABLE">stAtes</tt>
         identifier, will fail:
        </p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM "stAtEs"; </b></tt>
ERROR: Relation 'stAtEs' does not exist</pre><p class="calibre9">This statement fails because it instructs PostgreSQL to look for a table called, literally,
        <tt class="REPLACEABLE">stAtEs</tt> (rather than <tt class="REPLACEABLE">states</tt>). In other words, with the
        use of quotes, the statement has explicitly requested that PostgreSQL interpret the identifier name
        <span><i class="EMPHASIS">literally</i></span>.</p><p class="calibre9">All non-quoted identifiers are <span><i class="EMPHASIS">folded</i></span>, or converted, to lowercase. When specifying
        <tt class="REPLACEABLE">stAtEs</tt>, or <tt class="REPLACEABLE">STATES</tt> (i.e., any combination of
        uppercase or lowercase letters) <span><i class="EMPHASIS">without</i></span> quotes, PostgreSQL automatically converts the
        identifier to lowercase (<tt class="REPLACEABLE">states</tt>) before processing the statement.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>The folding of unquoted identifiers to lowercase names is a PostgreSQL-specific convention. The
          SQL92 standard specifies that unquoted identifiers always be converted to uppercase. For both legacy and
          readability reasons, PostgreSQL does not intend to move to this part of the SQL92 standard.</p><p class="calibre9">This should be of special note to database administrators familiar with other SQL products, such as
          Oracle, who expect case to automatically change to uppercase. If you are a developer, and you
          are interested in writing easily portable applications, be sure to consider this case issue to avoid conflicts over this convention.</p></blockquote></div><p class="calibre9">Since the parser can still read and understand mixed-case statements (provided that they are formed with the
        correct syntax), you should use uppercase and lowercase terminology carefully. Your use of case can both
        help and hinder your efficiency when working with a large amount of SQL.</p><p class="calibre9">We recommend that, for readability, you try typing identifiers in lowercase and keywords in uppercase, the convention used
        throughout this book. By visually separating the fixed, systematic terminology from the user-defined data objects, you make it a great deal easier to quickly read and understand complex SQL statements.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="WHENQUOTESAREREQUIRED" class="calibre8">When quotes are required</a></h3><p class="calibre9">The only instances where you are <span><i class="EMPHASIS">required</i></span> to use quotes are either when a database object's
        identifier is identical to a keyword, or when the identifier has at least one capitalized letter in its name. In either
        of these circumstances, you must remember to quote the identifier both when creating the object, as well as in any
        subsequent references to that object (e.g., in <tt class="REPLACEABLE">SELECT</tt>,
        <tt class="REPLACEABLE">DELETE</tt>, or <tt class="REPLACEABLE">UPDATE</tt> statements).</p><p class="calibre9">If you do not quote an identifier that is spelled identically to an existing keyword, PostgreSQL will
        return an error message because it interprets the intended identifier <span><i class="EMPHASIS">as a keyword</i></span>. For
        instance, if you had a table whose name was literally <tt class="REPLACEABLE">select</tt>, you would get an error message if you tried
        querying it with the following statement:</p><pre class="SCREEN">testdb=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM select; </b></tt>
ERROR: parser: parse error at or near "select"</pre><p class="calibre9">As you can see, an unquoted query on a table called <tt class="REPLACEABLE">select</tt> produces an
        error message. To specify that <tt class="REPLACEABLE">select</tt> is in fact a table, and not a keyword,
        it needs to be placed inside of quotes.  Therefore, the correct syntax to view a table named <tt class="REPLACEABLE">select</tt>
        is as follows.</p><pre class="SCREEN">testdb=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM "select";</b></tt>
 selected
----------
        0
        1
       52
      105
(4 rows)</pre><p class="calibre9">Remember that any identifiers with at least one capitalized letter must be treated similarly. For example, if
        you've for some reason created a table named <tt class="REPLACEABLE">ProDucts</tt> (notice the capitalized "P" and
        "D"), and you want to destroy it (as you probably should, with a name like that!), then once again the identifier needs
        to be quoted in order to accurately describe its name to PostgreSQL, as follow:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP TABLE ProDucts;</b></tt>
ERROR: table "products" does not exist
booktown=# <tt class="REPLACEABLE"><b class="calibre10">DROP TABLE "ProDucts";</b></tt>
DROP</pre><p class="calibre9">This technique can be extremely useful in some circumstances, even if you never name database objects with
        these criteria yourself. For example, importing data through an external ODBC connection (e.g., via Microsoft Access)
        can result in table names with all capitalized letters. Without the functionality of quoted identifiers, you would
        have no way to accurately reference these tables.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="IDENTIFIERVALIDITY" class="calibre8">Identifier validity</a></h3><p class="calibre9">Both keywords and identifier names in PostgreSQL have a maximum length limit of 31 characters. Parsed keywords or
        identifiers over that length limit are automatically truncated. Identifiers may begin with any letter (a through z), or with an underscore,
         and may then be followed by letters, numbers (0 through 9), or underscores. While keywords are not permitted to start or end
        with an underscore, identifier names <span><i class="EMPHASIS">are</i></span> permitted to do so. Neither keywords nor identifiers should ever begin with a
        number.</p><p class="calibre9">In <a href="x1428.htm#WHENQUOTESAREREQUIRED">the Section called <i class="EMPHASIS">When quotes are required</i></a>" we described how quoted identifiers could be used to "overrule" the case
        insensitivity of identifiers by placing quotes around them. The same rule-bending can apply to the assertion that an identifier
        cannot begin with a number.  While PostgreSQL will not allow you to create a table using the name
        <tt class="REPLACEABLE">1st_bent_rule</tt> without quotes, the name is acceptable if it is surrounded with quotes.</p><p class="calibre9"><a href="x1428.htm#BENDINGRULES">Example 3-3</a> first fails in trying to create an illegally named table. It then proceeds to bend the
        rules with quotes.</p><div class="NAVHEADER"><a name="BENDINGRULES"></a><p class="calibre9"><b class="calibre10">Example 3-3. Bending rules</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE 1st_bent_rule (rule_name text);</b></tt>
ERROR:  parser: parse error at or near "1"
booktown=# <tt class="REPLACEABLE"><b class="calibre10">CREATE TABLE "1st_bent_rule" (rule_name text);</b></tt>
CREATE</pre></div><p class="calibre9">Furthermore, while quotes themselves are, of course, not allowed within the set of quotes to refer to a table name,
        other normally illegal characters are allowed, such as spaces and ampersands. Take note that while
        the ANSI/ISO SQL standard forbids using identifiers with the same names as SQL keywords, PostgreSQL (like many other SQL
        implementations) has a similarly relaxed view on this, allowing you to force such names with quoted identifiers.</p><p class="calibre9">Remember that while the use of quotes can be a useful trick to know for unusual circumstances, if you wish to design portable,
        standard SQL statements and relations, it is best to adhere to ANSI/SIO standards whenever possible.</p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="CONSTANTS" class="calibre8">Constants</a></h2><p class="calibre9">While much of the data in working with a database is stored on the disk and referred to via identifiers (e.g., table
      names, column names, and functions), there are obviously times when new data must be introduced to the system.  This may be
      observed when inserting new records, when forming clauses to specify criteria to delete or modify, or even when
      performing calculations on existing records. This data is input through constants, which are sometimes called literals
      because they literally represent a value in a SQL statement (rather than referencing an existing value by identifier).</p><p class="calibre9">An <span><i class="EMPHASIS">implicitly typed</i></span> constant is one whose <span><i class="EMPHASIS">type</i></span> is recognized automatically
      by PostgreSQL's parser merely by its syntax. PostgreSQL supports five types of implicitly typed constants:</p><p class="calibre9"> </p><p class="calibre9"></p><ul class="calibre21"><li class="calibre22"><p class="calibre9"><span><i class="EMPHASIS">String</i></span></p></li><li class="calibre22"><p class="calibre9"><span><i class="EMPHASIS">Bit string</i></span></p></li><li class="calibre22"><p class="calibre9"><span><i class="EMPHASIS">Integer</i></span></p></li><li class="calibre22"><p class="calibre9"><span><i class="EMPHASIS">Floating point</i></span></p></li><li class="calibre22"><p class="calibre9"><span><i class="EMPHASIS">Boolean</i></span></p></li></ul>
<div class="NAVHEADER"><h3 class="AUTHOR"><a name="STRINGCONSTANTS" class="calibre8">String constants</a></h3><p class="calibre9">A string constant is an arbitrary sequence of characters bound by single quotes (apostrophes). These are
        typically used when inserting character data into a table or passing character data to any other database object. A
        practical example of the necessity of string constants is updating the first and last names of
        authors in Book Town's <tt class="REPLACEABLE">authors</tt> table:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM authors;</b></tt>
  id   | last_name |    first_name
-------+-----------+------------------
  1809 | Geisel    | Theodor Seuss
  1111 | Denham    | Ariel
 15990 | Bourgeois | Paulette
 25041 | Bianco    | Margery Williams
    16 | Alcott    | Luoisa May
   115 | Poe       | Edgar Allen
(6 rows)</pre><p class="calibre9">Looking at this table's contents, it might stand out to you that the <tt class="REPLACEABLE">first_name</tt> with
        <tt class="REPLACEABLE">id</tt> 16, <span><i class="EMPHASIS">Louisa May</i></span> has been misspelled as 
        <span><i class="EMPHASIS">Luoisa May</i></span>. To correct this, an <tt class="REPLACEABLE">UPDATE</tt> statement can be made with a string
        constant, as shown in <a href="x1428.htm#USINGSTRINGCONSTANTS">Example 3-4</a>.</p><div class="NAVHEADER"><a name="USINGSTRINGCONSTANTS"></a><p class="calibre9"><b class="calibre10">Example 3-4. Using string constants</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">UPDATE authors </b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">       SET first_name = 'Louisa May'</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">       WHERE first_name = 'Luoisa May';</b></tt>
UPDATE 1
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM authors;</b></tt>
  id   | last_name |    first_name
-------+-----------+------------------
  1809 | Geisel    | Theodor Seuss
  1111 | Denham    | Ariel
 15990 | Bourgeois | Paulette
 25041 | Bianco    | Margery Williams
    15 | Poe       | Edgar Allen
    16 | Alcott    | Louisa May
(6 rows)</pre></div><p class="calibre9">The <tt class="REPLACEABLE">UPDATE</tt> statement made in <a href="x1428.htm#USINGSTRINGCONSTANTS">Example 3-4</a> uses the string
        constants <span><i class="EMPHASIS">Louisa May</i></span> and <span><i class="EMPHASIS">Luoisa May</i></span> in conjunction with the
        <tt class="REPLACEABLE">SET</tt> and <tt class="REPLACEABLE">WHERE</tt> keywords. This statement updates the
        contents of the table referenced by the <tt class="REPLACEABLE">authors</tt> identifier and, as shown, corrects the
        misspelling.</p><p class="calibre9">The fact that string constants are bound by single quotes presents an obvious semantic problem, however, in that
        if the sequence itself contains a single quote, the literal bounds of the constant are made ambiguous. To
        <span><i class="EMPHASIS">escape</i></span> (make literal) a single quote within the string, you may type two adjacent single
        quotes. The parser will interpret the two adjacent single quotes within the string constant as a single, literal quote. PostgreSQL will also allow single quotes to be embedded by using a C-style backslash:</p><pre class="SCREEN">testdb=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 'PostgreSQL''s great!' AS example;</b></tt>
       example
---------------------
 PostgreSQL's great!
(1 row)</pre><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 'PostgreSQL\'s C-style slashes are great!' AS example;</b></tt>
                 example
-----------------------------------------
 PostgreSQL's C-style slashes are great!
(1 row)</pre><p class="calibre9">PostgreSQL also supports the C-style "backslash escape" sequences, which are listed in <a href="x1428.htm#POSTGRESQLSUPPORTEDCSTYLEESCAPESEQUENCES">Table 3-3</a>.</p><div class="NAVHEADER"><a name="POSTGRESQLSUPPORTEDCSTYLEESCAPESEQUENCES"></a><p class="calibre9"><b class="calibre10">Table 3-3. PostgreSQL supported C-style escape sequences</b></p><table border="1" width="100%" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="4" valign="TOP" class="calibre13"><p class="calibre9">Escape sequence</p></th><th width="24" valign="TOP" class="calibre13"><p class="calibre9">Description</p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\\</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Literal backslash</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\'</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Literal apostrophe</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\b</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Backspace</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\f</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Form feed</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\n</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Newline</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\r</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Carriage return</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\t</p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">Tab</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">\<tt class="REPLACEABLE"><i class="EMPHASIS">xxx</i></tt></p></td><td width="24" valign="TOP" class="calibre15"><p class="calibre9">ASCII character with the corresponding octal number <tt class="REPLACEABLE"><i class="EMPHASIS">xxx</i></tt></p></td></tr></tbody></table></div><div class="NAVHEADER"><p class="calibre9"></p><table class="calibre" border="1" width="100%"><tr class="calibre1"><td class="calibre23"><b class="calibre10">Warning</b></td></tr><tr class="calibre1"><td class="calibre15"><p class="calibre9">As a result of the backslashes' special meaning described in <a href="x1428.htm#POSTGRESQLSUPPORTEDCSTYLEESCAPESEQUENCES">Table 3-3</a>, in order to include a backslash in the string you
          <span><i class="EMPHASIS">must</i></span> escape it using a another backslash (e.g., <tt class="REPLACEABLE">'A single backslash is: \\'</tt>
          will transform the pair of backslashes into a single backslash).</p></td></tr></table></div><p class="calibre9">When entering two quoted character strings to PostgreSQL that are separated by some amount of whitespace, and where that
        whitespace includes at least one newline, the strings are concatenated and viewed as if they had been typed as one constant. This
        is illustrated in <a href="x1428.htm#MULTILINESTRINGCONSTANTS">Example 3-5</a>.</p><div class="NAVHEADER"><a name="MULTILINESTRINGCONSTANTS"></a><p class="calibre9"><b class="calibre10">Example 3-5. Multiline string constants</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 'book'</b></tt>
booktown-#
booktown-# <tt class="REPLACEABLE"><b class="calibre10">'end' AS example;</b></tt>
 example
---------
 bookend
(1 row)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 'bookend' AS example;</b></tt>
 example
---------
 bookend
(1 row)</pre></div><p class="calibre9">As you can see, the semantics of the two statements is equivalent.
        However, at least one newline is <span><i class="EMPHASIS">required</i></span> for this interpretation to be possible,
        as spaces alone would result in the following error:</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 'book' 'end' AS mistake;</b></tt>
ERROR:  parser: parse error at or near "'"</pre><p class="calibre9">This error occurs because without a newline, PostgreSQL will assume that you are referring to two separate constants. If you
        wish to concatenate two string constants this way on a single line, PostgreSQL supports the
        <tt class="REPLACEABLE">||</tt> operator for text concatenation (see <a href="c7547.htm">Chapter 5</a>, for more details on this operator).</p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT 'book' || 'end' AS example;</b></tt>
 example
---------
 bookend
(1 row)</pre></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="BITSTRINGCONSTANTS" class="calibre8">Bit string constants</a></h3><p class="calibre9">Bit string constants provide a way to directly represent a binary value with an arbitrary sequence of ones and
        zeroes. Similarly to string constants, they are bound by single quotes, but they also must be preceded by a leading
        <tt class="REPLACEABLE">B</tt> character (which may be uppercase or lowercase). This character identifies to
        PostgreSQL that the forthcoming constant is a bit string, and not a normal string of character data.</p><p class="calibre9">Syntactically, the opening single quote must follow immediately after the leading
        <tt class="REPLACEABLE">B</tt>, and the bit string may not contain any character other than
        0 or 1. While there cannot be whitespace within this
        string of bits, it can be continued across multiple lines just like regular string constants, as documented in
        <a href="x1428.htm#STRINGCONSTANTS">the Section called <i class="EMPHASIS">String constants</i></a>."</p><p class="calibre9">Bit string constants are generally only useful when working with tables or functions that require binary values.
        <a href="x1428.htm#USINGBITSTRINGCONSTANTS">Example 3-6</a> demonstrates the use of a bit string constant upon a simple table containing raw
        bytes. A bit string byte is inserted into a list of bytes in the <tt class="REPLACEABLE">my_bytes</tt> table, and
        insertion is verified with a simple query.</p><div class="NAVHEADER"><a name="USINGBITSTRINGCONSTANTS"></a><p class="calibre9"><b class="calibre10">Example 3-6. Using bit string constants</b></p><pre class="SCREEN">testdb=# <tt class="REPLACEABLE"><b class="calibre10">INSERT INTO my_bytes VALUES (B'00000000');</b></tt>
testdb=# <tt class="REPLACEABLE"><b class="calibre10">SELECT my_byte FROM my_bytes;</b></tt>
 my_byte
----------
 10000000
 10000001
 10000101
 11111111
 00000000
(5 rows)</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="INTEGERCONSTANTS" class="calibre8">Integer constants</a></h3><p class="calibre9">Integer constants are far more frequently used than bit string constants. PostgreSQL identifies an integer constant
        as any token that consists solely of a sequence of numbers (without a decimal point) and that is outside of
        single-quotes. Technically, SQL defines integer constants as a sequence of decimal digits with no decimal point.
        The range of values available for an integer constant depends largely on the context within which it is used, but PostgreSQL's default for the
        integer data type is a 4-byte signed integer, with range from –2147483648 to 2147483647.</p><p class="calibre9">Integer constants are used anywhere you wish to represent a literal integer value.  They are used frequently
        within mathematical operations, as well as in SQL commands that reference a column with an integer data type.  <a href="x1428.htm#USINGINTEGERCONSTANTS">Example 3-7</a> is a simple demonstration of the use of integer constants to update an author's numeric
        identifier via an <tt class="REPLACEABLE">UPDATE</tt> command.</p><p class="calibre9">Consider once again the <tt class="REPLACEABLE">authors</tt> table used in previous sections, which correlates
        a numeric author identifier with two character strings representing the author's first and last name. Suppose that, for
        administrative reasons, it has been deemed necessary that any author with an identifier of less than 100 must be modified
        to a value of more than 100.</p><p class="calibre9">The first step to correct this would be to locate any author with such an <tt class="REPLACEABLE">id</tt>
        value. An integer constant can first be used in a <tt class="REPLACEABLE">SELECT</tt> statement's
        <tt class="REPLACEABLE">WHERE</tt> clause to perform a less-than comparison to check.</p><div class="NAVHEADER"><a name="USINGINTEGERCONSTANTS"></a><p class="calibre9"><b class="calibre10">Example 3-7. Using integer constants</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM authors WHERE id &lt; 100;</b></tt>
  id   | last_name |    first_name
-------+-----------+------------------
    16 | Alcott    | Louisa May
(1 row)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM authors WHERE id = 116;</b></tt>
  id   | last_name |    first_name
-------+-----------+------------------
(0 rows)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">UPDATE authors </b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">   SET id = 116 </b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10"> WHERE id = 16;</b></tt>
UPDATE 1
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM authors WHERE id = 116;</b></tt>
  id   | last_name |    first_name
-------+-----------+------------------
   116 | Alcott    | Louisa May
(1 row)</pre></div><p class="calibre9">In <a href="x1428.htm#USINGINTEGERCONSTANTS">Example 3-7</a>, the <tt class="REPLACEABLE">WHERE</tt> clause in the
        <tt class="REPLACEABLE">SELECT</tt> statement compares the <tt class="REPLACEABLE">id</tt> column identifier
        against an integer constant of 100, returning one row. Once the author with the offending
        <tt class="REPLACEABLE">id</tt> is found, a second <tt class="REPLACEABLE">SELECT</tt> statement is issued to
        check for an existing author with an <tt class="REPLACEABLE">id</tt> of 116. This is to verify
        that the new id is not in use by another author within the <tt class="REPLACEABLE">authors</tt> table, as this column
        has been specified as requiring a unique identifier. Finally, an <tt class="REPLACEABLE">UPDATE</tt> statement is
         executed, again using integer constants in both the <tt class="REPLACEABLE">SET</tt> and
         <tt class="REPLACEABLE">WHERE</tt> clauses.</p></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="FLOATINGPOINTCONSTANTS" class="calibre8">Floating-point constants</a></h3><p class="calibre9">A floating-point constant is similar to an integer constant, but it is used to represent decimal values as well as
        whole integers. These are required whenever such a floating-point value must be represented literally within a SQL
        statement.</p><p class="calibre9">A floating-point constant can be represented in several forms, as shown in <a href="x1428.htm#FLOATINGPOINTREPRESENTATIONS">Table 3-4</a>.
        Each occurrence of <tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt> represents one or more digits.</p><div class="NAVHEADER"><a name="FLOATINGPOINTREPRESENTATIONS"></a><p class="calibre9"><b class="calibre10">Table 3-4. Floating-point representations</b></p><table border="1" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="6" valign="TOP" class="calibre13"><p class="calibre9">Representation</p></th><th width="6" valign="TOP" class="calibre13"><p class="calibre9">Example</p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE"><i class="EMPHASIS">##.##</i></tt></p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">6.4</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>e[+-]<tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>]</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">8e-8</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9">[<tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>].<tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>[e[+-]<tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>]</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">.04e8</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>.[<tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>][e[+-]<tt class="REPLACEABLE"><i class="EMPHASIS">##</i></tt>]</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">4.e5</p></td></tr></tbody></table></div><p class="calibre9">In the first form, there must be at least one digit before or after the decimal point for PostgreSQL to recognize
        the value as a floating-point constant versus an integer constant. The other options involve having at least one digit
        before or after an <span><i class="EMPHASIS">exponent clause</i></span>, denoted by the <span><i class="EMPHASIS">e</i></span> in the list. The presence
        of either the decimal point, the exponent clause, or both, distinguishes an integer constant from a floating-point. </p><p class="calibre9">Each of these valid formats is represented in <a href="x1428.htm#VALIDFLOATINGPOINTVALUES">Example 3-8</a> through a simple SQL
        <tt class="REPLACEABLE">SELECT</tt> statement illustrating a variety of floating-point conventions.</p><div class="NAVHEADER"><a name="VALIDFLOATINGPOINTVALUES"></a><p class="calibre9"><b class="calibre10">Example 3-8. Valid floating-point values</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT .04 AS small_float,</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">   -16.63 AS negative_float,</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">      4e3 AS exponential_float,</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">   6.1e-2 AS negative_exponent;</b></tt>
 small_float | negative_float | exponential_float | negative_exponent
-------------+----------------+-------------------+-------------------
        0.04 |         -16.63 |              4000 |             0.061
(1 row)</pre></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="BOOLEANCONSTANTS" class="calibre8">Boolean constants</a></h3><p class="calibre9">Boolean constants are much simpler than any other constant values recognized by PostgreSQL, as they may consist
        only of two possible values: true and false. When PostgreSQL encounters either of these terms outside of single quotes,
        they are implicitly interpreted as Boolean constants, rather than a string constant. <a href="x1428.htm#THEDIFFERENCEBETWEENTRUEANDTRUE">Example 3-9</a> shows this important distinction. </p><div class="NAVHEADER"><a name="THEDIFFERENCEBETWEENTRUEANDTRUE"></a><p class="calibre9"><b class="calibre10">Example 3-9. The difference between true and 'true'</b></p><pre class="SCREEN">testdb=# SELECT true AS boolean_t,
testdb-#        'true' AS string_t,
testdb-#        false AS boolean_f,
testdb-#        'false' AS string_f;
 bool_t | string_t | bool_f | string_f
--------+----------+--------+----------
 t      | true     | f      | false
(1 row)</pre></div><p class="calibre9">When the terms <tt class="REPLACEABLE">true</tt> and <tt class="REPLACEABLE">false</tt> are parsed by PostgreSQL outside of single
        quotes, they are implied Boolean values. As shown in <a href="x1428.htm#THEDIFFERENCEBETWEENTRUEANDTRUE">Example 3-9</a>, PostgreSQL
        displays values which are literally of the type <tt class="REPLACEABLE">boolean</tt> as <tt class="REPLACEABLE">t</tt>
        or <tt class="REPLACEABLE">f</tt>, though be careful not to try to use only <tt class="REPLACEABLE">t</tt>
        or <tt class="REPLACEABLE">f</tt> as Boolean constant values, as this will not be interpreted correctly by PostgreSQL,
        and will cause an error.</p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="SPECIALCHARACTERSYMBOLS" class="calibre8">Special Character Symbols</a></h2><p class="calibre9">Special character symbols are characters with a pre-defined syntactic meaning in PostgreSQL. They are typically
      disallowed from being used in identifier names for this reason, though as mentioned in the section on <a href="x1428.htm#QUOTEDIDENTIFIERS">quoted identifiers</a>, this restriction can usually be worked around with quotes if need
      be.</p><div class="NAVHEADER"><h3 class="AUTHOR"><a name="PUNCTUATIONSYMBOLS" class="calibre8">Punctuation symbols</a></h3><p class="calibre9">Some special character symbols help to make up the "punctuation" of a SQL statement, much like parentheses, periods
        and commas do in the English language. <a href="x1428.htm#PUNCTUATIONSYMBOLSTABLE">Table 3-5</a> shows some common PostgreSQL-recognized
        syntactic symbols.</p><div class="NAVHEADER"><a name="PUNCTUATIONSYMBOLSTABLE"></a><p class="calibre9"><b class="calibre10">Table 3-5. Punctuation Symbols</b></p><table border="1" width="100%" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="6" valign="TOP" class="calibre13"><p class="calibre9">Character</p></th><th width="23" valign="TOP" class="calibre13"><p class="calibre9">Definition</p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">*</tt> (asterisk)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9"> Used with the <tt class="REPLACEABLE">SELECT</tt> command to query all columns in the table, and with the <tt class="REPLACEABLE">count()</tt> aggregate function to count all rows in a table.</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">()</tt> (parentheses)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Used to group expressions, enforce operator precedence, and to make function calls. The use of parentheses is highly subjective to the context in which they are used.</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">[]</tt> (brackets)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Used in the selection of specific elements in an array, or in the declaration of an array type (e.g., with the <tt class="REPLACEABLE">CREATE TABLE</tt> command).</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">;</tt> (semicolon)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Used to terminate a SQL command. The only place it can be used within a statement is within a string constant or quoted identifier.</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">,</tt> (comma)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Some commands use the comma to separate elements within a list.</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">.</tt> (period)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Used in floating-point constants (e.g., 3.1415), as well as to reference column names as children of tables (e.g., <tt class="REPLACEABLE">table_name.column_name</tt>).</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">:</tt> (colon)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Used to select <span><i class="EMPHASIS">slices</i></span> from arrays.</p></td></tr><tr class="calibre12"><td width="6" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">$</tt> (dollar sign)</p></td><td width="23" valign="TOP" class="calibre15"><p class="calibre9">Used in the body of a function definition to represent a positional parameter, or argument.</p></td></tr></tbody></table></div></div><div class="NAVHEADER"><h3 class="AUTHOR"><a name="OPERATORSYMBOLS" class="calibre8">Operator symbols</a></h3><p class="calibre9">An operator is another type of special character symbol; it is used to perform <span><i class="EMPHASIS">operations</i></span>
        on identifiers or constants, returning resultant values. Operators can be used for mathematical operations, such as
        addition, as well as to perform comparison and logical operations.</p><p class="calibre9">Consider again the <tt class="REPLACEABLE">books</tt> table, and its numeric
        <tt class="REPLACEABLE">author_id</tt> field. Recall that the <tt class="REPLACEABLE">author_id</tt> column is
        an integer used to identify an author. Now imagine that, due to a system modification, all author identifiers must be incremented by 1,500.  This can be
        achieved by evaluating the result of an operation (an <span><i class="EMPHASIS">operator expression</i></span>) in an
        <tt class="REPLACEABLE">UPDATE</tt> statement upon the <tt class="REPLACEABLE">author_id</tt> column.  This
        requires use of the addition (<tt class="REPLACEABLE">+</tt>) operator. An example of this can be seen in <a href="x1428.htm#OPERATORSINSTATEMENTS">Example 3-10</a>.</p><div class="NAVHEADER"><a name="OPERATORSINSTATEMENTS"></a><p class="calibre9"><b class="calibre10">Example 3-10. Operators in statements</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM books;</b></tt>
  id  |            title            | author_id | subject_id
------+-----------------------------+-----------+------------
 7808 | The Shining                 |      4156 |          9
  156 | The Tell-Tale Heart         |        15 |          9
 4513 | Dune                        |      1866 |         15
 4267 | 2001: A Space Odyssey       |      2001 |         15
 1608 | The Cat in the Hat          |      1809 |          2
 1590 | Bartholomew and the Oobleck |      1809 |          2
(6 rows)

booktown=# <tt class="REPLACEABLE"><b class="calibre10">UPDATE books SET author_id = author_id + 1500; </b></tt>
UPDATE 6
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM books;</b></tt>
  id  |            title            | author_id | subject_id
------+-----------------------------+-----------+------------
 7808 | The Shining                 |      5656 |          9
  156 | The Tell-Tale Heart         |      1515 |          9
 4513 | Dune                        |      3366 |         15
 4267 | 2001: A Space Odyssey       |      3501 |         15
 1608 | The Cat in the Hat          |      3309 |          2
 1590 | Bartholomew and the Oobleck |      3309 |          2
(6 rows)</pre></div><p class="calibre9">As you can see in <a href="x1428.htm#OPERATORSINSTATEMENTS">Example 3-10</a>, each <tt class="REPLACEABLE">author_id</tt> record is
        modified with the results of the <tt class="REPLACEABLE">+</tt> operator's operation upon the previous
        <tt class="REPLACEABLE">author_id</tt> value.</p><p class="calibre9">Common operators that you are may already familiar with include the basic mathematical operators: the
        <tt class="REPLACEABLE">+</tt> sign for the addition of two numeric values, the
        <tt class="REPLACEABLE">-</tt> sign for the subtraction of one numeric value from another,
        etc. Some of the more esoteric operators include the bitwise <tt class="REPLACEABLE">&amp;</tt> and
        <tt class="REPLACEABLE">|</tt> operators, which modify binary values at the bit level.</p><p class="calibre9">In addition to these character symbol operators, it's important to remember the SQL keywords, which
        are frequently called operators as well. Most notably, this includes the logical operators
        <tt class="REPLACEABLE">AND</tt>, <tt class="REPLACEABLE">OR</tt>, and <tt class="REPLACEABLE">NOT</tt>.
        While technically keywords, these terms are grouped with the operators because of their operational effect upon constants
        and identifiers.</p><p class="calibre9"><a href="x1428.htm#FUNDAMENTALPOSTGRESQLOPERATORS">Table 3-6</a> lists some fundamental PostgreSQL operators.</p><div class="NAVHEADER"><a name="FUNDAMENTALPOSTGRESQLOPERATORS"></a><p class="calibre9"><b class="calibre10">Table 3-6. Fundamental PostgreSQL operators</b></p><table border="1" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="5" valign="TOP" class="calibre13"><p class="calibre9">Category</p></th><th width="1" valign="TOP" class="calibre13"><p class="calibre9">Operator</p></th><th width="18" valign="TOP" class="calibre13"><p class="calibre9">Definition</p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td rowspan="6" width="5" valign="TOP" class="calibre15"><p class="calibre9"><span><i class="EMPHASIS">Mathematical operators</i></span></p></td><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">+</tt> (addition)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9"> Adds two numeric types</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">-</tt> (subtraction)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Subtracts one numeric type from another</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">/</tt> (division)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Divides one numeric type by another</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">*</tt> (multiplication)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Multiplies one numeric type by another</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">!</tt> (factorial)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Returns an integer's factorial</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">@</tt> (absolute value)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Returns the absolute value of a numeric value</p></td></tr><tr class="calibre12"><td rowspan="4" width="5" valign="TOP" class="calibre15"><p class="calibre9"><span><i class="EMPHASIS">Comparison operators</i></span></p></td><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">=</tt> (equivalence)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Compares two values for equivalence</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">&lt;</tt> (less than)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Evaluates whether or not one number is less than another</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">&gt;</tt> (greater than)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Evaluates whether or not one number is larger than another</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">~</tt> (regular expression)</p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Performs a regular expression comparison on text
                values</p></td></tr><tr class="calibre12"><td rowspan="3" width="5" valign="TOP" class="calibre15"><p class="calibre9"><span><i class="EMPHASIS">Logical operators</i></span></p></td><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">AND</tt></p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Returns true if both Boolean conditions are true</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">OR</tt></p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Returns true if at least one of two Boolean conditions is true</p></td></tr><tr class="calibre12"><td width="1" valign="TOP" class="calibre15"><p class="calibre9"><tt class="REPLACEABLE">NOT</tt></p></td><td width="18" valign="TOP" class="calibre15"><p class="calibre9">Returns the opposite of a Boolean condition</p></td></tr></tbody></table></div><p class="calibre9">While many operators have various connotations depending on their context, the
        <tt class="REPLACEABLE">=</tt> operator is an especially important one due to its meaning when used with an
        <tt class="REPLACEABLE">UPDATE</tt> statement's <tt class="REPLACEABLE">SET</tt> clause.</p><p class="calibre9">While in most expressions the <tt class="REPLACEABLE">=</tt> operator is an equivalence operator (used to
        compare two values for equivalence), when following the <tt class="REPLACEABLE">SET</tt> clause and an identifier
        name in an <tt class="REPLACEABLE">UPDATE</tt> statement, the <tt class="REPLACEABLE">=</tt> is read as an
        <span><i class="EMPHASIS">assignment</i></span> operator. This means that it is used to assign a new value to an existing identifier, as
        the <tt class="REPLACEABLE">SET</tt> term implies.</p><p class="calibre9">For more information on operators, see <a href="c7547.htm#USINGOPERATORS">the Section called <i class="EMPHASIS">Operators</i> in Chapter 5</a>."</p></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="COMMENTS" class="calibre8">Comments</a></h2><p class="calibre9">Comments are blocks of text that, through special character sequences, can embed non-SQL text within SQL
      code. These can be used within blocks of code, because PostgreSQL removes the commented areas from the input stream and
      treats it as whitespace. There are two styles of comments available: single-line comments, and multiline comments.</p><p class="calibre9">Single-line comments are preceded by two dashes (<tt class="REPLACEABLE">- -</tt>) and may either be on a line by
      themselves, or they may follow valid SQL tokens. (The comments themselves are not considered tokens to PostgreSQL's parser, as
      any character data following the <tt class="REPLACEABLE">- -</tt> sequence, up to the end of the line, is treated as
      whitespace.) This is demonstrated in <a href="x1428.htm#SINGLELINECOMMENTS">Example 3-11</a>.</p><div class="NAVHEADER"><a name="SINGLELINECOMMENTS"></a><p class="calibre9"><b class="calibre10">Example 3-11. Single-line comments</b></p><pre class="SCREEN">testdb=# SELECT 'Test' -- This can follow valid SQL tokens,
testdb-#               -- or be on a line of it own.
testdb-# AS example;
 example
---------
 Test
(1 row)</pre></div><p class="calibre9">Multiline comments begin with a sequential slash-asterisk
      (<tt class="REPLACEABLE">/*</tt>) sequence, and terminate
      with a sequential asterisk-slash (<tt class="REPLACEABLE">*/</tt>)
      sequence. This style of commenting may already be familiar to C
      programmers, but there is one key difference between PostgreSQL's
      interpreter and the C language interpreter: PostgreSQL comments may be
      <span><i class="EMPHASIS">nested</i></span>. Therefore, when you create a multiline
      comment within another multiline comment, the <tt class="REPLACEABLE">*/</tt>
      used to close the inner comment does not also close the outer comment.
      <a href="x1428.htm#MULTILINECOMMENTS">Example 3-12</a> provides a comment explanation.
      </p><div class="NAVHEADER"><a name="MULTILINECOMMENTS"></a><p class="calibre9"><b class="calibre10">Example 3-12. Multiline comments</b></p><pre class="SCREEN">testdb=# SELECT 'Multi' /* This comment extends across
testdb*#                 * numerous lines, and can be
testdb*#                 * /* nested safely */ */
testdb-# || '-test' AS example;
  example
------------
 Multi-test
(1 row)</pre></div><p class="calibre9">Nesting comments can be useful if you have a file containing SQL syntax of which you wish to comment a
      large portion before sending to PostgreSQL for interpreting and execution. If you have already used multiline comments
      within that document and you wish to comment a large section which includes those comments, PostgreSQL is intelligent
      enough to recognize that a closing comment sequence (<tt class="REPLACEABLE">*/</tt>) closes only the most recently
      opened comment, not the entire commented region.</p><div class="NAVHEADER"><blockquote class="NOTE"><p class="calibre9"><b class="calibre10">Note: </b>The asterisk character by itself (without an adjacent slash character) has no special meaning within a comment.
        The extra asterisks in <a href="x1428.htm#MULTILINECOMMENTS">Example 3-12</a> on multiline comments are provided only for aesthetic purposes
        and readability.</p></blockquote></div></div><div class="NAVHEADER"><h2 class="SECT"><a name="PUTTINGITALLTOGETHER" class="calibre8">Putting It All Together</a></h2><p class="calibre9">In summary, a SQL statement is comprised of tokens, where each token can represent either a keyword, identifier, quoted identifier, constant, or special character symbol. <a href="x1428.htm#ASIMPLESQLQUERY">Table 3-7</a> uses a simple
      <tt class="REPLACEABLE">SELECT</tt> statement to illustrate a basic, but complete, SQL statement and its
      components.</p><div class="NAVHEADER"><a name="ASIMPLESQLQUERY"></a><p class="calibre9"><b class="calibre10">Table 3-7. A simple SQL query</b></p><table border="1" width="100%" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="4" valign="TOP" class="calibre13"><p class="calibre9"></p></th><th width="4" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">SELECT</tt></p></th><th width="10" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">id, name</tt></p></th><th width="4" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">FROM</tt></p></th><th width="4" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">states</tt></p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Token Type</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Keyword</p></td><td width="10" valign="TOP" class="calibre15"><p class="calibre9">Identifiers</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Keyword</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Identifier</p></td></tr><tr class="calibre12"><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Description</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Command</p></td><td width="10" valign="TOP" class="calibre15"><p class="calibre9">Id and name columns</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Clause</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">Table name</p></td></tr></tbody></table></div><p class="calibre9">As shown in the table, the <tt class="REPLACEABLE">SELECT</tt> statement contains the keywords
      <tt class="REPLACEABLE">SELECT</tt> and <tt class="REPLACEABLE">FROM</tt>.  Together, the
      <tt class="REPLACEABLE">FROM</tt> keyword and <tt class="REPLACEABLE">states</tt> token compose
      a clause, as they modify and further describe the <tt class="REPLACEABLE">SELECT</tt> command.</p><p class="calibre9">The <tt class="REPLACEABLE">id</tt>, <tt class="REPLACEABLE">name</tt>, and
      <tt class="REPLACEABLE">states</tt> tokens are the identifiers of the statement. The
      <tt class="REPLACEABLE">id</tt> and <tt class="REPLACEABLE">name</tt> identifiers specify the selected columns, while the <tt class="REPLACEABLE">states</tt> identifier specifies the table name to select from. Therefore,
      with the preceding SQL query, you are instructing PostgreSQL to display the columns named
      <tt class="REPLACEABLE">id</tt> and <tt class="REPLACEABLE">name</tt> for each row from the
      <tt class="REPLACEABLE">states</tt> table.  <a href="x1428.htm#EXAMPLESQLQUERY">Example 3-13</a> shows the output
      this query generates within the <tt class="REPLACEABLE">booktown</tt> database.</p><div class="NAVHEADER"><a name="EXAMPLESQLQUERY"></a><p class="calibre9"><b class="calibre10">Example 3-13. Example SQL query</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT id, name FROM states;</b></tt>
 id |    name
----+------------
 42 | Washington
 51 | Oregon
(2 rows)

booktown=#</pre></div><p class="calibre9">Getting more complicated, <a href="x1428.htm#UPDATEEXAMPLETHESETCLAUSE">Table 3-8</a> and <a href="x1428.htm#UPDATEEXAMPLETHEWHERECLAUSE">Table 3-9</a>
      break down another example statement. This statement uses the <tt class="REPLACEABLE">UPDATE</tt> command, along with
      <tt class="REPLACEABLE">SET</tt> and <tt class="REPLACEABLE">WHERE</tt> clauses, which respectively specify with
      <span><i class="EMPHASIS">what</i></span> to update the records, and <span><i class="EMPHASIS">how</i></span> to find the records to update.</p><div class="NAVHEADER"><a name="UPDATEEXAMPLETHESETCLAUSE"></a><p class="calibre9"><b class="calibre10">Table 3-8. UPDATE example: the SET clause</b></p><table border="1" width="100%" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="5" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">UPDATE</tt></p></th><th width="4" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">states</tt></p></th><th width="4" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">SET</tt></p></th><th width="4" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">id</tt></p></th><th width="5" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">=</tt></p></th><th width="6" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">51</tt></p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="5" valign="TOP" class="calibre15"><p class="calibre9">keyword</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">identifier</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">keyword</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">identifier</p></td><td width="5" valign="TOP" class="calibre15"><p class="calibre9">operator</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">integer constant</p></td></tr><tr class="calibre12"><td width="5" valign="TOP" class="calibre15"><p class="calibre9">command</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">table name</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">clause</p></td><td width="4" valign="TOP" class="calibre15"><p class="calibre9">column</p></td><td width="5" valign="TOP" class="calibre15"><p class="calibre9">assignment</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">new id value</p></td></tr></tbody></table></div><div class="NAVHEADER"><a name="UPDATEEXAMPLETHEWHERECLAUSE"></a><p class="calibre9"><b class="calibre10">Table 3-9. UPDATE example: the WHERE clause</b></p><table border="1" width="100%" class="calibre"><thead class="calibre11"><tr class="calibre12"><th width="7" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">WHERE</tt></p></th><th width="7" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">name</tt></p></th><th width="6" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">=</tt></p></th><th width="8" valign="TOP" class="calibre13"><p class="calibre9"><tt class="REPLACEABLE">'Oregon'</tt></p></th></tr></thead><tbody class="calibre14"><tr class="calibre12"><td width="7" valign="TOP" class="calibre15"><p class="calibre9">keyword</p></td><td width="7" valign="TOP" class="calibre15"><p class="calibre9">identifier</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">operator</p></td><td width="8" valign="TOP" class="calibre15"><p class="calibre9">string constant</p></td></tr><tr class="calibre12"><td width="7" valign="TOP" class="calibre15"><p class="calibre9">clause</p></td><td width="7" valign="TOP" class="calibre15"><p class="calibre9">column name</p></td><td width="6" valign="TOP" class="calibre15"><p class="calibre9">equivalence</p></td><td width="8" valign="TOP" class="calibre15"><p class="calibre9">string value to match</p></td></tr></tbody></table></div><p class="calibre9">When executed, this statement examines each record's <tt class="REPLACEABLE">name</tt> column to find matches for
      the <tt class="REPLACEABLE">WHERE</tt> clause's stated condition (equivalence to the string constant 'Oregon'). Then,
      for each row which matches that condition, it updates the <tt class="REPLACEABLE">id</tt> column with the value
      51.</p><p class="calibre9">Breaking it down, this <tt class="REPLACEABLE">UPDATE</tt> statement has three keywords, three identifiers, two
      operators, and two constants. The keywords are <tt class="REPLACEABLE">UPDATE</tt> (the SQL command),
      <tt class="REPLACEABLE">SET</tt> (specifies the updates to make), and <tt class="REPLACEABLE">WHERE</tt> (identifies
      the rows to update). The identifiers are the <tt class="REPLACEABLE">states</tt> table name, the <tt class="REPLACEABLE">id</tt> column
      name, and the <tt class="REPLACEABLE">name</tt> column name.</p><p class="calibre9">The operators are both represented by the <tt class="REPLACEABLE">=</tt> operator. When used with the
      <tt class="REPLACEABLE">SET</tt> clause, this operator is used for assignment (to assign a new value to an existing
      record's identified column); this is a special use which is unique to the <tt class="REPLACEABLE">SET</tt> clause.  In
      contrast, when used with the <tt class="REPLACEABLE">WHERE</tt> clause, the <tt class="REPLACEABLE">=</tt> operator
      is used to check equivalence between values. In this case, this means that the equivalence operator will check the value of
      a record's <tt class="REPLACEABLE">name</tt> column against a string constant with the value of
      <span><i class="EMPHASIS">Oregon</i></span>.</p><p class="calibre9">Finally, the constants in this statement are the integer constant 51 (the new value for the
      <tt class="REPLACEABLE">id</tt> column), and the string constant <span><i class="EMPHASIS">Oregon</i></span> (compared to the
      <tt class="REPLACEABLE">name</tt> column through the <tt class="REPLACEABLE">WHERE</tt> clause).</p><p class="calibre9"><a href="x1428.htm#ASQLUPDATE">Example 3-14</a> therefore updates the <tt class="REPLACEABLE">states</tt> table by setting the
      <tt class="REPLACEABLE">id</tt> column to 51 whenever the <tt class="REPLACEABLE">name</tt>
      column matches the value <span><i class="EMPHASIS">Oregon</i></span>. It then checks the results of that
      <tt class="REPLACEABLE">UPDATE</tt> statement with another <tt class="REPLACEABLE">SELECT</tt> statement.</p><div class="NAVHEADER"><a name="ASQLUPDATE"></a><p class="calibre9"><b class="calibre10">Example 3-14. A SQL update</b></p><pre class="SCREEN">booktown=# <tt class="REPLACEABLE"><b class="calibre10">UPDATE states </b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10">   SET id = 51</b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10"> WHERE name = 'Oregon';</b></tt>
UPDATE 1
booktown=# <tt class="REPLACEABLE"><b class="calibre10">SELECT * FROM states </b></tt>
booktown-# <tt class="REPLACEABLE"><b class="calibre10"> WHERE name = 'Oregon';</b></tt>
 id |  name  | abbreviation
----+--------+--------------
 51 | Oregon | OR
(1 row)</pre></div></div></div><div class="NAVHEADER"><hr width="100%" class="calibre6"/><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0" class="calibre"><tr class="calibre1"><td width="33%" valign="top" class="calibre3"><a href="x1277.htm" accesskey="P">Prev</a></td><td width="34%" valign="top" class="calibre4"><a href="book1.htm" accesskey="H">Home</a></td><td width="33%" valign="top" class="calibre5"><a href="x2632.htm" accesskey="N">Next</a></td></tr><tr class="calibre1"><td width="33%" valign="top" class="calibre3">Introduction to Relational Databases</td><td width="34%" valign="top" class="calibre4"><a href="c1164.htm" accesskey="U">Up</a></td><td width="33%" valign="top" class="calibre5">Data Types</td></tr></table></div></div>

{% endraw %}

