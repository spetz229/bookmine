---
layout: page
title: "Practical Vim (for Kathryn Amaral)"
prev: f_0134.html
next: f_0136.html
book_path: books/drew-neil-practical-vim-edit-text-at-the-speed-of-thought-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<table class="arr-recipe" id="sec.todo.register">
<tr class="calibre14">
<td class="arr-recipe-number">Tip 99</td>
<td class="arr-recipe-name">Collect TODO Items in a Register</td>
</tr>
</table>
<p id="N1A43B" class="calibre4">
<span class="calibre5">
        Combining the <code class="cf">:global</code> and <code class="cf">:yank</code> commands allows us to collect all lines that match a <code class="cf">{pattern}</code> in a register.
    </span>
</p>
<p id="N1A468" class="calibre4">
      This excerpt of code contains a couple of comments that lead with “TODO”:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td colspan="2" class="calibre33">
<a href="http://media.pragprog.com/titles/dnvim/code/global/markdown.js">global/markdown.js</a>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​Markdown.dialects.Gruber = {​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​    lists: <strong class="prompt">function</strong>() {​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​        <em class="comment">// TODO: Cache this regexp for certain depths.</em>​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​        <strong class="prompt">function</strong> regex_for_depth(depth) { <em class="comment">/* implementation */</em> }​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​    },​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​    "`": <strong class="prompt">function</strong> inlineCode( text ) {​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​        <strong class="prompt">var</strong> m = text.match( /(`+)(([\s\S]*?)\1)/ );​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​        <strong class="prompt">if</strong> ( m &amp;&amp; m[2] )​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​            <strong class="prompt">return</strong> [ m[1].length + m[2].length ];​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​        <strong class="prompt">else</strong> {​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​            <em class="comment">// TODO: No matching end code found - warn!</em>​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​            <strong class="prompt">return</strong> [ 1, <em class="string">"`"</em> ];​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​        }​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​    }​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​}​</code>​</div>
</td>
</tr>
</table>
<p id="N1A4C4" class="calibre4">
      Suppose that we wanted to collect all of the TODO items in one place. We could view them all at a glance by running this command:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">:g/TODO</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>&lt;= </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​  // TODO: Cache this regexp for certain depths.​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​      // TODO: No matching end code found - warn!​</code>​</div>
</td>
</tr>
</table>
<p id="N1A4DB" class="calibre4">
      Remember, <code class="cf">:print</code> is the default <code class="cf">[cmd]</code> for the <code class="cf">:global</code> command. This simply echoes each line containing the word “TODO.” It’s not a great deal of use though, because the messages disappear as soon as we execute another command.
    </p>
<p id="N1A4F1" class="calibre4">
      Here’s an alternative strategy: let’s yank each line containing the word “TODO” into a register. Then we can paste the contents of that register into another file and keep them around for later.
    </p>
<p id="N1A4F4" class="calibre4">
      We’ll use the <code class="cf">a</code> register. First we’ll need to clear it by running <span class="calibre17">qaq</span>. Let’s break that down: <span class="calibre17">qa</span> tells Vim to start recording a macro into the <code class="cf">a</code> register, and then <span class="calibre17">q</span> stops the recording. We didn’t type anything while the macro was recording, so the register ends up empty. We can check that by running the following:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">:reg a</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>&lt;= </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​--- Registers ---​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​"a​</code>​</div>
</td>
</tr>
</table>
<p id="N1A524" class="calibre4">
      Now we can go ahead and yank the TODO comments into the register:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">:g/TODO/yank A</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">:reg a</strong>​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>&lt;= </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​"a // TODO: Cache this regexp for certain depths.​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​      // TODO: No matching end code found - warn!​</code>​</div>
</td>
</tr>
</table>
<p id="N1A540" class="calibre4">
      The trick here is that we’ve addressed our register with an uppercase <code class="cf">A</code>. That tells Vim to <span class="calibre5">append</span> to the specified register, whereas a lowercase <code class="cf">a</code> would overwrite the register’s contents. We can read the global command as “For each line that matches the pattern <code class="cf">/TODO/</code>, append the entire line into register <code class="cf">a</code>.”
    </p>
<p id="N1A55C" class="calibre4">
      This time, when we run <code class="cf">:reg a</code>, we can see that the register contains the two TODO items from the document. (For the sake of legibility, I’ve formatted these items on two separate lines, but in Vim it actually shows a <code class="cf">^J</code> symbol for newlines.) We could then open up a new buffer in a split window and run <span class="calibre17">"ap</span> to paste the <code class="cf">a</code> register into the new document.
    </p>
<h3 class="calibre22">Discussion</h3>
<p id="N1A56F" class="calibre4">
        In this example, we’ve just collected two TODO items, which we could have done by hand quite rapidly. But this technique scales well. If the document contained a dozen TODO items, it would require the same effort on our part.
      </p>
<p id="N1A572" class="calibre4">
        We could even combine the <code class="cf">:global</code> command with either <code class="cf">:bufdo</code> or <code class="cf">:argdo</code> to collect all TODO items from a set of files. I’ll leave that as an exercise for you, but look to <a xmlns:str="http://exslt.org/strings" href="f_0131.html#sec.substitute.in.project">Tip 96</a>, for a hint at the workflow.
      </p>
<p id="N1A596" class="calibre4">
        Here’s an alternative solution:
      </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">:g/TODO/t$</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N1A5A6" class="calibre4">
        It uses the <code class="cf">:t</code> command, which we met in <a xmlns:str="http://exslt.org/strings" href="f_0051.html#sec.ex.copy.move">Tip 29</a>. Rather than appending each TODO item to a register, we simply copy it to the end of the file. After running this command, we could jump to the end of the file to review the TODO items. This technique is more straightforward because it avoids messing around with registers. But it won’t work as neatly with the <code class="cf">:argdo</code> and <code class="cf">:bufdo</code> commands.
      </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

