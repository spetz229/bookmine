---
layout: page
title: "Practical Vim (for Kathryn Amaral)"
prev: f_0109.html
next: f_0111.html
book_path: books/drew-neil-practical-vim-edit-text-at-the-speed-of-thought-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<table class="arr-recipe" id="sec.pattern.zs">
<tr class="calibre14">
<td class="arr-recipe-number">Tip 77</td>
<td class="arr-recipe-name">Stake the Boundaries of a Match</td>
</tr>
</table>
<p id="N186FF" class="calibre4">
<span class="calibre5">
        Sometimes we might want to specify a broad pattern and then focus on a subset of the match. Vim’s <code class="cf">\zs</code> and <code class="cf">\ze</code> items allow us to do just that. 
    </span>
</p>
<p id="N1871B" class="calibre4">
      Up until now, we’ve assumed a complete overlap between search patterns and the matches they generate. It’s time to pry these apart into two separate concepts. Let’s start by defining them. When we talk of a <span class="calibre5">pattern</span>, we refer to the regular expression (or literal text) that we type into the search field. When we talk of a <span class="calibre5">match</span>, we refer to any text in the document that appears highlighted (assuming the <code class="cf">‘hlsearch’</code> option is enabled).
    </p>
<p id="N18727" class="calibre4">
      The boundaries of a match normally correspond to the start and end of a pattern. But we can use the <code class="cf">\zs</code> and <code class="cf">\ze</code> items to crop the match, making it a subset of the entire pattern (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">/\zs</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/pattern.html#/\zs">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>). The <code class="cf">\zs</code> item marks the start of a match, while the <code class="cf">\ze</code> item matches the end of a match. Together, they allow us to specify a pattern that entirely matches a range of characters and then zoom in on a subset of the match. Just like the word delimiters (from the previous tip), <code class="cf">\zs</code> and <code class="cf">\ze</code> are zero-width items.
    </p>
<p id="N18743" class="calibre4">
      An example would help at this point. If we searched for <code class="cf">/Practical Vim</code>
<span class="calibre17">&lt;CR&gt;</span> then any occurrences of “Practical Vim” in our document would light up. If we were to modify the search pattern to <code class="cf">/Practical \zsVim</code>
<span class="calibre17">&lt;CR&gt;</span>, then only the word “Vim” would be highlighted. The word “Practical” would be excluded from the match, even though it is still part of the pattern. As a result, occurrences of the word “Vim” that directly follow the word “Practical” will be highlighted, but any occurrences of the word “Vim” that do not follow the word “Practical” will not match. The outcome is quite different from simply searching for <code class="cf">/Vim</code>
<span class="calibre17">&lt;CR&gt;</span>. 
    </p>
<div class="sidebar" id="sidebar.lookaround">
<div class="sidebar-title">Lookaround Expressions</div>
<div class="calibre1">
<p id="N1875B" class="calibre4">
        Vim’s <code class="cf1">\zs</code> and <code class="cf1">\ze</code> items are conceptually similar to Perl’s <span class="calibre5">lookaround</span> assertions.<a id="FNPTR-21" href="f_0111.html#FOOTNOTE-21">[21]</a> Although the syntax differs between the regex engines in Perl and Vim, the <code class="cf1">\zs</code> item is roughly equivalent to <span class="calibre5">positive lookbehind</span>, while <code class="cf1">\ze</code> is equivalent to <span class="calibre5">positive lookahead</span>.
      </p>
<p id="N1878D" class="calibre4">
        As you might expect, Perl also supports negative variants of the lookaround assertions. These are zero-width items that match only if the specified pattern is <span class="calibre5">not</span> present. Vim also supports the full matrix of negative/positive lookahead/lookbehind assertions, but again, the syntax differs from Perl. For a side-by-side comparison, look up <strong xmlns:str="http://exslt.org/strings" class="calibre10">perl-patterns</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/pattern.html#perl-patterns">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>.
      </p>
<p id="N18797" class="calibre4">
        Instead of using <code class="cf1">\zs</code> and <code class="cf1">\ze</code>, we could rewrite the <code class="cf1">/\v"\zs[^"]+\ze"</code>
<span class="calibre17">&lt;CR&gt;</span> pattern from <a xmlns:str="http://exslt.org/strings" href="#sec.pattern.zs">Tip 77</a>, using Vim’s positive lookaround items, like so:
      </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix4" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline4" valign="top">
<div class="calibre38">
​<code class="calibre39">​<strong class="prompt">/\v"@&lt;=[^"]+"@=</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N187B6" class="calibre4">
        I don’t know about you, but I find the version using <code class="cf1">\zs</code> and <code class="cf1">\ze</code> easier to parse. Negative lookaround expressions are used heavily in some of Vim’s syntax highlighting definitions, but I’ve found little need for them in everyday usage. However, I’ve found many uses for positive lookaround expressions, so it seems fitting that they should have their own shorthand tokens, namely <code class="cf1">\zs</code> and <code class="cf1">\ze</code>.
      </p>
</div>
</div>
<p id="N187CE" class="calibre4">
      Here’s another example, this time using both <code class="cf">\zs</code> and <code class="cf">\ze</code> to tweak the start and end of the match:
    </p>
<table class="simpletable">
<thead class="calibre23">
<tr class="calibre7">
<th class="hlines">Keystrokes</th>
<th class="hlines">Buffer Contents</th>
</tr>
</thead>
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre24">{start}</td>
<td class="calibre24">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">M</span>atch "quoted words"---not quote marks.​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<code class="cf">/\v"[^"]+"</code>
<span class="calibre17">&lt;CR&gt;</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​Match <span class="shade-fg-black">
<span class="shade-fg-white">"</span>quoted words"</span>---not quote marks.​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<code class="cf">/\v"\zs[^"]+\ze"</code>
<span class="calibre17">&lt;CR&gt;</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​Match "<span class="shade-fg-black">
<span class="shade-fg-white">q</span>uoted words</span>"---not quote marks.​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<p id="N18837" class="calibre4">
      The basic pattern uses a common regex idiom: <code class="cf">"[^"]+"</code>. The pattern begins and ends with a quote mark and then matches one or more characters in between that are anything but a quote mark. In the final rendition of the pattern, we add the <code class="cf">\zs</code> item after the opening quote mark and the <code class="cf">\ze</code> item before the closing quote mark. This excludes the quote marks from the match, leaving only the contents of the quotes highlighted. Note that the quote marks are still a critical element in the pattern, even though they are excluded from the match.
    </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

