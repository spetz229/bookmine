---
layout: page
title: "Practical Vim (for Kathryn Amaral)"
prev: f_0095.html
next: f_0097.html
book_path: books/drew-neil-practical-vim-edit-text-at-the-speed-of-thought-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<table class="arr-recipe" id="N171F3">
<tr class="calibre14">
<td class="arr-recipe-number">Tip 65</td>
<td class="arr-recipe-name">Normalize, Strike, Abort</td>
</tr>
</table>
<p id="N171F9" class="calibre4">
<span class="calibre5">
        Executing a macro can sometimes produce unexpected results, but we can achieve better consistency if we follow a handful of best practices.
    </span>
</p>
<p id="N17203" class="calibre4">
      When we execute a macro, Vim blindly repeats the sequence of canned keystrokes. If we aren’t careful, the outcome when we replay a macro might diverge from our expectations. But it’s possible to compose macros that are more flexible, adapting to do the right thing in each context.
    </p>
<p id="N17206" class="calibre4">
      The golden rule is this: when recording a macro, ensure that every command is repeatable.
    </p>
<h3 class="calibre22">Normalize the Cursor Position</h3>
<p id="N1720D" class="calibre4">
        As soon as you start recording a macro, ask yourself these questions: where am I, where have I come from, and where am I going? Before you do anything, make sure your cursor is positioned so that the next command does what you expect, where you expect it.
      </p>
<p id="N17215" class="calibre4">
        That might mean moving the cursor to the next search match (<span class="calibre17">n</span>) or the start of the current line (<span class="calibre17">0</span>) or perhaps the first line of the current file (<span class="calibre17">gg</span>). Always starting on square one makes it easier to strike the right target every time.
      </p>
<h3 class="calibre22">Strike Your Target with a Repeatable Motion</h3>
<p id="N17226" class="calibre4">
        Vim has a rich vocabulary of motions for getting around a text file. Use them well.
      </p>
<p id="N1722E" class="calibre4">
        Don’t just hammer the <span class="calibre17">l</span> key until your cursor reaches its target. Remember, Vim executes your keystrokes blindly. Moving your cursor ten characters to the right might get you where you need to go right now as you record the macro, but what about when you play it back later? In another context, moving the cursor ten places to the right might overshoot the mark or stop short of it.
      </p>
<p id="N17234" class="calibre4">
        Word-wise motions, such as <span class="calibre17">w</span>, <span class="calibre17">b</span>, <span class="calibre17">e</span>, and <span class="calibre17">ge</span> tend to be more flexible than character-wise <span class="calibre17">h</span> and <span class="calibre17">l</span> motions. If we recorded the motion <span class="calibre17">0</span> followed by <span class="calibre17">e</span>, we could expect consistent results each time we executed the macro. The cursor would end up on the last character of the first word of the current line. It wouldn’t matter how many characters that word contained, so long as the line contained at least one word.
      </p>
<p id="N1724F" class="calibre4">
        Navigate by search. Use text objects. Exploit the full arsenal of Vim’s motions to make your macros as flexible and repeatable as you can. Don’t forget: when recording a macro, using the mouse is <span class="calibre5">verboten</span>!
      </p>
<h3 id="sec.macro.abort" class="calibre22">Abort When a Motion Fails</h3>
<p id="N1725F" class="calibre4">
        Vim’s motions can fail. For example, if our cursor is positioned on the first line of a file, the <span class="calibre17">k</span> command does nothing. The same goes for <span class="calibre17">j</span> when our cursor is on the last line of a file. By default, Vim beeps at us when a motion fails, although we can mute it with the <code class="cf">‘visualbell’</code> setting (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">'visualbell'</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/options.html#'visualbell'">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>).
      </p>
<p id="N17288" class="calibre4">
        If a motion fails while a macro is executing, then Vim aborts the rest of the macro. Consider this a feature, not a bug. We can use motions as a simple test of whether or not the macro should be executed in the current context.
      </p>
<p id="N1728B" class="calibre4">
        Consider this example: We start by searching for a pattern. Let’s say that the document has ten matches. We start recording a macro using the <span class="calibre17">n</span> command to repeat the last search. With our cursor positioned on a match, we make some small change to the text and stop recording the macro. The result of our edit is that this particular region of text no longer matches our search pattern. Now the document has only nine matches.
      </p>
<p id="N17291" class="calibre4">
        When we execute this macro, it jumps to the next match and makes the same change. Now the document has only eight matches. We execute the macro again and again, until eventually no matches remain. If we attempt to execute the macro now, the <span class="calibre17">n</span> command will fail because there are no more matches. The macro aborts.
      </p>
<p id="N17297" class="calibre4">
        Suppose that the macro was stored in the <code class="cf">a</code> register. Rather than executing <span class="calibre17">@a</span> ten times, we could prefix it with a count: <span class="calibre17">10@a</span>. The beauty of this technique is that we can be unscrupulous about how many times we execute this macro. Don’t care for counting? It doesn’t matter! We could execute <span class="calibre17">100@a</span> or even <span class="calibre17">1000@a</span>, and it would produce the same result.
      
	  </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

