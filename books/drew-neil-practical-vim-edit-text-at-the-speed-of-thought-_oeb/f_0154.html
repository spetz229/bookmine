---
layout: page
title: "Practical Vim (for Kathryn Amaral)"
prev: f_0153.html
next: f_0155.html
book_path: books/drew-neil-practical-vim-edit-text-at-the-speed-of-thought-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<table class="arr-recipe" id="sec.keyword.origins">
<tr class="calibre14">
<td class="arr-recipe-number">Tip 113</td>
<td class="arr-recipe-name">Understand the Source of Keywords</td>
</tr>
</table>
<p id="N1BBCF" class="calibre4">
<span class="calibre5">
        Generic keyword autocompletion compiles its word list from a handful of sources. We can be more specific about which sources we want to use to build a word list.
    </span>
</p>
<p id="N1BBDF" class="calibre4">
      Several variant forms of autocompletion use a specific file or set of files to generate their word list. Generic keyword autocompletion uses an amalgamation of these word lists. To understand where generic keywords come from, we should first look at each of the more targeted forms of autocompletion.
    </p>
<h3 class="calibre22">The Buffer List</h3>
<p id="N1BBE6" class="calibre4">
      The simplest mechanism for populating the autocomplete word list would be to use words only from the current buffer. Current file keyword completion does just that and is triggered with <span class="calibre17">&lt;C-x&gt;&lt;C-n&gt;</span> (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">compl-current</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-current">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>). This can be useful when generic keyword completion generates too many suggestions and you know that the word you want is somewhere in the current buffer.
    </p>
<p id="N1BBF5" class="calibre4">
      But current buffer keyword completion has little to offer when the current buffer has a low word count. To augment the word list, we can have Vim source keywords from each item in the buffer list. We can inspect these by running this command:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">:ls!</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N1BC05" class="calibre4">
      Generic keywords are sourced from the contents of each file in this list, which represents all of the files that have been opened in the current Vim session. As we’ll see next, we needn’t even open a file for its contents to be pulled into the autocomplete word list.
    </p>
<h3 class="calibre22">Included Files</h3>
<p id="N1BC0C" class="calibre4">
      Most programming languages provide some way of loading code from an external file or library. In C, this can be done using the <code class="cf">#include</code> directive, whereas Python uses <code class="cf">import</code> and Ruby uses <code class="cf">require</code>. If we are working on a file that includes code from another library, then it would be useful if Vim could read the contents of those referenced files when building a word list for autocompletion. And that is exactly what happens when we trigger keyword completion with the <span class="calibre17">&lt;C-x&gt;&lt;C-i&gt;</span> command (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">compl-keyword</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-keyword">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>).
    </p>
<p id="N1BC24" class="calibre4">
      Vim understands the C way of including files, but it can be taught to follow the corresponding directives in other languages by tweaking the <code class="cf">‘include’</code> setting (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">'include'</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/options.html#'include'">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>). This is usually handled by a file-type plugin. And the good news is that Vim is distributed with support for many languages, so you shouldn’t have to tinker with this setting unless you are working with an unsupported language. Try opening a Ruby or Python file and running <code class="cf">:set include?</code>, and you should find that Vim already knows how to look up included files for those languages.
    </p>
<h3 id="sec.compl.tag" class="calibre22">Tag Files</h3>
<p id="N1BC3C" class="calibre4">
      In <a xmlns:str="http://exslt.org/strings" href="f_0138.html#chp.ctags">Chapter 16, ​<em class="calibre5">Index and Navigate <br class="calibre1"/>Source Code with ctags</em>​</a>, we met Exuberant Ctags, which is an external program that scans source code for keywords such as function names, class names, and any other constructs that are significant in the given language. When <code class="cf">ctags</code> is run on a codebase, it generates an index of keywords, which are addressed and sorted alphabetically. By convention, the index is saved in a file called <code class="cf">tags</code>.
    </p>
<p id="N1BC50" class="calibre4">
      The main reason for indexing a codebase with <code class="cf">ctags</code> is to make it easier to navigate, but a <code class="cf">tags</code> file creates a useful by-product: a list of keywords that can be used for autocompletion. We can dial up this list using the <span class="calibre17">&lt;C-x&gt;&lt;C-]&gt;</span> command (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">compl-tag</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-tag">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>).
    </p>
<p id="N1BC60" class="calibre4">
      If the word you are trying to complete is a language object (such as a function name or class name), then tag autocompletion will give a good signal-to-noise ratio.
    </p>
<h3 class="calibre22">Put It All Together</h3>
<p id="N1BC67" class="calibre4">
      Generic keyword autocompletion generates suggestions by combining the word list generated from the buffer list, included files, and tag files into one. If you want to tweak this behavior, see <a xmlns:str="http://exslt.org/strings" href="#sidebar.complete">​<em class="calibre5">Customizing the Generic Autocompletion</em>​</a>. Remember, generic keyword autocompletion is triggered simply with the <span class="calibre17">&lt;C-n&gt;</span> chord, whereas the more focused variants are all invoked with <span class="calibre17">&lt;C-x&gt;</span> followed by another chord.
    </p>
<div class="sidebar" id="sidebar.complete">
<div class="sidebar-title">Customizing the Generic Autocompletion</div>
<div class="calibre1">
<p id="N1BC7F" class="calibre4">
      We can customize the list of places that are scanned by generic keyword completion using the <code class="cf1">‘complete’</code> option. This option holds a comma-separated list of one-letter flags, whose presence enables scanning of a particular place. The default setting is <code class="cf1">complete=.,w,b,u,t,i</code>. We could disable scanning of included files by running the following:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix4" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline4" valign="top">
<div class="calibre38">
​<code class="calibre39">​<strong class="prompt">:set complete-=i</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N1BC9F" class="calibre4">
      Or we could enable completion of words in the spelling dictionary by running this:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix4" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline4" valign="top">
<div class="calibre38">
​<code class="calibre39">​<strong class="prompt">:set complete+=k</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N1BCAF" class="calibre4">
      Look up <strong xmlns:str="http://exslt.org/strings" class="calibre10">'complete'</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/options.html#'complete'">
<img alt="info" src="images/information.png" class="calibre21"/>​</a> to find out what each of the flags does.
    </p>
</div>
</div>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

