---
layout: page
title: "Practical Vim (for Kathryn Amaral)"
prev: f_0088.html
next: f_0090.html
book_path: books/drew-neil-practical-vim-edit-text-at-the-speed-of-thought-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<table class="arr-recipe" id="sec.xp.ddp.yyp">
<tr class="calibre14">
<td class="arr-recipe-number">Tip 59</td>
<td class="arr-recipe-name">Delete, Yank, and Put with Vim’s Unnamed Register</td>
</tr>
</table>
<p id="N162D7" class="calibre4">
<span class="calibre5">
        Vim’s delete, yank, and put commands are designed to make common tasks easy by default. We’ll study a few problems that can easily be solved using Vim’s unnamed register, and then we’ll finish by looking at a task that requires a better understanding of how Vim’s registers work.
    </span>
</p>
<p id="N162E7" class="calibre4">
      Normally when we discuss cut, copy, and paste, we talk about putting text on a clipboard. In Vim’s terminology, we don’t deal with a clipboard but instead with <span class="calibre5">registers</span>. In <a xmlns:str="http://exslt.org/strings" href="f_0090.html#sec.special.registers">Tip 60</a>, we’ll see that Vim has multiple registers, and we can specify which ones we want to use. But let’s start off by looking at what can be done using the <span class="calibre5">unnamed register</span>.
    </p>
<h3 id="sec.transpose.chars" class="calibre22">Transposing Characters</h3>
<p id="N16301" class="calibre4">
        I consistently misspell some words. Over time, I may notice that I habitually mistype a certain word, and then I can train myself out of it. But some spelling mistakes are more haphazard. The most common typing error that I make is to get two characters in the wrong order. Vim makes it easy to fix such mistakes.
      </p>
<p id="N1630E" class="calibre4">
        Suppose that we’re typing out the title of this book when we make such a transposition error:
      </p>
<table class="simpletable">
<thead class="calibre23">
<tr class="calibre7">
<th class="hlines">Keystrokes</th>
<th class="hlines">Buffer Contents</th>
</tr>
</thead>
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre24">
<p class="last-para-in-cell">{start}</p>
</td>
<td class="calibre24">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​Practica lvi<span class="shade-fg-white">m</span>​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">F␣</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​Practica<span class="shade-fg-white"> </span>lvim​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">x</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​Practica<span class="shade-fg-white">l</span>vim​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">p</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​Practical<span class="shade-fg-white"> </span>vim​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<p id="N16374" class="calibre4">
        Here we’ve typed the space too soon, but it’s easily mended. The <span class="calibre17">F␣</span> command places our cursor on the first of the two characters that we want to swap (see <a xmlns:str="http://exslt.org/strings" href="f_0076.html#sec.fchar">Tip 49</a>). The <span class="calibre17">x</span> command cuts the character under the cursor, placing a copy of it in the unnamed register. Then the <span class="calibre17">p</span> command pastes the contents of the unnamed register after the cursor position.
      </p>
<p id="N1638E" class="calibre4">
        Taken together, the <span class="calibre17">xp</span> commands can be considered as “Transpose the next two characters.”
      </p>
<h3 class="calibre22">Transposing Lines</h3>
<p id="N16398" class="calibre4">
        We can just as easily transpose the order of two lines of text. Instead of using the <span class="calibre17">x</span> command to cut the current character, we can use the <span class="calibre17">dd</span> command, which cuts the current line, placing it into the unnamed register:
      </p>
<table class="simpletable">
<thead class="calibre23">
<tr class="calibre7">
<th class="hlines">Keystrokes</th>
<th class="hlines">Buffer Contents</th>
</tr>
</thead>
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre24">
<p class="last-para-in-cell">{start}</p>
</td>
<td class="calibre24">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">2</span>) line two​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​1) line one​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​3) line three​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">dd</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">1</span>) line one​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​3) line three​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">p</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​1) line one​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">2</span>) line two​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​3) line three​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<p id="N16409" class="calibre4">
        The <span class="calibre17">p</span> command knows that this time we’re dealing with a line-wise chunk of text, so it does the thing we would expect: it pastes the contents of the unnamed register after the current <span class="calibre5">line</span>. Remember, when we pressed <span class="calibre17">xp</span> in the previous example, the <span class="calibre17">p</span> command pasted after the current <span class="calibre5">character</span>.
      </p>
<p id="N1641B" class="calibre4">
        The <span class="calibre17">ddp</span> sequence could be considered to stand for “Transpose the order of this line and its successor.”
      </p>
<h3 id="sec.yyp" class="calibre22">Duplicating Lines</h3>
<p id="N16426" class="calibre4">
        If we want to create a new line of text that’s broadly similar to another line but with one or two small differences, we can give ourselves a head start by duplicating a line and using it as a template. In Vim, a line-wise yank followed by a put operation does the trick:
      </p>
<table class="simpletable">
<thead class="calibre23">
<tr class="calibre7">
<th class="hlines">Keystrokes</th>
<th class="hlines">Buffer Contents</th>
</tr>
</thead>
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre24">
<p class="last-para-in-cell">
<code class="cf">{start}</code>
</p>
</td>
<td class="calibre24">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​1) line one​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">2</span>) line two​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">yyp</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​1) line one​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​2) line two​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">2</span>) line two​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<p id="N1647B" class="calibre4">
      Note the similarities between these two sequences, <span class="calibre17">ddp</span> and <span class="calibre17">yyp</span>. The first does a line-wise cut and paste, which effectively transposes the order of two lines. The second sequence does a line-wise copy and paste, which effectively duplicates a line.
    </p>
<h3 id="sec.clobber" class="calibre22">Oops! I Clobbered My Yank</h3>
<p id="N16489" class="calibre4">
        So far, Vim’s delete, yank, and put operations are looking quite intuitive. They make common tasks trivially easy to perform. Now let’s look at a scenario where things don’t work out quite so smoothly. Start off with this sample:
      </p>
<table class="processedcode">
<tr class="calibre28">
<td colspan="2" class="calibre33">
<a href="http://media.pragprog.com/titles/dnvim/code/copy_and_paste/collection.js">copy_and_paste/collection.js</a>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​collection = getCollection();​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​process(somethingInTheWay, target);​</code>​</div>
</td>
</tr>
</table>
<p id="N1649C" class="calibre4">
        We’re going to copy <code class="cf">collection</code> into the unnamed register and then replace <code class="cf">somethingInTheWay</code> with the word that we’ve just copied. 
        <a xmlns:str="http://exslt.org/strings" href="#table.cut-and-paste-wrong">Table 15, ​<em class="calibre5">Copy and Paste—First Attempt</em>​</a> shows a first attempt.
      </p>
<hr class="calibre37"/>
<div class="figurecaption" id="table.cut-and-paste-wrong">Table 15. Copy and Paste—First Attempt</div>
<table class="simpletable">
<thead class="calibre23">
<tr class="calibre7">
<th class="hlines">Keystrokes</th>
<th class="hlines">Buffer Contents</th>
</tr>
</thead>
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre24">
<p class="last-para-in-cell">
<span class="calibre17">yiw</span>
</p>
</td>
<td class="calibre24">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​<span class="shade-fg-white">c</span>ollection = getCollection();​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​process(somethingInTheWay, target);​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">jww</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​collection = getCollection();​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​process(<span class="shade-fg-white">s</span>omethingInTheWay, target);​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">diw</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​collection = getCollection();​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​process(<span class="shade-fg-white">,</span> target);​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<p class="last-para-in-cell">
<span class="calibre17">P</span>
</p>
</td>
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​collection = getCollection();​</code>​</div>
</td>
</tr>
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​process(somethingInTheWa<span class="shade-fg-white">y</span>, target);​</code>​</div>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<hr class="calibre37"/>
<p id="N1651C" class="calibre4">
        To begin with, our cursor is already on the word we want to copy, so we can get it into the unnamed register by typing <span class="calibre17">yiw</span>. </p>
<p id="N16531" class="calibre4">Next we move our cursor to the place where we want to paste our <code class="cf">collection</code>, but before we can put it there we’ll have to clear a space for it. So we run <span class="calibre17">diw</span> to delete the word <code class="cf">somethingInTheWay</code>.
      </p>
<p id="N1653D" class="calibre4">
        Now we can hit the <span class="calibre17">P</span> key to paste the contents of our unnamed register in front of the cursor. But instead of pasting the word <code class="cf">collection</code>, which we yanked earlier, we get the word <code class="cf">somethingInTheWay</code>. What’s going on?
      </p>
<p id="N16549" class="calibre4">
        The <span class="calibre17">diw</span> command doesn’t just delete the word: it also copies it into the unnamed register. Or to rephrase that using more familiar terminology—<span class="calibre17">diw</span>
<span class="calibre5">cuts</span> the word. (See <a xmlns:str="http://exslt.org/strings" href="#sidebar.terminology">​<em class="calibre5">Vim’s Terminology Versus the World</em>​</a>, for a discussion).
      </p>
<p id="N1655F" class="calibre4">
        It’s obvious now what we did wrong. When we ran the <span class="calibre17">diw</span> command, it overwrote the contents of the unnamed register. That’s why when we pressed <span class="calibre17">P</span>, we got back the word we just deleted rather than the word we yanked earlier.
      </p>
<p id="N16568" class="calibre4">
        To solve this problem, we’ll have to get a deeper understanding of how Vim’s registers work.
      </p>
<div class="sidebar" id="sidebar.terminology">
<div class="sidebar-title">Vim's Terminology Versus the World</div>
<div class="calibre1">
<p id="N16579" class="calibre4">
    The cut, copy, and paste terminology is universally understood, and these operations are available across most desktop software programs and operating systems. Vim provides these features too, but it uses different terminology: delete, yank, and put.
    </p>
<p id="N16581" class="calibre4">
      Vim’s put command is effectively identical to the paste operation. Fortunately, both words begin with the letter <span class="calibre5">p</span>, so the mnemonic for the key command works whichever terminology we use.
    </p>
<p id="N1658D" class="calibre4">
      Vim’s yank command is equivalent to the copy operation. Historically, the <span class="calibre17">c</span> command was already assigned to the <span class="calibre5">change</span> operation, so vi’s authors were pushed to come up with an alternative name. The <span class="calibre17">y</span> key was available, so the copy operation became the yank command.
    </p>
<p id="N1659F" class="calibre4">
      Vim’s delete command is equivalent to the standard cut operation. That is, it copies the specified text into a register and then removes it from the document. Understanding this is key to avoiding the common pitfall outlined in <a xmlns:str="http://exslt.org/strings" href="#sec.clobber">​<em class="calibre5">Oops! I Clobbered My Yank</em>​</a>.
    </p>
<p id="N165AC" class="calibre4">
      You might be wondering what Vim’s equivalent is for really deleting text—that is, how can you remove text from the document and not copy it into any registers? Vim’s answer is a special register called the black hole, from which nothing returns. The black hole register is addressed by the <code class="cf1">_</code> symbol (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">quote_</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/change.html#quote_">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>), so <span class="calibre17">"_d{motion}</span> performs a true deletion.
    </p>
</div>
</div>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

