---
layout: page
title: "Practical Vim (for Kathryn Amaral)"
prev: f_0105.html
next: f_0107.html
book_path: books/drew-neil-practical-vim-edit-text-at-the-speed-of-thought-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<table class="arr-recipe" id="sec.pattern.search">
<tr class="calibre14">
<td class="arr-recipe-number">Tip 73</td>
<td class="arr-recipe-name">Use the <code class="cf2">\v</code> Pattern Switch for Regex Searches</td>
</tr>
</table>
<p id="N181E0" class="calibre4">
<span class="calibre5">
        Vim’s regular expression syntax is closer in style to POSIX than to Perl. For programmers who already know Perl’s regexes, this can be a source of frustration. Using the <code class="cf">very magic</code> pattern switch, we can make Vim adopt a more familiar syntax for regular expressions.
    </span>
</p>
<p id="N181FC" class="calibre4">
      Let’s say that we want to compose a regular expression that matches each of the color codes in this snippet of CSS:
    </p>
<table class="processedcode">
<tr class="calibre28">
<td colspan="2" class="calibre33">
<a href="http://media.pragprog.com/titles/dnvim/code/patterns/color.css">patterns/color.css</a>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">body</strong>   { color: #3c3c3c; }​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">a</strong>      { color: #0000EE; }​</code>​</div>
</td>
</tr>
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span> </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">strong</strong> { color: #000; }​</code>​</div>
</td>
</tr>
</table>
<p id="N18218" class="calibre4">
      We need to match a <code class="cf">#</code> character followed by either three or six hexadecimal characters. That includes all numeric digits, plus the letters <code class="cf">A</code> through <code class="cf">F</code> in upper- or lowercase.
    </p>
<h3 class="calibre22">Find Hex Colors with Magic Search</h3>
<p id="N18228" class="calibre4">
        The following regular expression meets these requirements:
      </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">/#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N18242" class="calibre4">
        Try it out if you like. It works ok, but look at all of those backslashes—five in total!
      </p>
<p id="N18245" class="calibre4">
        We’re using three types of brackets here. Square brackets have a special meaning by default, so we don’t need to escape them. Parentheses match the <code class="cf">(</code> and <code class="cf">)</code> characters literally, so we have to escape them to make them take on a special meaning. The same goes for curly braces, but get this: we have to escape only the opening member of the pair. We can leave the closing brace unescaped, and Vim will figure out our intentions. This is <span class="calibre5">not</span> the case for parentheses, where both the opening and closing member of the pair must be escaped.
		</p>
<p id="N1826A" class="calibre4">
        Each of the three bracket types is governed by a different set of rules. Read the previous paragraph again, and commit them to memory. I’ll wait. Tell you what: don’t bother!
      </p>
<h3 class="calibre22">Find Hex Colors with Very Magic Search</h3>
<p id="N18271" class="calibre4">
        We can normalize the rules for all special symbols with the <code class="cf">\v</code> pattern switch. This enables <code class="cf">very magic</code> search, where all characters assume a special meaning, with the exception of “<code class="cf">_</code>”, uppercase and lowercase letters, and the digits <code class="cf">0</code> through <code class="cf">9</code> (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">\v</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/pattern.html#\v">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>).
      </p>
<p id="N18295" class="calibre4">
	  The <code class="cf">\v</code> pattern switch makes Vim’s regular expression engine behave much more like that of Perl, Python, or Ruby. There are still differences, which we’ll draw attention to throughout this chapter, but they’re easier to remember than arbitrary rules about what must and must not be escaped.
      </p>
<p id="N1829B" class="calibre4">
        Let’s rewrite that regular expression for matching hex colors, this time using the <code class="cf">\v</code> pattern switch:
      </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})</strong>​</code>​</div>
</td>
</tr>
</table>
<p id="N182AE" class="calibre4">
        The <code class="cf">\v</code> switch at the start causes all subsequent characters to take on a special meaning. It looks much more readable without all of those backslash characters, don’t you think?
      </p>
<h3 class="calibre22">Use the Hex Character Class to Further Refine the Pattern</h3>
<p id="N182B8" class="calibre4">
        We can make one further refinement to this pattern: instead of spelling out the character collection <code class="cf">[0-9a-fA-F]</code> in full, we can replace it with the character class <code class="cf">\x</code> (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">/character-classes</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/pattern.html#/character-classes">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>). This pattern has exactly the same meaning as the previous one:
      </p>
<table class="processedcode">
<tr class="calibre28">
<td class="codeprefix" valign="top">
<span>=&gt; </span>
</td>
<td class="codeline" valign="top">
<div class="calibre29">
​<code class="calibre30">​<strong class="prompt">/\v#(\x{6}|\x{3})</strong>​</code>​</div>
</td>
</tr>
</table>
<h3 class="calibre22">Discussion</h3>
<p id="N182E0" class="calibre4">
        This table presents each of the regular expressions side by side for easy comparison:
      </p>
<table class="simpletable">
<thead class="calibre23">
<tr class="calibre7">
<th class="hlines">Pattern</th>
<th class="hlines">Remarks</th>
</tr>
</thead>
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre24">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix1" valign="top">
<span> </span>
</td>
<td class="codeline1" valign="top">
<div class="calibre32">
​<code class="calibre30">​#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)​</code>​</div>
</td>
</tr>
</table>
</td>
<td class="calibre24">
<p class="last-para-in-cell">
              Using magic search, we have to escape <code class="cf">(</code>, <code class="cf">)</code>, <code class="cf">|</code>, and <code class="cf">{</code> characters to confer special meaning upon them.
            </p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})​</code>​</div>
</td>
</tr>
</table>
</td>
<td class="calibre26">
<p class="last-para-in-cell">
              Using the <code class="cf">\v</code> pattern switch, the  <code class="cf">(</code>, <code class="cf">)</code>, <code class="cf">|</code>, and <code class="cf">{</code> characters assume special meaning.
            </p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre26">
<table class="processedcode1">
<tr class="calibre31">
<td class="codeprefix2" valign="top">
<span> </span>
</td>
<td class="codeline2" valign="top">
<div class="calibre32">
​<code class="calibre30">​\v#(\x{6}|\x{3})​</code>​</div>
</td>
</tr>
</table>
</td>
<td class="calibre26">
<p class="last-para-in-cell">
              We can compact the expression further by using the <code class="cf">\x</code> character class, which stands for <code class="cf">[0-9A-Fa-f]</code>.
            </p>
</td>
</tr>
</tbody>
</table>
<p id="N18347" class="calibre4">
        One final note: the <code class="cf">#</code> character has no special meaning, so it is matched literally. Remember how <code class="cf">very magic</code> search treats all characters as special, except for “<code class="cf">_</code>”, letters, and numbers? It looks like we’ve found an exception to this rule!
      </p>
<p id="N1835A" class="calibre4">
        Vim’s answer is that any characters that do not yet have a special meaning are “reserved for future expansions” (see <strong xmlns:str="http://exslt.org/strings" class="calibre10">/\\</strong>
<a xmlns:str="http://exslt.org/strings" href="http://vimdoc.sourceforge.net/htmldoc/pattern.html#/\\">
<img alt="info" src="images/information.png" class="calibre21"/>​</a>). In other words, just because <code class="cf">#</code> has no special meaning today does not mean that will be true for future versions. If <code class="cf">#</code> were to take on a special meaning, then we would have to escape it to match the “#” character literally. But don’t let that thought keep you awake at night.
      </p>
<div class="sidebar">
<div class="sidebar-title">History Lesson: On the Heritage of Vim's Pattern Syntax</div>
<div class="calibre1">
<p id="N18372" class="calibre4">
        Vim has two older syntaxes for patterns besides the ones enabled by <code class="cf1">\v</code> and <code class="cf1">\V</code> switches. Vim’s default is <span class="calibre5">magic</span> search, while <span class="calibre5">nomagic</span> search emulates the behavior of vi. They can be enabled with the <code class="cf1">\m</code> and <code class="cf1">\M</code> switches, respectively.
      </p>
<p id="N18397" class="calibre4">
        The <code class="cf1">\M</code> nomagic switch has a similar effect to the <code class="cf1">\V</code> literal switch, except that a couple of characters automatically take on a special meaning: namely, the <code class="cf1">^</code> and <code class="cf1">$</code> symbols.
      </p>
<p id="N183AB" class="calibre4">
        Magic search automatically assigns a special meaning to a handful of extra symbols, such as the <code class="cf1">.</code>, <code class="cf1">*</code>, and square brackets. Magic search was created to make it easier to build simple regexes, but it stopped short of adding special meaning to symbols such as <code class="cf1">+</code>, <code class="cf1">?</code>, parentheses, and braces, each of which must be escaped to assign them with their special meaning.
      </p>
<p id="N183BA" class="calibre4">
        Magic search goes halfway toward making regular expressions easier to compose. As a result, the rules over what to escape seem haphazard, making them difficult to memorize. The <code class="cf1">\v</code> pattern search switch fixes this by assigning a special meaning to every symbol except <code class="cf1">_</code>, numbers, and letters. That’s easily remembered and happens to be consistent with the rules for Perl’s regular expressions.
      </p>
</div>
</div>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

