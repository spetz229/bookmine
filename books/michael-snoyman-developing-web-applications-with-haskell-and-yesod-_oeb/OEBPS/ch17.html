---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch16s06.html
next: OEBPS/pt03.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre8"></div><div class="book" title="Chapter 17. Creating a Subsite"><div class="book"><div class="book"><div class="book"><div class="calibre8"></div><h1 class="title1"><a id="I_chapter6_d1e8129" class="calibre1"></a>Chapter 17. Creating a Subsite</h1></div></div></div><p class="calibre7">How many sites provide authentication systems? Or need to provide Create, Read, Update,
        Delete (CRUD) management of some objects? Or a blog? Or a wiki?</p><p class="calibre7">The theme here is that many websites include common components that can be reused throughout multiple sites. However, it is often quite difficult to get code to be modular enough to be truly plug-and-play: a component will require hooks into the routing system, usually for multiple routes, and will need some way of sharing styling information with the master site.</p><p class="calibre7">In Yesod, the solution is subsites. A subsite is a collection of routes and their handlers that can be easily inserted into a master site. By using type classes, it is easy to ensure that the master site provides certain capabilities, and to access the default site layout. And with type-safe URLs, it’s easy to link from the master site to subsites.</p><div class="book" title="Hello World"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect16_d1e8138" class="calibre1"></a>Hello World</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Writing subsites is a little bit tricky, involving a number of different types. Let’s
            start off with a simple Hello World subsite:</p><a id="I_programlisting6_d1e8144" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE QuasiQuotes, TypeFamilies, MultiParamTypeClasses #-}</code>
<code class="cm">{-# LANGUAGE TemplateHaskell, FlexibleInstances, OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Yesod</code>

<code class="cm">-- Subsites have foundations just like master sites.</code>
<code class="kr">data</code> <code class="kt">HelloSub</code> <code class="ow">=</code> <code class="kt">HelloSub</code>

<code class="cm">-- We have a familiar analogue from mkYesod, with just one extra parameter.</code>
<code class="cm">-- We'll discuss that later.</code>
<code class="nf">mkYesodSub</code> <code class="s">"HelloSub"</code> <code class="kt">[]</code> <code class="p">[</code><code class="n">parseRoutes</code><code class="o">|</code>
<code class="o">/</code> <code class="kt">SubRootR</code> <code class="kt">GET</code>
<code class="o">|</code><code class="p">]</code>

<code class="cm">-- And we'll spell out the handler type signature.</code>
<code class="nf">getSubRootR</code> <code class="ow">::</code> <code class="kt">Yesod</code> <code class="n">master</code> <code class="ow">=&gt;</code> <code class="kt">GHandler</code> <code class="kt">HelloSub</code> <code class="n">master</code> <code class="kt">RepHtml</code>
<code class="nf">getSubRootR</code> <code class="ow">=</code> <code class="n">defaultLayout</code> <code class="p">[</code><code class="n">whamlet</code><code class="o">|</code><code class="kt">Welcome</code> <code class="n">to</code> <code class="n">the</code> <code class="n">subsite</code><code class="o">!|</code><code class="p">]</code>

<code class="cm">-- And let's create a master site that calls it.</code>
<code class="kr">data</code> <code class="kt">Master</code> <code class="ow">=</code> <code class="kt">Master</code>
    <code class="p">{</code> <code class="n">getHelloSub</code> <code class="ow">::</code> <code class="kt">HelloSub</code>
    <code class="p">}</code>

<code class="nf">mkYesod</code> <code class="s">"Master"</code> <code class="p">[</code><code class="n">parseRoutes</code><code class="o">|</code>
<code class="o">/</code> <code class="kt">RootR</code> <code class="kt">GET</code>
<code class="o">/</code><code class="n">subsite</code> <code class="kt">SubsiteR</code> <code class="kt">HelloSub</code> <code class="n">getHelloSub</code>
<code class="o">|</code><code class="p">]</code>

<code class="kr">instance</code> <code class="kt">Yesod</code> <code class="kt">Master</code>

<code class="cm">-- Spelling out type signature again.</code>
<code class="nf">getRootR</code> <code class="ow">::</code> <code class="kt">GHandler</code> <code class="n">sub</code> <code class="kt">Master</code> <code class="kt">RepHtml</code> <code class="cm">-- could also replace sub with Master</code>
<code class="nf">getRootR</code> <code class="ow">=</code> <code class="n">defaultLayout</code> <code class="p">[</code><code class="n">whamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">h1</code><code class="o">&gt;</code><code class="kt">Welcome</code> <code class="n">to</code> <code class="n">the</code> <code class="n">homepage</code>
<code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code>
    <code class="kt">Feel</code> <code class="n">free</code> <code class="n">to</code> <code class="n">visit</code> <code class="n">the</code> <code class="o">#</code>
    <code class="o">&lt;</code><code class="n">a</code> <code class="n">href</code><code class="o">=@</code><code class="p">{</code><code class="kt">SubsiteR</code> <code class="kt">SubRootR</code><code class="p">}</code><code class="o">&gt;</code><code class="n">subsite</code>
    <code class="nf">\</code> <code class="n">as</code> <code class="n">well</code><code class="o">.</code>
<code class="o">|</code><code class="p">]</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="n">warpDebug</code> <code class="mi">3000</code> <code class="o">$</code> <code class="kt">Master</code> <code class="kt">HelloSub</code>
</pre><p class="calibre7">This very simple example actually shows most of the complications involved in creating a
            subsite. Like a normal Yesod application, everything in a subsite is centered around a
            foundation data type, <code class="literal">HelloSub</code> in our case. We then
            use <code class="literal">mkYesodSub</code>, in much the same way that we use
                <code class="literal">mkYesod</code>, to create the route data type and the
            dispatch/render functions. (We’ll come back to that extra parameter in a second.)</p><p class="calibre7">What’s interesting is the type signature of <code class="literal">getSubRootR</code>. Up until now, we have tried to ignore the <code class="literal">GHandler</code> data type, or <span class="firstname"><em class="calibre4">if</em></span> we need to
            acknowledge its existence, pretend the first two type arguments are always the same. Now
            we get to finally acknowledge the truth about this funny data type.</p><p class="calibre7">A handler function always has two foundation types associated with it: the subsite and the
            master site. When you write a normal application, <span class="bold"><strong class="bold">those two data
                types are the same</strong></span>. However, when you are working in a subsite, they will
            necessarily be different. So the type signature for <code class="literal">getSubRootR</code> uses <code class="literal">HelloSub</code> for the
            first argument and <code class="literal">master</code> for the second.</p><p class="calibre7">The <code class="literal">defaultLayout</code> function is part of the Yesod typeclass. Therefore, in order to call it, the <code class="literal">master</code> type argument must be an instance of <code class="literal">Yesod</code>. The advantage of this approach is that any modifications to the master site’s <code class="literal">defaultLayout</code> method will automatically be reflected in subsites.</p><p class="calibre7">When we embed a subsite in our master site route definition, we need to specify four
            pieces of information: the route to use as the base of the subsite (in this case,
                <code class="literal">/subsite</code>), the constructor for the subsite routes
                (<code class="literal">SubsiteR</code>), the subsite foundation data type
                (<code class="literal">HelloSub</code>), and a function that takes a master
            foundation value and returns a subsite foundation value (<code class="literal">getHelloSub</code>).</p><p class="calibre7">In the definition of getRootR, we can see how the route constructor gets used. In a sense, <code class="literal">SubsiteR</code> promotes any subsite route to a master site route, making it possible to safely link to it from any master site template.</p></div></div></div>

{% endraw %}

