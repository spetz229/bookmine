---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apas02.html
next: OEBPS/apas04.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Types"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e8828" class="calibre1"></a>Types</h1></div></div></div><p class="calibre7"></p><p class="calibre7">I purposely started with the ErrorT transformer, as it is one of the simplest for this
      inversion mechanism. Unfortunately, others are a bit more complicated. Take for instance,
      ReaderT. It is defined as <code class="literal">newtype ReaderT r m a = ReaderT {
        runReaderT :: r -&gt; m a }</code>. If we apply <code class="literal">runReaderT</code> to it, we get a function that returns a monadic value. So we’re going
      to need some extra machinery to deal with all that stuff. And this is when we leave Kansas
      behind.</p><p class="calibre7">There are a few approaches to solving these problems. In the past, I implemented a
      solution using type families in the <code class="function">neither</code> package.
      Anders Kaseorg implemented a much more straightforward solution in <code class="function">monad-peel</code>. And for efficiency, in <code class="function">monad-control</code>, Bas van Dijk uses CPS (continuation passing style) and
      existential types.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">The code taken from monad-control actually applies to version
        0.2.0.3
        changed things just a bit, by making the state explicit with an associated type, and
        generalizing <code class="literal">MonadControlIO</code> to <code class="literal">MonadBaseControl</code>, but the concepts are still the same.</p></div><p class="calibre7">The first type we’re going to look at
      is:<a id="I_programlisting_d1e8869" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">type</code> <code class="kt">Run</code> <code class="n">t</code> <code class="ow">=</code> <code class="n">forall</code> <code class="n">n</code> <code class="n">o</code> <code class="n">b</code><code class="o">.</code> <code class="p">(</code><code class="kt">Monad</code> <code class="n">n</code><code class="p">,</code> <code class="kt">Monad</code> <code class="n">o</code><code class="p">,</code> <code class="kt">Monad</code> <code class="p">(</code><code class="n">t</code> <code class="n">o</code><code class="p">))</code> <code class="ow">=&gt;</code> <code class="n">t</code> <code class="n">n</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="n">n</code> <code class="p">(</code><code class="n">t</code> <code class="n">o</code> <code class="n">b</code><code class="p">)</code>
</pre><p class="calibre7">That’s
      incredibly dense, so let’s talk it out. The only “input” data type to this thing is t, a monad
      transformer. A Run is a function that will then work with <span class="bold"><strong class="bold">any</strong></span>
      combination of types n, o, and b (that’s what the forall means). n and o are both monads,
      while b is a simple value contained by them.</p><p class="calibre7">The lefthand side of the Run function, <code class="literal">t n b</code>, is our
      monad transformer wrapped around the n monad and holding a b value. So for example, that could
      be a <code class="literal">MyTrans FirstMonad MyValue</code>. It then returns a value
      with the transformer “popped” inside, with a brand new monad at its core. In other words,
        <code class="literal">FirstMonad (MyTrans NewMonad MyValue)</code>.</p><p class="calibre7">That might sound pretty scary at first, but it actually isn’t as foreign as you’d think:
      this is essentially what we did with ErrorT. We started with ErrorT on the outside, wrapping
      around IO, and ended up with an IO by itself containing an Either. Well, guess what: another
      way to represent an Either is <code class="literal">ErrorT MyError Identity</code>. So
      essentially, we pulled the IO to the outside and plunked an Identity in its place. We’re doing
      the same thing in a Run: pulling the FirstMonad outside and replacing it with a NewMonad.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">Now might be a good time to get a beer.</p></div><p class="calibre7">Alright, now we’re getting somewhere. If we had access to one of those Run functions, we could
   use it to peel off the ErrorT on our sayHiError function and pass it to withMyFile. With the
   magic of undefined, we can play such a game:</p><a id="I_programlisting_d1e8896" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">errorRun</code> <code class="ow">::</code> <code class="kt">Run</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code><code class="p">)</code>
<code class="nf">errorRun</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">useMyFileError2</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">Identity</code> <code class="nb">()</code><code class="p">)</code>
<code class="nf">useMyFileError2</code> <code class="ow">=</code>
    <code class="kr">let</code> <code class="n">afterRun</code> <code class="ow">::</code> <code class="kt">Handle</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">Identity</code> <code class="nb">()</code><code class="p">)</code>
        <code class="n">afterRun</code> <code class="n">handle</code> <code class="ow">=</code> <code class="n">errorRun</code> <code class="o">$</code> <code class="n">sayHiError</code> <code class="n">handle</code>
        <code class="n">applied</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">Identity</code> <code class="nb">()</code><code class="p">)</code>
        <code class="n">applied</code> <code class="ow">=</code> <code class="n">withMyFile</code> <code class="n">afterRun</code>
     <code class="kr">in</code> <code class="n">applied</code>
</pre><p class="calibre7">This looks eerily similar to our previous example. In fact, errorRun is acting almost
   identically to runErrorT. However, we’re still left with two problems: we don’t know where to get
   that errorRun value from, and we still need to restructure the original ErrorT after we’re
   done.</p><div class="book" title="MonadTransControl"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3097281" class="calibre1"></a>MonadTransControl</h2></div></div></div><p class="calibre7"></p><p class="calibre7">Obviously, in the specific case we have before us, we could use our knowledge of the
        ErrorT transformer to beat the types into submission and create our Run function manually.
        But what we <span class="firstname"><em class="calibre4">really</em></span> want is a general solution for many transformers. At
        this point, you know we need a typeclass.</p><p class="calibre7">So let’s review what we need: access to a Run function, and some way to restructure our
   original transformer after the fact. And thus was born MonadTransControl, with its single method
   liftControl:</p><a id="I_programlisting_d1e8912" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">class</code> <code class="kt">MonadTrans</code> <code class="n">t</code> <code class="ow">=&gt;</code> <code class="kt">MonadTransControl</code> <code class="n">t</code> <code class="kr">where</code>
    <code class="n">liftControl</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">Run</code> <code class="n">t</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">t</code> <code class="n">m</code> <code class="n">a</code>
</pre><p class="calibre7">Let’s look at this closely. liftControl takes a function (the one we’ll be writing). That
   function is provided with a Run function, and must return a value in some monad (m). liftControl
   will then take the result of that function and reinstate the original transformer on top of
   everything.</p><a id="I_programlisting_d1e8916" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">useMyFileError3</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="n">m</code> <code class="nb">()</code><code class="p">)</code>
<code class="nf">useMyFileError3</code> <code class="ow">=</code>
    <code class="n">liftControl</code> <code class="n">inside</code>
  <code class="kr">where</code>
    <code class="n">inside</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Run</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="n">m</code> <code class="nb">()</code><code class="p">)</code>
    <code class="n">inside</code> <code class="n">run</code> <code class="ow">=</code> <code class="n">withMyFile</code> <code class="o">$</code> <code class="n">helper</code> <code class="n">run</code>
    <code class="n">helper</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code>
           <code class="ow">=&gt;</code> <code class="kt">Run</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Handle</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="n">m</code> <code class="nb">()</code><code class="p">)</code>
    <code class="n">helper</code> <code class="n">run</code> <code class="n">handle</code> <code class="ow">=</code> <code class="n">run</code> <code class="p">(</code><code class="n">sayHiError</code> <code class="n">handle</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code><code class="p">)</code>
</pre><p class="calibre7">Close, but not exactly what I had in mind. What’s up with the double monads? Well, let’s start
   at the end: sayHiError handle returns a value of type <code class="literal">ErrorT MyError IO ()</code>. This
   we knew already, no surprises. What might be a little surprising (it got me, at least) is the
   next two steps.</p><p class="calibre7">First we apply
        run
        to that value. Like we’d discussed before, the result is that the IO inner monad is popped
        to the outside, to be replaced by some arbitrary monad (represented by m here). So we end up
        with an IO (ErrorT MyError m ()). OK…We then get the same result after applying withMyFile.
        Not surprising.</p><p class="calibre7">The last step took me a long time to understand correctly. Remember how we said that we
        reconstruct the original transformer? Well, so we do: by plopping it right on top of
        everything else we have. So our end result is the previous type
        <code class="literal">IO (ErrorT MyError m ())</code>- with a <code class="literal">ErrorT MyError</code> stuck on the front.</p><p class="calibre7">That seems just about utterly worthless, right? Well, almost. But don’t forget, that “m”
        can be any monad, including IO. If we treat it that way, we get <code class="literal">ErrorT MyError IO (ErrorT MyError IO ())</code>. That looks a lot like <code class="literal">m (m a)</code>, and we want just plain old <code class="literal">m
          a</code>. Fortunately, now we’re in
        luck:<a id="I_programlisting_d1e8955" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">useMyFileError4</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">useMyFileError4</code> <code class="ow">=</code> <code class="n">join</code> <code class="n">useMyFileError3</code>
</pre><p class="calibre7">And
        it turns out that this usage is so common, that Bas had mercy on us and defined a helper
        function:<a id="I_programlisting_d1e8958" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">control</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Monad</code> <code class="n">m</code><code class="p">,</code> <code class="kt">Monad</code> <code class="p">(</code><code class="n">t</code> <code class="n">m</code><code class="p">),</code> <code class="kt">MonadTransControl</code> <code class="n">t</code><code class="p">)</code>
        <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">Run</code> <code class="n">t</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="p">(</code><code class="n">t</code> <code class="n">m</code> <code class="n">a</code><code class="p">))</code> <code class="ow">-&gt;</code> <code class="n">t</code> <code class="n">m</code> <code class="n">a</code>
<code class="nf">control</code> <code class="ow">=</code> <code class="n">join</code> <code class="o">.</code> <code class="n">liftControl</code>
</pre><p class="calibre7">So
        all we need to write
        is:<a id="I_programlisting_d1e8962" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">useMyFileError5</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">useMyFileError5</code> <code class="ow">=</code>
    <code class="n">control</code> <code class="n">inside</code>
  <code class="kr">where</code>
    <code class="n">inside</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Run</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="n">m</code> <code class="nb">()</code><code class="p">)</code>
    <code class="n">inside</code> <code class="n">run</code> <code class="ow">=</code> <code class="n">withMyFile</code> <code class="o">$</code> <code class="n">helper</code> <code class="n">run</code>
    <code class="n">helper</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code>
           <code class="ow">=&gt;</code> <code class="kt">Run</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Handle</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="n">m</code> <code class="nb">()</code><code class="p">)</code>
    <code class="n">helper</code> <code class="n">run</code> <code class="n">handle</code> <code class="ow">=</code> <code class="n">run</code> <code class="p">(</code><code class="n">sayHiError</code> <code class="n">handle</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code><code class="p">)</code>
</pre><p class="calibre7">And just to make it a little
   shorter:<a id="I_programlisting_d1e8967" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">useMyFileError6</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">useMyFileError6</code> <code class="ow">=</code> <code class="n">control</code> <code class="o">$</code> <code class="nf">\</code><code class="n">run</code> <code class="ow">-&gt;</code> <code class="n">withMyFile</code> <code class="o">$</code> <code class="n">run</code> <code class="o">.</code> <code class="n">sayHiError</code>
</pre></div><div class="book" title="MonadControlIO"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3097517" class="calibre1"></a>MonadControlIO</h2></div></div></div><p class="calibre7"></p><p class="calibre7">The MonadTrans class provides the lift method, which allows you to lift an action one
        level in the stack. There is also the MonadIO class that provides liftIO, which lifts an IO
        action as far in the stack as desired. We have the same breakdown in monad-control. But
        first, we need a corollary to
        Run:<a id="I_programlisting_d1e8976" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">type</code> <code class="kt">RunInBase</code> <code class="n">m</code> <code class="n">base</code> <code class="ow">=</code> <code class="n">forall</code> <code class="n">b</code><code class="o">.</code> <code class="n">m</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="n">base</code> <code class="p">(</code><code class="n">m</code> <code class="n">b</code><code class="p">)</code>
</pre><p class="calibre7">Instead
        of dealing with a transformer, we’re dealing with two monads. base is the underlying monad,
        and m is a stack built on top of it. RunInBase is a function that takes a value of the
        entire stack, pops out that base, and puts in on the outside. Unlike in the Run type, we
        don’t replace it with an arbitrary monad, but with the original one. To use some more
        concrete types:</p><a id="I_programlisting_d1e8982" class="firstname"></a><pre class="programlistinghaskell"><code class="kt">RunInBase</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code><code class="p">)</code> <code class="kt">IO</code> <code class="ow">=</code> <code class="n">forall</code> <code class="n">b</code><code class="o">.</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">b</code><code class="p">)</code>
</pre><p class="calibre7">This should look fairly similar to what we’ve been looking at so far, the only difference is
   that we want to deal with a specific inner monad. Our MonadControlIO class is really just an
   extension of MonadControlTrans using this RunInBase.</p><a id="I_programlisting_d1e8986" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">class</code> <code class="kt">MonadIO</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">MonadControlIO</code> <code class="n">m</code> <code class="kr">where</code>
    <code class="n">liftControlIO</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">RunInBase</code> <code class="n">m</code> <code class="kt">IO</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code>
</pre><p class="calibre7">Simply put, liftControlIO takes a function, which receives a RunInBase. That RunInBase
        can be used to strip down our monad to just an IO, and then liftControlIO builds everything
        back up again. And like MonadControlTrans, it comes with a helper function:</p><a id="I_programlisting_d1e8990" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">controlIO</code> <code class="ow">::</code> <code class="kt">MonadControlIO</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">RunInBase</code> <code class="n">m</code> <code class="kt">IO</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="n">m</code> <code class="n">a</code><code class="p">))</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code>
<code class="nf">controlIO</code> <code class="ow">=</code> <code class="n">join</code> <code class="o">.</code> <code class="n">liftControlIO</code>
</pre><p class="calibre7">We can easily rewrite our previous example with
   it:<a id="I_programlisting_d1e8994" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">useMyFileError7</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">useMyFileError7</code> <code class="ow">=</code> <code class="n">controlIO</code> <code class="o">$</code> <code class="nf">\</code><code class="n">run</code> <code class="ow">-&gt;</code> <code class="n">withMyFile</code> <code class="o">$</code> <code class="n">run</code> <code class="o">.</code> <code class="n">sayHiError</code>
</pre><p class="calibre7">And
   as an advantage, it easily scales to multiple
   transformers:<a id="I_programlisting_d1e8997" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">sayHiCrazy</code> <code class="ow">::</code> <code class="kt">Handle</code> <code class="ow">-&gt;</code> <code class="kt">ReaderT</code> <code class="kt">Int</code> <code class="p">(</code><code class="kt">StateT</code> <code class="kt">Double</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code><code class="p">))</code> <code class="nb">()</code>
<code class="nf">sayHiCrazy</code> <code class="n">handle</code> <code class="ow">=</code> <code class="n">liftIO</code> <code class="o">$</code> <code class="n">hPutStrLn</code> <code class="n">handle</code> <code class="s">"Madness!"</code>

<code class="nf">useMyFileCrazy</code> <code class="ow">::</code> <code class="kt">ReaderT</code> <code class="kt">Int</code> <code class="p">(</code><code class="kt">StateT</code> <code class="kt">Double</code> <code class="p">(</code><code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code><code class="p">))</code> <code class="nb">()</code>
<code class="nf">useMyFileCrazy</code> <code class="ow">=</code> <code class="n">controlIO</code> <code class="o">$</code> <code class="nf">\</code><code class="n">run</code> <code class="ow">-&gt;</code> <code class="n">withMyFile</code> <code class="o">$</code> <code class="n">run</code> <code class="o">.</code> <code class="n">sayHiCrazy</code>
</pre></div></div></div>

{% endraw %}

