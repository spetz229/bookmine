---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apas06.html
next: OEBPS/apbs02.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Appendix B. Conduit"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_appendix_d1e9048" class="calibre1"></a>Appendix B. Conduit</h1></div></div></div><p class="calibre7">Conduits are a solution to the streaming data problem. Oftentimes, laziness allows us to
    process large amounts of data without pulling all values into memory. However, doing so in the
    presence of I/O requires us to use <em class="calibre4">lazy I/O</em>. The main downside to lazy
    I/O is non-determinism: we have no guarantees of when our resource finalizers will be run. For
    small application, this may be acceptable, but for a high-load server, we could quickly run out
    of scarce resources, such as file handles.</p><p class="calibre7">Conduits allow us to process large streams of data while still retaining deterministic
    resource handling. They provide a unified interface for data streams, whether they come from
    files, sockets, or memory. And when combined with <code class="literal">ResourceT</code>,
    we can safely allocate resources, knowing that they will always be reclaimed—even in the
    presence of exceptions.</p><p class="calibre7">This appendix covers version 0.2 of the <code class="function">conduit</code> package.</p><div class="book" title="Conduits in Five Minutes"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e9066" class="calibre1"></a>Conduits in Five Minutes</h1></div></div></div><p class="calibre7"></p><p class="calibre7">While a good understanding of the lower-level mechanics of conduits is advisable, you can get
   very far without it. Let’s start off with some high-level examples. Don’t worry if some of the
   details seem a bit magical right now. We’ll cover everything in the course of this appendix.
   Let’s start with the terminology, and then some sample code.</p><div class="book"><dl class="book"><dt class="calibre9"><span class="firstname">Source</span></dt><dd class="calibre10"><p class="calibre7">A producer of data. The data could be in a file, coming from a socket, or in memory as a
     list. To access this data, we <em class="calibre4">pull</em> from the source.</p></dd><dt class="calibre9"><span class="firstname">Sink</span></dt><dd class="calibre10"><p class="calibre7">A consumer of data. Basic examples would be a sum function (adding up a stream of numbers
     fed in), a file sink (which writes all incoming bytes to a file), or a socket. We
      <em class="calibre4">push</em> data into a sink. When the sink finishes processing (we’ll explain that
     later), it returns some value.</p></dd><dt class="calibre9"><span class="firstname">Conduit</span></dt><dd class="calibre10"><p class="calibre7">A transformer of data. The simplest example is a map function, though there are many others.
     Like a sink, we <em class="calibre4">push</em> data into a conduit. But instead of returning a single value
     at the end, a conduit can return multiple outputs every time it is pushed to.</p></dd><dt class="calibre9"><span class="firstname">Fuse</span></dt><dd class="calibre10"><p class="calibre7">(Thanks to David Mazieres for the term.) A conduit can be <em class="calibre4">fused</em> with a source
     to produce a new, modified source (the <code class="literal">$=</code> operator). For example, you could
     have a source that reads bytes from a file, and a conduit that decodes bytes into text. If you
     fuse them together, you would now have a source that reads text from a file. Likewise, a
     conduit and a sink can fuse into a new sink (<code class="literal">=$</code>), and two conduits can fuse
     into a new conduit (<code class="literal">=$=</code>).</p></dd><dt class="calibre9"><span class="firstname">Connect</span></dt><dd class="calibre10"><p class="calibre7">You can connect a source to a sink using the <code class="literal">$$</code> operator. Doing so will
     pull data from the source and push it to the sink, until either the source or sink signals that
     they are “done.”</p></dd></dl></div><p class="calibre7">Let’s see some examples of conduit code.</p><a id="I_programlisting_d1e9129" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code> <code class="cm">-- the core library</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Conduit.List</code> <code class="kr">as</code> <code class="n">CL</code> <code class="cm">-- some list-like functions</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Conduit.Binary</code> <code class="kr">as</code> <code class="n">CB</code> <code class="cm">-- bytes</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Conduit.Text</code> <code class="kr">as</code> <code class="n">CT</code>

<code class="kr">import</code> <code class="nn">Data.ByteString</code> <code class="p">(</code><code class="kt">ByteString</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Data.Text</code> <code class="p">(</code><code class="kt">Text</code><code class="p">)</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Text</code> <code class="kr">as</code> <code class="n">T</code>
<code class="kr">import</code> <code class="nn">Control.Monad.ST</code> <code class="p">(</code><code class="nf">runST</code><code class="p">)</code>

<code class="cm">-- Let's start with the basics: connecting a source to a sink. We'll use the</code>
<code class="cm">-- built-in file functions to implementing efficient, constant-memory,</code>
<code class="cm">-- resource-friendly file copying.</code>
<code class="cm">--</code>
<code class="cm">-- Two things to note: we use $$ to connect our source to our sink, and then</code>
<code class="cm">-- use runResourceT.</code>
<code class="nf">copyFile</code> <code class="ow">::</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">copyFile</code> <code class="n">src</code> <code class="n">dest</code> <code class="ow">=</code> <code class="n">runResourceT</code> <code class="o">$</code> <code class="kt">CB</code><code class="o">.</code><code class="n">sourceFile</code> <code class="n">src</code> <code class="o">$$</code> <code class="kt">CB</code><code class="o">.</code><code class="n">sinkFile</code> <code class="n">dest</code>


<code class="cm">-- The Data.Conduit.List module provides a number of helper functions for</code>
<code class="cm">-- creating sources, sinks, and conduits. Let's look at a typical fold: summing</code>
<code class="cm">-- numbers.</code>
<code class="nf">sumSink</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Sink</code> <code class="kt">Int</code> <code class="n">m</code> <code class="kt">Int</code>
<code class="nf">sumSink</code> <code class="ow">=</code> <code class="kt">CL</code><code class="o">.</code><code class="n">fold</code> <code class="p">(</code><code class="o">+</code><code class="p">)</code> <code class="mi">0</code>

<code class="cm">-- If we want to go a little more low-level, we can code our sink with the</code>
<code class="cm">-- sinkState function. This function takes three parameters: an initial state,</code>
<code class="cm">-- a push function (receive some more data), and a close function.</code>
<code class="nf">sumSink2</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Sink</code> <code class="kt">Int</code> <code class="n">m</code> <code class="kt">Int</code>
<code class="nf">sumSink2</code> <code class="ow">=</code> <code class="n">sinkState</code>
    <code class="mi">0</code> <code class="cm">-- initial value</code>

    <code class="cm">-- update the state with the new input and</code>
    <code class="cm">-- indicate that we want more input</code>
    <code class="p">(</code><code class="nf">\</code><code class="n">accum</code> <code class="n">i</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="o">$</code> <code class="kt">StateProcessing</code> <code class="p">(</code><code class="n">accum</code> <code class="o">+</code> <code class="n">i</code><code class="p">))</code>
    <code class="p">(</code><code class="nf">\</code><code class="n">accum</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="n">accum</code><code class="p">)</code> <code class="cm">-- return the current accum value on close</code>

<code class="cm">-- Another common helper function is sourceList. Let's see how we can combine</code>
<code class="cm">-- that function with our sumSink to reimplement the built-in sum function.</code>
<code class="nf">sum'</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Int</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Int</code>
<code class="nf">sum'</code> <code class="n">input</code> <code class="ow">=</code> <code class="n">runST</code> <code class="o">$</code> <code class="n">runResourceT</code> <code class="o">$</code> <code class="kt">CL</code><code class="o">.</code><code class="n">sourceList</code> <code class="n">input</code> <code class="o">$$</code> <code class="n">sumSink</code>

<code class="cm">-- Since this is Haskell, let's write a source to generate all of the</code>
<code class="cm">-- Fibonacci numbers. We'll use sourceState. The state will contain the next</code>
<code class="cm">-- two numbers in the sequence. We also need to provide a pull function, which</code>
<code class="cm">-- will return the next number and update the state.</code>
<code class="nf">fibs</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Source</code> <code class="n">m</code> <code class="kt">Int</code>
<code class="nf">fibs</code> <code class="ow">=</code> <code class="n">sourceState</code>
    <code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code> <code class="cm">-- initial state</code>
    <code class="p">(</code><code class="nf">\</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="o">$</code> <code class="kt">StateOpen</code> <code class="p">(</code><code class="n">y</code><code class="p">,</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code><code class="p">)</code> <code class="n">x</code><code class="p">)</code>

<code class="cm">-- Suppose we want to get the sum of the first 10 Fibonacci numbers. We can use</code>
<code class="cm">-- the isolate conduit to make sure the sum sink only consumes 10 values.</code>
<code class="nf">sumTenFibs</code> <code class="ow">::</code> <code class="kt">Int</code>
<code class="nf">sumTenFibs</code> <code class="ow">=</code>
       <code class="n">runST</code> <code class="cm">-- runs fine in pure code</code>
     <code class="o">$</code> <code class="n">runResourceT</code>
     <code class="o">$</code> <code class="n">fibs</code>
    <code class="o">$=</code> <code class="kt">CL</code><code class="o">.</code><code class="n">isolate</code> <code class="mi">10</code> <code class="cm">-- fuse the source and conduit into a source</code>
    <code class="o">$$</code> <code class="n">sumSink</code>

<code class="cm">-- We can also fuse the conduit into the sink instead, we just swap a few</code>
<code class="cm">-- operators.</code>
<code class="nf">sumTenFibs2</code> <code class="ow">::</code> <code class="kt">Int</code>
<code class="nf">sumTenFibs2</code> <code class="ow">=</code>
       <code class="n">runST</code>
     <code class="o">$</code> <code class="n">runResourceT</code>
     <code class="o">$</code> <code class="n">fibs</code>
    <code class="o">$$</code> <code class="kt">CL</code><code class="o">.</code><code class="n">isolate</code> <code class="mi">10</code>
    <code class="o">=$</code> <code class="n">sumSink</code>

<code class="cm">-- Alright, let's make some conduits. Let's turn our numbers into text. Sounds</code>
<code class="cm">-- like a job for a map...</code>

<code class="nf">intToText</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Text</code> <code class="cm">-- just a helper function</code>
<code class="nf">intToText</code> <code class="ow">=</code> <code class="kt">T</code><code class="o">.</code><code class="n">pack</code> <code class="o">.</code> <code class="n">show</code>

<code class="nf">textify</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Conduit</code> <code class="kt">Int</code> <code class="n">m</code> <code class="kt">Text</code>
<code class="nf">textify</code> <code class="ow">=</code> <code class="kt">CL</code><code class="o">.</code><code class="n">map</code> <code class="n">intToText</code>

<code class="cm">-- Like previously, we can use a conduitState helper function. But here, we</code>
<code class="cm">-- don't even need state, so we provide a dummy state value.</code>
<code class="nf">textify2</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Conduit</code> <code class="kt">Int</code> <code class="n">m</code> <code class="kt">Text</code>
<code class="nf">textify2</code> <code class="ow">=</code> <code class="n">conduitState</code>
    <code class="nb">()</code>
    <code class="p">(</code><code class="nf">\</code><code class="nb">()</code> <code class="n">input</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="o">$</code> <code class="kt">StateProducing</code> <code class="nb">()</code> <code class="p">[</code><code class="n">intToText</code> <code class="n">input</code><code class="p">])</code>
    <code class="p">(</code><code class="nf">\</code><code class="nb">()</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="kt">[]</code><code class="p">)</code>

<code class="cm">-- Let's make the unlines conduit, that puts a newline on the end of each piece</code>
<code class="cm">-- of input. We'll just use CL.map; feel free to write it with conduitState as</code>
<code class="cm">-- well for practice.</code>
<code class="nf">unlines'</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Conduit</code> <code class="kt">Text</code> <code class="n">m</code> <code class="kt">Text</code>
<code class="nf">unlines'</code> <code class="ow">=</code> <code class="kt">CL</code><code class="o">.</code><code class="n">map</code> <code class="o">$</code> <code class="nf">\</code><code class="n">t</code> <code class="ow">-&gt;</code> <code class="n">t</code> <code class="p">`</code><code class="kt">T</code><code class="o">.</code><code class="n">append</code><code class="p">`</code> <code class="s">"</code><code class="se">\n</code><code class="s">"</code>

<code class="cm">-- And let's write a function that prints the first N fibs to a file. We'll</code>
<code class="cm">-- use UTF-8 encoding.</code>
<code class="nf">writeFibs</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">writeFibs</code> <code class="n">count</code> <code class="n">dest</code> <code class="ow">=</code>
      <code class="n">runResourceT</code>
    <code class="o">$</code> <code class="n">fibs</code>
   <code class="o">$=</code> <code class="kt">CL</code><code class="o">.</code><code class="n">isolate</code> <code class="n">count</code>
   <code class="o">$=</code> <code class="n">textify</code>
   <code class="o">$=</code> <code class="n">unlines'</code>
   <code class="o">$=</code> <code class="kt">CT</code><code class="o">.</code><code class="n">encode</code> <code class="kt">CT</code><code class="o">.</code><code class="n">utf8</code>
   <code class="o">$$</code> <code class="kt">CB</code><code class="o">.</code><code class="n">sinkFile</code> <code class="n">dest</code>

<code class="cm">-- We used the $= operator to fuse the conduits into the sources, producing a</code>
<code class="cm">-- single source. We can also do the opposite: fuse the conduits into the sink. We can even combine the two.</code>
<code class="nf">writeFibs2</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">writeFibs2</code> <code class="n">count</code> <code class="n">dest</code> <code class="ow">=</code>
      <code class="n">runResourceT</code>
    <code class="o">$</code> <code class="n">fibs</code>
   <code class="o">$=</code> <code class="kt">CL</code><code class="o">.</code><code class="n">isolate</code> <code class="n">count</code>
   <code class="o">$=</code> <code class="n">textify</code>
   <code class="o">$$</code> <code class="n">unlines'</code>
   <code class="o">=$</code> <code class="kt">CT</code><code class="o">.</code><code class="n">encode</code> <code class="kt">CT</code><code class="o">.</code><code class="n">utf8</code>
   <code class="o">=$</code> <code class="kt">CB</code><code class="o">.</code><code class="n">sinkFile</code> <code class="n">dest</code>

<code class="cm">-- Or we could fuse all those inner conduits into a single conduit...</code>
<code class="nf">someIntLines</code> <code class="ow">::</code> <code class="kt">ResourceThrow</code> <code class="n">m</code> <code class="cm">-- encoding can throw an exception</code>
             <code class="ow">=&gt;</code> <code class="kt">Int</code>
             <code class="ow">-&gt;</code> <code class="kt">Conduit</code> <code class="kt">Int</code> <code class="n">m</code> <code class="kt">ByteString</code>
<code class="nf">someIntLines</code> <code class="n">count</code> <code class="ow">=</code>
      <code class="kt">CL</code><code class="o">.</code><code class="n">isolate</code> <code class="n">count</code>
  <code class="o">=$=</code> <code class="n">textify</code>
  <code class="o">=$=</code> <code class="n">unlines'</code>
  <code class="o">=$=</code> <code class="kt">CT</code><code class="o">.</code><code class="n">encode</code> <code class="kt">CT</code><code class="o">.</code><code class="n">utf8</code>

<code class="cm">-- and then use that conduit</code>
<code class="nf">writeFibs3</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">writeFibs3</code> <code class="n">count</code> <code class="n">dest</code> <code class="ow">=</code>
      <code class="n">runResourceT</code>
    <code class="o">$</code> <code class="n">fibs</code>
   <code class="o">$=</code> <code class="n">someIntLines</code> <code class="n">count</code>
   <code class="o">$$</code> <code class="kt">CB</code><code class="o">.</code><code class="n">sinkFile</code> <code class="n">dest</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">putStrLn</code> <code class="o">$</code> <code class="s">"First ten fibs: "</code> <code class="o">++</code> <code class="n">show</code> <code class="n">sumTenFibs</code>
    <code class="n">writeFibs</code> <code class="mi">20</code> <code class="s">"fibs.txt"</code>
    <code class="n">copyFile</code> <code class="s">"fibs.txt"</code> <code class="s">"fibs2.txt"</code>
</pre></div></div></div>

{% endraw %}

