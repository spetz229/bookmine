---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apd.html
next: OEBPS/apes02.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Appendix E. http-conduit"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_appendix_d1e11007" class="calibre1"></a>Appendix E. http-conduit</h1></div></div></div><p class="calibre7">Most of Yesod is about serving content over HTTP. But that’s only half the story: someone
    has to receive it. And even when you’re writing a web app, sometimes that someone will be you.
    If you want to consume content from other services or interact with RESTful APIs, you’ll need to
    write client code. And the recommended approach for that is <code class="function">http-conduit</code>.</p><p class="calibre7">This chapter is not directly connected to Yesod, and will be generally useful for anyone
   wanting to make HTTP requests.</p><div class="book" title="Synopsis"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e11017" class="calibre1"></a>Synopsis</h1></div></div></div><p class="calibre7"></p><a id="I_programlisting_d1e11021" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Network.HTTP.Conduit</code> <code class="cm">-- the main module</code>

<code class="cm">-- The streaming interface uses conduits</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Data.Conduit.Binary</code> <code class="p">(</code><code class="nf">sinkFile</code><code class="p">)</code>

<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.ByteString.Lazy</code> <code class="kr">as</code> <code class="n">L</code>
<code class="kr">import</code> <code class="nn">Control.Monad.IO.Class</code> <code class="p">(</code><code class="nf">liftIO</code><code class="p">)</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="cm">-- Simplest query: just download the information from the given URL as a</code>
    <code class="cm">-- lazy ByteString.</code>
    <code class="n">simpleHttp</code> <code class="s">"http://www.example.com/foo.txt"</code> <code class="o">&gt;&gt;=</code> <code class="kt">L</code><code class="o">.</code><code class="n">writeFile</code> <code class="s">"foo.txt"</code>

    <code class="cm">-- Use the streaming interface instead. We need to run all of this inside a</code>
    <code class="cm">-- ResourceT, to ensure that all our connections get properly cleaned up in</code>
    <code class="cm">-- the case of an exception.</code>
    <code class="n">runResourceT</code> <code class="o">$</code> <code class="kr">do</code>
        <code class="cm">-- We need a Manager, which keeps track of open connections. simpleHttp</code>
        <code class="cm">-- creates a new manager on each run (i.e., it never reuses</code>
        <code class="cm">-- connections).</code>
        <code class="n">manager</code> <code class="ow">&lt;-</code> <code class="n">liftIO</code> <code class="o">$</code> <code class="n">newManager</code> <code class="n">def</code>

        <code class="cm">-- A more efficient version of the simpleHttp query above. First we</code>
        <code class="cm">-- parse the URL to a request.</code>
        <code class="n">req</code> <code class="ow">&lt;-</code> <code class="n">liftIO</code> <code class="o">$</code> <code class="n">parseUrl</code> <code class="s">"http://www.example.com/foo.txt"</code>

        <code class="cm">-- Now get the response</code>
        <code class="n">res</code> <code class="ow">&lt;-</code> <code class="n">http</code> <code class="n">req</code> <code class="n">manager</code>

        <code class="cm">-- And finally stream the value to a file</code>
        <code class="n">responseBody</code> <code class="n">res</code> <code class="o">$$</code> <code class="n">sinkFile</code> <code class="s">"foo.txt"</code>

        <code class="cm">-- Make it a POST request, don't follow redirects, and accept any</code>
        <code class="cm">-- status code.</code>
        <code class="kr">let</code> <code class="n">req2</code> <code class="ow">=</code> <code class="n">req</code>
                <code class="p">{</code> <code class="n">method</code> <code class="ow">=</code> <code class="s">"POST"</code>
                <code class="p">,</code> <code class="n">redirectCount</code> <code class="ow">=</code> <code class="mi">0</code>
                <code class="p">,</code> <code class="n">checkStatus</code> <code class="ow">=</code> <code class="nf">\</code><code class="kr">_</code> <code class="kr">_</code> <code class="ow">-&gt;</code> <code class="kt">Nothing</code>
                <code class="p">}</code>
        <code class="n">res2</code> <code class="ow">&lt;-</code> <code class="n">http</code> <code class="n">req2</code> <code class="n">manager</code>
        <code class="n">responseBody</code> <code class="n">res2</code> <code class="o">$$</code> <code class="n">sinkFile</code> <code class="s">"post-foo.txt"</code>
</pre></div></div></div>

{% endraw %}

