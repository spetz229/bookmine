---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apfs02.html
next: OEBPS/apfs04.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Text.XML"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e11552" class="calibre1"></a>Text.XML</h1></div></div></div><p class="calibre7"></p><p class="calibre7">The recommended entry point to xml-conduit is the <code class="function">Text.XML</code> module. This module exports all of the data types you’ll need
            to manipulate XML in a DOM fashion, as well as a number of different approaches for
            parsing and rendering XML content. Let’s start with the simple
            ones:<a id="I_programlisting_d1e11561" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">readFile</code>  <code class="ow">::</code> <code class="kt">ParseSettings</code>  <code class="ow">-&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">Document</code>
<code class="nf">writeFile</code> <code class="ow">::</code> <code class="kt">RenderSettings</code> <code class="ow">-&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">Document</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
</pre><p class="calibre7">This
            introduces the <code class="literal">ParseSettings</code> and <code class="literal">RenderSettings</code> data types. You can use these to modify the
            behavior of the parser and renderer, such as adding character entities and turning on
            pretty (i.e., indented) output. Both these types are instances of the <code class="function">Default</code> typeclass, so you can simply use <code class="literal">def</code> when these need to be supplied. That is how we will
            supply these values through the rest of the chapter; please see the API docs for more
            information.</p><p class="calibre7">It’s worth pointing out that in addition to the file-based API, there is also a text- and
        bytestring-based API. The bytestring-powered functions all perform intelligent encoding
            detections, and support UTF-8, UTF-16, and UTF-32, in either big or little endian, with
            and without a Byte-Order Marker (BOM). All output is generated in UTF-8.</p><p class="calibre7">For complex data lookups, we recommend using the higher-level cursors API. The
   standard <code class="literal">Text.XML</code> API not only forms the basis for that higher level, but is
   also a great API for simple XML transformations and for XML generation. See the synopsis for an
   example.</p><div class="book" title="A Note About File Paths"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3104448" class="calibre1"></a>A Note About File Paths</h2></div></div></div><p class="calibre7"></p><p class="calibre7">In the type signature above, we have a type <code class="literal">FilePath</code>.
                However, <span class="bold"><strong class="bold">this isn’t <code class="userinput">Prelude.FilePath</code></strong></span>. The standard <code class="literal">Prelude</code> defines a type synonym <code class="literal">type FilePath = [Char]</code>. Unfortunately, there are many
                limitations to using such an approach, including confusion of filename character
                encodings and differences in path separators.</p><p class="calibre7">Instead, <code class="literal">xml-conduit</code> uses the <code class="function">system-filepath</code> package,
   which defines an abstract <code class="literal">FilePath</code> type. I’ve personally found this to be a much
   nicer approach to work with. The package is fairly easy to follow, so I won’t go into details
   here. But I do want to give a few quick explanations of how to use it:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">Since a <code class="literal">FilePath</code> is an instance of <code class="literal">IsString</code>, you can type
    in regular strings and they will be treated properly, as long as the
     <code class="literal">OverloadedStrings</code> extension is enabled. (I highly recommend enabling it
    anyway, as it makes dealing with <code class="literal">Text</code> values much more pleasant.)</p></li><li class="listitem"><p class="calibre7">If you need to explicitly convert to or from <code class="literal">Prelude</code>’s
     <code class="literal">FilePath</code>, you should use the
     <code class="function">encodeString</code> and
     <code class="function">decodeString</code>, respectively. This
    takes into account file path encodings.</p></li><li class="listitem"><p class="calibre7">Instead of manually splicing together directory names and file names with
                        extensions, use the operators in the <code class="literal">Filesystem.Path.CurrentOS</code> module, e.g., <code class="literal">myfolder &lt;/&gt; filename &lt;.&gt;
                            extension</code>.</p></li></ul></div></div></div></div>

{% endraw %}

