---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apfs03.html
next: OEBPS/apfs05.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Cursor"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e11664" class="calibre1"></a>Cursor</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Suppose you want to pull the title out of an XHTML document. You could do so with the
    <code class="literal">Text.XML</code> interface we just described, using standard pattern matching on the
   children of elements. But that would get very tedious, very quickly. Probably the gold standard
   for these kinds of lookups is XPath, where you would be able to write <code class="literal">/html/head/title</code>. And that’s exactly what inspired the design of the <code class="function">Text.XML.Cursor</code> combinators.</p><p class="calibre7">A cursor is an XML node that knows its location in the tree; it’s able to traverse
   upwards, sideways, and downwards. (Under the surface, this is achieved by <a class="ulink" href="http://www.haskell.org/haskellwiki/Tying_the_Knot">tying
    the knot</a>.) There are two functions available for creating cursors from
    <code class="literal">Text.XML</code> types: <code class="literal">fromDocument</code> and
   <code class="literal">fromNode</code>.</p><p class="calibre7">We also have the concept of an <em class="calibre4">Axis</em>, defined as <code class="literal">type Axis = Cursor -&gt; [Cursor]</code>. It’s easiest to get started by looking at
   example axes: child returns zero or more cursors that are the child of the current one, parent
   returns the single parent cursor of the input, or an empty list if the input is the root element,
   and so on.</p><p class="calibre7">In addition, there are some axes that take predicates. <code class="literal">element</code> is a commonly used function that filters down to only elements
            that match the given name. For example, <code class="literal">element
                "title"</code> will return the input element if its name is “title,” or an empty
            list otherwise.</p><p class="calibre7">Another common function which isn’t quite an axis is <code class="literal">content :: Cursor -&gt;
    [Text]</code>. For all content nodes, it returns the contained text; otherwise, it returns an
   empty list.</p><p class="calibre7">And thanks to the monad instance for lists, it’s easy to string all of these
   together. For example, to do our title lookup, we would write the following program:</p><a id="I_programlisting_d1e11716" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Prelude</code> <code class="kr">hiding</code> <code class="p">(</code><code class="nf">readFile</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Text.XML</code>
<code class="kr">import</code> <code class="nn">Text.XML.Cursor</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Text</code> <code class="kr">as</code> <code class="n">T</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">doc</code> <code class="ow">&lt;-</code> <code class="n">readFile</code> <code class="n">def</code> <code class="s">"test.xml"</code>
    <code class="kr">let</code> <code class="n">cursor</code> <code class="ow">=</code> <code class="n">fromDocument</code> <code class="n">doc</code>
    <code class="n">print</code> <code class="o">$</code> <code class="kt">T</code><code class="o">.</code><code class="n">concat</code> <code class="o">$</code>
            <code class="n">child</code> <code class="n">cursor</code> <code class="o">&gt;&gt;=</code> <code class="n">element</code> <code class="s">"head"</code> <code class="o">&gt;&gt;=</code> <code class="n">child</code>
                         <code class="o">&gt;&gt;=</code> <code class="n">element</code> <code class="s">"title"</code> <code class="o">&gt;&gt;=</code> <code class="n">descendant</code> <code class="o">&gt;&gt;=</code> <code class="n">content</code>
</pre><p class="calibre7">What this says is:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre7">Get me all the child nodes of the root element.</p></li><li class="listitem"><p class="calibre7">Filter down to only the elements named “head.”</p></li><li class="listitem"><p class="calibre7">Get all the children of all those head elements.</p></li><li class="listitem"><p class="calibre7">Filter down to only the elements named “title.”</p></li><li class="listitem"><p class="calibre7">Get all the descendants of all those title elements. (A descendant is a child, or a
    descendant of a child. Yes, that was a recursive definition.)</p></li><li class="listitem"><p class="calibre7">Get only the text nodes.</p></li></ol></div><p class="calibre7">So for the input document:</p><a id="I_programlisting_d1e11742" class="firstname"></a><pre class="programlistinghaskell">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My &lt;b&gt;Title&lt;/b&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;Foo bar baz&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p class="calibre7">We end up with the output <code class="literal">My Title</code>. This is all well and good, but it’s much
   more verbose than the XPath solution. To combat this verbosity, Aristid Breitkreuz added a set of
   operators to the Cursor module to handle many common cases. So we can rewrite our example as:</p><a id="I_programlisting_d1e11749" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Prelude</code> <code class="kr">hiding</code> <code class="p">(</code><code class="nf">readFile</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Text.XML</code>
<code class="kr">import</code> <code class="nn">Text.XML.Cursor</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Text</code> <code class="kr">as</code> <code class="n">T</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">doc</code> <code class="ow">&lt;-</code> <code class="n">readFile</code> <code class="n">def</code> <code class="s">"test.xml"</code>
    <code class="kr">let</code> <code class="n">cursor</code> <code class="ow">=</code> <code class="n">fromDocument</code> <code class="n">doc</code>
    <code class="n">print</code> <code class="o">$</code> <code class="kt">T</code><code class="o">.</code><code class="n">concat</code> <code class="o">$</code>
        <code class="n">cursor</code> <code class="o">$/</code> <code class="n">element</code> <code class="s">"head"</code> <code class="o">&amp;/</code> <code class="n">element</code> <code class="s">"title"</code> <code class="o">&amp;//</code> <code class="n">content</code>
</pre><p class="calibre7"><code class="literal">$/</code> says to apply the axis on the right to the children of
   the cursor on the left. <code class="literal">&amp;/</code> is almost identical, but is instead
   used to combine two axes together. This is a general rule in <code class="literal">Text.XML.Cursor</code>: operators beginning with $ directly apply an axis, while &amp; will
   combine two together. <code class="literal">&amp;//</code> is used for applying an axis to all
   descendants.</p><p class="calibre7">Let’s go for a more complex, if more contrived, example. We have a document that looks
   like:</p><a id="I_programlisting_d1e11766" class="firstname"></a><pre class="programlistinghaskell">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Headings&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;hgroup&gt;
            &lt;h1&gt;Heading 1 foo&lt;/h1&gt;
            &lt;h2 class="foo"&gt;Heading 2 foo&lt;/h2&gt;
        &lt;/hgroup&gt;
        &lt;hgroup&gt;
            &lt;h1&gt;Heading 1 bar&lt;/h1&gt;
            &lt;h2 class="bar"&gt;Heading 2 bar&lt;/h2&gt;
        &lt;/hgroup&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p class="calibre7">We want to get the content of all the <code class="literal">h1</code> tags which
            precede an <code class="literal">h2</code> tag with a <code class="literal">class</code> attribute of “bar.” To perform this convoluted lookup, we can
            write:</p><a id="I_programlisting_d1e11779" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Prelude</code> <code class="kr">hiding</code> <code class="p">(</code><code class="nf">readFile</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Text.XML</code>
<code class="kr">import</code> <code class="nn">Text.XML.Cursor</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Text</code> <code class="kr">as</code> <code class="n">T</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">doc</code> <code class="ow">&lt;-</code> <code class="n">readFile</code> <code class="n">def</code> <code class="s">"test2.xml"</code>
    <code class="kr">let</code> <code class="n">cursor</code> <code class="ow">=</code> <code class="n">fromDocument</code> <code class="n">doc</code>
    <code class="n">print</code> <code class="o">$</code> <code class="kt">T</code><code class="o">.</code><code class="n">concat</code> <code class="o">$</code>
        <code class="n">cursor</code> <code class="o">$//</code> <code class="n">element</code> <code class="s">"h2"</code>
               <code class="o">&gt;=&gt;</code> <code class="n">attributeIs</code> <code class="s">"class"</code> <code class="s">"bar"</code>
               <code class="o">&gt;=&gt;</code> <code class="n">precedingSibling</code>
               <code class="o">&gt;=&gt;</code> <code class="n">element</code> <code class="s">"h1"</code>
               <code class="o">&amp;//</code> <code class="n">content</code>
</pre><p class="calibre7">Let’s step through that. First we get all <code class="literal">h2</code> elements in the document. (<code class="literal">$//</code> gets all descendants of the root element.) Then we
            filter out only those with <code class="literal">class=bar</code>. That <code class="literal">&gt;=&gt;</code> operator is actually the standard operator from
                <code class="function">Control.Monad</code>; yet another advantage of the
            monad instance of lists. <code class="literal">precedingSibling</code> finds all
            nodes that come before our node <span class="bold"><strong class="bold">and</strong></span> that share the same
            parent. (There is also a <code class="literal">preceding</code> axis which takes
            all elements earlier in the tree.) We then take just the <code class="literal">h1</code> elements, and then grab their content.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">The equivalent XPath, for comparison, would be <code class="literal">//h2[@class =
    'bar']/preceding-sibling::h1//text()</code>.</p></div><p class="calibre7">While the cursor API isn’t quite as succinct as XPath, it has the advantages of being standard
   Haskell code, and of type safety.</p></div></div>

{% endraw %}

