---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apf.html
next: OEBPS/apfs03.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Types"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e11341" class="calibre1"></a>Types</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Let’s take a bottom-up approach to analyzing types. This section will also serve as a primer on
   the XML data model itself, so don’t worry if you’re not completely familiar with it.</p><p class="calibre7">I think the first place where Haskell really shows its strength is with the <code class="function">Name</code> data type. Many languages (like Java) struggle with
            properly expressing names. The issue is that there are in fact three components to a
            name: its local name, its namespace (optional), and its prefix (also optional). Let’s
            look at some XML to explain:</p><a id="I_programlisting_d1e11352" class="firstname"></a><pre class="programlistinghaskell">&lt;no-namespace/&gt;
&lt;no-prefix xmlns="first-namespace" first-attr="value1"/&gt;
&lt;foo:with-prefix xmlns:foo="second-namespace" foo:second-attr="value2"/&gt;</pre><p class="calibre7">The first tag has a local name of <code class="literal">no-namespace</code>, and no
   namespace or prefix. The second tag (local name: <code class="literal">no-prefix</code>) <span class="firstname"><em class="calibre4">also</em></span> has no prefix, but it does have a namespace (<code class="literal">first-namespace</code>). <code class="literal">first-attr</code>, however, does <span class="firstname"><em class="calibre4">not</em></span>
   inherit that namespace: attribute namespaces must always be explicitly set with a prefix.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">Namespaces are almost always URIs of some sort, though there is <span class="firstname">nothing</span> in any specification
   requiring that it be so.</p></div><p class="calibre7">The third tag has a local name of <code class="literal">with-prefix</code>, a prefix of
    <code class="literal">foo</code> and a namespace of <code class="literal">second-namespace</code>.
   Its attribute has a <code class="literal">second-attr</code> local name and the same prefix and namespace.
   The <code class="literal">xmlns</code> and <code class="literal">xmlns:foo</code> attributes are part of the namespace
   specification, and are not considered attributes of their respective elements.</p><p class="calibre7">So let’s review what we need from a name: every name has a local name, and it can optionally
   have a prefix and namespace. Seems like a simple fit for a record type:</p><a id="I_programlisting_d1e11404" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Name</code> <code class="ow">=</code> <code class="kt">Name</code>
    <code class="p">{</code> <code class="n">nameLocalName</code> <code class="ow">::</code> <code class="kt">Text</code>
    <code class="p">,</code> <code class="n">nameNamespace</code> <code class="ow">::</code> <code class="kt">Maybe</code> <code class="kt">Text</code>
    <code class="p">,</code> <code class="n">namePrefix</code> <code class="ow">::</code> <code class="kt">Maybe</code> <code class="kt">Text</code>
    <code class="p">}</code>
</pre><p class="calibre7">According the the XML namespace standard, two names are considered equivalent if they
   have the same localname and namespace. In other words, the prefix is not important. Therefore,
    <code class="literal">xml-types</code> defines <code class="literal">Eq</code> and <code class="literal">Ord</code> instances that
   ignore the prefix.</p><p class="calibre7">The last class instance worth mentioning is <code class="literal">IsString</code>. It would be
   very tedious to have to manually type out <code class="literal">Name "p" Nothing Nothing</code>
   every time we want a paragraph. If you turn on <code class="literal">OverloadedStrings</code>,
    <code class="literal">"p"</code> will resolve to that all by itself! In addition, the
    <code class="literal">IsString</code> instance recognizes something called Clark notation, which allows you
   to prefix the namespace surrounded in curly brackets. In other words:</p><a id="I_programlisting_d1e11438" class="firstname"></a><pre class="programlistinghaskell"><code class="s">"{namespace}element"</code> <code class="o">==</code> <code class="kt">Name</code> <code class="s">"element"</code> <code class="p">(</code><code class="kt">Just</code> <code class="s">"namespace"</code><code class="p">)</code> <code class="kt">Nothing</code>
<code class="s">"element"</code> <code class="o">==</code> <code class="kt">Name</code> <code class="s">"element"</code> <code class="kt">Nothing</code> <code class="kt">Nothing</code>
</pre><div class="book" title="The Four Types of Nodes"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3104045" class="calibre1"></a>The Four Types of Nodes</h2></div></div></div><p class="calibre7"></p><p class="calibre7">XML documents are a tree of nested nodes. There are in fact four different types of nodes
   allowed: elements, content (i.e., text), comments, and processing instructions.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">You may not be familiar with that last one, as it’s less commonly used. It is marked
                    up as: <code class="literal">&lt;?target data?&gt;</code> There are two
                    surprising facts about processing instructions (PIs):</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">PIs don’t have attributes. While oftentimes you’ll see processing
                                instructions that appear to have attributes, there are in fact no
                                rules about that data of an instruction.</p></li><li class="listitem"><p class="calibre7">The <code class="literal">&lt;?xml ...?&gt;</code> stuff at
                                the beginning of a document is not a processing instruction. It is
                                simply the beginning of the document (known as the XML declaration),
                                and happens to look an awful lot like a PI. The difference though is
                                that the <code class="literal">&lt;?xml ...?&gt;</code> line
                                will not appear in your parsed content.</p></li></ul></div></div><p class="calibre7">Since processing instructions have two pieces of text associated with them (the target and the
   data), we have a simple data type:</p><a id="I_programlisting_d1e11467" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Instruction</code> <code class="ow">=</code> <code class="kt">Instruction</code>
    <code class="p">{</code> <code class="n">instructionTarget</code> <code class="ow">::</code> <code class="kt">Text</code>
    <code class="p">,</code> <code class="n">instructionData</code> <code class="ow">::</code> <code class="kt">Text</code>
    <code class="p">}</code>
</pre><p class="calibre7">Comments have no special data type since they are just text. But content is an
                interesting one: it could contain either plain text or unresolved entities (e.g.,
                    <code class="literal">&amp;copyright-statement;</code>). <code class="function">xml-types</code> keeps those unresolved entities in all the
                data types in order to completely match the spec. However, in practice, it can be
                very tedious to program against those data types. And in most use cases, an
                unresolved entity is going to end up as an error anyway.</p><p class="calibre7">So the <code class="function">Text.XML</code> module defines its own set of data
                types for nodes, elements, and documents that removes all unresolved entities. If
                you need to deal with unresolved entities instead, you should use the <code class="function">Text.XML.Unresolved</code> module. From now on, we’ll be
                focusing only on the <code class="literal">Text.XML</code> data types, though
                they are almost identical to the <code class="literal">xml-types</code>
                versions.</p><p class="calibre7">Anyway, after that detour: content is just a piece of text, and therefore it too does
                not have a special data type. The last node type is an element, which contains three
                pieces of information: a name, a list of attributes and a list of children nodes. An
                attribute has two pieces of information: a name and a value. (In <code class="literal">xml-types</code>, this value could contain unresolved
                entities as well.) So our <code class="literal">Element</code> is defined
                as:</p><a id="I_programlisting_d1e11499" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Element</code> <code class="ow">=</code> <code class="kt">Element</code>
    <code class="p">{</code> <code class="n">elementName</code> <code class="ow">::</code> <code class="kt">Name</code>
    <code class="p">,</code> <code class="n">elementAttributes</code> <code class="ow">::</code> <code class="p">[(</code><code class="kt">Name</code><code class="p">,</code> <code class="kt">Text</code><code class="p">)]</code>
    <code class="p">,</code> <code class="n">elementNodes</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Node</code><code class="p">]</code>
    <code class="p">}</code>
</pre><p class="calibre7">Which of course begs the question: what does a <code class="literal">Node</code> look like? This
   is where Haskell really shines: its sum types model the XML data model perfectly.</p><a id="I_programlisting_d1e11507" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Node</code>
    <code class="ow">=</code> <code class="kt">NodeElement</code> <code class="kt">Element</code>
    <code class="o">|</code> <code class="kt">NodeInstruction</code> <code class="kt">Instruction</code>
    <code class="o">|</code> <code class="kt">NodeContent</code> <code class="kt">Text</code>
    <code class="o">|</code> <code class="kt">NodeComment</code> <code class="kt">Text</code>
</pre></div><div class="book" title="Documents"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3104233" class="calibre1"></a>Documents</h2></div></div></div><p class="calibre7"></p><p class="calibre7">So now we have elements and nodes, but what about an entire document? Let’s just lay out
                the data types:</p><a id="I_programlisting_d1e11515" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Document</code> <code class="ow">=</code> <code class="kt">Document</code>
    <code class="p">{</code> <code class="n">documentPrologue</code> <code class="ow">::</code> <code class="kt">Prologue</code>
    <code class="p">,</code> <code class="n">documentRoot</code> <code class="ow">::</code> <code class="kt">Element</code>
    <code class="p">,</code> <code class="n">documentEpilogue</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Miscellaneous</code><code class="p">]</code>
    <code class="p">}</code>

<code class="kr">data</code> <code class="kt">Prologue</code> <code class="ow">=</code> <code class="kt">Prologue</code>
    <code class="p">{</code> <code class="n">prologueBefore</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Miscellaneous</code><code class="p">]</code>
    <code class="p">,</code> <code class="n">prologueDoctype</code> <code class="ow">::</code> <code class="kt">Maybe</code> <code class="kt">Doctype</code>
    <code class="p">,</code> <code class="n">prologueAfter</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Miscellaneous</code><code class="p">]</code>
    <code class="p">}</code>

<code class="kr">data</code> <code class="kt">Miscellaneous</code>
    <code class="ow">=</code> <code class="kt">MiscInstruction</code> <code class="kt">Instruction</code>
    <code class="o">|</code> <code class="kt">MiscComment</code> <code class="kt">Text</code>

<code class="kr">data</code> <code class="kt">Doctype</code> <code class="ow">=</code> <code class="kt">Doctype</code>
    <code class="p">{</code> <code class="n">doctypeName</code> <code class="ow">::</code> <code class="kt">Text</code>
    <code class="p">,</code> <code class="n">doctypeID</code> <code class="ow">::</code> <code class="kt">Maybe</code> <code class="kt">ExternalID</code>
    <code class="p">}</code>

<code class="kr">data</code> <code class="kt">ExternalID</code>
    <code class="ow">=</code> <code class="kt">SystemID</code> <code class="kt">Text</code>
    <code class="o">|</code> <code class="kt">PublicID</code> <code class="kt">Text</code> <code class="kt">Text</code>
</pre><p class="calibre7">The XML spec says that a document has a single root element
    (<code class="literal">documentRoot</code>). It also has an optional doctype statement. Before and after
   both the doctype and the root element, you are allowed to have comments and processing
   instructions. (You can also have whitespace, but that is ignored in the parsing.)</p><p class="calibre7">So what’s up with the doctype? Well, it specifies the root element of the document, and then
   optional public and system identifiers. These are used to refer to DTD files, which give more
   information about the file (e.g., validation rules, default attributes, entity resolution). Let’s
   see some examples:</p><a id="I_programlisting_d1e11524" class="firstname"></a><pre class="programlistinghaskell">&lt;!DOCTYPE root&gt; &lt;!-- no external identifier --&gt;
&lt;!DOCTYPE root SYSTEM "root.dtd"&gt; &lt;!-- a system identifier --&gt;
&lt;!DOCTYPE root PUBLIC "My Root Public Identifier" "root.dtd"&gt; &lt;!-- public identifiers have a system ID as well --&gt;</pre><p class="calibre7">And that, my friends, is the entire XML data model. For many parsing purposes, you’ll be
                able to simply ignore the entire <code class="literal">Document</code> data
                type and go immediately to the <code class="literal">documentRoot</code>.</p></div><div class="book" title="Events"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3104316" class="calibre1"></a>Events</h2></div></div></div><p class="calibre7"></p><p class="calibre7">In addition to the document API, <code class="literal">xml-types</code> defines an
                    <code class="function">Event</code> data type. This can be used for
                constructing streaming tools, which can be much more memory efficient for certain
                kinds of processing (e.g., adding an extra attribute to all elements). We will not
                be covering the streaming API currently, though it should look very familiar after
                analyzingthe document API.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">You can see an example of the streaming API in the Sphinx case
    study.</p></div></div></div></div>

{% endraw %}

