---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apcs03.html
next: OEBPS/ape.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Appendix D. Settings Types"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_appendix_d1e10898" class="calibre1"></a>Appendix D. Settings Types</h1></div></div></div><p class="calibre7">Let’s say you’re writing a web server. You want the server to take a port to listen on, and
    an application to run. So you create the following function:</p><a id="I_programlisting_d1e10903" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">run</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Application</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
</pre><p class="calibre7">But suddenly you realize that some people will want to customize their timeout durations. So
   you modify your API:</p><a id="I_programlisting_d1e10910" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">run</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Application</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
</pre><p class="calibre7">So, which <code class="literal">Int</code> is the timeout, and which is the port? Well, you could create
   some type aliases, or comment your code. But there’s another problem creeping into our code: this
    <code class="literal">run</code> function is getting unmanageable. Soon we’ll need to take an extra
   parameter to indicate how exceptions should be handled, and then another one to control which
   host to bind to, and so on.</p><p class="calibre7">So a more extensible solution is to introduce a settings data type:</p><a id="I_programlisting_d1e10922" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Settings</code> <code class="ow">=</code> <code class="kt">Settings</code>
    <code class="p">{</code> <code class="n">settingsPort</code> <code class="ow">::</code> <code class="kt">Int</code>
    <code class="p">,</code> <code class="n">settingsHost</code> <code class="ow">::</code> <code class="kt">String</code>
    <code class="p">,</code> <code class="n">settingsTimeout</code> <code class="ow">::</code> <code class="kt">Int</code>
    <code class="p">}</code>
</pre><p class="calibre7">And this makes the calling code almost self-documenting:</p><a id="I_programlisting_d1e10926" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">run</code> <code class="kt">Settings</code>
    <code class="p">{</code> <code class="n">settingsPort</code> <code class="ow">=</code> <code class="mi">8080</code>
    <code class="p">,</code> <code class="n">settingsHost</code> <code class="ow">=</code> <code class="s">"127.0.0.1"</code>
    <code class="p">,</code> <code class="n">settingsTimeout</code> <code class="ow">=</code> <code class="mi">30</code>
    <code class="p">}</code> <code class="n">myApp</code>
</pre><p class="calibre7">Great, couldn’t be clearer, right? True, but what happens when you have 50 settings to your
    web server? Do you really want to have to specify all of those each time? Of course not. So
    instead, the web server should provide a set of defaults:</p><a id="I_programlisting_d1e10931" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">defaultSettings</code> <code class="ow">=</code> <code class="kt">Settings</code> <code class="mi">3000</code> <code class="s">"127.0.0.1"</code> <code class="mi">30</code>
</pre><p class="calibre7">And now, instead of needing to write that long bit of code above, we can get away with:</p><a id="I_programlisting_d1e10935" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">run</code> <code class="n">defaultSettings</code> <code class="p">{</code> <code class="n">settingsPort</code> <code class="ow">=</code> <code class="mi">8080</code> <code class="p">}</code> <code class="n">myApp</code> <code class="cm">-- (1)</code>
</pre><p class="calibre7">This is great, except for one minor hitch. Let’s say we now decide to add an extra record to
    <code class="literal">Settings</code>. Any code out in the wild looking like
   this:<a id="I_programlisting_d1e10942" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">run</code> <code class="p">(</code><code class="kt">Settings</code> <code class="mi">8080</code> <code class="s">"127.0.0.1"</code> <code class="mi">30</code><code class="p">)</code> <code class="n">myApp</code> <code class="cm">-- (2)</code>
</pre><p class="calibre7">will
   be broken, since the <code class="literal">Settings</code> constructor now takes 4 arguments. The proper
   thing to do would be to bump the major version number so that dependent packages don’t get
   broken. But having to change major versions for every minor setting you add is a nuisance. The
   solution? Don’t export the <code class="literal">Settings</code> constructor:</p><a id="I_programlisting_d1e10951" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">module</code> <code class="nn">MyServer</code>
    <code class="p">(</code> <code class="kt">Settings</code>
    <code class="p">,</code> <code class="nf">settingsPort</code>
    <code class="p">,</code> <code class="nf">settingsHost</code>
    <code class="p">,</code> <code class="nf">settingsTimeout</code>
    <code class="p">,</code> <code class="nf">run</code>
    <code class="p">,</code> <code class="nf">defaultSettings</code>
    <code class="p">)</code> <code class="kr">where</code>
</pre><p class="calibre7">With this approach, no one can write code like (2), so you can freely add new records without
   any fear of code breaking.</p><p class="calibre7">The one downside of this approach is that it’s not immediately obvious from the Haddocks that
   you can actually change the settings via record syntax. That’s the point of this chapter: to
   clarify what’s going on in the libraries that use this technique.</p><p class="calibre7">I personally use this technique in a few places, feel free to have a look at the Haddocks to
   see what I mean.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">Warp: <code class="function">Settings</code></p></li><li class="listitem"><p class="calibre7">http-conduit: <code class="function">Request</code> and
     <code class="function">ManagerSettings</code></p></li><li class="listitem"><p class="calibre7">xml-conduit</p><div class="book"><ul class="itemizedlist2"><li class="listitem"><p class="calibre7 pcalibre">Parsing: <code class="function">ParseSettings</code></p></li><li class="listitem"><p class="calibre7 pcalibre">Rendering: <code class="function">RenderSettings</code></p></li></ul></div></li></ul></div><p class="calibre7">As a tangential issue, <code class="literal">http-conduit</code> and <code class="literal">xml-conduit</code> actually
   create instances of the <code class="function">Default</code> typeclass instead of
   declaring a brand new identifier. This means you can just type <code class="literal">def</code> instead of
    <code class="literal">defaultParserSettings</code>.</p></div></div>

{% endraw %}

