---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch10s05.html
next: OEBPS/ch10s07.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Manipulation"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect110_d1e5450" class="calibre1"></a>Manipulation</h1></div></div></div><p class="calibre7">Querying is only half the battle. We also need to be able to add data to and modify
            existing data in the database.</p><div class="book" title="Insert"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3087296" class="calibre1"></a>Insert</h2></div></div></div><p class="calibre7">It’s all well and good to be able to play with data in the database, but how does it get
        there in the first place? The answer is the <code class="literal">insert</code>
        function. You just give it a value, and it gives back an ID.</p><p class="calibre7">At this point, it makes sense to explain a bit of the philosophy behind Persistent. In
        many other ORM solutions, the data types used to hold data are opaque: you need to go
        through their defined interfaces to get at and modify the data. That’s not the case with
        Persistent: we’re using plain old Algebraic Data Types for the whole thing. This means you
        still get all the great benefits of pattern matching, currying, and everything else you’re
        used to.</p><p class="calibre7">However, there are a few things we <span class="firstname"><em class="calibre4">can’t</em></span> do. For one, there’s no
        way to automatically update values in the database every time the record is updated in
        Haskell. Of course, with Haskell’s normal stance of purity and immutability, this wouldn’t
        make much sense anyway, so I don’t shed any tears over it.</p><p class="calibre7">However, there is one issue that newcomers are often bothered by: why are IDs and values
   completely separate? It seems like it would be very logical to embed the ID inside the value. In
   other words, instead of
   having:<a id="I_programlisting10_d1e5472" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Person</code> <code class="ow">=</code> <code class="kt">Person</code> <code class="p">{</code> <code class="n">name</code> <code class="ow">::</code> <code class="kt">String</code> <code class="p">}</code>
</pre><p class="calibre7">have<a id="I_programlisting10_d1e5475" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Person</code> <code class="ow">=</code> <code class="kt">Person</code> <code class="p">{</code> <code class="n">personId</code> <code class="ow">::</code> <code class="kt">PersonId</code><code class="p">,</code> <code class="n">name</code> <code class="ow">::</code> <code class="kt">String</code> <code class="p">}</code>
</pre><p class="calibre7">Well, there’s one problem with this right off the bat: how do we do an <code class="literal">insert</code>? If a Person needs to have an ID, and we get the ID by
        inserting, and an insert needs a Person, we have an impossible loop. We could solve this
        with <code class="literal">undefined</code>, but that’s just asking for
        trouble.</p><p class="calibre7">OK, you say, let’s try something a bit
   safer:<a id="I_programlisting10_d1e5487" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Person</code> <code class="ow">=</code> <code class="kt">Person</code> <code class="p">{</code> <code class="n">personId</code> <code class="ow">::</code> <code class="kt">Maybe</code> <code class="kt">PersonId</code><code class="p">,</code> <code class="n">name</code> <code class="ow">::</code> <code class="kt">String</code> <code class="p">}</code>
</pre><p class="calibre7">I
   definitely prefer <code class="literal">insert $ Person Nothing "Michael"</code> to <code class="literal">insert $ Person undefined "Michael"</code>. And now our types will be much simpler, right?
   For example, <code class="literal">selectList</code> could return a simple <code class="literal">[Person]</code>
   instead of that ugly <code class="literal">[Entity SqlPersist Person]</code>.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7"><code class="literal">Entity</code> is a data type that ties together both the ID
          and value of an entity. Since IDs can be different based on backend, we also need to
          provide the Persistent backend we’re using. The data type <code class="literal">Entity SqlPersist Person</code> can be read as “the ID and value of a person stored
          in a SQL database.”</p></div><p class="calibre7">The problem is that the “ugliness” is incredibly useful. Having <code class="literal">Entity SqlPersist Person</code> makes it obvious, at the type level,
        that we’re dealing with a value that exists in the database. Let’s say we want to
        create a link to another page that requires the <code class="literal">PersonId</code>
        (not an uncommon occurrence as we’ll discuss later). The <code class="literal">Entity SqlPersist Person</code> form gives us unambiguous access to that information;
        embedding <code class="literal">PersonId</code> within <code class="literal">Person</code> with a <code class="literal">Maybe</code> wrapper means an extra
        runtime check for <code class="literal">Just</code>, instead of a more error-proof
        compile time check.</p><p class="calibre7">Finally, there’s a semantic mismatch with embedding the ID within the value. The
          <code class="literal">Person</code> is the value. Two people are identical (in the
        context of a database) if all their fields are the same. By embedding the ID in the value,
        we’re no longer talking about a person, but about a row in the database. Equality is
        no longer really equality, it’s identity: is this the <span class="firstname"><em class="calibre4">same
        person</em></span>, as opposed to an equivalent person.</p><p class="calibre7">In other words, there are some annoyances with having the ID separated out, but overall,
        it’s the <span class="firstname"><em class="calibre4">right</em></span> approach, which in the grand scheme of things
        leads to better, less buggy code.</p></div><div class="book" title="Update"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3087540" class="calibre1"></a>Update</h2></div></div></div><p class="calibre7">Now, in the context of that discussion, let’s think about updating. The simplest
        way to update
        is:<a id="I_programlisting10_d1e5556" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">let</code> <code class="n">michael</code> <code class="ow">=</code> <code class="kt">Person</code> <code class="s">"Michael"</code> <code class="mi">26</code>
    <code class="n">michaelAfterBirthday</code> <code class="ow">=</code> <code class="n">michael</code> <code class="p">{</code> <code class="n">personAge</code> <code class="ow">=</code> <code class="mi">27</code> <code class="p">}</code>
</pre><p class="calibre7">But
        that’s not actually updating anything, it’s just creating a new <code class="literal">Person</code> value based on the old one. When we say update,
        we’re <span class="firstname"><em class="calibre4">not</em></span> talking about modifications to the values in Haskell.
        (We better not be of course, since Haskell data types are immutable.)</p><p class="calibre7">Instead, we’re looking at ways of modifying rows in a table. And the simplest way
        to do that is with the <code class="literal">update</code> function.</p><a id="I_programlisting10_d1e5570" class="firstname"></a><pre class="programlistinghaskell">    <code class="n">personId</code> <code class="ow">&lt;-</code> <code class="n">insert</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"Michael"</code> <code class="s">"Snoyman"</code> <code class="mi">26</code>
    <code class="n">update</code> <code class="n">personId</code> <code class="p">[</code><code class="kt">PersonAge</code> <code class="o">=.</code> <code class="mi">27</code><code class="p">]</code>
</pre><p class="calibre7"><code class="literal">update</code> takes two arguments: an ID and a list of
          <code class="literal">Update</code>s. The simplest update is assignment, but
        it’s not always the best. What if you want to increase someone’s age by 1, but
        you don’t have their current age? Persistent has you covered:</p><a id="I_programlisting10_d1e5579" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">haveBirthday</code> <code class="n">personId</code> <code class="ow">=</code> <code class="n">update</code> <code class="n">personId</code> <code class="p">[</code><code class="kt">PersonAge</code> <code class="o">+=.</code> <code class="mi">1</code><code class="p">]</code>
</pre><p class="calibre7">And as you might expect, we have all the basic mathematical operators: <code class="literal">+=.</code>, <code class="literal">-=.</code>, <code class="literal">*=.</code>, and <code class="literal">/=.</code> (full stop).
        These can be convenient for updating a single record, but they are also essential for proper
        ACID guarantees. Imagine the alternative: pull out a <code class="literal">Person</code>, increment the age, and update the new value. If you have two
        threads/processes working on this database at the same time, you’re in for a world of
        hurt (hint: race conditions).</p><p class="calibre7">Sometimes you’ll want to update many fields at once (give all your employees a 5%
        pay increase, for example). <code class="literal">updateWhere</code> takes two
        parameters: a list of filters and a list of updates to apply.</p><a id="I_programlisting10_d1e5610" class="firstname"></a><pre class="programlistinghaskell">    <code class="n">updateWhere</code> <code class="p">[</code><code class="kt">PersonFirstName</code> <code class="o">==.</code> <code class="s">"Michael"</code><code class="p">]</code> <code class="p">[</code><code class="kt">PersonAge</code> <code class="o">*=.</code> <code class="mi">2</code><code class="p">]</code> <code class="cm">-- it's been a long day</code>
</pre><p class="calibre7">Occassionally, you’ll just want to completely replace the value in a database with a
        different value. For that, you use (surprise) the <code class="literal">replace</code>
        function.</p><a id="I_programlisting10_d1e5617" class="firstname"></a><pre class="programlistinghaskell">    <code class="n">personId</code> <code class="ow">&lt;-</code> <code class="n">insert</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"Michael"</code> <code class="s">"Snoyman"</code> <code class="mi">26</code>
    <code class="n">replace</code> <code class="n">personId</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"John"</code> <code class="s">"Doe"</code> <code class="mi">20</code>
</pre></div><div class="book" title="Delete"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3087732" class="calibre1"></a>Delete</h2></div></div></div><p class="calibre7">As much as it pains us, sometimes we must part with our data. To do so, we have three
   functions:</p><div class="book"><dl class="book"><dt class="calibre9"><span class="firstname">delete</span></dt><dd class="calibre10"><p class="calibre7">Delete based on an ID</p></dd><dt class="calibre9"><span class="firstname">deleteBy</span></dt><dd class="calibre10"><p class="calibre7">Delete based on a unique constraint</p></dd><dt class="calibre9"><span class="firstname">deleteWhere</span></dt><dd class="calibre10"><p class="calibre7">Delete based on a set of filters</p></dd></dl></div><a id="I_programlisting10_d1e5643" class="firstname"></a><pre class="programlistinghaskell">    <code class="n">personId</code> <code class="ow">&lt;-</code> <code class="n">insert</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"Michael"</code> <code class="s">"Snoyman"</code> <code class="mi">26</code>
    <code class="n">delete</code> <code class="n">personId</code>
    <code class="n">deleteBy</code> <code class="o">$</code> <code class="kt">UniqueName</code> <code class="s">"Michael"</code> <code class="s">"Snoyman"</code>
    <code class="n">deleteWhere</code> <code class="p">[</code><code class="kt">PersonFirstName</code> <code class="o">==.</code> <code class="s">"Michael"</code><code class="p">]</code>
</pre><p class="calibre7">We can even use deleteWhere to wipe out all the records in a table, we just need to give
        some hints to GHC as to what table we’re interested in:</p><a id="I_programlisting10_d1e5647" class="firstname"></a><pre class="programlistinghaskell">    <code class="n">deleteWhere</code> <code class="p">(</code><code class="kt">[]</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Filter</code> <code class="kt">Person</code><code class="p">])</code>
</pre></div></div></div>

{% endraw %}

