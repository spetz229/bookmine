---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apbs07.html
next: OEBPS/apcs02.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Appendix C. Web Application Interface"><div class="book"><div class="book"><div class="book"><h1 class="title1"><a id="I_appendix_d1e10732" class="calibre1"></a>Appendix C. Web Application Interface</h1></div></div></div><p class="calibre7">It is a problem almost every language used for web development has dealt with: the low-level
    interface between the web server and the application. The earliest example of a solution is the
    venerable and battle-worn
    Common
    Gateway Interface (CGI), providing a language-agnostic interface using only
    standard input, standard output, and environment variables.</p><p class="calibre7">Back when Perl was becoming the de facto web programming language, a major shortcoming of
    CGI became apparent: the process needed to be started anew for each request. When dealing with
    an interpreted language and application requiring database connection, this overhead became
    unbearable. FastCGI (and later SCGI) arose as a successor to CGI, but it seems that much of the
    programming world went in a different direction.</p><p class="calibre7">Each language began creating its own standard for interfacing with servers: mod_perl,
    mod_python, mod_php, mod_ruby. Within the same language, multiple interfaces arose. In some
    cases, we even had interfaces on top of interfaces. And all of this led to much duplicated
    effort: a Python application designed to work with FastCGI wouldn’t work with
    mod_python—mod_python only exists for certain web servers—and these programming language
    specific web server extensions need to be written for each programming language.</p><p class="calibre7">Haskell has its own history. We originally had the <code class="function">cgi</code> package, which provided a monadic interface. The <code class="function">fastcgi</code> package then provided the same interface. Meanwhile, it seemed that the majority of Haskell web development focused on the standalone server. The problem is that each server comes with its own interface, meaning that you need to target a specific backend. This means that it is impossible to share common features, like GZIP encoding, development servers, and testing frameworks.</p><p class="calibre7">WAI attempts to solve this, by providing a generic and efficient interface between web servers and applications. Any <span class="bold"><strong class="bold">handler</strong></span> supporting the interface can serve any WAI application, while any application using the interface can run on any handler.</p><p class="calibre7">At the time of writing, there are various backends, including Warp, FastCGI, and development
    server. There are even more esoteric backends like <code class="function">wai-handler-webkit</code> for creating desktop apps. <code class="function">wai-extra</code> provides many common middleware components like GZIP, JSON-P, and
    virtual hosting. <code class="function">wai-test</code> makes it easy to write unit
    tests, and <code class="function">wai-handler-devel</code> lets you develop your
    applications without worrying about stopping to compile. Yesod targets WAI, and Happstack is in
    the process of converting over as well. It’s also used by some applications that skip the
    framework entirely, including the new Hoogle.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">Yesod provides an alternate approach for a devel server, known as <em class="calibre4">yesod devel</em>. The difference from wai-handler-devel is that yesod devel actually
      compiles your code each time, respecting all settings in your cabal file. This is the
      recommended approach for general Yesod development.</p></div><div class="book" title="The Interface"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e10781" class="calibre1"></a>The Interface</h1></div></div></div><p class="calibre7"></p><p class="calibre7">The interface itself is very straightforward: an application takes a request and returns a
      response. A response is an HTTP status, a list of headers and a response body. A request
      contains various information: the requested path, query string, request body, HTTP version,
      and so on.</p><div class="book" title="Response Body"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3102396" class="calibre1"></a>Response Body</h2></div></div></div><p class="calibre7"></p><p class="calibre7">Haskell has a data type known as a lazy bytestring. By utilizing laziness, you can
        create large values without exhausting memory. Using lazy I/O, you can do such tricks as
        having a value which represents the entire contents of a file, yet only occupies a small
        memory footprint. In theory, a lazy bytestring is the only representation necessary for a
        response body.</p><p class="calibre7">In practice, while lazy byte strings are wonderful for generating “pure” values, the
            lazy I/O necessary to read a file introduces some non-determinism into our programs.
            When serving thousands of small files a second, the limiting factor is not memory, but
            file handles. Using lazy I/O, file handles may not be freed immediately, leading to
            resource exhaustion. To deal with this, WAI uses <em class="calibre4">conduits</em>.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">Versions of WAI before 1.0 used enumerators in place of conduits. While both conduits
            and enumerators solve the same basic problem, experience showed that enumerators were
            too constricting in their inversion of control approach, making it difficult to
            structure more complicated systems like a streaming proxy server. Conduits were designed
            with the express purpose of making a better WAI.</p></div><p class="calibre7">The data type relevant to us now is a <em class="calibre4">source</em>. A source produces a stream of
            data, producing a single chunk at a time. In the case of WAI, the request body would be
            a source passed to the application, and the response body would be a source returned
            from the application.</p><p class="calibre7">There are two further optimizations: many systems provide a sendfile system call, which
        sends a file directly to a socket, bypassing a lot of the memory copying inherent in more
        general I/O system calls. Additionally, there is a data type in Haskell called <code class="literal">Builder</code> which allows efficient copying of bytes into
        buffers.</p><p class="calibre7">The WAI response body therefore has three constructors: one for pure builders (<code class="literal">ResponseBuilder</code>), one for a source of builders (<code class="literal">ResponseSource</code>), and one for files (<code class="literal">ResponseFile</code>).</p></div><div class="book" title="Request Body"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3102488" class="calibre1"></a>Request Body</h2></div></div></div><p class="calibre7"></p><p class="calibre7">In order to avoid the need to load the entire request body into memory, we use
            sources here as well. Since the purpose of these values are for reading (not writing),
            we use <code class="literal">ByteString</code>s in place of <code class="literal">Builder</code>s. There is a record inside <code class="literal">Request</code> called
                <code class="literal">requestBody</code>, with type <code class="literal">BufferedSource IO
                ByteString</code>. We can use all of the standard conduit functions to interact
            with this source.</p><p class="calibre7">The request body could in theory contain any type of data, but the most common are URL encoded and multipart form data. The <code class="function">wai-extra</code> package contains built-in support for parsing these in a memory-efficient manner.</p></div></div></div></div>

{% endraw %}

