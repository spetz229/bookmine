---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apa.html
next: OEBPS/apas03.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Intuition"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e8776" class="calibre1"></a>Intuition</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Let’s try and develop an external intuition of what’s happening here. The ErrorT monad
      transformer adds extra functionality to the IO monad. We’ve defined a way to “tack on” that
      extra functionality to normal IO actions: we add that Right constructor and wrap it all in
      ErrorT. Wrapping in Right is our way of saying “it went OK”; there wasn’t anything wrong with
      this action.</p><p class="calibre7">Now this intuitively makes sense: since the IO monad doesn’t have the concept of returning a
   MyError when something goes wrong, it will always succeed in the lifting phase. (Note: This has
    <span class="bold"><strong class="bold">nothing</strong></span> to do with runtime exceptions, don’t even think about them.) What we have is a
   guaranteed one-directional translation up the monad stack.</p><p class="calibre7">Let’s take another example: the Reader monad. A Reader has access to some extra piece of data
   floating around. Whatever is running in the inner monad doesn’t know about that extra piece of
   information. So how would you do a lift? You just ignore that extra information. The Writer
   monad? Don’t write anything. State? Don’t change anything. I’m seeing a pattern here.</p><p class="calibre7">But now let’s try and go in the opposite direction: I have something in a Reader, and I’d
      like to run it in the base monad (e.g., IO). Well... that’s not going to work, is it? I need
      that extra piece of information, I’m relying on it, and it’s not there. There’s simply no way
      to go in the opposite direction without providing that extra value.</p><p class="calibre7">Or is there? If you remember, we’d pointed out earlier that ErrorT is just a simple wrapper
   around the inner monad. In other words, if I have <code class="literal">errorValue :: ErrorT MyError IO
    MyValue</code>, I can apply <code class="literal">runErrorT</code> and get a value of type <code class="literal">IO
    (Either MyError MyValue)</code>. The looks quite a bit like bi-directional translation,
   doesn’t it?</p><p class="calibre7">Well, not quite. We originally had an <code class="literal">ErrorT MyError IO</code> monad, with a value of
   type <code class="literal">MyValue</code>. Now we have a monad of type <code class="literal">IO</code> with a value of
   type <code class="literal">Either MyError MyValue</code>. So this process has in fact changed the value,
   while the lifting process leaves it the same.</p><p class="calibre7">But still, with a little fancy footwork we can unwrap the ErrorT, do some processing, and then
   wrap it back up again.</p><a id="I_programlisting_d1e8818" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">useMyFileError1</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">useMyFileError1</code> <code class="ow">=</code>
    <code class="kr">let</code> <code class="n">unwrapped</code> <code class="ow">::</code> <code class="kt">Handle</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">MyError</code> <code class="nb">()</code><code class="p">)</code>
        <code class="n">unwrapped</code> <code class="n">handle</code> <code class="ow">=</code> <code class="n">runErrorT</code> <code class="o">$</code> <code class="n">sayHiError</code> <code class="n">handle</code>
        <code class="n">applied</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">MyError</code> <code class="nb">()</code><code class="p">)</code>
        <code class="n">applied</code> <code class="ow">=</code> <code class="n">withMyFile</code> <code class="n">unwrapped</code>
        <code class="n">rewrapped</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="nb">()</code>
        <code class="n">rewrapped</code> <code class="ow">=</code> <code class="kt">ErrorT</code> <code class="n">applied</code>
     <code class="kr">in</code> <code class="n">rewrapped</code>
</pre><p class="calibre7">This is the crucial point of this whole article, so look closely. We first unwrap our monad.
   This means that, to the outside world, it’s now just a plain old IO value. Internally, we’ve
   stored all the information from our ErrorT transformer. Now that we have a plain old IO, we can
   easily pass it off to withMyFile. withMyFile takes in the internal state and passes it back out
   unchanged. Finally, we wrap everything back up into our original ErrorT.</p><p class="calibre7">This is the entire pattern of monad-control: we embed the extra features of our monad
   transformer inside the value. Once in the value, the type system ignores it and focuses on the
   inner monad. When we’re done playing around with that inner monad, we can pull our state back out
   and reconstruct our original monad stack.</p></div></div>

{% endraw %}

