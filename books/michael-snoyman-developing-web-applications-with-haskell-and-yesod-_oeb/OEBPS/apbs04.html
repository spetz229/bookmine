---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apbs03.html
next: OEBPS/apbs05.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Source"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e9700" class="calibre1"></a>Source</h1></div></div></div><p class="calibre7"></p><p class="calibre7">I think it’s simplest to understand sources by looking at the types:</p><a id="I_programlisting_d1e9706" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">SourceResult</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Open</code> <code class="p">(</code><code class="kt">Source</code> <code class="n">m</code> <code class="n">a</code><code class="p">)</code> <code class="n">a</code> <code class="o">|</code> <code class="kt">Closed</code>
<code class="kr">data</code> <code class="kt">Source</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Source</code>
    <code class="p">{</code> <code class="n">sourcePull</code> <code class="ow">::</code> <code class="kt">ResourceT</code> <code class="n">m</code> <code class="p">(</code><code class="kt">SourceResult</code> <code class="n">m</code> <code class="n">a</code><code class="p">)</code>
    <code class="p">,</code> <code class="n">sourceClose</code> <code class="ow">::</code> <code class="kt">ResourceT</code> <code class="n">m</code> <code class="nb">()</code>
    <code class="p">}</code>
</pre><p class="calibre7">A source has just two operations on it: you can pull data from it, and you can close it (think
      of closing a file handle). When you pull, you either get some data and the a new
        <code class="literal">Source</code> (the source is still open), or nothing (the source is closed). Let’s
      look at some of the simplest sources:</p><a id="I_programlisting_d1e9713" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Prelude</code> <code class="kr">hiding</code> <code class="p">(</code><code class="nf">repeat</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code>

<code class="cm">-- | Never give any data</code>
<code class="nf">eof</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">Source</code> <code class="n">m</code> <code class="n">a</code>
<code class="nf">eof</code> <code class="ow">=</code> <code class="kt">Source</code>
    <code class="p">{</code> <code class="n">sourcePull</code> <code class="ow">=</code> <code class="n">return</code> <code class="kt">Closed</code>
    <code class="p">,</code> <code class="n">sourceClose</code> <code class="ow">=</code> <code class="n">return</code> <code class="nb">()</code>
    <code class="p">}</code>

<code class="cm">-- | Always give the same value</code>
<code class="nf">repeat</code> <code class="ow">::</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Source</code> <code class="n">m</code> <code class="n">a</code>
<code class="nf">repeat</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Source</code>
    <code class="p">{</code> <code class="n">sourcePull</code> <code class="ow">=</code> <code class="n">return</code> <code class="o">$</code> <code class="kt">Open</code> <code class="p">(</code><code class="n">repeat</code> <code class="n">a</code><code class="p">)</code> <code class="n">a</code>
    <code class="p">,</code> <code class="n">sourceClose</code> <code class="ow">=</code> <code class="n">return</code> <code class="nb">()</code>
    <code class="p">}</code>
</pre><p class="calibre7">These sources are very straightforward, since they always return the same results.
      Additionally, their close records don’t do anything. You might think that this is a bug:
      shouldn’t a call to <code class="literal">sourcePull</code> return <code class="literal">Closed</code> after it’s been closed? This isn’t required, since one of
      the rules of sources is that they can never be reused. In other words:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">If a <code class="literal">Source</code> returns <code class="literal">Open</code>, it has provided you with a new <code class="literal">Source</code>, which you should use in place of the original one.</p></li><li class="listitem"><p class="calibre7">If it returns <code class="literal">Closed</code>, then you cannot perform any more operations on
        it.</p></li></ul></div><p class="calibre7">Don’t worry too much about the invariant. In practice, you will almost never call
        <code class="literal">sourcePull</code> or <code class="literal">sourceClose</code> yourself. In fact, you hardly
      even write them yourself either (that’s what <code class="literal">sourceState</code> and
        <code class="literal">sourceIO</code> are for). The point is that we can make some assumptions when we
      implement our sources.</p><div class="book" title="State"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3099559" class="calibre1"></a>State</h2></div></div></div><p class="calibre7"></p><p class="calibre7">There is something similar about the two sources mentioned above: they never change. They
    <span class="firstname"><em class="calibre4">always</em></span> return the same value. In other words, they have no state. For almost all serious
   sources, we’ll need some kind of state.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">The state might actually be defined outside of our program. For example, if we write a
   source that reads data from a <code class="literal">Handle</code>, we don’t need to manually specify any
   state, since the <code class="literal">Handle</code> itself already has.</p></div><p class="calibre7">The way we store state in a source is by updating the returned <code class="literal">Source</code> value in
   the <code class="literal">Open</code> constructor. This is best seen with an example.</p><a id="I_programlisting_d1e9788" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Control.Monad.Trans.Resource</code>

<code class="cm">-- | Provide data from the list, one element at a time.</code>
<code class="nf">sourceList</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Source</code> <code class="n">m</code> <code class="n">a</code>
<code class="nf">sourceList</code> <code class="n">list</code> <code class="ow">=</code> <code class="kt">Source</code>
    <code class="p">{</code> <code class="n">sourcePull</code> <code class="ow">=</code>
        <code class="kr">case</code> <code class="n">list</code> <code class="kr">of</code>
            <code class="kt">[]</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="kt">Closed</code> <code class="cm">-- no more data</code>

            <code class="cm">-- This is where we store our state: by returning a new</code>
            <code class="cm">-- Source with the rest of the list</code>
            <code class="n">x</code><code class="kt">:</code><code class="n">xs</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="o">$</code> <code class="kt">Open</code> <code class="p">(</code><code class="n">sourceList</code> <code class="n">xs</code><code class="p">)</code> <code class="n">x</code>
        <code class="p">,</code> <code class="n">sourceClose</code> <code class="ow">=</code> <code class="n">return</code> <code class="nb">()</code>
        <code class="p">}</code>
</pre><p class="calibre7">Each time we pull from the source, it checks the input list. If the list is empty, pulling
   returns <code class="literal">Closed</code>, which makes sense. If the list is not empty, pulling returns
    <code class="literal">Open</code> with both the next value in the list, and a new <code class="literal">Source</code>
   value containing the rest of the input list.</p></div><div class="book" title="sourceState and sourceIO"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3099660" class="calibre1"></a>sourceState and sourceIO</h2></div></div></div><p class="calibre7"></p><p class="calibre7">In addition to being able to manually create <code class="literal">Source</code>s,
        we also have a few convenience functions that allow us to create most sources in a more
        high-level fashion. <code class="literal">sourceState</code> lets you write code
        similar to how you would use the <code class="literal">State</code> monad. You provide
        an initial state, your pull function is provided with the current state, and it returns a
        new state and a return value. Let’s use this to reimplement sourceList.</p><a id="I_programlisting_d1e9816" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Control.Monad.Trans.Resource</code>

<code class="cm">-- | Provide data from the list, one element at a time.</code>
<code class="nf">sourceList</code> <code class="ow">::</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Source</code> <code class="n">m</code> <code class="n">a</code>
<code class="nf">sourceList</code> <code class="n">state0</code> <code class="ow">=</code> <code class="n">sourceState</code>
    <code class="n">state0</code>
    <code class="n">pull</code>
  <code class="kr">where</code>
    <code class="n">pull</code> <code class="kt">[]</code> <code class="ow">=</code> <code class="n">return</code> <code class="kt">StateClosed</code>
    <code class="n">pull</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="n">return</code> <code class="o">$</code> <code class="kt">StateOpen</code> <code class="n">xs</code> <code class="n">x</code>
</pre><p class="calibre7">Notice the usage of the <code class="literal">StateClosed</code> and <code class="literal">StateOpen</code>
   constructors. These are very similar to <code class="literal">Closed</code> and <code class="literal">Open</code>, except
   that instead of specifying the next <code class="literal">Source</code> to be used, you provide the next
   state (here, the remainder of the list).</p><p class="calibre7">The other common activity is to perform some I/O allocation (like opening a file), registering
   some cleanup action (closing that file), and having a function for pulling data from that
   resource. <code class="literal">conduit</code> comes built-in with a <code class="literal">sourceFile</code> function
   that gives a stream of <code class="literal">ByteString</code>s. Let’s write a wildly inefficient alternative
   that returns a stream of characters.</p><a id="I_programlisting_d1e9846" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Control.Monad.Trans.Resource</code>
<code class="kr">import</code> <code class="nn">System.IO</code>
<code class="kr">import</code> <code class="nn">Control.Monad.IO.Class</code> <code class="p">(</code><code class="nf">liftIO</code><code class="p">)</code>

<code class="nf">sourceFile</code> <code class="ow">::</code> <code class="kt">ResourceIO</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">Source</code> <code class="n">m</code> <code class="kt">Char</code>
<code class="nf">sourceFile</code> <code class="n">fp</code> <code class="ow">=</code> <code class="n">sourceIO</code>
    <code class="p">(</code><code class="n">openFile</code> <code class="n">fp</code> <code class="kt">ReadMode</code><code class="p">)</code>
    <code class="n">hClose</code>
    <code class="p">(</code><code class="nf">\</code><code class="n">h</code> <code class="ow">-&gt;</code> <code class="n">liftIO</code> <code class="o">$</code> <code class="kr">do</code>
        <code class="n">eof</code> <code class="ow">&lt;-</code> <code class="n">hIsEOF</code> <code class="n">h</code>
        <code class="kr">if</code> <code class="n">eof</code>
            <code class="kr">then</code> <code class="n">return</code> <code class="kt">IOClosed</code>
            <code class="kr">else</code> <code class="n">fmap</code> <code class="kt">IOOpen</code> <code class="o">$</code> <code class="n">hGetChar</code> <code class="n">h</code><code class="p">)</code>
</pre><p class="calibre7">Like <code class="literal">sourceState</code>, it uses a variant on the <code class="literal">Open</code> and
    <code class="literal">Closed</code> constructors. <code class="literal">sourceIO</code> does a number of things for
   us:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">It registers the cleanup function with the <code class="literal">ResourceT</code> transformer, ensuring
    it gets called even in the presence of exceptions.</p></li><li class="listitem"><p class="calibre7">It sets up the <code class="literal">sourceClose</code> record to release the resource immediately.</p></li><li class="listitem"><p class="calibre7">As soon as you return <code class="literal">IOClosed</code>, it will release the resource.</p></li></ul></div></div></div></div>

{% endraw %}

