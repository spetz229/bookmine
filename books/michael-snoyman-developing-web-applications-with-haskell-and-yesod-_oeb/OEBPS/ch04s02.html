---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch04.html
next: OEBPS/ch04s03.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Types"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect14_d1e1262" class="calibre1"></a>Types</h1></div></div></div><p class="calibre7">Before we jump into syntax, let’s take a look at the various types involved. We mentioned
      in the introduction that types help protect us from XSS attacks. For example, let’s say that
      we have an HTML template that should display someone’s name; it might look like this:<a id="I_programlisting4_d1e1270" class="firstname"></a></p><pre class="programlistinghaskell">&lt;p&gt;Hello, my name is #{name}</pre><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7"><code class="literal">#{...}</code> is how we do variable interpolation in
          Shakespeare.</p></div><p class="calibre7">What should happen to <code class="literal">name</code>, and what should its data type be? A naive
      approach would be to use a <code class="literal">Text</code> value, and insert it
      verbatim. But that would give us quite a problem when <code class="literal">name="&lt;script src='http://nefarious.com/evil.js'&gt;&lt;/script&gt;"</code>. What we
      want is to be able to entity-encode the name, so that <code class="literal">&lt;</code>
      becomes <code class="literal">&amp;lt;</code>.</p><p class="calibre7">An equally naive approach is to simply entity-encode <span class="bold"><strong class="bold">every</strong></span> piece of text
   that gets embedded. What happens when you have some preexisting HTML generated from another
   process? For example, on the Yesod website, all Haskell code snippets are run through a
   colorizing function that wraps up words in appropriate <code class="literal">span</code> tags. If we
   entity escaped everything, code snippets would be completely unreadable!</p><p class="calibre7">Instead, we have an <code class="literal">Html</code> data type. In order to
      generate an <code class="literal">Html</code> value, we have two options for APIs: the
        <code class="literal">ToHtml</code> typeclass provides a way to convert <code class="literal">String</code> and <code class="literal">Text</code> values into
        <code class="literal">Html</code>, via its <code class="literal">toHtml</code>
      function, automatically escaping entities along the way. This would be the approach we’d want
      for the name above. For the code snippet example, we would use the preEscaped family of
      functions.</p><p class="calibre7">When you use variable interpolation in Hamlet (the HTML Shakespeare language), it
   automatically applies a <code class="literal">toHtml</code> call to the value inside. So if you interpolate a
    <code class="literal">String</code>, it will be entity-escaped. But if you provide an <code class="literal">Html</code>
   value, it will appear unmodified. In the code snippet example, we might interpolate with
   something like <code class="literal">#{preEscapedText myHaskellHtml}</code>.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">The <code class="literal">Html</code> data type, as well as the functions
        mentioned, are all provided by the <code class="function">blaze-html</code> package.
        This allows Hamlet to interact with all other blaze-html packages, and lets Hamlet provide a
        general solution for producing blaze-html values. Also, we get to take advantage of
        blaze-html’s amazing performance.</p></div><p class="calibre7">Similarly, we have <code class="literal">Css</code>/<code class="literal">ToCss</code>, as well as <code class="literal">Javascript</code>/<code class="literal">ToJavascript</code>. These provide some compile-time sanity checks that
      we haven’t accidentally stuck some HTML in our CSS.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">One other advantage on the CSS side is some helper data types for colors and units. For
        example: <code class="literal">.red { color: #{colorRed} }</code> Please
        see the Haddock documentation for more details.</p></div><div class="book" title="Type-Safe URLs"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3044260" class="calibre1"></a>Type-Safe URLs</h2></div></div></div><p class="calibre7">Possibly the most unique feature in Yesod is type-safe URLs, and the ability to use them
        conveniently is provided directly by Shakespeare. Usage is nearly identical to variable
        interpolation, we just use the at-sign (@) instead of the hash (#). We’ll cover the syntax
        later; first, let’s clarify the intuition.</p><p class="calibre7">Suppose we have an application with two routes: <em class="calibre4">http://example.com/profile/home</em> is the homepage, and <em class="calibre4">http://example.com/display/time</em> displays the current time. And let’s say we
        want to link from the homepage to the time. I can think of three different ways of
        constructing the URL:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre7">As a relative link: <em class="calibre4">../display/time</em></p></li><li class="listitem"><p class="calibre7">As an absolute link, without a domain: <em class="calibre4">/display/time</em></p></li><li class="listitem"><p class="calibre7">As an absolute link, with a domain: <em class="calibre4">http://example.com/display/time</em></p></li></ol></div><p class="calibre7">There are problems with each approach: the first will break if either URL changes. Also,
        it’s not suitable for all use cases; RSS and Atom feeds, for instance, require absolute
        URLs. The second is more resilient to change than the first, but still won’t be acceptable
        for RSS and Atom. And while the third works fine for all use cases, you’ll need to update
        every single URL in your application whenever your domain name changes. You think that
        doesn’t happen often? Just wait till you move from your development to staging and finally
        production server.</p><p class="calibre7">But more importantly, there is one huge problem with all approaches: if you change your
        routes at all, the compiler won’t warn you about the broken links. Not to mention that typos
        can wreak havoc as well.</p><p class="calibre7">The goal of type-safe URLs is to let the compiler check things for us as much as
        possible. In order to facilitate this, our first step must be to move away from plain old
        text, which the compiler doesn’t understand, to some well defined data types. For our simple
        application, let’s model our routes with a sum
        type:<a id="I_programlisting4_d1e1413" class="firstname"></a></p><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">MyRoute</code> <code class="ow">=</code> <code class="kt">Home</code> <code class="o">|</code> <code class="kt">Time</code>
</pre><p class="calibre7">Instead of placing a link like /display/time in our template, we can use the
    <code class="literal">Time</code> constructor. But at the end of the day, HTML is made up of text, not data
   types, so we need some way to convert these values to text. We call this a <em class="calibre4">URL
    rendering function</em>, and a simple one
   is:<a id="I_programlisting4_d1e1426" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">renderMyRoute</code> <code class="ow">::</code> <code class="kt">MyRoute</code> <code class="ow">-&gt;</code> <code class="kt">Text</code>
<code class="nf">renderMyRoute</code> <code class="kt">Home</code> <code class="ow">=</code> <code class="s">"http://example.com/profile/home"</code>
<code class="nf">renderMyRoute</code> <code class="kt">Time</code> <code class="ow">=</code> <code class="s">"http://example.com/display/time"</code>
</pre><p class="calibre7">
   </p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">URL rendering functions are actually a bit more complicated than this. They need to address
            query string parameters, handle records within the constructor, and more intelligently
            handle the domain name. But in practice, you don’t need to worry about this, since Yesod
            will automatically create your render functions. The one thing to point out is that the
            type signature is actually a little more complicated when handling query
            strings:<a id="I_programlisting4_d1e1433" class="firstname"></a></p><pre class="programlisting"><code class="kr">type</code> <code class="kt">Query</code> <code class="ow">=</code> <code class="p">[(</code><code class="kt">Text</code><code class="p">,</code> <code class="kt">Text</code><code class="p">)]</code>
<code class="kr">type</code> <code class="kt">Render</code> <code class="n">url</code> <code class="ow">=</code> <code class="n">url</code> <code class="ow">-&gt;</code> <code class="kt">Query</code> <code class="ow">-&gt;</code> <code class="kt">Text</code>
<code class="nf">renderMyRoute</code> <code class="ow">::</code> <code class="kt">Render</code> <code class="kt">MyRoute</code>
<code class="nf">renderMyRoute</code> <code class="kt">Home</code> <code class="kr">_</code> <code class="ow">=</code> <code class="o">...</code>
<code class="nf">renderMyRoute</code> <code class="kt">Time</code> <code class="kr">_</code> <code class="ow">=</code> <code class="o">...</code>
</pre></div><p class="calibre7">
  </p><p class="calibre7">OK, we have our render function, and we have type-safe URLs embedded in the templates.
        How does this fit together exactly? Instead of generating an <code class="literal">Html</code> (or <code class="literal">Css</code> or <code class="literal">Javascript</code>) value directly, Shakespearean templates actually produce a
        function, which takes this render function and produces HTML. To see this better, let’s have
        a quick (fake) peek at how Hamlet would work under the surface. Supposing we had a
        template:<a id="I_programlisting4_d1e1447" class="firstname"></a></p><pre class="programlistinghaskell">&lt;a href=@{Time}&gt;The time</pre><p class="calibre7">this
        would translate roughly into the Haskell
        code:<a id="I_programlisting4_d1e1450" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">\</code><code class="n">render</code> <code class="ow">-&gt;</code> <code class="n">mconcat</code> <code class="p">[</code><code class="s">"&lt;a href='"</code><code class="p">,</code> <code class="n">render</code> <code class="kt">Time</code><code class="p">,</code> <code class="s">"'&gt;The time&lt;/a&gt;"</code><code class="p">]</code>
</pre></div></div></div>

{% endraw %}

