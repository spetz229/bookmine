---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch05s05.html
next: OEBPS/ch05s07.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="whamlet"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect15_d1e2209" class="calibre1"></a>whamlet</h1></div></div></div><p class="calibre7">Let’s say you’ve got a fairly standard Hamlet template that embeds another Hamlet template
      to represent the footer:</p><a id="I_programlisting5_d1e2214" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">page</code> <code class="ow">=</code> <code class="p">[</code><code class="n">hamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code><code class="kt">This</code> <code class="n">is</code> <code class="n">my</code> <code class="n">page</code><code class="o">.</code> <code class="kt">I</code> <code class="n">hope</code> <code class="n">you</code> <code class="n">enjoyed</code> <code class="n">it</code><code class="o">.</code>
<code class="o">^</code><code class="p">{</code><code class="n">footer</code><code class="p">}</code>
<code class="o">|</code><code class="p">]</code>

<code class="nf">footer</code> <code class="ow">=</code> <code class="p">[</code><code class="n">hamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">footer</code><code class="o">&gt;</code>
    <code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code><code class="kt">That's</code> <code class="n">all</code> <code class="n">folks</code><code class="o">!</code>
<code class="o">|</code><code class="p">]</code>
</pre><p class="calibre7">That works fine if the footer is plain old HTML, but what if we want to add some style? Well,
   we can easily spice up the footer by turning it into a Widget:</p><a id="I_programlisting5_d1e2218" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">footer</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">toWidget</code> <code class="p">[</code><code class="n">lucius</code><code class="o">|</code> <code class="n">footer</code> <code class="p">{</code> <code class="n">font</code><code class="o">-</code><code class="n">weight</code><code class="kt">:</code> <code class="n">bold</code><code class="p">;</code> <code class="n">text</code><code class="o">-</code><code class="n">align</code><code class="kt">:</code> <code class="n">center</code> <code class="p">}</code> <code class="o">|</code><code class="p">]</code>
    <code class="n">toWidget</code> <code class="p">[</code><code class="n">hamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">footer</code><code class="o">&gt;</code>
    <code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code><code class="kt">That's</code> <code class="n">all</code> <code class="n">folks</code><code class="o">!</code>
<code class="o">|</code><code class="p">]</code>
</pre><p class="calibre7">But now we’ve got a problem: a Hamlet template can only embed another Hamlet template; it
      knows nothing about a Widget. This is where <code class="literal">whamlet</code> comes
      in. It takes exactly the same syntax as normal Hamlet, and variable (#{...}) and URL (@{...})
      interpolation are unchanged. But embedding (^{...}) takes a <code class="literal">Widget</code>, and the final result is a <code class="literal">Widget</code>. To
      use it, we can just do:</p><a id="I_programlisting5_d1e2231" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">page</code> <code class="ow">=</code> <code class="p">[</code><code class="n">whamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code><code class="kt">This</code> <code class="n">is</code> <code class="n">my</code> <code class="n">page</code><code class="o">.</code> <code class="kt">I</code> <code class="n">hope</code> <code class="n">you</code> <code class="n">enjoyed</code> <code class="n">it</code><code class="o">.</code>
<code class="o">^</code><code class="p">{</code><code class="n">footer</code><code class="p">}</code>
<code class="o">|</code><code class="p">]</code>
</pre><p class="calibre7">There is also <code class="literal">whamletFile</code>, if you would prefer to keep your template
      in a separate file.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">The scaffolded site has an even more convenient function, <code class="literal">widgetFile</code>, which will also include your Lucius, Cassius, and Julius files
        automatically. We’ll cover that in the scaffolding chapter.</p></div><div class="book" title="Types"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3065356" class="calibre1"></a>Types</h2></div></div></div><p class="calibre7">You may have noticed that I’ve been avoiding type signatures so far. That’s because
        there’s a little bit of a complication involved here. At the most basic level, all you need
        to know is that there’s a type synonym called <code class="literal">Widget</code>
        which you will almost always use. The technical details follow, but don’t worry if it’s a
        little hazy.</p><p class="calibre7">There isn’t actually a <code class="literal">Widget</code> type defined in the
        Yesod libraries, since the exact meaning of it changes between sites. Instead, we have a
        more general type <code class="literal">GWidget sub master a</code>. The first two
        parameters give the sub and master foundation types, respectively. The final parameter is
        the contained value, just like any <code class="literal">Monad</code> has.</p><p class="calibre7">So what’s the deal with that sub/master stuff? Well, when you’re writing some reusable
        code, such as a CRUD application, you can write it as a subsite that can be embedded within
        any other Yesod application. In such a case, we need to keep track of information for both
        the sub and master sites. The simplest example is for the type-safe URLs: Yesod needs to
        know how to take a route for your CRUD subsite and turn it into a route for the master site
        so that it can be properly rendered.</p><p class="calibre7">However, that sub/master distinction only ever matters when you’re interacting with
        subsites. When you’re writing your standard response code, you’re dealing with just your
        application, and so the sub and master sites will be the same. Since this is the most common
        case, the scaffolded site declares a type synonym to help you out. Let’s say your foundation
        type is MyCoolApp, it will define <code class="literal">type Widget = GWidget MyCoolApp
          MyCoolApp ()</code>. Therefore, we can get some very user-friendly type signatures on
        our widgets:</p><a id="I_programlisting5_d1e2270" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">footer</code> <code class="ow">::</code> <code class="kt">Widget</code>
<code class="nf">footer</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">toWidget</code> <code class="p">[</code><code class="n">lucius</code><code class="o">|</code> <code class="n">footer</code> <code class="p">{</code> <code class="n">font</code><code class="o">-</code><code class="n">weight</code><code class="kt">:</code> <code class="n">bold</code><code class="p">;</code> <code class="n">text</code><code class="o">-</code><code class="n">align</code><code class="kt">:</code> <code class="n">center</code> <code class="p">}</code> <code class="o">|</code><code class="p">]</code>
    <code class="n">toWidget</code> <code class="p">[</code><code class="n">hamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">footer</code><code class="o">&gt;</code>
    <code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code><code class="kt">That's</code> <code class="n">all</code> <code class="n">folks</code><code class="o">!</code>
<code class="o">|</code><code class="p">]</code>

<code class="nf">page</code> <code class="ow">::</code> <code class="kt">Widget</code>
<code class="nf">page</code> <code class="ow">=</code> <code class="p">[</code><code class="n">whamlet</code><code class="o">|</code>
<code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code><code class="kt">This</code> <code class="n">is</code> <code class="n">my</code> <code class="n">page</code><code class="o">.</code> <code class="kt">I</code> <code class="n">hope</code> <code class="n">you</code> <code class="n">enjoyed</code> <code class="n">it</code><code class="o">.</code>
<code class="o">^</code><code class="p">{</code><code class="n">footer</code><code class="p">}</code>
<code class="o">|</code><code class="p">]</code>
</pre><p class="calibre7">If you’ve been paying close attention, you might be confused. We used <code class="literal">lift</code> on <code class="literal">Widget</code> in the ID
        generation example above, but <code class="literal">GWidget</code> isn’t actually a
        monad transformer. What’s going on here? Well, in older versions of Yesod, it
          <span class="firstname"><em class="calibre4">was</em></span> a transformer around the <code class="literal">Handler</code> type. Unfortunately, this led to difficult-to-parse error messages. As
        a result, <code class="literal">GWidget</code> is now a <code class="literal">newtype</code> wrapper that hides away its monad-transformer essence. But we still
        want to be able to <code class="literal">lift</code> functions from the inner <code class="literal">Handler</code> monad.</p><p class="calibre7">To solve this, Yesod provides an alternate, more general <code class="literal">lift</code> function that
   works for both standard <code class="literal">MonadTrans</code> instances, and special
    <code class="literal">newtype</code> wrappers like <code class="literal">GWidget</code>. As a result, you can pretend
   like <code class="literal">GWidget</code> is a standard transformer, while still getting to keep your nice
   error message.</p><p class="calibre7">One last point: just like we have the breakdown between <code class="literal">Widget</code> and
    <code class="literal">GWidget</code>, we have a similar breakdown between <code class="literal">Handler</code> and
    <code class="literal">GHandler</code>.</p></div></div></div>

{% endraw %}

