---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apas04.html
next: OEBPS/apas06.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Lost State"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e9014" class="calibre1"></a>Lost State</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Let’s rewind a bit to our onExceptionError. It uses onException under the surface,
   which has a type signature: <code class="literal">IO a -&gt; IO b -&gt; IO a</code>. Let me ask you
   something: what happened to the b in the output? Well, it was thoroughly ignored. But that seems
   to cause us a bit of a problem. After all, we store our transformer state information in the
   value of the inner monad. If we ignore it, we’re essentially ignoring the monadic side effects as
   well!</p><p class="calibre7">And the answer is that, yes, this does happen with monad-control. Certain functions
   will drop some of the monadic side effects. This is put best by Bas, in the comments on the
   relevant functions:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre27">Note, any monadic side effects in m of the “release” computation
    will be discarded; it is run only for its side effects in IO.</p></blockquote></div><p class="calibre7">In practice, monad-control
   will usually be doing the right thing for you, but you need to be aware that some side effects
   may disappear.</p></div></div>

{% endraw %}

