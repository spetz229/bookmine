---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apas03.html
next: OEBPS/apas05.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Real Life Examples"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e8999" class="calibre1"></a>Real Life Examples</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Let’s solve some real-life problems with this code. Probably the biggest motivating use case is
   exception handling in a transformer stack. For example, let’s say that we want to automatically
   run some cleanup code when an exception is thrown. If this were normal IO code, we’d
   use:<a id="I_programlisting_d1e9005" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">onException</code><code class="err"> </code><code class="ow">::</code><code class="err"> </code><code class="kt">IO</code><code class="err"> </code><code class="n">a</code> <code class="ow">-&gt;</code><code class="err"> </code><code class="kt">IO</code><code class="err"> </code><code class="n">b</code> <code class="ow">-&gt;</code><code class="err"> </code><code class="kt">IO</code><code class="err"> </code><code class="n">a</code>
</pre><p class="calibre7">But if we’re
   in the ErrorT monad, we can’t pass in either the action or the cleanup. In comes controlIO to the
   rescue:<a id="I_programlisting_d1e9008" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">onExceptionError</code> <code class="ow">::</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">a</code>
                 <code class="ow">-&gt;</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">b</code>
                 <code class="ow">-&gt;</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">onExceptionError</code> <code class="n">action</code> <code class="n">after</code> <code class="ow">=</code> <code class="n">controlIO</code> <code class="o">$</code> <code class="nf">\</code><code class="n">run</code> <code class="ow">-&gt;</code>
    <code class="n">run</code> <code class="n">action</code> <code class="p">`</code><code class="n">onException</code><code class="p">`</code> <code class="n">run</code> <code class="n">after</code>
</pre><p class="calibre7">Let’s say we need to allocate some memory to store a Double in. In the IO monad, we could just
   use the alloca function. Once again, our solution is
   simple:<a id="I_programlisting_d1e9012" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">allocaError</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Ptr</code> <code class="kt">Double</code> <code class="ow">-&gt;</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">b</code><code class="p">)</code>
            <code class="ow">-&gt;</code> <code class="kt">ErrorT</code> <code class="kt">MyError</code> <code class="kt">IO</code> <code class="n">b</code>
<code class="nf">allocaError</code> <code class="n">f</code> <code class="ow">=</code> <code class="n">controlIO</code> <code class="o">$</code> <code class="nf">\</code><code class="n">run</code> <code class="ow">-&gt;</code> <code class="n">alloca</code> <code class="o">$</code> <code class="n">run</code> <code class="o">.</code> <code class="n">f</code>
</pre></div></div>

{% endraw %}

