---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch10s09.html
next: OEBPS/ch10s11.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Custom Fields"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect110_d1e5861" class="calibre1"></a>Custom Fields</h1></div></div></div><p class="calibre7">Occassionally, you will want to define a custom field to be used in your datastore. The most common case is an enumeration, such as employment status. For this, Persistent provides a helper Template Haskell function:</p><a id="I_programlisting10_d1e5866" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,</code>
<code class="cm">             OverloadedStrings, GADTs, FlexibleContexts #-}</code>
<code class="kr">import</code> <code class="nn">Database.Persist</code>
<code class="kr">import</code> <code class="nn">Database.Persist.Sqlite</code>
<code class="kr">import</code> <code class="nn">Database.Persist.TH</code>

<code class="kr">data</code> <code class="kt">Employment</code> <code class="ow">=</code> <code class="kt">Employed</code> <code class="o">|</code> <code class="kt">Unemployed</code> <code class="o">|</code> <code class="kt">Retired</code>
    <code class="kr">deriving</code> <code class="p">(</code><code class="kt">Show</code><code class="p">,</code> <code class="kt">Read</code><code class="p">,</code> <code class="kt">Eq</code><code class="p">)</code>
<code class="nf">derivePersistField</code> <code class="s">"Employment"</code>

<code class="nf">share</code> <code class="p">[</code><code class="n">mkPersist</code> <code class="n">sqlSettings</code><code class="p">,</code> <code class="n">mkMigrate</code> <code class="s">"migrateAll"</code><code class="p">]</code> <code class="p">[</code><code class="n">persist</code><code class="o">|</code>
<code class="kt">Person</code>
    <code class="n">name</code> <code class="kt">String</code>
    <code class="n">employment</code> <code class="kt">Employment</code>
<code class="o">|</code><code class="p">]</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="n">withSqliteConn</code> <code class="s">":memory:"</code> <code class="o">$</code> <code class="n">runSqlConn</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">runMigration</code> <code class="n">migrateAll</code>

    <code class="n">insert</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"Bruce Wayne"</code> <code class="kt">Retired</code>
    <code class="n">insert</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"Peter Parker"</code> <code class="kt">Unemployed</code>
    <code class="n">insert</code> <code class="o">$</code> <code class="kt">Person</code> <code class="s">"Michael"</code> <code class="kt">Employed</code>
</pre><p class="calibre7"><code class="literal">derivePersistField</code> stores the data in the database using a string
            field, and performs marshaling using the <code class="literal">Show</code> and <code class="literal">Read</code>
            instances of the data type. This may not be as efficient as storing via an integer, but
            it is much more future proof: even if you add extra constructors in the future, your
            data will still be valid.</p></div></div>

{% endraw %}

