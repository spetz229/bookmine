---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apbs06.html
next: OEBPS/apc.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Buffering"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e10341" class="calibre1"></a>Buffering</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Buffering is one of the unique features of conduits. With buffering, conduits no longer need to
   control the flow of your application. In some cases, this can lead to simpler code.</p><div class="book" title="Inversion of Control"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3101294" class="calibre1"></a>Inversion of Control</h2></div></div></div><p class="calibre7"></p><p class="calibre7">Buffering was actually one of the main motivations in the creation of the
    <code class="literal">conduit</code> package. To see its importance, we need to consider the approach we’ve
   seen so far, which we’ll call inversion of control, or IoC.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">Inversion of control can mean different things in different circles. If you object to its
   usage here, go ahead replace it with some other phrase like “warm, fuzzy thing.” I won’t be
   offended.</p></div><p class="calibre7">Suppose you want to count how many newline characters there are in a file. In the
        standard imperative approach, you would do something like:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre7">Open the file.</p></li><li class="listitem"><p class="calibre7">Pull some data into a buffer.</p></li><li class="listitem"><p class="calibre7">Loop over the values in the buffer, incrementing a counter on each newline
            character.</p></li><li class="listitem"><p class="calibre7">Return to 2.</p></li><li class="listitem"><p class="calibre7">Close the file.</p></li></ol></div><p class="calibre7">Notice that your code is explicitly calling out to other code, and that code is
        returning control back to your code. You have retained full control of the flow of execution
        of your program. The conduit approach we’ve seen so far does <span class="firstname"><em class="calibre4">not</em></span> work
        this way. Instead, you would:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre7">Write a sink that counts newlines and adds the result to an accumulator.</p></li><li class="listitem"><p class="calibre7">Connect the sink to a source.</p></li></ol></div><p class="calibre7">There’s no doubt in my mind that this is an easier approach. You don’t have to worry about
   opening and closing files or pulling data from the file. Instead, the data you need to process is
   simply presented to you. This is the advantage of IoC: you can focus on specifically your piece
   of the code.</p><p class="calibre7">We use this IoC approach all over Haskell: for example, instead of <code class="literal">readMVar</code>
   and <code class="literal">putMVar</code>, you can use <code class="literal">withMVar</code>. Don’t bother with
    <code class="literal">openFile</code> and <code class="literal">closeFile</code>, just use <code class="literal">withFile</code> and
   pass in a function that uses the <code class="literal">Handle</code>. Even C has a version of this: why
    <code class="literal">malloc</code> and <code class="literal">free</code> when you could just
   <code class="literal">alloca</code>?</p><p class="calibre7">Actually, that last one is a huge red herring. Of course you can’t just use
    <code class="literal">alloca</code> for everything. <code class="literal">alloca</code> only allocates memory locally on
   the stack, not dynamically on the heap. There’s no way to return your allocated memory outside
   the current function.</p><p class="calibre7">But actually, the same restriction applies to the whole family of <code class="literal">with</code> functions: you can never return an allocated resource
        outside of the “block.” Usually this works out just fine, but we need to recognize that this
          <span class="firstname"><em class="calibre4">is</em></span> a change in how we structure our programs. Oftentimes, with simple
        examples, this is a minor change. However, in larger settings this can become very difficult
        to manage, bordering on impossible at times.</p><div class="book" title="A web server"><div class="book"><div class="book"><div class="book"><h3 class="title5"><a id="id3101509" class="calibre1"></a>A web server</h3></div></div></div><p class="calibre7"></p><p class="calibre7">Let’s say we’re going to write a web server. We’re going to use the following low-level
   operations:</p><a id="I_programlisting_d1e10453" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Socket</code>
<code class="nf">recv</code>    <code class="ow">::</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">ByteString</code> <code class="cm">-- returns empty when the socket is closed</code>
<code class="nf">sendAll</code> <code class="ow">::</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">ByteString</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
</pre><p class="calibre7">We’re up to the part where we need to implement the function <code class="literal">handleConn</code> that
   handles an individual connection. It will look something like this:</p><a id="I_programlisting_d1e10460" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">Request</code>  <code class="cm">-- request headers, HTTP version, etc</code>
<code class="kr">data</code> <code class="kt">Response</code> <code class="cm">-- status code, response headers, response body</code>
<code class="kr">type</code> <code class="kt">Application</code> <code class="ow">=</code> <code class="kt">Request</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">Response</code>
<code class="nf">handleConn</code> <code class="ow">::</code> <code class="kt">Application</code> <code class="ow">-&gt;</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
</pre><p class="calibre7">What does our <code class="literal">handleConn</code> need to do? In broad strokes:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre7">Parse the request line.</p></li><li class="listitem"><p class="calibre7">Parse the request headers.</p></li><li class="listitem"><p class="calibre7">Construct the <code class="literal">Request</code> value.</p></li><li class="listitem"><p class="calibre7">Pass <code class="literal">Request</code> to the <code class="literal">Application</code> and get back a <code class="literal">Response</code>.</p></li><li class="listitem"><p class="calibre7">Send the <code class="literal">Response</code> over the <code class="literal">Socket</code>.</p></li></ol></div><p class="calibre7">We start off by writing steps 1 and 2 manually, without using conduits. We’ll do this very
   simply and just assume three space-separated strings. We end up with something that looks
   like:</p><a id="I_programlisting_d1e10507" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">RequestLine</code> <code class="ow">=</code> <code class="kt">RequestLine</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code>

<code class="nf">parseRequestLine</code> <code class="ow">::</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">RequestLine</code>
<code class="nf">parseRequestLine</code> <code class="n">socket</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">bs</code> <code class="ow">&lt;-</code> <code class="n">recv</code> <code class="n">socket</code> <code class="mi">4096</code>
    <code class="kr">let</code> <code class="p">(</code><code class="n">method</code><code class="kt">:</code><code class="n">path</code><code class="kt">:</code><code class="n">version</code><code class="kt">:</code><code class="n">ignored</code><code class="p">)</code> <code class="ow">=</code> <code class="kt">S8</code><code class="o">.</code><code class="n">words</code> <code class="n">bs</code>
    <code class="n">return</code> <code class="o">$</code> <code class="kt">RequestLine</code> <code class="n">method</code> <code class="n">path</code> <code class="n">version</code>
</pre><p class="calibre7">There are two issues here: it doesn’t handle the case where there are fewer than three
          words in the chunk of data, and it throws away any extra data. We can definitely solve
          both of these issues manually, but it’s very tedious. It’s much easier to implement this
          in terms of conduits.</p><a id="I_programlisting_d1e10512" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Data.ByteString</code> <code class="p">(</code><code class="kt">ByteString</code><code class="p">)</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.ByteString</code> <code class="kr">as</code> <code class="n">S</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Conduit.Binary</code> <code class="kr">as</code> <code class="n">CB</code>
<code class="kr">import</code> <code class="kr">qualified</code> <code class="nn">Data.Conduit.List</code> <code class="kr">as</code> <code class="n">CL</code>

<code class="kr">data</code> <code class="kt">RequestLine</code> <code class="ow">=</code> <code class="kt">RequestLine</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code>

<code class="nf">parseRequestLine</code> <code class="ow">::</code> <code class="kt">Sink</code> <code class="kt">ByteString</code> <code class="kt">IO</code> <code class="kt">RequestLine</code>
<code class="nf">parseRequestLine</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="kr">let</code> <code class="n">space</code> <code class="ow">=</code> <code class="n">toEnum</code> <code class="o">$</code> <code class="n">fromEnum</code> <code class="s">' '</code>
    <code class="kr">let</code> <code class="n">getWord</code> <code class="ow">=</code> <code class="kr">do</code>
            <code class="kt">CB</code><code class="o">.</code><code class="n">dropWhile</code> <code class="p">(</code><code class="o">==</code> <code class="n">space</code><code class="p">)</code>
            <code class="n">bss</code> <code class="ow">&lt;-</code> <code class="kt">CB</code><code class="o">.</code><code class="n">takeWhile</code> <code class="p">(</code><code class="o">/=</code> <code class="n">space</code><code class="p">)</code> <code class="o">=$</code> <code class="kt">CL</code><code class="o">.</code><code class="n">consume</code>
            <code class="n">return</code> <code class="o">$</code> <code class="kt">S</code><code class="o">.</code><code class="n">concat</code> <code class="n">bss</code>

    <code class="n">method</code> <code class="ow">&lt;-</code> <code class="n">getWord</code>
    <code class="n">path</code> <code class="ow">&lt;-</code> <code class="n">getWord</code>
    <code class="n">version</code> <code class="ow">&lt;-</code> <code class="n">getWord</code>
    <code class="n">return</code> <code class="o">$</code> <code class="kt">RequestLine</code> <code class="n">method</code> <code class="n">path</code> <code class="n">version</code>
</pre><p class="calibre7">This means that our code will automatically be supplied with more data as it comes in, and any
   extra data will automatically be buffered in the <code class="literal">Source</code>, ready for the next time
   it’s used. Now we can easily structure our program together, demonstrating the power of the
   conduits approach:</p><a id="I_programlisting_d1e10519" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Data.ByteString</code> <code class="p">(</code><code class="kt">ByteString</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Data.Conduit.Network</code> <code class="p">(</code><code class="nf">sourceSocket</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Control.Monad.IO.Class</code> <code class="p">(</code><code class="nf">liftIO</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Network.Socket</code> <code class="p">(</code><code class="kt">Socket</code><code class="p">)</code>

<code class="kr">data</code> <code class="kt">RequestLine</code> <code class="ow">=</code> <code class="kt">RequestLine</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code>
<code class="kr">type</code> <code class="kt">Headers</code> <code class="ow">=</code> <code class="p">[(</code><code class="kt">ByteString</code><code class="p">,</code> <code class="kt">ByteString</code><code class="p">)]</code>
<code class="kr">data</code> <code class="kt">Request</code> <code class="ow">=</code> <code class="kt">Request</code> <code class="kt">RequestLine</code> <code class="kt">Headers</code>
<code class="kr">data</code> <code class="kt">Response</code> <code class="ow">=</code> <code class="kt">Response</code>
<code class="kr">type</code> <code class="kt">Application</code> <code class="ow">=</code> <code class="kt">Request</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">Response</code>

<code class="nf">parseRequestHeaders</code> <code class="ow">::</code> <code class="kt">Sink</code> <code class="kt">ByteString</code> <code class="kt">IO</code> <code class="kt">Headers</code>
<code class="nf">parseRequestHeaders</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">parseRequestLine</code> <code class="ow">::</code> <code class="kt">Sink</code> <code class="kt">ByteString</code> <code class="kt">IO</code> <code class="kt">RequestLine</code>
<code class="nf">parseRequestLine</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">sendResponse</code> <code class="ow">::</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">Response</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">sendResponse</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">handleConn</code> <code class="ow">::</code> <code class="kt">Application</code> <code class="ow">-&gt;</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">handleConn</code> <code class="n">app</code> <code class="n">socket</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">req</code> <code class="ow">&lt;-</code> <code class="n">runResourceT</code> <code class="o">$</code> <code class="n">sourceSocket</code> <code class="n">socket</code> <code class="o">$$</code> <code class="kr">do</code>
        <code class="n">requestLine</code> <code class="ow">&lt;-</code> <code class="n">parseRequestLine</code>
        <code class="n">headers</code> <code class="ow">&lt;-</code> <code class="n">parseRequestHeaders</code>
        <code class="n">return</code> <code class="o">$</code> <code class="kt">Request</code> <code class="n">requestLine</code> <code class="n">headers</code>
    <code class="n">res</code> <code class="ow">&lt;-</code> <code class="n">liftIO</code> <code class="o">$</code> <code class="n">app</code> <code class="n">req</code>
    <code class="n">liftIO</code> <code class="o">$</code> <code class="n">sendResponse</code> <code class="n">socket</code> <code class="n">res</code>
</pre></div><div class="book" title="Whither the request body?"><div class="book"><div class="book"><div class="book"><h3 class="title5"><a id="id3101747" class="calibre1"></a>Whither the request body?</h3></div></div></div><p class="calibre7"></p><p class="calibre7">This is all great, until we realize <span class="firstname"><em class="calibre4">we can’t read the request body</em></span>. The
    <code class="literal">Application</code> is simply given the <code class="literal">Request</code>, and lives in the
    <code class="literal">IO</code> monad. It has no access whatsoever to the incoming stream of data.</p><p class="calibre7">There’s an easy fix for this actually: have the <code class="literal">Application</code> live in the
    <code class="literal">Sink</code> monad. This is the very approach we took with
    <code class="function">enumerator</code>-based WAI 0.4. However, there are two problems:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">People find it confusing. What people <span class="firstname"><em class="calibre4">expect</em></span> is that the <code class="literal">Request</code>
    value would have a <code class="literal">requestBody</code> value of type <code class="literal">Source</code>.</p></li><li class="listitem"><p class="calibre7">This makes certain kinds of usage incredibly difficult. For example, trying to write an HTTP
    proxy combining WAI and <code class="literal">http-enumerator</code> proved to be almost impossible.</p></li></ul></div><p class="calibre7">This is the downside of inversion of control. Our code wants to be in control. It wants to be
   given something to pull from, something to push to, and run with it. We need some solution to the
   problem.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">If you think the situation I described with the proxy isn’t so bad, it’s because
            I’ve gone easy on the details. We also need to take into account streaming the response
            body, and the streaming needs to happen on both the client and server side.</p></div><p class="calibre7">The simplest solution would be to just create a new <code class="literal">Source</code> and pass that to
          the <code class="literal">Application</code>. Unfortunately, this will cause problems with our buffering. You
   see, when we connect our source to the <code class="literal">parseRequestLine</code> and
    <code class="literal">parseRequestHeaders</code> sinks, it made a call to <code class="literal">recv</code>. If the data
   it received was not enough to cover all of the headers, it would issue another call. When it had
   enough data, it would stop. However, odds are that it didn’t stop <span class="firstname"><em class="calibre4">exactly</em></span> at the end of
   the headers. It likely consumed a bit of the request body as well.</p><p class="calibre7">If we just create a new source and pass that to the request, it will be missing the beginning
   of the request body. We need some way to pass that buffered data along.</p></div></div><div class="book" title="BufferedSource"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3101916" class="calibre1"></a>BufferedSource</h2></div></div></div><p class="calibre7"></p><p class="calibre7">And so we finally get to introduce the last data type in conduits:
    <code class="literal">BufferedSource</code>. This is an abstract data type, but all it really does is keep a
   mutable reference to a buffer and an underlying <code class="literal">Source</code>. In order to create one
   of these, you use the <code class="literal">bufferSource</code> function.</p><a id="I_programlisting_d1e10619" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">bufferSource</code><code class="err"> </code><code class="ow">::</code><code class="kt">Resource</code><code class="err"> </code><code class="n">m</code> <code class="ow">=&gt;</code><code class="err"> </code><code class="kt">Source</code><code class="err"> </code><code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code><code class="err"> </code><code class="kt">ResourceT</code><code class="err"> </code><code class="n">m</code> <code class="p">(</code><code class="kt">BufferedSource</code><code class="err"> </code><code class="n">m</code> <code class="n">a</code><code class="p">)</code>
</pre><p class="calibre7">This one little change is what allows us to easily solve our web server dilemma. Instead
        of connecting a <code class="literal">Source</code> to our parsing <code class="literal">Sink</code>s, we use a <code class="literal">BufferedSource</code>. At the end of each connection, any leftover data is put back on
        the buffer. For our web server case, we can now create a <code class="literal">BufferedSource</code>, use that to read the request line and headers, and then pass
        that same <code class="literal">BufferedSource</code> to the application for reading
        the request body.</p></div><div class="book" title="Typeclass"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3101993" class="calibre1"></a>Typeclass</h2></div></div></div><p class="calibre7"></p><p class="calibre7">We want to be able to connect a buffered source to a sink, just like we would a regular
        source. We would also like to be able to fuse it to a conduit. In order to make this
        convenient,
        conduit
        has a typeclass, <code class="literal">IsSource</code>. There are instances provided
        for both <code class="literal">Source</code> and <code class="literal">BufferedSource</code>. Both the connect (<code class="literal">$$</code>) and
        left-fuse (<code class="literal">$=</code>) operators use this typeclass.</p><p class="calibre7">There’s one “gotcha” in the <code class="literal">BufferedSource</code> instance of this typeclass, so
   let’s explain it. Suppose we want to write a file copy function, without any buffering. This is a
   fairly standard usage of conduits:</p><a id="I_programlisting_d1e10669" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">sourceFile</code> <code class="n">input</code> <code class="o">$$</code> <code class="n">sinkFile</code> <code class="n">output</code>
</pre><p class="calibre7">When this line is run, both the input and output files are opened, the data is copied, and then
   both files are closed. Let’s change this example slightly to use buffering:</p><a id="I_programlisting_d1e10673" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">bsrc</code> <code class="ow">&lt;-</code> <code class="n">bufferSource</code> <code class="o">$</code> <code class="n">sourceFile</code> <code class="n">input</code>
<code class="nf">bsrc</code> <code class="o">$$</code> <code class="n">isolate</code> <code class="mi">50</code> <code class="o">=$</code> <code class="n">sinkFile</code> <code class="n">output1</code>
<code class="nf">bsrc</code> <code class="o">$$</code> <code class="n">sinkFile</code> <code class="n">output2</code>
</pre><p class="calibre7">When is the input file opened and closed? The opening occurs on the first line, when buffering
   the source. And if we follow the normal rules from sources, the file should be closed after the
   second line. However, if we did that, we couldn’t reuse <code class="literal">bsrc</code> for line 3!</p><p class="calibre7">So instead, <code class="literal">$$</code> does <span class="firstname"><em class="calibre4">not</em></span> close the file. As a result, you can pass a
   buffered source to as many actions as you want, without concerns that the file handle has been
   closed out from under you.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">If you remember from earlier, the invariant of a source is that it cannot be pulled from
   after it returns a <code class="literal">Closed</code> response. In order to allow you to work more easily
   with a <code class="literal">BufferedSource</code>, this invariant is relaxed. It is the responsibility of
   the <code class="literal">BufferSource</code> implementation to ensure that after the underlying
    <code class="literal">Source</code> is closed, it is never used again.</p></div><p class="calibre7">This presents one caveat: when you’re finished with a buffered source, you should manually call
    <code class="literal">bsourceClose</code> on it. However, as usual, this is merely an optimization, as the
   source will automatically be closed when <code class="literal">runResourceT</code> is called.</p></div><div class="book" title="Recapping the Web Server"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3102166" class="calibre1"></a>Recapping the Web Server</h2></div></div></div><p class="calibre7"></p><p class="calibre7">So what exactly does our web server look like now?</p><a id="I_programlisting_d1e10717" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">Data.ByteString</code> <code class="p">(</code><code class="kt">ByteString</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Data.Conduit.Network</code> <code class="p">(</code><code class="nf">sourceSocket</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Control.Monad.IO.Class</code> <code class="p">(</code><code class="nf">liftIO</code><code class="p">)</code>
<code class="kr">import</code> <code class="nn">Network.Socket</code> <code class="p">(</code><code class="kt">Socket</code><code class="p">)</code>

<code class="kr">data</code> <code class="kt">RequestLine</code> <code class="ow">=</code> <code class="kt">RequestLine</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code> <code class="kt">ByteString</code>
<code class="kr">type</code> <code class="kt">Headers</code> <code class="ow">=</code> <code class="p">[(</code><code class="kt">ByteString</code><code class="p">,</code> <code class="kt">ByteString</code><code class="p">)]</code>
<code class="kr">data</code> <code class="kt">Request</code> <code class="ow">=</code> <code class="kt">Request</code> <code class="kt">RequestLine</code> <code class="kt">Headers</code> <code class="p">(</code><code class="kt">BufferedSource</code> <code class="kt">IO</code> <code class="kt">ByteString</code><code class="p">)</code>
<code class="kr">data</code> <code class="kt">Response</code> <code class="ow">=</code> <code class="kt">Response</code>
<code class="kr">type</code> <code class="kt">Application</code> <code class="ow">=</code> <code class="kt">Request</code> <code class="ow">-&gt;</code> <code class="kt">ResourceT</code> <code class="kt">IO</code> <code class="kt">Response</code>

<code class="nf">parseRequestHeaders</code> <code class="ow">::</code> <code class="kt">Sink</code> <code class="kt">ByteString</code> <code class="kt">IO</code> <code class="kt">Headers</code>
<code class="nf">parseRequestHeaders</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">parseRequestLine</code> <code class="ow">::</code> <code class="kt">Sink</code> <code class="kt">ByteString</code> <code class="kt">IO</code> <code class="kt">RequestLine</code>
<code class="nf">parseRequestLine</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">sendResponse</code> <code class="ow">::</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">Response</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">sendResponse</code> <code class="ow">=</code> <code class="n">undefined</code>

<code class="nf">handleConn</code> <code class="ow">::</code> <code class="kt">Application</code> <code class="ow">-&gt;</code> <code class="kt">Socket</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">handleConn</code> <code class="n">app</code> <code class="n">socket</code> <code class="ow">=</code> <code class="n">runResourceT</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">bsrc</code> <code class="ow">&lt;-</code> <code class="n">bufferSource</code> <code class="o">$</code> <code class="n">sourceSocket</code> <code class="n">socket</code>
    <code class="n">requestLine</code> <code class="ow">&lt;-</code> <code class="n">bsrc</code> <code class="o">$$</code> <code class="n">parseRequestLine</code>
    <code class="n">headers</code> <code class="ow">&lt;-</code> <code class="n">bsrc</code> <code class="o">$$</code> <code class="n">parseRequestHeaders</code>
    <code class="kr">let</code> <code class="n">req</code> <code class="ow">=</code> <code class="kt">Request</code> <code class="n">requestLine</code> <code class="n">headers</code> <code class="n">bsrc</code>
    <code class="n">res</code> <code class="ow">&lt;-</code> <code class="n">app</code> <code class="n">req</code>
    <code class="n">liftIO</code> <code class="o">$</code> <code class="n">sendResponse</code> <code class="n">socket</code> <code class="n">res</code>
</pre><p class="calibre7">We’ve made a few minor changes. Firstly, the <code class="literal">Application</code> now lives in the
    <code class="literal">ResourceT IO</code> monad. This isn’t strictly necessary, but it’s very convenient:
   the application can now register cleanup actions that will only take place after the response has
   been fully sent to the client.</p><p class="calibre7">But the major changes are in the <code class="literal">handleConn</code> function. We now start off by
   buffering our source. This buffered source is then used twice in our function, and then passed
   off to the application.</p></div></div></div>

{% endraw %}

