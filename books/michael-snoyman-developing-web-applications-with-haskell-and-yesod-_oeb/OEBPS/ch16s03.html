---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch16s02.html
next: OEBPS/ch16s04.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Message Files"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect15_d1e7953" class="calibre1"></a>Message Files</h1></div></div></div><p class="calibre7"></p><p class="calibre7">The simplest approach to creating translations is via <em class="calibre4">message
      files</em>. The setup is simple: there is a single folder containing all of your
      translation files, with a single file for each language. Each file is named based on its
      language code, e.g., <em class="calibre4">en.msg</em>. And each line in a file
      handles one phrase, which correlates to a single constructor in your message data type.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">The scaffolded site already includes a fully configured message folder.</p></div><p class="calibre7">So firstly, a word about language codes. There are really two choices available: using a
   two-letter language code, or a language-LOCALE code. For example, when I load up a page in my web
   browser, it sends two language codes: en-US and en. What my browser is saying is “if you have
   American English, I like that the most. If you have English, I’ll take that instead.”</p><p class="calibre7">So which format should you use in your application? Most likely two-letter codes, unless
      you are actually creating separate translations by locale. This ensures that someone asking
      for Canadian English will still see your English. Behind the scenes, Yesod will add the
      two-letter codes where relevant. For example, suppose a user has the following language
      list:<a id="I_programlisting5_d1e7975" class="firstname"></a></p><pre class="programlistinghaskell">pt-BR, es, he</pre><p class="calibre7">What this means is “I
      like Brazilian Portuguese, then Spanish, and then Hebrew.” Suppose your application provides
      the languages pt (general Portuguese) and English, with English as the default. Strictly
      following the user’s language list would result in the user being served English. Instead,
      Yesod translates that list
      into:<a id="I_programlisting5_d1e7981" class="firstname"></a></p><pre class="programlistinghaskell">pt-BR, es, he, pt</pre><p class="calibre7">In other words:
      unless you’re giving different translations based on locale, just stick to the two-letter
      language codes.</p><p class="calibre7">Now what about these message files? The syntax should be very familiar after your work
      with Hamlet and Persistent. The line starts off with the name of the message. Since this is a
      data constructor, it must start with a capital letter. Next, you can have individual
      parameters, which must be given in lowercase. These will be arguments to the data
      constructor.</p><p class="calibre7">The argument list is terminated by a colon, and then followed by the translated string, which
   allows usage of our typical variable interpolation syntax <code class="literal">#{myVar}</code>. By referring
   to the parameters defined before the colon, and using translation helper functions to deal with
   issues like pluralization, you can create all the translated messages you need.</p><div class="book" title="Specifying Types"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3093768" class="calibre1"></a>Specifying Types</h2></div></div></div><p class="calibre7"></p><p class="calibre7">Since we will be creating a data type out of our message specifications, each parameter
        to a data constructor must be given a data type. We use a @-syntax for this. For example, to
        create the data type <code class="literal">data MyMessage = MsgHello | MsgSayAge
          Int</code>, we would write:</p><a id="I_programlisting5_d1e8003" class="firstname"></a><pre class="programlistinghaskell">Hello: Hi there!
SayAge age@Int: Your age is: #{show age}</pre><p class="calibre7">But there are two problems with this:</p><div class="book"><ol class="orderedlist"><li class="listitem"><p class="calibre7">It’s not very DRY (don’t repeat yourself) to have to specify this data type in every
            file.</p></li><li class="listitem"><p class="calibre7">Translators will be confused having to specify these data types.</p></li></ol></div><p class="calibre7">So instead, the type specification is only required in the main language file. This is
   specified as the third argument in the <code class="literal">mkMessage</code> function. This also specifies
   what the backup language will be, to be used when none of the languages provided by your
   application match the user’s language list.</p></div></div></div>

{% endraw %}

