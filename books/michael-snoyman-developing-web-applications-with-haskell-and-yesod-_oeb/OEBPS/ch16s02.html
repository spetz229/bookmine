---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch16.html
next: OEBPS/ch16s03.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Overview"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect15_d1e7915" class="calibre1"></a>Overview</h1></div></div></div><p class="calibre7"></p><p class="calibre7">Most existing i18n solutions out there, like gettext or Java message bundles, work on the
   principle of string lookups. Usually some form of printf-interpolation is used to interpolate
   variables into the strings. In Yesod, as you might guess, we instead rely on types. This gives us
   all of our normal advantages, such as the compiler automatically catching mistakes.</p><p class="calibre7">Let’s take a concrete example. Suppose our application has two things it wants to say
   to a user: say hello, and state how many users are logged into the system. This can be modeled
   with a sum type:</p><a id="I_programlisting5_d1e7923" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">data</code> <code class="kt">MyMessage</code> <code class="ow">=</code> <code class="kt">MsgHello</code> <code class="o">|</code> <code class="kt">MsgUsersLoggedIn</code> <code class="kt">Int</code>
</pre><p class="calibre7">I can also write a function to turn this data type into an English representation:</p><a id="I_programlisting5_d1e7927" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">toEnglish</code> <code class="ow">::</code> <code class="kt">MyMessage</code> <code class="ow">-&gt;</code> <code class="kt">String</code>
<code class="nf">toEnglish</code> <code class="kt">MsgHello</code> <code class="ow">=</code> <code class="s">"Hello there!"</code>
<code class="nf">toEnglish</code> <code class="p">(</code><code class="kt">MsgUsersLoggedIn</code> <code class="mi">1</code><code class="p">)</code> <code class="ow">=</code> <code class="s">"There is 1 user logged in."</code>
<code class="nf">toEnglish</code> <code class="p">(</code><code class="kt">MsgUsersLoggedIn</code> <code class="n">i</code><code class="p">)</code> <code class="ow">=</code> <code class="s">"There are "</code> <code class="o">++</code> <code class="n">show</code> <code class="n">i</code> <code class="o">++</code> <code class="s">" users logged in."</code>
</pre><p class="calibre7">We can also write similar functions for other languages. The advantage to this
   inside-Haskell approach is that we have the full power of Haskell for addressing tricky grammar
   issues, especially pluralization.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">You may think pluralization isn’t so complicated: you have one version for 1 item, and
   another for any other count. That might be true in English, but it’s not true for every language.
   Russian, for example, has six different forms, and you need to use some modulus logic to
   determine which one to use.</p></div><p class="calibre7">The downside, however, is that you have to write all of this inside of Haskell, which won’t be
   very translator-friendly. To solve this, Yesod introduces the concept of message files. We’ll
   cover that in a little bit.</p><p class="calibre7">Assuming we have this full set of translation functions, how do we go about using
   them? What we need is a new function to wrap them all up together, and then choose the
   appropriate translation function based on the user’s selected language. Once we have that, Yesod
   can automatically choose the most relevant render function and call it on the values you
   provide.</p><p class="calibre7">In order to simplify things a bit, Hamlet has a special interpolation syntax,
    <code class="literal">_{...}</code>, which handles all the calls to the render functions. And in order to
   associate a render function with your application, you use the <code class="literal">YesodMessage</code>
   typeclass.</p></div></div>

{% endraw %}

