---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/apbs02.html
next: OEBPS/apbs04.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="The Resource Monad Transformer"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect1_d1e9155" class="calibre1"></a>The Resource Monad Transformer</h1></div></div></div><p class="calibre7"></p><p class="calibre7">The Resource transformer (<code class="literal">ResourceT</code>) plays a vital role
      in proper resource management in the conduit project. It is included within the <code class="literal">conduit</code> package itself. We’ll explain <code class="literal">ResourceT</code> as its own entity. While some of the design decisions clearly are
      biased toward conduits, <code class="literal">ResourceT</code> should remain a usable
      tool in its own right.</p><div class="book" title="Goals"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3098207" class="calibre1"></a>Goals</h2></div></div></div><p class="calibre7"></p><p class="calibre7">What’s wrong with the following code?</p><a id="I_programlisting_d1e9182" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">System.IO</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">output</code> <code class="ow">&lt;-</code> <code class="n">openFile</code> <code class="s">"output.txt"</code> <code class="kt">WriteMode</code>
    <code class="n">input</code>  <code class="ow">&lt;-</code> <code class="n">openFile</code> <code class="s">"input.txt"</code>  <code class="kt">ReadMode</code>
    <code class="n">hGetContents</code> <code class="n">input</code> <code class="o">&gt;&gt;=</code> <code class="n">hPutStr</code> <code class="n">output</code>
    <code class="n">hClose</code> <code class="n">input</code>
    <code class="n">hClose</code> <code class="n">output</code>
</pre><p class="calibre7">If the file <em class="calibre4">input.txt</em> does not exist, then an exception will be thrown
   when trying to open it. As a result, <code class="literal">hClose output</code> will never be called, and
   we’ll have leaked a scarce resource (a file descriptor). In our tiny program, this isn’t a big
   deal, but clearly we can’t afford such waste in a long running, highly active server process.</p><p class="calibre7">Fortunately, solving the problem is easy:</p><a id="I_programlisting_d1e9194" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">System.IO</code>

<code class="nf">main</code> <code class="ow">=</code>
    <code class="n">withFile</code> <code class="s">"output.txt"</code> <code class="kt">WriteMode</code> <code class="o">$</code> <code class="nf">\</code><code class="n">output</code> <code class="ow">-&gt;</code>
    <code class="n">withFile</code> <code class="s">"input.txt"</code> <code class="kt">ReadMode</code> <code class="o">$</code> <code class="nf">\</code><code class="n">input</code> <code class="ow">-&gt;</code>
    <code class="n">hGetContents</code> <code class="n">input</code> <code class="o">&gt;&gt;=</code> <code class="n">hPutStr</code> <code class="n">output</code>
</pre><p class="calibre7"><code class="literal">withFile</code> makes sure that the <code class="literal">Handle</code> is always closed, even in the presence of exceptions. It also handles
        asynchronous exceptions. Overall, it’s a great approach to use…when you can use it. While
        often <code class="literal">withFile</code> is easy to use, sometimes it can require
        restructuring our programs. And this restructuring can range from mildly tedious to wildly
        inefficient.</p><p class="calibre7">Let’s take enumerators for example. If you look in the documentation, there is an
          <code class="literal">enumFile</code> function (for reading contents from a file),
        but no <code class="literal">iterFile</code> (for writing contents to a file). That’s
        because the flow of control in an iteratee doesn’t allow proper allocation of the Handle.
        Instead, in order to write to a file, you need to allocate the Handle before entering the
        Iteratee, e.g.:</p><a id="I_programlisting_d1e9214" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">System.IO</code>
<code class="kr">import</code> <code class="nn">Data.Enumerator</code>
<code class="kr">import</code> <code class="nn">Data.Enumerator.Binary</code>

<code class="nf">main</code> <code class="ow">=</code>
    <code class="n">withFile</code> <code class="s">"output.txt"</code> <code class="kt">WriteMode</code> <code class="o">$</code> <code class="nf">\</code><code class="n">output</code> <code class="ow">-&gt;</code>
    <code class="n">run_</code> <code class="o">$</code> <code class="n">enumFile</code> <code class="s">"input.txt"</code> <code class="o">$$</code> <code class="n">iterHandle</code> <code class="n">output</code>
</pre><p class="calibre7">This code works fine, but imagine that, instead of simply piping data directly to the file,
   there was a huge amount of computation that occurred before we need to use the output handle. We
   will have allocated a file descriptor long before we needed it, and thereby locked up a scarce
   resource in our application. Besides this, there are times when we <span class="firstname"><em class="calibre4">can’t</em></span> allocate the file
   before hand, such as when we won’t know which file to open until we’ve read from the input
   file.</p><p class="calibre7">One of the stated goals of conduits is to solve this problem, and it does so via
    <code class="literal">ResourceT</code>. As a result, the above program can be written in conduit as:</p><a id="I_programlisting_d1e9227" class="firstname"></a><pre class="programlistinghaskell"><code class="cm">{-# LANGUAGE OverloadedStrings #-}</code>
<code class="kr">import</code> <code class="nn">Data.Conduit</code>
<code class="kr">import</code> <code class="nn">Data.Conduit.Binary</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="n">runResourceT</code> <code class="o">$</code> <code class="n">sourceFile</code> <code class="s">"input.txt"</code> <code class="o">$$</code> <code class="n">sinkFile</code> <code class="s">"output.txt"</code>
</pre></div><div class="book" title="How It Works"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3098367" class="calibre1"></a>How It Works</h2></div></div></div><p class="calibre7"></p><p class="calibre7">There are essentially three base functions on <code class="literal">ResourceT</code>, and then a bunch of
   conveniences thrown on top. The first function is:</p><a id="I_programlisting_d1e9238" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">register</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code> <code class="ow">-&gt;</code> <code class="kt">ResourceT</code> <code class="kt">IO</code> <code class="kt">ReleaseKey</code>
</pre><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">This function, and the others below, are actually more polymorphic than implied here,
   allowing other monads besides <code class="literal">IO</code>. In fact, almost any transformer on top of
    <code class="literal">IO</code>, as well as any <code class="literal">ST</code> stacks, work. We’ll cover the details of
   that later.</p></div><p class="calibre7">This function registers a piece of code that it asserts <span class="bold"><strong class="bold">must</strong></span> be run. It gives back a
    <code class="literal">ReleaseKey</code>, which is used by the next function:</p><a id="I_programlisting_d1e9260" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">release</code> <code class="ow">::</code> <code class="kt">ReleaseKey</code> <code class="ow">-&gt;</code> <code class="kt">ResourceT</code> <code class="kt">IO</code> <code class="nb">()</code>
</pre><p class="calibre7">Calling <code class="literal">release</code> on a <code class="literal">ReleaseKey</code> immediately performs the
   action you previously registered. You may call <code class="literal">release</code> on the same
    <code class="literal">ReleaseKey</code> as many times as you like; the first time it is called, it
    <em class="calibre4">unregisters</em> the action. This means you can safely register an action like a memory
   free, and have no concerns that it will be called twice.</p><p class="calibre7">Eventually, we’ll want to exit our special <code class="literal">ResourceT</code>. To do so, we use:</p><a id="I_programlisting_d1e9284" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">runResourceT</code> <code class="ow">::</code> <code class="kt">ResourceT</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
</pre><p class="calibre7">This seemingly innocuous function is where all the magic happens. It runs through all of the
   registered cleanup actions and performs them. It is fully exception safe, meaning the cleanups
   will be performed in the presence of both synchronous and asynchronous exceptions. And as
   mentioned before, calling <code class="literal">release</code> will unregister an action, so there is no
   concern of double-freeing.</p><p class="calibre7">Finally, as a convenience, we provide one more function for the common case of allocating a
   resource and registering a release action:</p><a id="I_programlisting_d1e9294" class="firstname"></a><pre class="programlistinghaskell"><code class="nf">with</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="cm">-- ^ allocate</code>
     <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code><code class="p">)</code> <code class="cm">-- ^ free resource</code>
     <code class="ow">-&gt;</code> <code class="kt">ResourceT</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">ReleaseKey</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code>
</pre><p class="calibre7">So, to rework our first buggy example to use <code class="literal">ResourceT</code>, we would write:</p><a id="I_programlisting_d1e9301" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">import</code> <code class="nn">System.IO</code>
<code class="kr">import</code> <code class="nn">Control.Monad.Trans.Resource</code>
<code class="kr">import</code> <code class="nn">Control.Monad.Trans.Class</code> <code class="p">(</code><code class="nf">lift</code><code class="p">)</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="n">runResourceT</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="p">(</code><code class="n">releaseO</code><code class="p">,</code> <code class="n">output</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">with</code> <code class="p">(</code><code class="n">openFile</code> <code class="s">"output.txt"</code> <code class="kt">WriteMode</code><code class="p">)</code> <code class="n">hClose</code>
    <code class="p">(</code><code class="n">releaseI</code><code class="p">,</code> <code class="n">input</code><code class="p">)</code>  <code class="ow">&lt;-</code> <code class="n">with</code> <code class="p">(</code><code class="n">openFile</code> <code class="s">"input.txt"</code>  <code class="kt">ReadMode</code><code class="p">)</code>  <code class="n">hClose</code>
    <code class="n">lift</code> <code class="o">$</code> <code class="n">hGetContents</code> <code class="n">input</code> <code class="o">&gt;&gt;=</code> <code class="n">hPutStr</code> <code class="n">output</code>
    <code class="n">release</code> <code class="n">releaseI</code>
    <code class="n">release</code> <code class="n">releaseO</code>
</pre><p class="calibre7">Now there is no concern of any exceptions preventing the releasing of resources. We could skip
   the <code class="literal">release</code> calls if we want to, and in an example this small, it would not make
   any difference. But for larger applications, where we want processing to continue, this ensures
   that the <code class="literal">Handle</code>s are freed as early as possible, keeping our scarce resource
   usage to a minimum.</p></div><div class="book" title="Some Type Magic"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3098577" class="calibre1"></a>Some Type Magic</h2></div></div></div><p class="calibre7"></p><p class="calibre7">As alluded to, there’s a bit more to <code class="literal">ResourceT</code> than simply running in
    <code class="literal">IO</code>. Let’s cover some of the things we need from this underlying
    <code class="literal">Monad</code>.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7">Mutable references to keep track of the registered release actions. You might think we could
    just use a <code class="literal">StateT</code> transformer, but then our state wouldn’t survive
    exceptions.</p></li><li class="listitem"><p class="calibre7">We only want to register actions in the <em class="calibre4">base monad</em>. For
            example, if we have a <code class="literal">ResourceT (WriterT [Int] IO)</code>
            stack, we only want to register <code class="literal">IO</code> actions. This
            makes it easy to lift our stacks around (i.e., add an extra transformer to the middle of
            an existing stack), and avoids confusing issues about the threading of other monadic
            side effects.</p></li><li class="listitem"><p class="calibre7">Some way to guarantee an action is performed, even in the presence of exceptions. This boils
    down to needing a <code class="literal">bracket</code>-like function.</p></li></ul></div><p class="calibre7">For the first point, we define a new typeclass to represent monads that have mutable
   references:</p><a id="I_programlisting_d1e9353" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">class</code> <code class="kt">Monad</code> <code class="n">m</code> <code class="ow">=&gt;</code> <code class="kt">HasRef</code> <code class="n">m</code> <code class="kr">where</code>
    <code class="kr">type</code> <code class="kt">Ref</code> <code class="n">m</code> <code class="ow">::</code> <code class="o">*</code> <code class="ow">-&gt;</code> <code class="o">*</code>
    <code class="n">newRef'</code> <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Ref</code> <code class="n">m</code> <code class="n">a</code><code class="p">)</code>
    <code class="n">readRef'</code> <code class="ow">::</code> <code class="kt">Ref</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code>
    <code class="n">writeRef'</code> <code class="ow">::</code> <code class="kt">Ref</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="nb">()</code>
    <code class="n">modifyRef'</code> <code class="ow">::</code> <code class="kt">Ref</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">))</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">b</code>
    <code class="n">mask</code> <code class="ow">::</code> <code class="p">((</code><code class="n">forall</code> <code class="n">a</code><code class="o">.</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">b</code>
    <code class="n">mask_</code> <code class="ow">::</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code>
    <code class="n">try</code> <code class="ow">::</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">)</code>
</pre><p class="calibre7">We have an associated type to signify what the reference type should be. (For fans of
        fundeps, you’ll see in the next section that this <span class="firstname"><em class="calibre4">has</em></span> to be an
        associated type.) Then we provide a number of basic reference operations. Finally, there are
        some functions to help with exceptions, which are needed to safely implement the functions
        described in the last section. The instance for <code class="literal">IO</code> is
        very straightforward:</p><a id="I_programlisting_d1e9363" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">instance</code> <code class="kt">HasRef</code> <code class="kt">IO</code> <code class="kr">where</code>
    <code class="kr">type</code> <code class="kt">Ref</code> <code class="kt">IO</code> <code class="ow">=</code> <code class="kt">I</code><code class="o">.</code><code class="kt">IORef</code>
    <code class="n">newRef'</code> <code class="ow">=</code> <code class="kt">I</code><code class="o">.</code><code class="n">newIORef</code>
    <code class="n">modifyRef'</code> <code class="ow">=</code> <code class="kt">I</code><code class="o">.</code><code class="n">atomicModifyIORef</code>
    <code class="n">readRef'</code> <code class="ow">=</code> <code class="kt">I</code><code class="o">.</code><code class="n">readIORef</code>
    <code class="n">writeRef'</code> <code class="ow">=</code> <code class="kt">I</code><code class="o">.</code><code class="n">writeIORef</code>
    <code class="n">mask</code> <code class="ow">=</code> <code class="kt">E</code><code class="o">.</code><code class="n">mask</code>
    <code class="n">mask_</code> <code class="ow">=</code> <code class="kt">E</code><code class="o">.</code><code class="n">mask_</code>
    <code class="n">try</code> <code class="ow">=</code> <code class="kt">E</code><code class="o">.</code><code class="n">try</code>
</pre><p class="calibre7">However, we have a problem when it comes to implementing the <code class="literal">ST</code> instance: there is no way to deal with exceptions in the <code class="literal">ST</code> monad. As a result, <code class="literal">mask</code>,
          <code class="literal">mask_</code> and <code class="literal">try</code> are
        given default implementations that do no exception checking. This gives rise to the first
        word of warning: <span class="bold"><strong class="bold">operations in the ST monad are not exception
          safe</strong></span>. You should not be allocating scarce resources in ST when using <code class="literal">ResourceT</code>.
        You
        might be wondering why we would bother with <code class="literal">ResourceT</code> for
          <code class="literal">ST</code> at all. The answer is that there
        is a lot you can do with conduits without allocating scarce resources, and <code class="literal">ST</code> is a great method to do this in a pure way. But more on this
        later.</p><p class="calibre7">Now onto point 2: we need some way to deal with this base monad concept. Again, we use an
   associated type (again explained in the next section). Our solution looks something like:</p><a id="I_programlisting_d1e9405" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">class</code> <code class="p">(</code><code class="kt">HasRef</code> <code class="p">(</code><code class="kt">Base</code> <code class="n">m</code><code class="p">),</code> <code class="kt">Monad</code> <code class="n">m</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Resource</code> <code class="n">m</code> <code class="kr">where</code>
    <code class="kr">type</code> <code class="kt">Base</code> <code class="n">m</code> <code class="ow">::</code> <code class="o">*</code> <code class="ow">-&gt;</code> <code class="o">*</code>

    <code class="n">resourceLiftBase</code> <code class="ow">::</code> <code class="kt">Base</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code>
</pre><p class="calibre7">But we forgot about point 3: some <code class="literal">bracket</code>-like function. So we need one more
   method in this typeclass:</p><a id="I_programlisting_d1e9413" class="firstname"></a><pre class="programlistinghaskell">    <code class="n">resourceBracket_</code> <code class="ow">::</code> <code class="kt">Base</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Base</code> <code class="n">m</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">c</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">c</code>
</pre><p class="calibre7">The reason the first two arguments to <code class="literal">resourceBracket_</code> (allocation and
   cleanup) live in <code class="literal">Base m</code> instead of <code class="literal">m</code> is that, in
    <code class="literal">ResourceT</code>, all allocation and cleanup lives in the base monad.</p><p class="calibre7">So on top of our <code class="literal">HasRef</code> instance for <code class="literal">IO</code>, we now need a <code class="literal">Resource</code>
        instance as well. This is similarly straightforward:</p><a id="I_programlisting_d1e9440" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">instance</code> <code class="kt">Resource</code> <code class="kt">IO</code> <code class="kr">where</code>
    <code class="kr">type</code> <code class="kt">Base</code> <code class="kt">IO</code> <code class="ow">=</code> <code class="kt">IO</code>
    <code class="n">resourceLiftBase</code> <code class="ow">=</code> <code class="n">id</code>
    <code class="n">resourceBracket_</code> <code class="ow">=</code> <code class="kt">E</code><code class="o">.</code><code class="n">bracket_</code>
</pre><p class="calibre7">We have similar <code class="literal">ST</code> instances, with <code class="literal">resourceBracket_</code> having no
   exception safety. The final step is dealing with monad transformers. We don’t need to provide a
    <code class="literal">HasRef</code> instance, but we do need a <code class="literal">Resource</code> instance. The
   tricky part is providing a valid implementation of <code class="literal">resourceBracket_</code>. For this,
   we use some functions from <code class="function">monad-control</code>:</p><a id="I_programlisting_d1e9466" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">instance</code> <code class="p">(</code><code class="kt">MonadTransControl</code> <code class="n">t</code><code class="p">,</code> <code class="kt">Resource</code> <code class="n">m</code><code class="p">,</code> <code class="kt">Monad</code> <code class="p">(</code><code class="n">t</code> <code class="n">m</code><code class="p">))</code>
        <code class="ow">=&gt;</code> <code class="kt">Resource</code> <code class="p">(</code><code class="n">t</code> <code class="n">m</code><code class="p">)</code> <code class="kr">where</code>
    <code class="kr">type</code> <code class="kt">Base</code> <code class="p">(</code><code class="n">t</code> <code class="n">m</code><code class="p">)</code> <code class="ow">=</code> <code class="kt">Base</code> <code class="n">m</code>

    <code class="n">resourceLiftBase</code> <code class="ow">=</code> <code class="n">lift</code> <code class="o">.</code> <code class="n">resourceLiftBase</code>
    <code class="n">resourceBracket_</code> <code class="n">a</code> <code class="n">b</code> <code class="n">c</code> <code class="ow">=</code>
        <code class="n">control'</code> <code class="o">$</code> <code class="nf">\</code><code class="n">run</code> <code class="ow">-&gt;</code> <code class="n">resourceBracket_</code> <code class="n">a</code> <code class="n">b</code> <code class="p">(</code><code class="n">run</code> <code class="n">c</code><code class="p">)</code>
      <code class="kr">where</code>
        <code class="n">control'</code> <code class="n">f</code> <code class="ow">=</code> <code class="n">liftWith</code> <code class="n">f</code> <code class="o">&gt;&gt;=</code> <code class="n">restoreT</code> <code class="o">.</code> <code class="n">return</code>
</pre><p class="calibre7">For any transformer, its base is the base of its inner monad. Similarly, we lift to the
        base by lifting to the inner monad and then lifting to the base from there. The tricky part
        is the implementation of <code class="literal">resourceBracket_</code>. I will not go
        into a detailed explanation, as I would simply make a fool of myself.</p></div><div class="book" title="Definition of ResourceT"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3098953" class="calibre1"></a>Definition of ResourceT</h2></div></div></div><p class="calibre7"></p><p class="calibre7">We now have enough information to understand the definition of <code class="literal">ResourceT</code>:</p><a id="I_programlisting_d1e9482" class="firstname"></a><pre class="programlistinghaskell"><code class="kr">newtype</code> <code class="kt">ReleaseKey</code> <code class="ow">=</code> <code class="kt">ReleaseKey</code> <code class="kt">Int</code>

<code class="kr">type</code> <code class="kt">RefCount</code> <code class="ow">=</code> <code class="kt">Int</code>
<code class="kr">type</code> <code class="kt">NextKey</code> <code class="ow">=</code> <code class="kt">Int</code>

<code class="kr">data</code> <code class="kt">ReleaseMap</code> <code class="n">base</code> <code class="ow">=</code>
    <code class="kt">ReleaseMap</code> <code class="o">!</code><code class="kt">NextKey</code> <code class="o">!</code><code class="kt">RefCount</code> <code class="o">!</code><code class="p">(</code><code class="kt">IntMap</code> <code class="p">(</code><code class="n">base</code> <code class="nb">()</code><code class="p">))</code>

<code class="kr">newtype</code> <code class="kt">ResourceT</code> <code class="n">m</code> <code class="n">a</code> <code class="ow">=</code>
    <code class="kt">ResourceT</code> <code class="p">(</code><code class="kt">Ref</code> <code class="p">(</code><code class="kt">Base</code> <code class="n">m</code><code class="p">)</code> <code class="p">(</code><code class="kt">ReleaseMap</code> <code class="p">(</code><code class="kt">Base</code> <code class="n">m</code><code class="p">))</code> <code class="ow">-&gt;</code> <code class="n">m</code> <code class="n">a</code><code class="p">)</code>
</pre><p class="calibre7">We see that <code class="literal">ReleaseKey</code> is simply an <code class="literal">Int</code>. If you skip a few
   lines down, this will make sense, since we’re using an <code class="literal">IntMap</code> to keep track of
   the registered actions. We also define two type synonyms: <code class="literal">RefCount</code> and
    <code class="literal">NextKey</code>. <code class="literal">NextKey</code> keeps track of the most recently assigned
   value for a key, and is incremented each time <code class="literal">register</code> is called. We’ll touch on
    <code class="literal">RefCount</code> later.</p><p class="calibre7">The <code class="literal">ReleaseMap</code>
        includes
        three pieces of information: the next key and the reference count, and then the map of all
        registered actions. Notice that <code class="literal">ReleaseMap</code> takes a type
        parameter <code class="literal">base</code>, which states which monad release actions
        must live in.</p><p class="calibre7">Finally, a <code class="literal">ResourceT</code> is essentially a <code class="literal">ReaderT</code> that keeps a
   mutable reference to a <code class="literal">ReleaseMap</code>. The reference type is determined by the base
   of the monad in question, as is the cleanup monad. This is why we need to use associated
   types.</p><p class="calibre7">The majority of the rest of the code in the <code class="literal">Control.Monad.Trans.Resource</code>
   module is just providing instances for the <code class="literal">ResourceT</code> type.</p></div><div class="book" title="Other Typeclasses"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3099103" class="calibre1"></a>Other Typeclasses</h2></div></div></div><p class="calibre7"></p><p class="calibre7">There are three other typeclasses provided by the module:</p><div class="book"><dl class="book"><dt class="calibre9"><span class="firstname">ResourceUnsafeIO</span></dt><dd class="calibre10"><p class="calibre7">Any monad which can lift <code class="literal">IO</code> actions into it,
              but that this may be considered unsafe. The prime candidate here is <code class="literal">ST</code>. Care should be taken to only lift actions that do not
              acquire scarce resources and which don’t “fire the missiles.” In other words, all the
              normal warnings of <code class="literal">unsafeIOToST</code> apply.</p></dd><dt class="calibre9"><span class="firstname">ResourceThrow</span></dt><dd class="calibre10"><p class="calibre7">For actions that can throw exceptions. This automatically applies to all
     <code class="literal">IO</code>-based monads. For <code class="literal">ST</code>-based monads, you can use the
     supplied <code class="literal">ExceptionT</code> transformer to provide exception-throwing capabilities.
     Some functions in conduit, for example, will require this (e.g., text decoding).</p></dd><dt class="calibre9"><span class="firstname">ResourceIO</span></dt><dd class="calibre10"><p class="calibre7">A convenience class tying together a bunch of other classes, included the two mentioned
     above. This is purely for convenience; you could achieve the same effect without this type
     class, you’d just have to do a lot more typing.</p></dd></dl></div></div><div class="book" title="Forking"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3099183" class="calibre1"></a>Forking</h2></div></div></div><p class="calibre7"></p><p class="calibre7">It would seem that forking a thread would be inherently unsafe with <code class="literal">ResourceT</code>,
   since the parent thread may call <code class="literal">runResourceT</code> while the child thread is still
   accessing some of the allocated resources. This is indeed true, <span class="firstname"><em class="calibre4">if</em></span> you use the normal
    <code class="literal">forkIO</code> function.</p><div class="tip" title="Note"><h3 class="title3">Note</h3><p class="calibre7">You can’t actually use the standard <code class="literal">forkIO</code>, since it only operates in the
    <code class="literal">IO</code> monad, but you could use the <code class="literal">fork</code> function from
    <code class="function">lifted-base</code>. In fact, due to this issue, the <code class="function">regions</code>
   package does not provide a <code class="literal">MonadBaseControl</code> instance for its transformer (which
   is very similar to <code class="literal">ResourceT</code>). However, our goal in <code class="literal">ResourceT</code>
   is not to make it impossible for programmers to mess up, only to make it easier to do the right
   thing. Therefore, we still provide the instance, even though it could be abused.</p></div><p class="calibre7">In order to solve this, <code class="literal">ResourceT</code> includes reference counting. When you fork a
   new thread via <code class="literal">resourceForkIO</code>, the <code class="literal">RefCount</code> value of the
    <code class="literal">ReleaseMap</code> is incremented. Every time <code class="literal">runResourceT</code> is called,
   the value is decremented. Only when the value hits 0 are all the release actions called.</p></div><div class="book" title="Convenience Exports"><div class="book"><div class="book"><div class="book"><h2 class="title4"><a id="id3099305" class="calibre1"></a>Convenience Exports</h2></div></div></div><p class="calibre7"></p><p class="calibre7">In addition to what’s been listed so far, there are a few extra functions exported (mostly) for
   convenience.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><p class="calibre7"><code class="literal">newRef</code>, <code class="literal">writeRef</code>, and <code class="literal">readRef</code> wrap up the
     <code class="literal">HasRef</code> versions of the functions and allow them to run in any
     <code class="literal">ResourceT</code>.</p></li><li class="listitem"><p class="calibre7"><code class="literal">withIO</code> is essentially a type-restricted version of <code class="literal">with</code>,
    but working around some of the nastiness with types you would otherwise run into. In general:
    you’ll want to use <code class="literal">withIO</code> when writing <code class="literal">IO</code> code.</p></li><li class="listitem"><p class="calibre7"><code class="literal">transResourceT</code> lets you modify which monad your
            ResourceT is running in, assuming it keeps the same
            base.<a id="I_programlisting_d1e9698" class="firstname"></a></p><pre class="programlistinghaskell"><code class="nf">transResourceT</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Base</code> <code class="n">m</code> <code class="o">~</code> <code class="kt">Base</code> <code class="n">n</code><code class="p">)</code>
               <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">m</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">n</code> <code class="n">a</code><code class="p">)</code>
               <code class="ow">-&gt;</code> <code class="kt">ResourceT</code> <code class="n">m</code> <code class="n">a</code>
               <code class="ow">-&gt;</code> <code class="kt">ResourceT</code> <code class="n">n</code> <code class="n">a</code>
<code class="nf">transResourceT</code> <code class="n">f</code> <code class="p">(</code><code class="kt">ResourceT</code> <code class="n">mx</code><code class="p">)</code> <code class="ow">=</code> <code class="kt">ResourceT</code> <code class="p">(</code><code class="nf">\</code><code class="n">r</code> <code class="ow">-&gt;</code> <code class="n">f</code> <code class="p">(</code><code class="n">mx</code> <code class="n">r</code><code class="p">))</code>
</pre></li></ul></div></div></div></div>

{% endraw %}

