---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-APP-A.html
next: understandlk-APP-A-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-APP-A-SECT-1"></a>
<h3 class="docSection1Title">A.1. Prehistoric Age: the BIOS</h3><a name="IDX-APP-A-0002"></a>
<a name="IDX-APP-A-0003"></a>
<p class="docText1">The moment after a computer is powered on, it is practically useless because the RAM chips contain random data and no operating system is running. To begin the boot, a special hardware circuit raises the logical value of the RESET pin of the CPU. After RESET is asserted, some registers of the processor (including <tt class="calibre25">cs</tt> and <tt class="calibre25">eip</tt>) are set to fixed values, and the code found at physical address <tt class="calibre25">0xfffffff0</tt> is executed. This address is mapped by the hardware to a certain read-only, persistent memory chip that is often called Read-Only Memory (ROM). The set of programs stored in ROM is traditionally called the <span class="docEmphasis">Basic Input/Output System</span> (<span class="docEmphasis">BIOS</span>) in the 80 x 86 architecture, because it includes several interrupt-driven low-level procedures used by all operating systems in the booting phase to handle the hardware devices that make up the computer. Some operating systems, such as Microsoft's MS-DOS<a name="IDX-APP-A-0004"></a> 
, rely on BIOS to implement most system calls.</p>
<p class="docText1">Once in protected mode (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-2.html#understandlk-CHP-2-SECT-2">Segmentation in Hardware</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>), Linux does not use BIOS any longer, but it provides its own device driver for every hardware device on the computer. In fact, the BIOS procedures must be executed in real mode, so they cannot share functions even if that would be beneficial.</p>
<p class="docText1">The BIOS uses Real Mode addresses because they are the only ones available when the computer is turned on. A Real Mode address is composed of a <span class="docEmphasis">seg</span> segment and an <span class="docEmphasis">off</span> offset; the corresponding physical address is given by <span class="docEmphasis">seg</span>*16+<span class="docEmphasis">off</span>. As a result, no Global Descriptor Table, Local Descriptor Table, or paging table is needed by the CPU addressing circuit to translate a logical address into a physical one. Clearly, the code that initializes the GDT, LDT, and paging tables must run in Real Mode.</p>
<p class="docText1">Linux is forced to use BIOS in the bootstrapping phase, when it must retrieve the kernel image from disk or from some other external device. The BIOS bootstrap procedure<a name="IDX-APP-A-0005"></a> 
 essentially performs the following four operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Executes a series of tests on the computer hardware to establish which devices are present and whether they are working properly. This phase is often called <span class="docEmphasis">Power-On Self-Test</span> (<span class="docEmphasis">POST</span>). During this phase, several messages, such as the BIOS version banner, are displayed.</p><p class="docList">Recent 80 x 86, AMD64, and Itanium computers make use of the <span class="docEmphasis">Advanced Configuration and Power Interface</span>(<span class="docEmphasis">ACPI</span><a name="IDX-APP-A-0006"></a> 
) standard. The bootstrap code in an ACPI-compliant BIOS builds several tables that describe the hardware devices present in the system. These tables have a vendor-independent format and can be read by the operating system kernel to learn how to handle the devices.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the hardware devices. This phase is crucial in modern PCI-based architectures, because it guarantees that all hardware devices operate without conflicts on the IRQ lines and I/O ports. At the end of this phase, a table of installed PCI devices is displayed.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Searches for an operating system to boot. Actually, depending on the BIOS setting, the procedure may try to access (in a predefined, customizable order) the first sector (<span class="docEmphasis">boot sector</span>) of every floppy disk, hard disk, and CD-ROM in the system.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">As soon as a valid device is found, it copies the contents of its first sector into RAM, starting from physical address <tt class="calibre25">0x00007c00</tt>, and then jumps into that address and executes the code just loaded.</p></div></li></ol></div>
<p class="docText1">The rest of this appendix takes you from the most primitive starting state to the full glory of a running Linux system.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

