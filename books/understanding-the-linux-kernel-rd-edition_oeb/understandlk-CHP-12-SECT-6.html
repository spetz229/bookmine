---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-12-SECT-5.html
next: understandlk-CHP-12-SECT-7.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-12-SECT-6"></a>
<h3 class="docSection1Title">12.6. Implementations of VFS System Calls</h3><a name="IDX-CHP-12-3265"></a>
<p class="docText1">For the sake of brevity, we cannot discuss the implementation<a name="IDX-CHP-12-3266"></a> 
 of all the VFS system calls listed in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-1.html#understandlk-CHP-12-TABLE-1">Table 12-1</a>. However, it could be useful to sketch out the implementation of a few system calls, in order to show how VFS's data structures interact.</p>
<p class="docText1">Let's reconsider the example proposed at the beginning of this chapter: a user issues a shell command that copies the MS-DOS<a name="IDX-CHP-12-3267"></a> 
 file <i class="docEmphasis">/floppy/TEST</i> to the Ext2 file <i class="docEmphasis">/tmp/test</i>. The command shell invokes an external program such as <i class="docEmphasis">cp</i>, which we assume executes the following code fragment:</p>
<pre class="calibre27">
    inf = open("/floppy/TEST", O_RDONLY, 0);
    outf = open("/tmp/test", O_WRONLY | O_CREAT | O_TRUNC, 0600);
    do {
        len = read(inf, buf, 4096);
        write(outf, buf, len);
    } while (len);
    close(outf);
    close(inf);</pre><br class="calibre7"/>
<p class="docText1">Actually, the code of the real <span class="docEmphasis">cp</span> program is more complicated, because it must also check for possible error codes returned by each system call. In our example, we focus our attention on the "normal" behavior of a copy operation.</p>
<a name="understandlk-CHP-12-SECT-6.1"></a>
<h4 class="docSection2Title">12.6.1. The open( ) System Call</h4><a name="IDX-CHP-12-3268"></a>
<a name="IDX-CHP-12-3269"></a>
<a name="IDX-CHP-12-3270"></a>
<a name="IDX-CHP-12-3271"></a>
<a name="IDX-CHP-12-3272"></a>
<a name="IDX-CHP-12-3273"></a>
<a name="IDX-CHP-12-3274"></a>
<a name="IDX-CHP-12-3275"></a>
<a name="IDX-CHP-12-3276"></a>
<a name="IDX-CHP-12-3277"></a>
<a name="IDX-CHP-12-3278"></a>
<a name="IDX-CHP-12-3279"></a>
<a name="IDX-CHP-12-3280"></a>
<a name="IDX-CHP-12-3281"></a>
<a name="IDX-CHP-12-3282"></a>
<a name="IDX-CHP-12-3283"></a>
<a name="IDX-CHP-12-3284"></a>
<a name="IDX-CHP-12-3285"></a>
<a name="IDX-CHP-12-3286"></a>
<a name="IDX-CHP-12-3287"></a>
<a name="IDX-CHP-12-3288"></a>
<a name="IDX-CHP-12-3289"></a>
<a name="IDX-CHP-12-3290"></a>
<a name="IDX-CHP-12-3291"></a>
<a name="IDX-CHP-12-3292"></a>
<p class="docText1">The <tt class="calibre25">open( )</tt> system call is serviced by the <tt class="calibre25">sys_open( )</tt> function, which receives as its parameters the pathname <tt class="calibre25">filename</tt> of the file to be opened, some access mode flags <tt class="calibre25">flags</tt>, and a permission bit mask <tt class="calibre25">mode</tt> if the file must be created. If the system call succeeds, it returns a file descriptorthat is, the index assigned to the new file in the <tt class="calibre25">current-&gt;files-&gt;fd</tt> array of pointers to file objects; otherwise, it returns -1.</p>
<p class="docText1">In our example, <tt class="calibre25">open( )</tt> is invoked twice; the first time to open <i class="docEmphasis">/floppy/TEST</i> for reading (<tt class="calibre25">O_RDONLY</tt> flag) and the second time to open <i class="docEmphasis">/tmp/test</i> for writing (<tt class="calibre25">O_WRONLY</tt> flag). If <i class="docEmphasis">/tmp/test</i> does not already exist, it is created (<tt class="calibre25">O_CREAT</tt> flag) with exclusive read and write access for the owner (octal <tt class="calibre25">0600</tt> number in the third parameter).</p>
<p class="docText1">Conversely, if the file already exists, it is rewritten from scratch (<tt class="calibre25">O_TRUNC</tt> flag). <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-18">Table 12-18</a> lists all flags of the <tt class="calibre25">open( )</tt> system call.</p>
<a name="understandlk-CHP-12-TABLE-18"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-18. The flags of the open( ) system call</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Flag name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_RDONLY</tt></p></td><td class="docTableCell"><p class="docText2">Open for reading</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_WRONLY</tt></p></td><td class="docTableCell"><p class="docText2">Open for writing</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_RDWR</tt></p></td><td class="docTableCell"><p class="docText2">Open for both reading and writing</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_CREAT</tt></p></td><td class="docTableCell"><p class="docText2">Create the file if it does not exist</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_EXCL</tt></p></td><td class="docTableCell"><p class="docText2">With <tt class="calibre25">O_CREAT</tt>, fail if the file already exists</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_NOCTTY</tt></p></td><td class="docTableCell"><p class="docText2">Never consider the file as a controlling terminal</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_TRUNC</tt></p></td><td class="docTableCell"><p class="docText2">Truncate the file (remove all existing contents)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_APPEND</tt></p></td><td class="docTableCell"><p class="docText2">Always write at end of the file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_NONBLOCK</tt></p></td><td class="docTableCell"><p class="docText2">No system calls will block on the file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_NDELAY</tt></p></td><td class="docTableCell"><p class="docText2">Same as <tt class="calibre25">O_NONBLOCK</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_SYNC</tt></p></td><td class="docTableCell"><p class="docText2">Synchronous write (block until physical write terminates)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">FASYNC</tt></p></td><td class="docTableCell"><p class="docText2">I/O event notification via signals</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_DIRECT</tt></p></td><td class="docTableCell"><p class="docText2">Direct I/O transfer (no kernel buffering)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_LARGEFILE</tt></p></td><td class="docTableCell"><p class="docText2">Large file (size greater than 2 GB)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_DIRECTORY</tt></p></td><td class="docTableCell"><p class="docText2">Fail if file is not a directory</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">O_NOFOLLOW</tt></p></td><td class="docTableCell"><p class="docText2">Do not follow a trailing symbolic link in pathname</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">O_NOATIME</p></td><td class="docTableCell"><p class="docText2">Do not update the inode's last access time</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Let's describe the operation of the <tt class="calibre25">sys_open( )</tt> function. It performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">getname( )</tt> to read the file pathname from the process address space.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">get_unused_fd( )</tt> to find an empty slot in <tt class="calibre25">current-&gt;files-&gt;fd</tt>. The corresponding index (the new file descriptor) is stored in the <tt class="calibre25">fd</tt> local variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">filp_open( )</tt> function, passing as parameters the pathname, the access mode flags, and the permission bit mask. This function, in turn, executes the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Copies the access mode flags into <tt class="calibre25">namei_flags</tt>, but encodes the access mode flags <tt class="calibre25">O_RDONLY</tt>, <tt class="calibre25">O_WRONLY</tt>, and <tt class="calibre25">O_RDWR</tt> with a special format: the bit at index 0 (lowest-order) of <tt class="calibre25">namei_flags</tt> is set only if the file access requires read privileges; similarly, the bit at index 1 is set only if the file access requires write privileges. Notice that it is not possible to specify in the <tt class="calibre25">open( )</tt> system call that a file access does not require either read or write privileges; this makes sense, however, in a pathname lookup operation involving symbolic links.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">open_namei( )</tt>, passing to it the pathname, the modified access mode flags, and the address of a local <tt class="calibre25">nameidata</tt> data structure. The function performs the lookup operation in the following manner:</p><ul class="calibre67"><li class="calibre12"><p class="docList">If <tt class="calibre25">O_CREAT</tt> is not set in the access mode flags, starts the lookup operation with the <tt class="calibre25">LOOKUP_PARENT</tt> flag not set and the <tt class="calibre25">LOOKUP_OPEN</tt> flag set. Moreover, the <tt class="calibre25">LOOKUP_FOLLOW</tt> flag is set only if <tt class="calibre25">O_NOFOLLOW</tt> is cleared, while the <tt class="calibre25">LOOKUP_DIRECTORY</tt> flag is set only if the <tt class="calibre25">O_DIRECTORY</tt> flag is set.</p></li><li class="calibre12"><p class="docList">If <tt class="calibre25">O_CREAT</tt> is set in the access mode flags, starts the lookup operation with the <tt class="calibre25">LOOKUP_PARENT</tt>, <tt class="calibre25">LOOKUP_OPEN</tt>, and <tt class="calibre25">LOOKUP_CREATE</tt> flags set. Once the <tt class="calibre25">path_lookup( )</tt> function successfully returns, checks whether the requested file already exists. If not, allocates a new disk inode by invoking the <tt class="calibre25">create</tt> method of the parent inode.</p></li></ul><p class="docList">The <tt class="calibre25">open_namei( )</tt> function also executes several security checks on the file located by the lookup operation. For instance, the function checks whether the inode associated with the dentry object found really exists, whether it is a regular file, and whether the current process is allowed to access it according to the access mode flags. Also, if the file is opened for writing, the function checks that the file is not locked by other processes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">dentry_open( )</tt> function, passing to it the addresses of the dentry object and the mounted filesystem object located by the lookup operation, and the access mode flags. In turn, this function:</p><div class="calibre44"><ol class="docList4" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a new file object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">f_flags</tt> and <tt class="calibre25">f_mode</tt> fields of the file object according to the access mode flags passed to the <tt class="calibre25">open( )</tt> system call.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">f_dentry</tt> and <tt class="calibre25">f_vfsmnt</tt> fields of the file object according to the addresses of the dentry object and the mounted filesystem object passed as parameters.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">f_op</tt> field to the contents of the <tt class="calibre25">i_fop</tt> field of the corresponding inode object. This sets up all the methods for future file operations.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Inserts the file object into the list of opened files pointed to by the <tt class="calibre25">s_files</tt> field of the filesystem's superblock.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">open</tt> method of the file operations is defined, the function invokes it.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">file_ra_state_init( )</tt> to initialize the read-ahead data structures (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">O_DIRECT</tt> flag is set, it checks whether direct I/O operations can be performed on the file (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address of the file object.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address of the file object.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">current-&gt;files-&gt;fd[fd]</tt> to the address of the file object returned by <tt class="calibre25">dentry_open( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns <tt class="calibre25">fd</tt>.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-6.2"></a>
<h4 class="docSection2Title">12.6.2. The read( ) and write( ) System Calls</h4><a name="IDX-CHP-12-3293"></a>
<a name="IDX-CHP-12-3294"></a>
<a name="IDX-CHP-12-3295"></a>
<a name="IDX-CHP-12-3296"></a>
<a name="IDX-CHP-12-3297"></a>
<p class="docText1">Let's return to the code in our <span class="docEmphasis">cp</span> example. The <tt class="calibre25">open( )</tt> system calls return two file descriptors, which are stored in the <tt class="calibre25">inf</tt> and <tt class="calibre25">outf</tt> variables. Then the program starts a loop: at each iteration, a portion of the <i class="docEmphasis">/floppy/TEST</i> file is copied into a local buffer (<tt class="calibre25">read( )</tt> system call), and then the data in the local buffer is written into the <i class="docEmphasis">/tmp/test</i> file (<tt class="calibre25">write( )</tt> system call).</p>
<p class="docText1">The <tt class="calibre25">read( )</tt> and <tt class="calibre25">write( )</tt> system calls are quite similar. Both require three parameters: a file descriptor <tt class="calibre25">fd</tt>, the address <tt class="calibre25">buf</tt> of a memory area (the buffer containing the data to be transferred), and a number <tt class="calibre25">count</tt> that specifies how many bytes should be transferred. Of course, <tt class="calibre25">read( )</tt> transfers the data from the file into the buffer, while <tt class="calibre25">write( )</tt> does the opposite. Both system calls return either the number of bytes that were successfully transferred or -1 to signal an error condition.</p>
<p class="docText1">A return value less than <tt class="calibre25">count</tt> does not mean that an error occurred. The kernel is always allowed to terminate the system call even if not all requested bytes were transferred, and the user application must accordingly check the return value and reissue, if necessary, the system call. Typically, a small value is returned when reading from a pipe or a terminal device, when reading past the end of the file, or when the system call is interrupted by a signal. The end-of-file condition (EOF) can easily be recognized by a zero return value from <tt class="calibre25">read( )</tt>. This condition will not be confused with an abnormal termination due to a signal, because if <tt class="calibre25">read( )</tt> is interrupted by a signal before a data is read, an error occurs.</p>
<p class="docText1">The read or write operation always takes place at the file offset specified by the current file pointer (field <tt class="calibre25">f_pos</tt> of the file object). Both system calls update the file pointer by adding the number of transferred bytes to it.</p>
<p class="docText1">In short, both <tt class="calibre25">sys_read( )</tt> (the <tt class="calibre25">read( )</tt>'s service routine) and <tt class="calibre25">sys_write( )</tt> (the <tt class="calibre25">write( )</tt>'s service routine) perform almost the same steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">fget_light( )</tt> to derive from <tt class="calibre25">fd</tt> the address <tt class="calibre25">file</tt> of the corresponding file object (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.6">Files Associated with a Process</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the flags in <tt class="calibre25">file-&gt;f_mode</tt> do not allow the requested access (read or write operation), it returns the error code <tt class="calibre25">-EBADF</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">file</tt> object does not have a <tt class="calibre25">read( )</tt> or <tt class="calibre25">aio_read( )</tt> (<tt class="calibre25">write( )</tt> or <tt class="calibre25">aio_write( )</tt>) file operation, it returns the error code <tt class="calibre25">-EINVAL</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">access_ok()</tt> to perform a coarse check on the <tt class="calibre25">buf</tt> and <tt class="calibre25">count</tt> parameters (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10-SECT-4.html#understandlk-CHP-10-SECT-4.1">Verifying the Parameters</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">rw_verify_area( )</tt> to check whether there are conflicting mandatory locks for the file portion to be accessed. If so, it returns an error code, or puts the current process to sleep if the lock has been requested with a <tt class="calibre25">F_SETLKW</tt> command (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-7.html#understandlk-CHP-12-SECT-7">File Locking</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If defined, it invokes either the <tt class="calibre25">file-&gt;f_op-&gt;read</tt> or <tt class="calibre25">file-&gt;f_op-&gt;write</tt> method to transfer the data; otherwise, invokes either the <tt class="calibre25">file-&gt;f_op-&gt;aio_read</tt> or <tt class="calibre25">file-&gt;f_op-&gt;aio_write</tt> method. All these methods, which are discussed in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>, return the number of bytes that were actually transferred. As a side effect, the file pointer is properly updated.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">fput_light( )</tt> to release the file object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the number of bytes actually transferred.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-6.3"></a>
<h4 class="docSection2Title">12.6.3. The close( ) System Call</h4><a name="IDX-CHP-12-3298"></a>
<a name="IDX-CHP-12-3299"></a>
<a name="IDX-CHP-12-3300"></a>
<a name="IDX-CHP-12-3301"></a>
<a name="IDX-CHP-12-3302"></a>
<a name="IDX-CHP-12-3303"></a>
<p class="docText1">The loop in our example code terminates when the <tt class="calibre25">read( )</tt> system call returns the value 0that is, when all bytes of <i class="docEmphasis">/floppy/TEST</i> have been copied into <i class="docEmphasis">/tmp/test</i>. The program can then close the open files, because the copy operation has completed.</p>
<p class="docText1">The <tt class="calibre25">close( )</tt> system call receives as its parameter <tt class="calibre25">fd</tt>, which is the file descriptor of the file to be closed. The <tt class="calibre25">sys_close( )</tt> service routine performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Gets the file object address stored in <tt class="calibre25">current-&gt;files-&gt;fd[fd]</tt>; if it is <tt class="calibre25">NULL</tt>, returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">current-&gt;files-&gt;fd[fd]</tt> to <tt class="calibre25">NULL</tt>. Releases the file descriptor <tt class="calibre25">fd</tt> by clearing the corresponding bits in the <tt class="calibre25">open_fds</tt> and <tt class="calibre25">close_on_exec</tt> fields of <tt class="calibre25">current-&gt;files</tt> (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a> for the Close on Execution flag).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">filp_close( )</tt>, which performs the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">flush</tt> method of the file operations, if defined.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases all mandatory locks on the file, if any (see next section).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">fput( )</tt> to release the file object.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 0 or an error code. An error code can be raised by the <tt class="calibre25">flush</tt> method or by an error in a previous write operation on the file.</p></div></li></ol></div>

<br class="calibre7"/>

</div>

{% endraw %}

