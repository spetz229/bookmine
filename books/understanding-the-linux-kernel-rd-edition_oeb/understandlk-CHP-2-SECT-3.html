---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-2-SECT-2.html
next: understandlk-CHP-2-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-2-SECT-3"></a>
<h3 class="docSection1Title">2.3. Segmentation in Linux</h3><a name="IDX-CHP-2-0340"></a>
<a name="IDX-CHP-2-0341"></a>
<a name="IDX-CHP-2-0342"></a>
<a name="IDX-CHP-2-0343"></a>
<a name="IDX-CHP-2-0344"></a>
<a name="IDX-CHP-2-0345"></a>
<a name="IDX-CHP-2-0346"></a>
<a name="IDX-CHP-2-0347"></a>
<p class="docText1">Segmentation has been included in 80 x 86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Memory management is simpler when all processes use the same segment register values  that is, when they share the same set of linear addresses.</p></li><li class="calibre12"><p class="docText1">One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures in particular have limited support for segmentation.</p></li></ul>
<p class="docText1">The 2.6 version of Linux uses segmentation only when required by the 80 x 86 architecture.</p>
<p class="docText1">All Linux processes running in User Mode use the same pair of segments to address instructions and data. These segments are called <span class="docEmphasis">user code segment</span><a name="IDX-CHP-2-0348"></a> 
 and <span class="docEmphasis">user data segment</span><a name="IDX-CHP-2-0349"></a> 
, respectively. Similarly, all Linux processes running in Kernel Mode use the same pair of segments to address instructions and data: they are called <span class="docEmphasis">kernel code segment</span><a name="IDX-CHP-2-0350"></a> 
 and <span class="docEmphasis">kernel data segment</span><a name="IDX-CHP-2-0351"></a> 
, respectively. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-2-TABLE-3">Table 2-3</a> shows the values of the Segment Descriptor fields for these four crucial segments.</p>
<a name="understandlk-CHP-2-TABLE-3"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 2-3. Values of the Segment Descriptor fields for the four main Linux segments</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Segment</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Base</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">G</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Limit</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">S</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">DPL</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">D/B</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">P</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2">user code</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0x00000000</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0xfffff</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">10</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">1</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">user data</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0x00000000</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0xfffff</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">2</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">1</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">kernel code</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0x00000000</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0xfffff</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">10</p></td><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">1</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">kernel data</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0x00000000</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">0xfffff</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">2</p></td><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">1</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The corresponding Segment Selectors are defined by the macros <tt class="calibre25">_ _USER_CS</tt>, <tt class="calibre25">_ _USER_DS</tt>, <tt class="calibre25">_ _KERNEL_CS</tt>, and <tt class="calibre25">_ _KERNEL_DS</tt>, respectively. To address the kernel code segment, for instance, the kernel just loads the value yielded by the <tt class="calibre25">_ _KERNEL_CS</tt> macro into the <tt class="calibre25">cs</tt> segmentation register.</p>
<p class="docText1">Notice that the linear addresses associated with such segments all start at 0 and reach the addressing limit of 2<sup class="calibre37">32</sup> -1. This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses.</p>
<p class="docText1">Another important consequence of having all segments start at <tt class="calibre25">0x00000000</tt> is that in Linux, logical addresses coincide with linear addresses; that is, the value of the Offset field of a logical address always coincides with the value of the corresponding linear address.</p>
<p class="docText1">As stated earlier, the Current Privilege Level of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the <tt class="calibre25">RPL</tt> field of the Segment Selector stored in the <tt class="calibre25">cs</tt> register. Whenever the CPL is changed, some segmentation registers must be correspondingly updated. For instance, when the <tt class="calibre25">CPL</tt> is equal to 3 (User Mode), the <tt class="calibre25">ds</tt> register must contain the Segment Selector of the user data segment, but when the CPL is equal to 0, the <tt class="calibre25">ds</tt> register must contain the Segment Selector of the kernel data segment.</p>
<p class="docText1">A similar situation occurs for the <tt class="calibre25">ss</tt> register. It must refer to a User Mode stack inside the user data segment when the CPL is 3, and it must refer to a Kernel Mode stack inside the kernel data segment when the CPL is 0. When switching from User Mode to Kernel Mode, Linux always makes sure that the <tt class="calibre25">ss</tt> register contains the Segment Selector of the kernel data segment.</p>
<p class="docText1">When saving a pointer to an instruction or to a data structure, the kernel does not need to store the Segment Selector component of the logical address, because the <tt class="calibre25">ss</tt> register contains the current Segment Selector. As an example, when the kernel invokes a function, it executes a <tt class="calibre25">call</tt><a name="IDX-CHP-2-0352"></a> 
 assembly language instruction specifying just the Offset component of its logical address; the Segment Selector is implicitly selected as the one referred to by the <tt class="calibre25">cs</tt> register. Because there is just one segment of type "executable in Kernel Mode," namely the code segment identified by <tt class="calibre25">__KERNEL_CS</tt>, it is sufficient to load <tt class="calibre25">__KERNEL_CS</tt> into <tt class="calibre25">cs</tt> whenever the CPU switches to Kernel Mode. The same argument goes for pointers to kernel data structures (implicitly using the <tt class="calibre25">ds</tt> register), as well as for pointers to user data structures (the kernel explicitly uses the <tt class="calibre25">es</tt> register).</p>
<p class="docText1">Besides the four segments just described, Linux makes use of a few other specialized segments. We'll introduce them in the next section while describing the Linux GDT.</p>
<a name="understandlk-CHP-2-SECT-3.1"></a>
<h4 class="docSection2Title">2.3.1. The Linux GDT</h4><a name="IDX-CHP-2-0353"></a>
<a name="IDX-CHP-2-0354"></a>
<a name="IDX-CHP-2-0355"></a>
<a name="IDX-CHP-2-0356"></a>
<p class="docText1">In uniprocessor systems there is only one GDT, while in multiprocessor systems there is one GDT for every CPU in the system. All GDTs are stored in the <tt class="calibre25">cpu_gdt_table</tt> array, while the addresses and sizes of the GDTs (used when initializing the <tt class="calibre25">gdtr</tt> registers) are stored in the <tt class="calibre25">cpu_gdt_descr</tt> array. If you look in the Source Code Index, you can see that these symbols are defined in the file <i class="docEmphasis">arch/i386/kernel/head.S</i><a name="IDX-CHP-2-0357"></a>
<a name="IDX-CHP-2-0358"></a> 
. Every macro, function, and other symbol in this book is listed in the Source Code Index, so you can quickly find it in the source code.</p>
<p class="docText1">The layout of the GDTs is shown schematically in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-2-FIG-6">Figure 2-6</a>. Each GDT includes 18 segment descriptors and 14 null, unused, or reserved entries. Unused entries are inserted on purpose so that Segment Descriptors usually accessed together are kept in the same 32-byte line of the hardware cache (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-4.html#understandlk-CHP-2-SECT-4.7">Hardware Cache</a>" later in this chapter).</p>
<p class="docText1">The 18 segment descriptors included in each GDT point to the following segments:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Four user and kernel code and data segments (see previous section).</p></li><li class="calibre12"><p class="docText1">A Task State Segment (TSS), different for each processor in the system. The linear address space corresponding to a TSS is a small subset of the linear address space corresponding to the kernel data segment. The Task State Segments are sequentially stored in the <tt class="calibre25">init_tss</tt> array; in particular, the <tt class="calibre25">Base</tt> field of the TSS descriptor for the <span class="docEmphasis">n</span><sup class="calibre37">th</sup> CPU points to the <span class="docEmphasis">n</span><sup class="calibre37">th</sup> component of the <tt class="calibre25">init_tss</tt> array. The <tt class="calibre25">G</tt> (granularity) flag is cleared, while the <tt class="calibre25">Limit</tt> field is set to <tt class="calibre25">0xeb</tt>, because the TSS segment is 236 bytes long. The <tt class="calibre25">Type</tt> field is set to 9 or 11 (available 32-bit TSS), and the <tt class="calibre25">DPL</tt> is set to 0, because processes in User Mode are not allowed to access TSS segments. You will find details on how Linux uses TSSs in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-3.html#understandlk-CHP-3-SECT-3.2">Task State Segment</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>.</p><a name="understandlk-CHP-2-FIG-6"></a><p class="calibre14"><center class="calibre8">
<h5 class="docFigureTitle">Figure 2-6. The Global Descriptor Table</h5>
<img border="0" alt="" src="understandlk_0206.jpg" class="calibre39"/></center></p></li><li class="calibre12"><p class="docText1">A segment including the default Local Descriptor Table (LDT), usually shared by all processes (see the next section).</p></li><li class="calibre12"><p class="docText1">Three <span class="docEmphasis">Thread-Local Storage (TLS)</span> segments: this is a mechanism that allows multithreaded applications to make use of up to three segments containing data local to each thread. The <tt class="calibre25">set_thread_area( )</tt><a name="IDX-CHP-2-0359"></a> 
 and <tt class="calibre25">get_thread_area( )</tt><a name="IDX-CHP-2-0360"></a> 
 system calls, respectively, create and release a TLS segment for the executing process.</p></li><li class="calibre12"><p class="docText1">Three segments related to Advanced Power Management (APM<a name="IDX-CHP-2-0361"></a> 
): the BIOS<a name="IDX-CHP-2-0362"></a> 
 code makes use of segments, so when the Linux APM driver invokes BIOS functions to get or set the status of APM devices, it may use custom code and data segments.</p></li><li class="calibre12"><p class="docText1">Five segments related to Plug and Play (PnP<a name="IDX-CHP-2-0363"></a> 
) BIOS services. As in the previous case, the BIOS code makes use of segments, so when the Linux PnP driver invokes BIOS functions to detect the resources used by PnP devices, it may use custom code and data segments.</p></li><li class="calibre12"><p class="docText1">A special TSS segment used by the kernel to handle "Double fault<a name="IDX-CHP-2-0364"></a> 
" exceptions (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.2">Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></li></ul>
<p class="docText1">As stated earlier, there is a copy of the GDT for each processor in the system. All copies of the GDT store identical entries, except for a few cases. First, each processor has its own TSS segment, thus the corresponding GDT's entries differ. Moreover, a few entries in the GDT may depend on the process that the CPU is executing (LDT and TLS Segment Descriptors). Finally, in some cases a processor may temporarily modify an entry in its copy of the GDT; this happens, for instance, when invoking an APM's BIOS procedure.</p>
<a name="understandlk-CHP-2-SECT-3.2"></a>
<h4 class="docSection2Title">2.3.2. The Linux LDTs</h4><a name="IDX-CHP-2-0365"></a>
<a name="IDX-CHP-2-0366"></a>
<a name="IDX-CHP-2-0367"></a>
<p class="docText1">Most Linux User Mode applications do not make use of a Local Descriptor Table, thus the kernel defines a default LDT to be shared by most processes. The default Local Descriptor Table is stored in the <tt class="calibre25">default_ldt</tt> array. It includes five entries, but only two of them are effectively used by the kernel: a call gate for iBCS executables, and a call gate for Solaris<a name="IDX-CHP-2-0368"></a> 
/x86 executables (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-3.html#understandlk-CHP-20-SECT-3">Execution Domains</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>). <span class="docEmphasis">Call gates</span> are a mechanism provided by 80 x 86 microprocessors to change the privilege level of the CPU while invoking a predefined function; as we won't discuss them further, you should consult the Intel documentation for more details.</p>
<p class="docText1">In some cases, however, processes may require to set up their own LDT. This turns out to be useful to applications (such as Wine) that execute segment-oriented Microsoft Windows<a name="IDX-CHP-2-0369"></a> 
 applications. The <tt class="calibre25">modify_ldt( )</tt><a name="IDX-CHP-2-0370"></a> 
 system call allows a process to do this.</p>
<p class="docText1">Any custom LDT created by <tt class="calibre25">modify_ldt( )</tt> also requires its own segment. When a processor starts executing a process having a custom LDT, the LDT entry in the CPU-specific copy of the GDT is changed accordingly.</p>
<p class="docText1">User Mode applications also may allocate new segments by means of <tt class="calibre25">modify_ldt( )</tt>; the kernel, however, never makes use of these segments, and it does not have to keep track of the corresponding Segment Descriptors, because they are included in the custom LDT of the process.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

