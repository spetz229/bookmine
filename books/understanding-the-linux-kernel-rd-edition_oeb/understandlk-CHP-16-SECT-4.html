---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-16-SECT-3.html
next: understandlk-CHP-17.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-16-SECT-4"></a>
<h3 class="docSection1Title">16.4. Asynchronous I/O</h3><a name="IDX-CHP-16-4041"></a>
<a name="IDX-CHP-16-4042"></a>
<a name="IDX-CHP-16-4043"></a>
<p class="docText1">The POSIX 1003.1 standard defines a set of library functionslisted in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-16-TABLE-4">Table 16-4</a>for accessing the files in an asynchronous way. "Asynchronous" essentially means that when a User Mode process invokes a library function to read or write a file, the function terminates as soon as the read or write operation has been enqueued, possibly even before the actual I/O data transfer takes place. The calling process can thus continue its execution while the data is being transferred.</p>
<a name="understandlk-CHP-16-TABLE-4"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 16-4. The POSIX library functions for asynchronous I/O</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Function</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_read( )</tt><a name="IDX-CHP-16-4044"></a>
</p></td><td class="docTableCell"><p class="docText2">Asynchronously reads some data from a file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_write( )</tt><a name="IDX-CHP-16-4045"></a>
</p></td><td class="docTableCell"><p class="docText2">Asynchronously writes some data into a file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_fsync( )</tt><a name="IDX-CHP-16-4046"></a>
</p></td><td class="docTableCell"><p class="docText2">Requests a flush operation for all outstanding asynchronous I/O operations (does not block)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_error( )</tt><a name="IDX-CHP-16-4047"></a>
</p></td><td class="docTableCell"><p class="docText2">Gets the error code for an outstanding asynchronous I/O operation</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_return( )</tt><a name="IDX-CHP-16-4048"></a>
</p></td><td class="docTableCell"><p class="docText2">Gets the return code for a completed asynchronous I/O operation</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_cancel( )</tt><a name="IDX-CHP-16-4049"></a>
</p></td><td class="docTableCell"><p class="docText2">Cancels an outstanding asynchronous I/O operation</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_suspend( )</tt><a name="IDX-CHP-16-4050"></a>
</p></td><td class="docTableCell"><p class="docText2">Suspends the process until at least one of several outstanding I/O operations completes</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Using asynchronous I/O is quite simple. The application opens the file by means of the usual <tt class="calibre25">open( )</tt><a name="IDX-CHP-16-4051"></a> 
 system call. Then, it fills up a control block of type <tt class="calibre25">struct aiocb</tt> with the information describing the requested operation. The most commonly used fields of the <tt class="calibre25">struct aiocb</tt> control block are:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">aio_fildes</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The file descriptor of the file (as returned by the <tt class="calibre25">open( )</tt> system call)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">aio_buf</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The User Mode buffer for the file's data</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">aio_nbytes</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">How many bytes should be transferred</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">aio_offset</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Position in the file where the read or write operation will start (it is independent of the "synchronous" file pointer)</p></dd></dl>
<p class="docText1">Finally, the application passes the address of the control block to either <tt class="calibre25">aio_read( )</tt><a name="IDX-CHP-16-4052"></a> 
 or <tt class="calibre25">aio_write( )</tt><a name="IDX-CHP-16-4053"></a> 
; both functions terminate as soon as the requested I/O data transfer has been enqueued by the system library or kernel. The application can later check the status of the outstanding I/O operation by invoking <tt class="calibre25">aio_error( )</tt>, which returns <tt class="calibre25">EINPROGRESS</tt> if the data transfer is still in progress, 0 if it is successfully completed, or an error code in case of failure. The <tt class="calibre25">aio_return( )</tt> function returns the number of bytes effectively read or written by a completed asynchronous I/O operation, or <tt class="calibre25">-</tt>1 in case of failure.</p>
<a name="understandlk-CHP-16-SECT-4.1"></a>
<h4 class="docSection2Title">16.4.1. Asynchronous I/O in Linux 2.6</h4><a name="IDX-CHP-16-4054"></a>
<p class="docText1">Asynchronous I/O can be implemented by a system library without any kernel support at all. Essentially, the <tt class="calibre25">aio_read( )</tt> or <tt class="calibre25">aio_write( )</tt> library function clones the current process and lets the child invoke the synchronous <tt class="calibre25">read( )</tt><a name="IDX-CHP-16-4055"></a> 
 or <tt class="calibre25">write( )</tt><a name="IDX-CHP-16-4056"></a> 
 system calls; then, the parent terminates the <tt class="calibre25">aio_read( )</tt> or <tt class="calibre25">aio_write( )</tt> function and continues the execution of the program, hence it does not wait for the synchronous operation started by the child to finish. However, this "poor man's" version of the POSIX functions is significantly slower than a version that uses a kernel-level implementation of asynchronous I/O.</p>
<p class="docText1">The Linux 2.6 kernel version sports a set of system calls for asynchronous I/O. However, in Linux 2.6.11 this feature is a work in progress, and asyncronous I/O works properly only for files opened with the <tt class="calibre25">O_DIRECT</tt> flag set (see the previous section). The system calls for asynchronous I/O are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-16-TABLE-5">Table 16-5</a>.</p>
<a name="understandlk-CHP-16-TABLE-5"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 16-5. Linux system calls for asynchronous I/O</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">System call</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">io_setup( )</tt><a name="IDX-CHP-16-4057"></a>
</p></td><td class="docTableCell"><p class="docText2">Initializes an asynchronous context for the current process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">io_submit( )</tt><a name="IDX-CHP-16-4058"></a>
</p></td><td class="docTableCell"><p class="docText2">Submits one or more asynchronous I/O operations</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">io_getevents( )</tt><a name="IDX-CHP-16-4059"></a>
</p></td><td class="docTableCell"><p class="docText2">Gets the completion status of some outstanding asynchronous I/O operations</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">io_cancel( )</tt><a name="IDX-CHP-16-4060"></a>
</p></td><td class="docTableCell"><p class="docText2">Cancels an outstanding I/O operation</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">io_destroy( )</tt><a name="IDX-CHP-16-4061"></a>
</p></td><td class="docTableCell"><p class="docText2">Removes an asynchronous context for the current process</p></td></tr></table></p><br class="calibre7"/>
<a name="understandlk-CHP-16-SECT-4.1.1"></a>
<h5 class="docSection3Title">16.4.1.1. The asynchronous I/O context</h5><a name="IDX-CHP-16-4062"></a>
<a name="IDX-CHP-16-4063"></a>
<a name="IDX-CHP-16-4064"></a>
<a name="IDX-CHP-16-4065"></a>
<a name="IDX-CHP-16-4066"></a>
<a name="IDX-CHP-16-4067"></a>
<p class="docText1">If a User Mode process wants to make use of the <tt class="calibre25">io_submit( )</tt> system call to start an asynchronous I/O operation, it must create beforehand an <span class="docEmphasis">asynchronous I/O context</span>.</p>
<p class="docText1">Basically, an asynchronous I/O context (in short, AIO context) is a set of data structures that keep track of the on-going progresses of the asynchronous I/O operations requested by the process. Each AIO context is associated with a <tt class="calibre25">kioctx</tt> object, which stores all information relevant for the context. An application might create several AIO contexts; all <tt class="calibre25">kioctx</tt> descriptors of a given process are collected in a singly linked list rooted at the <tt class="calibre25">ioctx_list</tt> field of the memory descriptor (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-2.html#understandlk-CHP-9-TABLE-2">Table 9-2</a> in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>).</p>
<p class="docText1">We are not going to discuss in detail the <tt class="calibre25">kioctx</tt> object; however, we should pinpoint an important data structure referenced by the <tt class="calibre25">kioctx</tt> object: the AIO ring.</p>
<p class="docText1">The <span class="docEmphasis">AIO ring</span> is a memory buffer in the address space of the User Mode process that is also accessible by all processes in Kernel Mode. The User Mode starting address and length of the AIO ring are stored in the <tt class="calibre25">ring_info.mmap_base</tt> and <tt class="calibre25">ring_info.mmap_size</tt> fields of the <tt class="calibre25">kioctx</tt> object, respectively. The descriptors of all page frames composing the AIO ring are stored in an array pointed to by the <tt class="calibre25">ring_info.ring_pages</tt> field.</p>
<p class="docText1">The AIO ring is essentially a circular buffer where the kernel writes the completion reports of the outstanding asynchronous I/O operations. The first bytes of the AIO ring contain an header (a <tt class="calibre25">struct aio_ring</tt> data structure); the remaining bytes store <tt class="calibre25">io_event</tt> data structures, each of which describes a completed asynchronous I/O operation. Because the pages of the AIO ring are mapped in the User Mode address space of the process, the application can check directly the progress of the outstanding asynchronous I/O operations, thus avoiding using a relatively slow system call.</p>
<p class="docText1">The <tt class="calibre25">io_setup( )</tt> system call creates a new AIO context for the calling process. It expects two parameters: the maximum number of outstanding asynchronous I/O operations, which ultimately determines the size of the AIO ring, and a pointer to a variable that will store a handle to the context; this handle is also the base address of the AIO ring. The <tt class="calibre25">sys_io_setup( )</tt> service routine essentially invokes <tt class="calibre25">do_mmap( )</tt> to allocate a new anonymous memory region for the process that will contain the AIO ring (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-3.html#understandlk-CHP-9-SECT-3.4">Allocating a Linear Address Interval</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>), and creates and initializes a <tt class="calibre25">kioctx</tt> object describing the AIO context.</p>
<p class="docText1">Conversely, the <tt class="calibre25">io_destroy( )</tt> system call removes an AIO context; it also destroys the anonymous memory region containing the corresponding AIO ring. The system call blocks the current process until all outstanding asynchronous I/O operations are complete.</p>
<a name="understandlk-CHP-16-SECT-4.1.2"></a>
<h5 class="docSection3Title">16.4.1.2. Submitting the asynchronous I/O operations</h5><a name="IDX-CHP-16-4068"></a>
<a name="IDX-CHP-16-4069"></a>
<a name="IDX-CHP-16-4070"></a>
<a name="IDX-CHP-16-4071"></a>
<a name="IDX-CHP-16-4072"></a>
<a name="IDX-CHP-16-4073"></a>
<a name="IDX-CHP-16-4074"></a>
<a name="IDX-CHP-16-4075"></a>
<a name="IDX-CHP-16-4076"></a>
<a name="IDX-CHP-16-4077"></a>
<p class="docText1">To start some asynchronous I/O operations, the application invokes the <tt class="calibre25">io_submit( )</tt> system call. The system call has three parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ctx_id</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The handle returned by <tt class="calibre25">io_setup( )</tt>, which identifies the AIO context</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">iocbpp</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The address of an array of pointers to descriptors of type <tt class="calibre25">iocb</tt>, each of which describes one asynchronous I/O operation</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">nr</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The length of the array pointed to by <tt class="calibre25">iocbpp</tt></p></dd></dl>
<p class="docText1">The <tt class="calibre25">iocb</tt> data structure includes the same fields as the POSIX <tt class="calibre25">aiocb</tt> descriptor (<tt class="calibre25">aio_fildes</tt>, <tt class="calibre25">aio_buf</tt>, <tt class="calibre25">aio_nbytes</tt>, <tt class="calibre25">aio_offset</tt>) plus the <tt class="calibre25">aio_lio_opcode</tt> field that stores the type of the requested operation (typically read, write, or sync).</p>
<p class="docText1">The service routine <tt class="calibre25">sys_io_submit( )</tt> performs essentially the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Verifies that the array of <tt class="calibre25">iocb</tt> descriptors is valid.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Searches the <tt class="calibre25">kioctx</tt> object corresponding to the <tt class="calibre25">ctx_id</tt> handle in the list rooted at the <tt class="calibre25">ioctx_list</tt> field of the memory descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">For each <tt class="calibre25">iocb</tt> descriptor in the array, it executes the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Gets the address of the file object corresponding to the file descriptor stored in the <tt class="calibre25">aio_fildes</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates and initializes a new <tt class="calibre25">kiocb</tt> descriptor for the I/O operation.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks that there is a free slot in the AIO ring to store the completion result of the operation.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">ki_retry</tt> method of the <tt class="calibre25">kiocb</tt> descriptor according to the type of the operation (see below).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">aio_run_iocb( )</tt> function, which essentially invokes the <tt class="calibre25">ki_retry</tt> method to start the I/O data transfer for the corresponding asynchronous I/O operation. If the <tt class="calibre25">ki_retry</tt> method returns the value <tt class="calibre25">-EIOCBRETRY</tt>, the asynchronous I/O operation has been submitted but not yet fully satisfied: the <tt class="calibre25">aio_run_iocb( )</tt> function will be invoked again on this <tt class="calibre25">kiocb</tt> at a later time (see below). Otherwise, it invokes <tt class="calibre25">aio_complete( )</tt> to add a completion event for the asynchronous I/O operation in the ring of the AIO context.</p></div></li></ol></div></div></li></ol></div>
<p class="docText1">If the asynchronous I/O operation is a read request, the <tt class="calibre25">ki_retry</tt> method of the corresponding <tt class="calibre25">kiocb</tt> descriptor is implemented by <tt class="calibre25">aio_pread( )</tt>. This function essentially executes the <tt class="calibre25">aio_read</tt> method of the file object, then updates the <tt class="calibre25">ki_buf</tt> and <tt class="calibre25">ki_left</tt> fields of the <tt class="calibre25">kiocb</tt> descriptor (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-TABLE-1">Table 16-1</a> earlier in this chapter) according to the value returned by the <tt class="calibre25">aio_read</tt> method. Finally, <tt class="calibre25">aio_pread( )</tt> returns the number of bytes effectively read from the file, or the value <tt class="calibre25">-EIOCBRETRY</tt> if the function determines that not all requested bytes have been transferred. For most filesystems, the <tt class="calibre25">aio_read</tt> method of the file object ends up invoking the <tt class="calibre25">_ _generic_file_aio_read( )</tt> function. Assuming that the <tt class="calibre25">O_DIRECT</tt> flag of the file is set, this function ends up invoking the <tt class="calibre25">generic_file_direct_IO( )</tt> function, as described in the previous section. In this case, however, the <tt class="calibre25">_ _blockdev_direct_IO( )</tt> function does not block the current process waiting for the I/O data transfer to complete; instead, the function returns immediately. Because the asynchronous I/O operation is still outstanding, the <tt class="calibre25">aio_run_iocb( )</tt> will be invoked again, this time by the <span class="docEmphasis">aio</span><a name="IDX-CHP-16-4078"></a> 
 kernel thread of the <tt class="calibre25">aio_wq</tt> work queue. The <tt class="calibre25">kiocb</tt> descriptor keeps track of the progress of the I/O data transfer; eventually all requested data will be transferred and the completion result will be added to the AIO ring.</p>
<p class="docText1">Similarly, if the asynchronous I/O operation is a write request, the <tt class="calibre25">ki_retry</tt> method of the <tt class="calibre25">kiocb</tt> descriptor is implemented by <tt class="calibre25">aio_pwrite( )</tt>. This function essentially executes the <tt class="calibre25">aio_write</tt> method of the file object, then updates the <tt class="calibre25">ki_buf</tt> and <tt class="calibre25">ki_left</tt> fields of the <tt class="calibre25">kiocb</tt> descriptor (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-TABLE-1">Table 16-1</a> earlier in this chapter) according to the value returned by the <tt class="calibre25">aio_write</tt> method. Finally, <tt class="calibre25">aio_pwrite( )</tt> returns the number of bytes effectively written to the file, or the value <tt class="calibre25">-EIOCBRETRY</tt> if the function determines that not all requested bytes have been transferred. For most filesystems, the <tt class="calibre25">aio_write</tt> method of the file object ends up invoking the <tt class="calibre25">generic_file_aio_write_nolock( )</tt> function. Assuming that the <tt class="calibre25">O_DIRECT</tt> flag of the file is set, this function ends up invoking the <tt class="calibre25">generic_file_direct_IO( )</tt> function, as above.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

