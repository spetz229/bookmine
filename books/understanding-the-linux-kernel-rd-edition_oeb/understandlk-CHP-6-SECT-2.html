---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-6-SECT-1.html
next: understandlk-CHP-6-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-6-SECT-2"></a>
<h3 class="docSection1Title">6.2. The Linux Timekeeping Architecture</h3><a name="IDX-CHP-6-1660"></a>
<a name="IDX-CHP-6-1661"></a>
<p class="docText1">Linux must carry on several time-related activities. For instance, the kernel periodically:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Updates the time elapsed since system startup.</p></li><li class="calibre12"><p class="docText1">Updates the time and date.</p></li><li class="calibre12"><p class="docText1">Determines, for every CPU, how long the current process has been running, and preempts it if it has exceeded the time allocated to it. The allocation of time slots (also called "quanta") is discussed in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>.</p></li><li class="calibre12"><p class="docText1">Updates resource usage statistics.</p></li><li class="calibre12"><p class="docText1">Checks whether the interval of time associated with each software timer (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-5.html#understandlk-CHP-6-SECT-5">Software Timers and Delay Functions</a>") has elapsed.</p></li></ul>
<p class="docText1">Linux's <span class="docEmphasis">timekeeping architecture</span><a name="IDX-CHP-6-1662"></a> 
 is the set of kernel data structures and functions related to the flow of time. Actually, 80 x 86-based multiprocessor machines have a timekeeping architecture that is slightly different from the timekeeping architecture of uniprocessor machines:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">In a uniprocessor system, all time-keeping activities are triggered by interrupts raised by the global timer (either the Programmable Interval Timer or the High Precision Event Timer).</p></li><li class="calibre12"><p class="docText1">In a multiprocessor system, all general activities (such as handling of software timers) are triggered by the interrupts raised by the global timer, while CPU-specific activities (such as monitoring the execution time of the currently running process) are triggered by the interrupts raised by the local APIC timer.</p></li></ul>
<p class="docText1">Unfortunately, the distinction between the two cases is somewhat blurred. For instance, some early SMP systems based on Intel 80486 processors didn't have local APICs. Even nowadays, there are SMP motherboards so buggy that local timer interrupts are not usable at all. In these cases, the SMP kernel must resort to the UP timekeeping architecture. On the other hand, recent uniprocessor systems feature one local APIC, so the UP kernel often makes use of the SMP timekeeping architecture. However, to simplify our description, we won't discuss these hybrid cases and will stick to the two "pure" timekeeping architectures.</p>
<p class="docText1">Linux's timekeeping architecture depends also on the availability of the Time Stamp Counter (TSC), of the ACPI Power Management Timer, and of the High Precision Event Timer (HPET). The kernel uses two basic timekeeping functions: one to keep the current time up-to-date and another to count the number of nanoseconds that have elapsed within the current second. There are different ways to get the last value. Some methods are more precise and are available if the CPU has a Time Stamp Counter or a HPET; a less-precise method is used in the opposite case (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6.1">The time( ) and gettimeofday( ) System Calls</a>").</p>
<a name="understandlk-CHP-6-SECT-2.1"></a>
<h4 class="docSection2Title">6.2.1. Data Structures of the Timekeeping Architecture</h4><a name="IDX-CHP-6-1663"></a>
<a name="IDX-CHP-6-1664"></a>
<a name="IDX-CHP-6-1665"></a>
<a name="IDX-CHP-6-1666"></a>
<p class="docText1">The timekeeping architecture of Linux 2.6 makes use of a large number of data structures. As usual, we will describe the most important variables by referring to the 80 x 86 architecture.</p>
<a name="understandlk-CHP-6-SECT-2.1.1"></a>
<h5 class="docSection3Title">6.2.1.1. The timer object</h5>
<p class="docText1">In order to handle the possible timer sources in a uniform way, the kernel makes use of a "timer object," which is a descriptor of type <tt class="calibre25">timer_opts</tt> consisting of the timer name and of four standard methods shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-TABLE-1">Table 6-1</a>.</p>
<a name="understandlk-CHP-6-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 6-1. The fields of the timer_opts data structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">name</tt></p></td><td class="docTableCell"><p class="docText2">A string identifying the timer source</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">mark_offset</tt></p></td><td class="docTableCell"><p class="docText2">Records the exact time of the last tick; it is invoked by the timer interrupt handler</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">get_offset</tt></p></td><td class="docTableCell"><p class="docText2">Returns the time elapsed since the last tick</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">monotonic_clock</p></td><td class="docTableCell"><p class="docText2">Returns the number of nanoseconds since the kernel initialization</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">delay</p></td><td class="docTableCell"><p class="docText2">Waits for a given number of "loops" (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-5.html#understandlk-CHP-6-SECT-5.3">Delay Functions</a>")</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The most important methods of the timer object are <tt class="calibre25">mark_offset</tt> and <tt class="calibre25">get_offset</tt>. The <tt class="calibre25">mark_offset</tt> method is invoked by the timer interrupt handler, and records in a suitable data structure the exact time at which the tick occurred. Using the saved value, the <tt class="calibre25">get_offset</tt> method computes the time in microseconds elapsed since the last timer interrupt (tick). Thanks to these two methods, Linux timekeeping architecture achieves a sub-tick resolutionthat is, the kernel is able to determine the current time with a precision much higher than the tick duration. This operation is called <span class="docEmphasis">time interpolation</span><a name="IDX-CHP-6-1667"></a> 
.</p>
<p class="docText1">The <tt class="calibre25">cur_timer</tt> variable stores the address of the timer object corresponding to the "best" timer source available in the system. Initially, <tt class="calibre25">cur_timer</tt> points to <tt class="calibre25">timer_none</tt>, which is the object corresponding to a dummy timer source used when the kernel is being initialized. During kernel initialization, the <tt class="calibre25">select_timer( )</tt> function sets <tt class="calibre25">cur_timer</tt> to the address of the appropriate timer object. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-TABLE-2">Table 6-2</a> shows the most common timer objects used in the 80x86 architecture, in order of preference. As you see, <tt class="calibre25">select_timer( )</tt> selects the HPET, if available; otherwise, it selects the ACPI Power Management Timer<a name="IDX-CHP-6-1668"></a> 
, if available, or the TSC. As the last resort, <tt class="calibre25">select_timer( )</tt> selects the always-present PIT. The "Time interpolation" column lists the timer sources used by the <tt class="calibre25">mark_offset</tt> and <tt class="calibre25">get_offset</tt> methods of the timer object; the "Delay" column lists the timer sources used by the <tt class="calibre25">delay</tt> method.</p>
<a name="understandlk-CHP-6-TABLE-2"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 6-2. Typical timer objects of the 80<span class="docEmphasis">x</span>86 architecture, in order of preference</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Timer object name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Time interpolation</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Delay</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_hpet</tt></p></td><td class="docTableCell"><p class="docText2">High Precision Event Timer (HPET)</p></td><td class="docTableCell"><p class="docText2">HPET</p></td><td class="docTableCell"><p class="docText2">HPET</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">timer_pmtmr</p></td><td class="docTableCell"><p class="docText2">ACPI Power Management Timer (ACPI PMT)</p></td><td class="docTableCell"><p class="docText2">ACPI PMT</p></td><td class="docTableCell"><p class="docText2">TSC</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_tsc</tt></p></td><td class="docTableCell"><p class="docText2">Time Stamp Counter (TSC)</p></td><td class="docTableCell"><p class="docText2">TSC</p></td><td class="docTableCell"><p class="docText2">TSC</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_pit</tt></p></td><td class="docTableCell"><p class="docText2">Programmable Interval Timer (PIT)</p></td><td class="docTableCell"><p class="docText2">PIT</p></td><td class="docTableCell"><p class="docText2">Tight loop</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_none</tt></p></td><td class="docTableCell"><p class="docText2">Generic dummy timer source(used during kernel initialization)</p></td><td class="docTableCell"><p class="docText2">(none)</p></td><td class="docTableCell"><p class="docText2">Tight loop</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Notice that local APIC timers do not have a corresponding timer object. The reason is that local APIC timers are used only to generate periodic interrupts and are never used to achieve sub-tick resolution.</p>
<a name="understandlk-CHP-6-SECT-2.1.2"></a>
<h5 class="docSection3Title">6.2.1.2. The jiffies variable</h5><a name="IDX-CHP-6-1669"></a>
<a name="IDX-CHP-6-1670"></a>
<a name="IDX-CHP-6-1671"></a>
<a name="IDX-CHP-6-1672"></a>
<a name="IDX-CHP-6-1673"></a>
<a name="IDX-CHP-6-1674"></a>
<a name="IDX-CHP-6-1675"></a>
<a name="IDX-CHP-6-1676"></a>
<a name="IDX-CHP-6-1677"></a>
<a name="IDX-CHP-6-1678"></a>
<a name="IDX-CHP-6-1679"></a>
<p class="docText1">The <tt class="calibre25">jiffies</tt> variable is a counter that stores the number of elapsed ticks since the system was started. It is increased by one when a timer interrupt occursthat is, on every tick. In the 80 x 86 architecture, <tt class="calibre25">jiffies</tt> is a 32-bit variable, therefore it wraps around in approximately 50 daysa relatively short time interval for a Linux server. However, the kernel handles cleanly the overflow of <tt class="calibre25">jiffies</tt> thanks to the <tt class="calibre25">time_after</tt>, <tt class="calibre25">time_after_eq</tt>, <tt class="calibre25">time_before</tt>, and <tt class="calibre25">time_before_eq</tt> macros: they yield the correct value even if a wraparound occurred.</p>
<p class="docText1">You might suppose that <tt class="calibre25">jiffies</tt> is initialized to zero at system startup. Actually, this is not the case: <tt class="calibre25">jiffies</tt> is initialized to <tt class="calibre25">0xfffb6c20</tt>, which corresponds to the 32-bit signed value 300,000; therefore, the counter will overflow five minutes after the system boot. This is done on purpose, so that buggy kernel code that does not check for the overflow of <tt class="calibre25">jiffies</tt> shows up very soon in the developing phase and does not pass unnoticed in stable kernels.</p>
<p class="docText1">In a few cases, however, the kernel needs the real number of system ticks elapsed since the system boot, regardless of the overflows of <tt class="calibre25">jiffies</tt>. Therefore, in the 80 x 86 architecture the <tt class="calibre25">jiffies</tt> variable is equated by the linker to the 32 less significant bits of a 64-bit counter called <tt class="calibre25">jiffies_64</tt>. With a tick of 1 millisecond, the <tt class="calibre25">jiffies_64</tt> variable wraps around in several hundreds of millions of years, thus we can safely assume that it never overflows.</p>
<p class="docText1">You might wonder why <tt class="calibre25">jiffies</tt> has not been directly declared as a 64-bit <tt class="calibre25">unsigned long long</tt> integer on the 80 x 86 architecture. The answer is that accesses to 64-bit variables in 32-bit architectures cannot be done atomically. Therefore, every read operation on the whole 64 bits requires some synchronization technique to ensure that the counter is not updated while the two 32-bit half-counters are read; as a consequence, every 64-bit read operation is significantly slower than a 32-bit read operation.</p>
<p class="docText1">The <tt class="calibre25">get_jiffies_64( )</tt> function reads the value of <tt class="calibre25">jiffies_64</tt> and returns its value:</p>
<pre class="calibre27">
    unsigned long long get_jiffies_64(void)
    {
        unsigned long seq;
        unsigned long long ret;
        do {
            seq = read_seqbegin(&amp;xtime_lock);
            ret = jiffies_64;
        } while (read_seqretry(&amp;xime_lock, seq));
        return ret;
    }
</pre><br class="calibre7"/>
<p class="docText1">The 64-bit read operation is protected by the <tt class="calibre25">xtime_lock</tt> seqlock (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.6">Seqlocks</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>): the function keeps reading the <tt class="calibre25">jiffies_64</tt> variable until it knows for sure that it has not been concurrently updated by another kernel control path.</p>
<p class="docText1">Conversely, the critical region increasing the <tt class="calibre25">jiffies_64</tt> variable must be protected by means of <tt class="calibre25">write_seqlock(&amp;xtime_lock )</tt> and <tt class="calibre25">write_sequnlock( &amp;xtime_lock)</tt>. Notice that the <tt class="calibre25">++jiffies_64</tt> instruction also increases the 32-bit <tt class="calibre25">jiffies</tt> variable, because the latter corresponds to the lower half of <tt class="calibre25">jiffies_64</tt>.</p>
<a name="understandlk-CHP-6-SECT-2.1.3"></a>
<h5 class="docSection3Title">6.2.1.3. The xtime variable</h5><a name="IDX-CHP-6-1680"></a>
<a name="IDX-CHP-6-1681"></a>
<a name="IDX-CHP-6-1682"></a>
<a name="IDX-CHP-6-1683"></a>
<p class="docText1">The <tt class="calibre25">xtime</tt> variable stores the current time and date; it is a structure of type <tt class="calibre25">timespec</tt> having two fields:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">tv_sec</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Stores the number of seconds that have elapsed since midnight of January 1, 1970 (UTC)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">tv_nsec</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Stores the number of nanoseconds that have elapsed within the last second (its value ranges between 0 and 999,999,999)</p></dd></dl>
<p class="docText1">The <tt class="calibre25">xtime</tt> variable is usually updated once in a tickthat is, roughly 1000 times per second. As we'll see in the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6">System Calls Related to Timing Measurements</a>," user programs get the current time and date from the <tt class="calibre25">xtime</tt> variable. The kernel also often refers to it, for instance, when updating inode timestamps (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-1-SECT-5.html#understandlk-CHP-1-SECT-5.4">File Descriptor and Inode</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-1.html#understandlk-CHP-1">Chapter 1</a>).</p>
<p class="docText1">The <tt class="calibre25">xtime_lock</tt> seqlock avoids the race conditions that could occur due to concurrent accesses to the <tt class="calibre25">xtime</tt> variable. Remember that <tt class="calibre25">xtime_lock</tt> also protects the <tt class="calibre25">jiffies_64</tt> variable; in general, this seqlock is used to define several critical regions of the timekeeping architecture.</p>
<a name="understandlk-CHP-6-SECT-2.2"></a>
<h4 class="docSection2Title">6.2.2. Timekeeping Architecture in Uniprocessor Systems</h4>
<p class="docText1">In a uniprocessor system, all time-related activities are triggered by the interrupts raised by the Programmable Interval Timer on IRQ line 0. As usual, in Linux, some of these activities are executed as soon as possible right after the interrupt is raised, while the remaining activities are carried on by deferrable functions (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-5.html#understandlk-CHP-6-SECT-5.1">Dynamic Timers</a>").</p>
<a name="understandlk-CHP-6-SECT-2.2.1"></a>
<h5 class="docSection3Title">6.2.2.1. Initialization phase</h5><a name="IDX-CHP-6-1684"></a>
<a name="IDX-CHP-6-1685"></a>
<a name="IDX-CHP-6-1686"></a>
<a name="IDX-CHP-6-1687"></a>
<a name="IDX-CHP-6-1688"></a>
<a name="IDX-CHP-6-1689"></a>
<p class="docText1">During kernel initialization, the <tt class="calibre25">time_init( )</tt> function is invoked to set up the timekeeping architecture. It usually<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-FN3">[*]</a></sup> performs the following operations:</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-6-FN3">[*]</a></sup> The <tt class="calibre42">time_init( )</tt> function is executed before <tt class="calibre42">mem_init( )</tt>, which initializes the memory data structures. Unfortunately, the HPET registers are memory mapped, therefore initialization of the HPET chip has to be done after the execution of <tt class="calibre42">mem_init( )</tt>. Linux 2.6 adopts a cumbersome solution: if the kernel supports the HPET chip, the <tt class="calibre42">time_init( )</tt> function limits itself to trigger the activation of the <tt class="calibre42">hpet_time_init( )</tt> function.The latter function is executed after <tt class="calibre42">mem_init( )</tt> and performs the operations described in this section.</p></blockquote>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">xtime</tt> variable. The number of seconds elapsed since the midnight of January 1, 1970 is read from the Real Time Clock by means of the <tt class="calibre25">get_cmos_time( )</tt> function. The <tt class="calibre25">tv_nsec</tt> field of <tt class="calibre25">xtime</tt> is set, so that the forthcoming overflow of the <tt class="calibre25">jiffies</tt> variable will coincide with an increment of the <tt class="calibre25">tv_sec</tt> fieldthat is, it will fall on a second boundary.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">wall_to_monotonic</tt> variable. This variable is of the same type <tt class="calibre25">timespec</tt> as <tt class="calibre25">xtime</tt>, and it essentially stores the number of seconds and nanoseconds to be added to <tt class="calibre25">xtime</tt> in order to get a monotonic (ever increasing) flow of time. In fact, both leap seconds and synchronization with external clocks might suddenly change the <tt class="calibre25">tv_sec</tt> and <tt class="calibre25">tv_nsec</tt> fields of <tt class="calibre25">xtime</tt> so that they are no longer monotonically increased. As we'll see in the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6.4">System Calls for POSIX Timers</a>," sometimes the kernel needs a truly monotonic time source.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the kernel supports HPET, it invokes the <tt class="calibre25">hpet_enable( )</tt> function to determine whether the ACPI<a name="IDX-CHP-6-1690"></a> 
 firmware has probed the chip and mapped its registers in the memory address space. In the affirmative case, <tt class="calibre25">hpet_enable( )</tt> programs the first timer of the HPET chip so that it raises the IRQ 0 interrupt 1000 times per second. Otherwise, if the HPET chip is not available, the kernel will use the PIT: the chip has already been programmed by the <tt class="calibre25">init_IRQ( )</tt> function to raise 1000 timer interrupts per second, as described in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-1.html#understandlk-CHP-6-SECT-1.3">Programmable Interval Timer (PIT)</a>."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">select_timer( )</tt> to select the best timer source available in the system, and sets the <tt class="calibre25">cur_timer</tt> variable to the address of the corresponding timer object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">setup_irq( 0,&amp;irq0)</tt> to set up the interrupt gate corresponding to IRQ0the line associated with the system timer interrupt source (PIT or HPET).The <tt class="calibre25">irq0</tt> variable is statically defined as:</p><pre class="calibre60">
    struct irqaction irq0 = { timer_interrupt, SA_INTERRUPT, 0,
                              "timer", NULL, NULL };
</pre><br class="calibre7"/>
<p class="docList">From now on, the <tt class="calibre25">timer_interrupt( )</tt> function will be invoked once every tick with interrupts disabled, because the <tt class="calibre25">status</tt> field of IRQ 0's main descriptor has the <tt class="calibre25">SA_INTERRUPT</tt> flag set.</p></div></li></ol></div>
<a name="understandlk-CHP-6-SECT-2.2.2"></a>
<h5 class="docSection3Title">6.2.2.2. The timer interrupt handler</h5><a name="IDX-CHP-6-1691"></a>
<a name="IDX-CHP-6-1692"></a>
<a name="IDX-CHP-6-1693"></a>
<p class="docText1">The <tt class="calibre25">timer_interrupt( )</tt> function is the interrupt service routine (ISR) of the PIT or of the HPET; it performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Protects the time-related kernel variables by issuing a <tt class="calibre25">write_seqlock()</tt> on the <tt class="calibre25">xtime_lock</tt> seqlock (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.6">Seqlocks</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">mark_offset</tt> method of the <tt class="calibre25">cur_timer</tt> timer object. As explained in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-SECT-2.1">Data Structures of the Timekeeping Architecture</a>," there are four possible cases:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList"><tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_hpet</tt> object: in this case, the HPET chip is the source of timer interrupts. The <tt class="calibre25">mark_offset</tt> method checks that no timer interrupt has been lost since the last tick; in this unlikely case, it updates <tt class="calibre25">jiffies_64</tt> accordingly. Next, the method records the current value of the periodic HPET counter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList"><tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_pmtmr</tt> object: in this case, the PIT chip is the source of timer interrupts, but the kernel uses the APIC Power Management Timer to measure time with a finer resolution. The <tt class="calibre25">mark_offset</tt> method checks that no timer interrupt has been lost since the last tick and updates <tt class="calibre25">jiffies_64</tt> if necessary. Then, it records the current value of the APIC Power Management Timer counter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList"><tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_tsc</tt> object: in this case, the PIT chip is the source of timer interrupts, but the kernel uses the Time Stamp Counter to measure time with a finer resolution. The <tt class="calibre25">mark_offset</tt> method performs the same operations as in the previous case: it checks that no timer interrupt has been lost since the last tick and updates <tt class="calibre25">jiffies_64</tt> if necessary. Then, it records the current value of the TSC counter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList"><tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_pit</tt> object: in this case, the PIT chip is the source of timer interrupts, and there is no other timer circuit. The <tt class="calibre25">mark_offset</tt> method does nothing.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">do_timer_interrupt( )</tt> function, which in turn performs the following actions:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Increases by one the value of <tt class="calibre25">jiffies_64</tt>. Notice that this can be done safely, because the kernel control path still holds the <tt class="calibre25">xtime_lock</tt> seqlock for writing.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">update_times( )</tt> function to update the system date and time and to compute the current system load; these activities are discussed later in the sections "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-3.html#understandlk-CHP-6-SECT-3">Updating the Time and Date</a>" and "Updating System Statistics."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">update_process_times( )</tt> function to perform several time-related accounting operations for the local CPU (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-4.html#understandlk-CHP-6-SECT-4.1">Updating Local CPU Statistics</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">profile_tick( )</tt> function (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-4.html#understandlk-CHP-6-SECT-4.3">Profiling the Kernel Code</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the system clock is synchronized with an external clock (an <tt class="calibre25">adjtimex( )</tt> system call has been previously issued), invokes the <tt class="calibre25">set_rtc_mmss( )</tt> function once every 660 seconds (every 11 minutes) to adjust the Real Time Clock. This feature helps systems on a network synchronize their clocks (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6.2">The adjtimex( ) System Call</a>").</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">xtime_lock</tt> seqlock by invoking <tt class="calibre25">write_sequnlock()</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the value 1 to notify that the interrupt has been effectively handled (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.1">I/O Interrupt Handling</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></div></li></ol></div>
<a name="understandlk-CHP-6-SECT-2.3"></a>
<h4 class="docSection2Title">6.2.3. Timekeeping Architecture in Multiprocessor Systems</h4><a name="IDX-CHP-6-1694"></a>
<a name="IDX-CHP-6-1695"></a>
<a name="IDX-CHP-6-1696"></a>
<a name="IDX-CHP-6-1697"></a>
<a name="IDX-CHP-6-1698"></a>
<a name="IDX-CHP-6-1699"></a>
<a name="IDX-CHP-6-1700"></a>
<a name="IDX-CHP-6-1701"></a>
<p class="docText1">Multiprocessor systems can rely on two different sources of timer interrupts: those raised by the Programmable Interval Timer or the High Precision Event Timer, and those raised by the CPU local timers.</p>
<p class="docText1">In Linux 2.6, global timer interruptsraised by the PIT or the HPETsignal activities not related to a specific CPU, such as handling of software timers and keeping the system time up-to-date. Conversely, a CPU local timer interrupt signals timekeeping activities related to the local CPU, such as monitoring how long the current process has been running and updating the resource usage statistics.</p>
<a name="understandlk-CHP-6-SECT-2.3.1"></a>
<h5 class="docSection3Title">6.2.3.1. Initialization phase</h5>
<p class="docText1">The global timer interrupt handler is initialized by the <tt class="calibre25">time_init( )</tt> function, which has already been described in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-SECT-2.2">Timekeeping Architecture in Uniprocessor Systems</a>."</p>
<p class="docText1">The Linux kernel reserves the interrupt vector 239 (<tt class="calibre25">0xef</tt>) for local timer interrupts (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-TABLE-2">Table 4-2</a> in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). During kernel initialization, the <tt class="calibre25">apic_intr_init( )</tt> function sets up the IDT's interrupt gate corresponding to vector 239 with the address of the low-level interrupt handler <tt class="calibre25">apic_timer_interrupt( )</tt>. Moreover, each APIC has to be told how often to generate a local time interrupt. The <tt class="calibre25">calibrate_APIC_clock( )</tt> function computes how many bus clock signals are received by the local APIC of the booting CPU during a tick (1 ms). This exact value is then used to program the local APICs in such a way to generate one local timer interrupt every tick. This is done by the <tt class="calibre25">setup_APIC_timer( )</tt> function, which is executed once for every CPU in the system.</p>
<p class="docText1">All local APIC timers are synchronized because they are based on the common bus clock signal. This means that the value computed by <tt class="calibre25">calibrate_APIC_clock( )</tt> for the boot CPU is also good for the other CPUs in the system.</p>
<a name="understandlk-CHP-6-SECT-2.3.2"></a>
<h5 class="docSection3Title">6.2.3.2. The global timer interrupt handler</h5><a name="IDX-CHP-6-1702"></a>
<a name="IDX-CHP-6-1703"></a>
<a name="IDX-CHP-6-1704"></a>
<a name="IDX-CHP-6-1705"></a>
<a name="IDX-CHP-6-1706"></a>
<p class="docText1">The SMP version of the <tt class="calibre25">timer_interrupt()</tt> handler differs from the UP version in a few points:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The <tt class="calibre25">do_timer_interrupt( )</tt> function, invoked by <tt class="calibre25">timer_interrupt( )</tt>, writes into a port of the I/O APIC chip to acknowledge the timer IRQ.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">update_process_times( )</tt> function is not invoked, because this function performs actions related to a specific CPU.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">profile_tick( )</tt> function is not invoked, because this function also performs actions related to a specific CPU.</p></li></ul>
<a name="understandlk-CHP-6-SECT-2.3.3"></a>
<h5 class="docSection3Title">6.2.3.3. The local timer interrupt handler</h5>
<p class="docText1">This handler performs the timekeeping activities related to a specific CPU in the system, namely profiling the kernel code and checking how long the current process has been running on a given CPU.</p>
<p class="docText1">The <tt class="calibre25">apic_timer_interrupt( )</tt> assembly language function is equivalent to the following code:</p>
<pre class="calibre27">
    apic_timer_interrupt:
        pushl $(239-256)
        SAVE_ALL
        movl %esp, %eax
        call smp_apic_timer_interrupt
        jmp ret_from_intr
</pre><br class="calibre7"/>
<p class="docText1">As you can see, the low-level handler is very similar to the other low-level interrupt handlers already described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>. The high-level interrupt handler called <tt class="calibre25">smp_apic_timer_interrupt( )</tt> executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Gets the CPU logical number (say, <span class="docEmphasis">n</span>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases the <tt class="calibre25">apic_timer_irqs</tt> field of the <span class="docEmphasis">n</span><sup class="calibre37">th</sup> entry of the <tt class="calibre25">irq_stat</tt> array (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-4.html#understandlk-CHP-6-SECT-4.4">Checking the NMI Watchdogs</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acknowledges the interrupt on the local APIC.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Calls the <tt class="calibre25">irq_enter( )</tt> function (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.1.6">The do_IRQ( ) function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">smp_local_timer_interrupt( )</tt> function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Calls the <tt class="calibre25">irq_exit( )</tt> function.</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">smp_local_timer_interrupt( )</tt> function executes the per-CPU timekeeping activities. Actually, it performs the following main steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">profile_tick( )</tt> function (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-4.html#understandlk-CHP-6-SECT-4.3">Profiling the Kernel Code</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">update_process_times( )</tt> function to check how long the current process has been running and to update some local CPU statistics (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-4.html#understandlk-CHP-6-SECT-4.1">Updating Local CPU Statistics</a>" later in this chapter).</p></div></li></ol></div>
<p class="docText1">The system administrator can change the sample frequency of the kernel code profiler by writing into the <i class="docEmphasis">/proc/profile</i> file.To carry out the change, the kernel modifies the frequency at which local timer interrupts are generated. However, the <tt class="calibre25">smp_local_timer_interrupt( )</tt> function keeps invoking the <tt class="calibre25">update_process_times( )</tt> function exactly once every tick.</p>

<br class="calibre7"/>

</div>

{% endraw %}

