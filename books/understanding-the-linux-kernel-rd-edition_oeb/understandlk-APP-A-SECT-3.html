---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-APP-A-SECT-2.html
next: understandlk-APP-A-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-APP-A-SECT-3"></a>
<h3 class="docSection1Title">A.3. Middle Ages: the setup( ) Function</h3><a name="IDX-APP-A-0017"></a>
<p class="docText1">The code of the <tt class="calibre25">setup( )</tt> assembly language function has been placed by the linker at offset <tt class="calibre25">0x200</tt> of the kernel image file. The boot loader can therefore easily locate the code and copy it into RAM, starting from physical address <tt class="calibre25">0x00090200</tt>.</p>
<p class="docText1">The <tt class="calibre25">setup( )</tt> function must initialize the hardware devices in the computer and set up the environment for the execution of the kernel program. Although the BIOS already initialized most hardware devices, Linux does not rely on it, but reinitializes the devices in its own manner to enhance portability and robustness. <tt class="calibre25">setup( )</tt> performs essentially the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">In ACPI<a name="IDX-APP-A-0018"></a> 
-compliant systems, it invokes a BIOS routine that builds a table in RAM describing the layout of the system's physical memory (the table can be seen in the boot kernel messages by looking for the "BIOS-e820" label). In older systems, it invokes a BIOS routine that just returns the amount of RAM available in the system.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the keyboard repeat delay and rate. (When the user keeps a key pressed past a certain amount of time, the keyboard device sends the corresponding keycode over and over to the CPU.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the video adapter card.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Reinitializes the disk controller and determines the hard disk parameters.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks for an IBM Micro Channel bus (MCA).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks for a PS/2 pointing device (bus mouse).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks for Advanced Power Management (APM<a name="IDX-APP-A-0019"></a> 
) BIOS support.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the BIOS supports the <span class="docEmphasis">Enhanced Disk Drive Services</span><a name="IDX-APP-A-0020"></a> 
 (<span class="docEmphasis">EDD</span><a name="IDX-APP-A-0021"></a> 
), it invokes the proper BIOS procedure to build a table in RAM describing the hard disks available in the system. (The information included in the table can be seen by reading the files in the <i class="docEmphasis">firmware/edd</i> directory of the <span class="docEmphasis">sysfs</span><a name="IDX-APP-A-0022"></a> 
 special filesystem.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the kernel image was loaded low in RAM (at physical address <tt class="calibre25">0x00010000</tt>), the function moves it to physical address <tt class="calibre25">0x00001000</tt>. Conversely, if the kernel image was loaded high in RAM, the function does not move it. This step is necessary because to be able to store the kernel image on a floppy disk and to reduce the booting time, the kernel image stored on disk is compressed, and the decompression routine needs some free space to use as a temporary buffer following the kernel image in RAM.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the A20 pin located on the 8042 keyboard controller. The A20 pin is a hack introduced in the 80286<a name="IDX-APP-A-0023"></a> 
-based systems to make physical addresses compatible with those of the ancient 8088<a name="IDX-APP-A-0024"></a> 
 microprocessors. Unfortunately, the A20 pin must be properly set before switching to Protected Mode, otherwise the 21st bit of every physical address will always be regarded as zero by the CPU. Setting the A20 pin is a messy operation.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets up a provisional Interrupt Descriptor Table (IDT) and a provisional Global Descriptor Table (GDT).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Resets the floating-point unit (FPU<a name="IDX-APP-A-0025"></a> 
), if any.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Reprograms the Programmable Interrupt Controllers (PIC) to mask all interrupts, except IRQ2 which is the cascading interrupt between the two PICs.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Switches the CPU from Real Mode to Protected Mode by setting the <tt class="calibre25">PE</tt> bit in the <tt class="calibre25">cr0</tt><a name="IDX-APP-A-0026"></a> 
 status register. The <tt class="calibre25">PG</tt> bit in the <tt class="calibre25">cr0</tt> register is cleared, so paging is still disabled.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Jumps to the <tt class="calibre25">startup_32( )</tt> assembly language function.</p></div></li></ol></div>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

