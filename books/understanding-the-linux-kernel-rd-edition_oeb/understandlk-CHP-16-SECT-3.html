---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-16-SECT-2.html
next: understandlk-CHP-16-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-16-SECT-3"></a>
<h3 class="docSection1Title">16.3. Direct I/O Transfers</h3><a name="IDX-CHP-16-4028"></a>
<a name="IDX-CHP-16-4029"></a>
<a name="IDX-CHP-16-4030"></a>
<a name="IDX-CHP-16-4031"></a>
<a name="IDX-CHP-16-4032"></a>
<a name="IDX-CHP-16-4033"></a>
<a name="IDX-CHP-16-4034"></a>
<a name="IDX-CHP-16-4035"></a>
<a name="IDX-CHP-16-4036"></a>
<p class="docText1">As we have seen, in Version 2.6 of Linux, there is no substantial difference between accessing a regular file through the filesystem, accessing it by referencing its blocks on the underlying block device file, or even establishing a file memory mapping. There are, however, some highly sophisticated programs (<span class="docEmphasis">self-caching applications</span><a name="IDX-CHP-16-4037"></a> 
) that would like to have full control of the whole I/O data transfer mechanism. Consider, for example, high-performance database servers: most of them implement their own caching mechanisms that exploit the peculiar nature of the queries to the database. For these kinds of programs, the kernel page cache doesn't help; on the contrary, it is detrimental for the following reasons:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Lots of page frames are wasted to duplicate disk data already in RAM (in the user-level disk cache).</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">read( )</tt> and <tt class="calibre25">write( )</tt> system calls are slowed down by the redundant instructions that handle the page cache and the read-ahead; ditto for the paging operations related to the file memory mappings.</p></li><li class="calibre12"><p class="docText1">Rather than transferring the data directly between the disk and the user memory, the <tt class="calibre25">read( )</tt> and <tt class="calibre25">write( )</tt> system calls make two transfers: between the disk and a kernel buffer and between the kernel buffer and the user memory.</p></li></ul>
<p class="docText1">Because block hardware devices <span class="docEmphasis">must</span> be handled through interrupts and Direct Memory Access (DMA), and this can be done only in Kernel Mode, some sort of kernel support is definitely required to implement self-caching applications.</p>
<p class="docText1">Linux offers a simple way to bypass the page cache: <span class="docEmphasis">direct I/O transfers</span>. In each I/O direct transfer, the kernel programs the disk controller to transfer the data directly from/to pages belonging to the User Mode address space of a self-caching application.</p>
<p class="docText1">As we know, each data transfer proceeds asynchronously. While it is in progress, the kernel may switch the current process, the CPU may return to User Mode, the pages of the process that raised the data transfer might be swapped out, and so on. This works just fine for ordinary I/O data transfers because they involve pages of the disk caches<a name="IDX-CHP-16-4038"></a> 
. Disk caches are owned by the kernel, cannot be swapped out, and are visible to all processes in Kernel Mode.</p>
<p class="docText1">On the other hand, direct I/O transfers should move data within pages that belong to the User Mode address space of a given process. The kernel must take care that these pages are accessible by every process in Kernel Mode and that they are not swapped out while the data transfer is in progress. Let us see how this is achieved.</p>
<p class="docText1">When a self-caching application wishes to directly access a file, it opens the file specifying the <tt class="calibre25">O_DIRECT</tt> flag (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-6.html#understandlk-CHP-12-SECT-6.1">The open( ) System Call</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>). While servicing the <tt class="calibre25">open( )</tt><a name="IDX-CHP-16-4039"></a> 
 system call, the <tt class="calibre25">dentry_open( )</tt> function checks whether the <tt class="calibre25">direct_IO</tt> method is implemented for the <tt class="calibre25">address_space</tt> object of the file being opened, and returns an error code in the opposite case. The <tt class="calibre25">O_DIRECT</tt> flag can also be set for a file already opened by using the <tt class="calibre25">F_SETFL</tt> command of the <tt class="calibre25">fcntl( )</tt><a name="IDX-CHP-16-4040"></a> 
 system call.</p>
<p class="docText1">Let us consider first the case where the self-caching application issues a <tt class="calibre25">read( )</tt> system call on a file with <tt class="calibre25">O_DIRECT</tt>. As mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-SECT-1.1">Reading from a File</a>" earlier in this chapter, the <tt class="calibre25">read</tt> file method is usually implemented by the <tt class="calibre25">generic_file_read( )</tt> function, which initializes the <tt class="calibre25">iovec</tt> and <tt class="calibre25">kiocb</tt> descriptors and invokes <tt class="calibre25">_ _generic_file_aio_read( )</tt>. The latter function verifies that the User Mode buffer described by the <tt class="calibre25">iovec</tt> descriptor is valid, then checks whether the <tt class="calibre25">O_DIRECT</tt> flag of the file is set. When invoked by a <tt class="calibre25">read( )</tt> system call, the function executes a code fragment essentially equivalent to the following:</p>
<pre class="calibre27">
if (filp-&gt;f_flags &amp; O_DIRECT) {
    if (count == 0 || *ppos &gt; filp-&gt;f_mapping-&gt;host-&gt;i_size)
        return 0;
    retval = generic_file_direct_IO(READ, iocb, iov, *ppos, 1);
    if (retval &gt; 0)
        *ppos += retval;
    file_accessed(filp);
    return retval;
}</pre><br class="calibre7"/>
<p class="docText1">The function checks the current values of the file pointer, the file size, and the number of requested characters, and then invokes the <tt class="calibre25">generic_file_direct_IO( )</tt> function, passing to it the <tt class="calibre25">READ</tt> operation type, the <tt class="calibre25">iocb</tt> descriptor, the <tt class="calibre25">iovec</tt> descriptor, the current value of the file pointer, and the number of User Mode buffers specified in the <tt class="calibre25">io_vec</tt> descriptor (one). When <tt class="calibre25">generic_file_direct_IO( )</tt> terminates, <tt class="calibre25">_ _generic_file_aio_read( )</tt> updates the file pointer, sets the access timestamp on the file's inode, and returns.</p>
<p class="docText1">Something similar happens when a <tt class="calibre25">write( )</tt> system call is issued on a file having the <tt class="calibre25">O_DIRECT</tt> flag set. As mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-SECT-1.3">Writing to a File</a>" earlier in this chapter, the <tt class="calibre25">write</tt> method of the file ends up invoking <tt class="calibre25">generic_file_aio_write_nolock( )</tt>: this function checks whether the <tt class="calibre25">O_DIRECT</tt> flag is set and, if so, invokes the <tt class="calibre25">generic_file_direct_IO( )</tt> function, this time specifying the <tt class="calibre25">WRITE</tt> operation type.</p>
<p class="docText1">The <tt class="calibre25">generic_file_direct_IO( )</tt> function acts on the following parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">rw</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Type of operation: <tt class="calibre25">READ</tt> or <tt class="calibre25">WRITE</tt></p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">iocb</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Pointer to a <tt class="calibre25">kiocb</tt> descriptor (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-TABLE-1">Table 16-1</a>)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">iov</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Pointer to an array of <tt class="calibre25">iovec</tt> descriptors (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-SECT-1.1">Reading from a File</a>" earlier in this chapter)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">offset</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">File offset</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">nr_segs</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Number of <tt class="calibre25">iovec</tt> descriptors in the <tt class="calibre25">iov</tt> array</p></dd></dl>
<p class="docText1">The steps performed by <tt class="calibre25">generic_file_direct_IO( )</tt> are the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Gets the address <tt class="calibre25">file</tt> of the file object from the <tt class="calibre25">ki_filp</tt> field of the <tt class="calibre25">kiocb</tt> descriptor, and the address <tt class="calibre25">mapping</tt> of the <tt class="calibre25">address_space</tt> object from the <tt class="calibre25">file-&gt;f_mapping</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the type of operation is <tt class="calibre25">WRITE</tt> and if one or more processes have created a memory mapping associated with a portion of the file, it invokes <tt class="calibre25">unmap_mapping_range( )</tt> to unmap all pages of the file. This function also ensures that if any Page Table entry corresponding to a page to be unmapped has the <tt class="calibre25">Dirty</tt> bit set, then the corresponding page is marked as dirty in the page cache.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the radix tree rooted at <tt class="calibre25">mapping</tt> is not empty (<tt class="calibre25">mapping-&gt;nrpages</tt> greater than zero), it invokes the <tt class="calibre25">filemap_fdatawrite( )</tt> and <tt class="calibre25">filemap_fdatawait( )</tt> functions to flush all dirty pages to disk and to wait until the I/O operations complete (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-2.html#understandlk-CHP-16-SECT-2.5">Flushing Dirty Memory Mapping Pages to Disk</a>" earlier in this chapter). (Even if the self-caching application is accessing the file directly, there could be other applications in the system that access the file through the page cache. To avoid data loss, the disk image is synchronized with the page cache before starting the direct I/O transfer.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">direct_IO</tt> method of the <tt class="calibre25">mapping</tt> address space (see the following paragraphs).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the operation type was <tt class="calibre25">WRITE</tt>, it invokes <tt class="calibre25">invalidate_inode_pages2( )</tt> to scan all pages in the radix tree of <tt class="calibre25">mapping</tt> and to release them. The function also clears the User Mode Page Table entries that refer to those pages.</p></div></li></ol></div>
<p class="docText1">In most cases, the <tt class="calibre25">direct_IO</tt> method is a wrapper for the <tt class="calibre25">_ _blockdev_direct_IO( )</tt> function. This function is quite complex and invokes a large number of auxiliary data structures and functions; however, it executes essentially the same kind of operations already described in this chapter: it splits the data to be read or written in suitable blocks, locates the data on disk, and fills up one or more bio descriptors that describe the I/O operations to be performed. Of course, the data will be read or written directly in the User Mode buffers specified by the <tt class="calibre25">iovec</tt> descriptors in the <tt class="calibre25">iov</tt> array. The bio descriptors are submitted to the generic block layer by invoking the <tt class="calibre25">submit_bio( )</tt> function (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-2.html#understandlk-CHP-15-SECT-2.7">Submitting Buffer Heads to the Generic Block Layer</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>). Usually, the <tt class="calibre25">_ _blockdev_direct_IO( )</tt> function does not return until all direct I/O transfers have been completed; thus, once the <tt class="calibre25">read( )</tt> or <tt class="calibre25">write( )</tt> system call returns, the self-caching application can safely access the buffers containing the file data.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

