---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-11-SECT-1.html
next: understandlk-CHP-11-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-11-SECT-2"></a>
<h3 class="docSection1Title">11.2. Generating a Signal</h3><a name="IDX-CHP-11-2711"></a>
<a name="IDX-CHP-11-2712"></a>
<a name="IDX-CHP-11-2713"></a>
<a name="IDX-CHP-11-2714"></a>
<a name="IDX-CHP-11-2715"></a>
<a name="IDX-CHP-11-2716"></a>
<a name="IDX-CHP-11-2717"></a>
<a name="IDX-CHP-11-2718"></a>
<a name="IDX-CHP-11-2719"></a>
<a name="IDX-CHP-11-2720"></a>
<a name="IDX-CHP-11-2721"></a>
<a name="IDX-CHP-11-2722"></a>
<a name="IDX-CHP-11-2723"></a>
<a name="IDX-CHP-11-2724"></a>
<a name="IDX-CHP-11-2725"></a>
<a name="IDX-CHP-11-2726"></a>
<a name="IDX-CHP-11-2727"></a>
<a name="IDX-CHP-11-2728"></a>
<a name="IDX-CHP-11-2729"></a>
<a name="IDX-CHP-11-2730"></a>
<a name="IDX-CHP-11-2731"></a>
<a name="IDX-CHP-11-2732"></a>
<a name="IDX-CHP-11-2733"></a>
<a name="IDX-CHP-11-2734"></a>
<a name="IDX-CHP-11-2735"></a>
<a name="IDX-CHP-11-2736"></a>
<p class="docText1">Many kernel functions generate signals: they accomplish the first phase of signal handlingdescribed earlier in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-1.html#understandlk-CHP-11-SECT-1">The Role of Signals</a>"by updating one or more process descriptors as needed. They do not directly perform the second phase of delivering the signal but, depending on the type of signal and the state of the destination processes, may wake up some processes and force them to receive the signal.</p>
<p class="docText1">When a signal is sent to a process, either from the kernel or from another process, the kernel generates it by invoking one of the functions listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-TABLE-9">Table 11-9</a>.</p>
<a name="understandlk-CHP-11-TABLE-9"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 11-9. Kernel functions that generate a signal for a process</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">send_sig( )</tt></p></td><td class="docTableCell"><p class="docText2">Sends a signal to a single process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">send_sig_info( )</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">send_sig( )</tt>, with extended information in a <tt class="calibre25">siginfo_t</tt> structure</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">force_sig( )</tt></p></td><td class="docTableCell"><p class="docText2">Sends a signal that cannot be explicitly ignored or blocked by the process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">force_sig_info( )</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">force_sig( )</tt>, with extended information in a <tt class="calibre25">siginfo_t</tt> structure</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">force_sig_specific( )</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">force_sig( )</tt>, but optimized for <tt class="calibre25">SIGSTOP</tt> and <tt class="calibre25">SIGKILL</tt> signals</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">sys_tkill( )</p></td><td class="docTableCell"><p class="docText2">System call handler of <tt class="calibre25">tkill( )</tt><a name="IDX-CHP-11-2737"></a> 
 (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-4.html#understandlk-CHP-11-SECT-4">System Calls Related to Signal Handling</a>")</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">sys_tgkill( )</p></td><td class="docTableCell"><p class="docText2">System call handler of <tt class="calibre25">tgkill( )</tt><a name="IDX-CHP-11-2738"></a>
</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">All functions in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-TABLE-9">Table 11-9</a> end up invoking the <tt class="calibre25">specific_send_sig_info( )</tt> function described in the next section.</p>
<p class="docText1">When a signal is sent to a whole thread group, either from the kernel or from another process, the kernel generates it by invoking one of the functions listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-TABLE-10">Table 11-10</a>.</p>
<a name="understandlk-CHP-11-TABLE-10"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 11-10. Kernel functions that generate a signal for a thread group</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">send_group_sig_info( )</tt></p></td><td class="docTableCell"><p class="docText2">Sends a signal to a single thread group identified by the process descriptor of one of its members</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">kill_pg( )</tt></p></td><td class="docTableCell"><p class="docText2">Sends a signal to all thread groups in a process group (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-1-SECT-6.html#understandlk-CHP-1-SECT-6.7">Process Management</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-1.html#understandlk-CHP-1">Chapter 1</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">kill_pg_info( )</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">kill_pg( )</tt>, with extended information in a <tt class="calibre25">siginfo_t</tt> structure</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">kill_proc( )</tt></p></td><td class="docTableCell"><p class="docText2">Sends a signal to a single thread group identified by the PID of one of its members</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">kill_proc_info( )</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">kill_proc( )</tt>, with extended information in a <tt class="calibre25">siginfo_t</tt> structure</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">sys_kill( )</p></td><td class="docTableCell"><p class="docText2">System call handler of <tt class="calibre25">kill( )</tt> (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-4.html#understandlk-CHP-11-SECT-4">System Calls Related to Signal Handling</a>")</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">sys_rt_sigqueueinfo( )</p></td><td class="docTableCell"><p class="docText2">System call handler of <tt class="calibre25">rt_sigqueueinfo( )</tt></p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">All functions in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-TABLE-10">Table 11-10</a> end up invoking the <tt class="calibre25">group_send_sig_info( )</tt> function, which is described in the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-SECT-2.3">The group_send_sig_info( ) Function</a>."</p>
<a name="understandlk-CHP-11-SECT-2.1"></a>
<h4 class="docSection2Title">11.2.1. The specific_send_sig_info( ) Function</h4><a name="IDX-CHP-11-2739"></a>
<p class="docText1">The <tt class="calibre25">specific_send_sig_info( )</tt> function sends a signal to a specific process. It acts on three parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sig</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The signal number.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">info</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Either the address of a <tt class="calibre25">siginfo_t</tt> table or one of three special values: 0 means that the signal has been sent by a User Mode process, 1 means that it has been sent by the kernel, and 2 means that is has been sent by the kernel and the signal is <tt class="calibre25">SIGSTOP</tt> or <tt class="calibre25">SIGKILL</tt>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">t</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">A pointer to the descriptor of the destination process.</p></dd></dl>
<p class="docText1">The <tt class="calibre25">specific_send_sig_info( )</tt> function must be invoked with local interrupts disabled and the <tt class="calibre25">t-&gt;sighand-&gt;siglock</tt> spin lock already acquired. The function executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the process ignores the signal; in the affirmative case, returns 0 (signal not generated). The signal is ignored when all three conditions for ignoring a signal are satisfied, that is:</p><ul class="calibre61"><li class="calibre12"><p class="docList">The process is not being traced (<tt class="calibre25">PT_PTRACED</tt> flag in <tt class="calibre25">t-&gt;ptrace</tt> clear).</p></li><li class="calibre12"><p class="docList">The signal is not blocked (<tt class="calibre25">sigismember(&amp;t-&gt;blocked, sig)</tt> returns 0).</p></li><li class="calibre12"><p class="docList">The signal is either explicitly ignored (the <tt class="calibre25">sa_handler</tt> field of <tt class="calibre25">t-&gt;sighand-&gt;action[sig-1]</tt> is equal to <tt class="calibre25">SIG_IGN</tt>) or implicitly ignored (the <tt class="calibre25">sa_handler</tt> field is equal to <tt class="calibre25">SIG_DFL</tt> and the signal is <tt class="calibre25">SIGCONT</tt>, <tt class="calibre25">SIGCHLD</tt>, <tt class="calibre25">SIGWINCH</tt>, or <tt class="calibre25">SIGURG</tt>).</p></li></ul></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the signal is non-real-time (<tt class="calibre25">sig&lt;32</tt>) and another occurrence of the same signal is already pending in the private pending signal queue of the process (<tt class="calibre25">sigismember(&amp;t-&gt;pending.signal,sig)</tt> returns 1): in the affirmative case, nothing has to be done, thus returns 0.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">send_signal(sig, info, t, &amp;t-&gt;pending)</tt> to add the signal to the set of pending signals of the process; this function is described in detail in the next section.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">send_signal( )</tt> successfully terminated and the signal is not blocked (<tt class="calibre25">sigismember(&amp;t-&gt;blocked,sig)</tt> returns 0), invokes the <tt class="calibre25">signal_wake_up( )</tt> function to notify the process about the new pending signal. In turn, this function executes the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">TIF_SIGPENDING</tt> flags in <tt class="calibre25">t-&gt;tHRead_info-&gt;flags</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">try_to_wake_up( )</tt>see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.2">The try_to_wake_up( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>to awake the process if it is either in <tt class="calibre25">TASK_INTERRUPTIBLE</tt> state, or in <tt class="calibre25">TASK_STOPPED</tt> state and the signal is <tt class="calibre25">SIGKILL</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">try_to_wake_up( )</tt> returned 0, the process was already runnable: if so, it checks whether the process is already running on another CPU and, in this case, sends an interprocessor interrupt to that CPU to force a reschedule of the current process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.2">Interprocessor Interrupt Handling</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). Because each process checks the existence of pending signals when returning from the <tt class="calibre25">schedule( )</tt> function, the interprocessor interrupt ensures that the destination process quickly notices the new pending signal.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 1 (the signal has been successfully generated).</p></div></li></ol></div>
<a name="understandlk-CHP-11-SECT-2.2"></a>
<h4 class="docSection2Title">11.2.2. The send_signal( ) Function</h4><a name="IDX-CHP-11-2740"></a>
<p class="docText1">The <tt class="calibre25">send_signal( )</tt> function inserts a new item in a pending signal queue. It receives as its parameters the signal number <tt class="calibre25">sig</tt>, the address <tt class="calibre25">info</tt> of a <tt class="calibre25">siginfo_t</tt> data structure (or a special code, see the description of <tt class="calibre25">specific_send_sig_info( )</tt> in the previous section), the address <tt class="calibre25">t</tt> of the descriptor of the target process, and the address <tt class="calibre25">signals</tt> of the pending signal queue.</p>
<p class="docText1">The function executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If the value of <tt class="calibre25">info</tt> is 2, the signal is either <tt class="calibre25">SIGKILL</tt> or <tt class="calibre25">SIGSTOP</tt> and it has been generated by the kernel via the <tt class="calibre25">force_sig_specific( )</tt> function: in this case, it jumps to step 9. The action corresponding to these signals is immediately enforced by the kernel, thus the function may skip adding the signal to the pending signal queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the number of pending signals of the process's owner (<tt class="calibre25">t-&gt;user-&gt;sigpending</tt>) is smaller than the current process's resource limit <tt class="calibre25">(t-&gt;signal-&gt;rlim[RLIMIT_SIGPENDING].rlim_cur</tt>), the function allocates a <tt class="calibre25">sigqueue</tt> data structure for the new occurrence of the signal:</p><pre class="calibre60">
    q = kmem_cache_alloc(sigqueue_cachep, GFP_ATOMIC);
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the number of pending signals of the process's owner is too high or the memory allocation in the previous step failed, it jumps to step 9.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases the number of pending signals of the owner (<tt class="calibre25">t-&gt;user-&gt;sigpending</tt>) and the reference counter of the per-user data structure pointed to by <tt class="calibre25">t-&gt;user</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds the <tt class="calibre25">sigqueue</tt> data structure in the pending signal queue <tt class="calibre25">signals</tt>:</p><pre class="calibre60">
    list_add_tail(&amp;q-&gt;list, &amp;signals-&gt;list);
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Fills the <tt class="calibre25">siginfo_t</tt> table inside the <tt class="calibre25">sigqueue</tt> data structure:</p><pre class="calibre60">
    if ((unsigned long)info == 0) {
        q-&gt;info.si_signo = sig;
        q-&gt;info.si_errno = 0;
        q-&gt;info.si_code = SI_USER;
        q-&gt;info._sifields._kill._pid = current-&gt;pid;
        q-&gt;info._sifields._kill._uid = current-&gt;uid;
    } else if ((unsigned long)info == 1) {
        q-&gt;info.si_signo = sig;
        q-&gt;info.si_errno = 0;
        q-&gt;info.si_code = SI_KERNEL;
        q-&gt;info._sifields._kill._pid = 0;
        q-&gt;info._sifields._kill._uid = 0;
    } else
        copy_siginfo(&amp;q-&gt;info, info);
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">copy_siginfo( )</tt> function copies the <tt class="calibre25">siginfo_t</tt> table passed by the caller.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the bit corresponding to the signal in the bit mask of the queue:</p><pre class="calibre60">
    sigaddset(&amp;signals-&gt;signal, sig);
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 0: the signal has been successfully appended to the pending signal queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Here, an item will not be added to the signal pending queue, because there are already too many pending signals, or there is no free memory for the <tt class="calibre25">sigqueue</tt> data structure, or the signal is immediately enforced by the kernel. If the signal is real-time and was sent through a kernel function that is explicitly required to queue it, the function returns the error code <tt class="calibre25">-EAGAIN</tt>:</p><pre class="calibre60">
    if (sig&gt;=32 &amp;&amp; info &amp;&amp; (unsigned long) info != 1 &amp;&amp;
        info-&gt;si_code != SI_USER)
        return -EAGAIN;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the bit corresponding to the signal in the bit mask of the queue:</p><pre class="calibre60">
    sigaddset(&amp;signals-&gt;signal, sig);
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 0: even if the signal has not been appended to the queue, the corresponding bit has been set in the bit mask of pending signals.</p></div></li></ol></div>
<p class="docText1">It is important to let the destination process receive the signal even if there is no room for the corresponding item in the pending signal queue. Suppose, for instance, that a process is consuming too much memory. The kernel must ensure that the <tt class="calibre25">kill( )</tt><a name="IDX-CHP-11-2741"></a> 
 system call succeeds even if there is no free memory; otherwise, the system administrator doesn't have any chance to recover the system by terminating the offending process.</p>
<a name="understandlk-CHP-11-SECT-2.3"></a>
<h4 class="docSection2Title">11.2.3. The group_send_sig_info( ) Function</h4><a name="IDX-CHP-11-2742"></a>
<a name="IDX-CHP-11-2743"></a>
<a name="IDX-CHP-11-2744"></a>
<p class="docText1">The <tt class="calibre25">group_send_sig_info( )</tt> function sends a signal to a whole thread group. It acts on three parameters: a signal number <tt class="calibre25">sig</tt>, the address <tt class="calibre25">info</tt> of a <tt class="calibre25">siginfo_t</tt> tableor alternatively the special values 0, 1, or 2, as explained in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-SECT-2.1">The specific_send_sig_info( ) Function</a>"and the address <tt class="calibre25">p</tt> of a process descriptor.</p>
<p class="docText1">The function essentially executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks that the parameter <tt class="calibre25">sig</tt> is correct:</p><pre class="calibre60">
    if (sig &lt; 0 || sig &gt; 64)
        return -EINVAL;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the signal is being sent by a User Mode process, it checks whether the operation is allowed. The signal is delivered only if at least one of the following conditions holds:</p><ul class="calibre61"><li class="calibre12"><p class="docList">The owner of the sending process has the proper capability (usually, this simply means the signal was issued by the system administrator; see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>).</p></li><li class="calibre12"><p class="docList">The signal is <tt class="calibre25">SIGCONT</tt> and the destination process is in the same login session of the sending process.</p></li><li class="calibre12"><p class="docList">Both processes belong to the same user.</p></li></ul><p class="docList">If the User Mode process is not allowed to send the signal, the function returns the value <tt class="calibre25">-EPERM</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">sig</tt> parameter has the value 0, it returns immediately without generating any signal:</p><pre class="calibre60">
    if (!sig || !p-&gt;sighand)
        return 0;
</pre><br class="calibre7"/>
<p class="docList">Because 0 is not a valid signal number, it is used to allow the sending process to check whether it has the required privileges to send a signal to the destination thread group. The function also returns if the destination process is being killed, indicated by checking whether its signal handler descriptor has been released.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">p-&gt;sighand-&gt;siglock</tt> spin lock and disables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">handle_stop_signal( )</tt> function, which checks for some types of signals that might nullify other pending signals for the destination thread group. The latter function executes the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the thread group is being killed (<tt class="calibre25">SIGNAL_GROUP_EXIT</tt> flag in the <tt class="calibre25">flags</tt> field of the signal descriptor set), it returns.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">sig</tt> is a <tt class="calibre25">SIGSTOP</tt>, <tt class="calibre25">SIGTSTP</tt>, <tt class="calibre25">SIGTTIN</tt>, or <tt class="calibre25">SIGTTOU</tt> signal, the function invokes the <tt class="calibre25">rm_from_queue( )</tt> function to remove the <tt class="calibre25">SIGCONT</tt> signal from the shared pending signal queue <tt class="calibre25">p-&gt;signal-&gt;shared_pending</tt> and from the private queues of all members of the thread group.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">sig</tt> is <tt class="calibre25">SIGCONT</tt>, it invokes the <tt class="calibre25">rm_from_queue( )</tt> function to remove any <tt class="calibre25">SIGSTOP</tt>, <tt class="calibre25">SIGTSTP</tt>, <tt class="calibre25">SIGTTIN</tt>, and <tt class="calibre25">SIGTTOU</tt> signal from the shared pending signal queue <tt class="calibre25">p-&gt;signal-&gt;shared_pending</tt>; then, removes the same signals from the private pending signal queues of the processes belonging to the thread group, and awakens them:</p><pre class="calibre60">
    rm_from_queue(0x003c0000, &amp;p-&gt;signal-&gt;shared_pending);
    t = p;
    do {
        rm_from_queue(0x003c0000, &amp;t-&gt;pending);
        try_to_wake_up(t, TASK_STOPPED, 0);
        t = next_thread(t);
    } while (t != p);
</pre><br class="calibre7"/>
<p class="docList">The mask <tt class="calibre25">0x003c0000</tt> selects the four stop signals. At each iteration, the <tt class="calibre25">next_thread</tt> macro returns the descriptor address of a different lightweight process in the thread group (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.3">Relationships Among Processes</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>).<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-FN5">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-11-FN5">[*]</a></sup> The actual code is more complicated than the fragment just shown, because <tt class="calibre42">handle_stop_signal( )</tt> also takes care of the unusual case of the <tt class="calibre42">SIGCONT</tt> signal being caught, as well as of the race conditions due to a <tt class="calibre42">SIGCONT</tt> signal occurring while all processes in the thread group are being stopped.</p></blockquote></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the thread group ignores the signal; if so, returns the value 0 (success). The signal is ignored when all three conditions for ignoring a signal that are mentioned in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-1.html#understandlk-CHP-11-SECT-1">The Role of Signals</a>" are satisfied (see also step 1 in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-SECT-2.1">The specific_send_sig_info( ) Function</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the signal is non-real-time and another occurrence of the same signal is already pending in the shared pending signal queue of the thread group: if so, nothing has to be done, thus returns the value 0 (success):</p><pre class="calibre60">
    if (sig&lt;32 &amp;&amp; sigismember(&amp;p-&gt;signal-&gt;shared_pending.signal,sig))
        return 0;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">send_signal( )</tt> to append the signal to the shared pending signal queue (see the previous section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-SECT-2.2">The send_signal( ) Function</a>"). If <tt class="calibre25">send_signal( )</tt> returns a nonzero error code, it terminates while returning the same value.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">_ _group_complete_signal( )</tt> function to wake up one lightweight process in the thread group (see below).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">p-&gt;sighand-&gt;siglock</tt> spin lock and enables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 0 (success).</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">_ _group_complete_signal( )</tt> function scans the processes in the thread group, looking for a process that can receive the new signal. A process may be selected if it satisfies all the following conditions:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The process does not block the signal.</p></li><li class="calibre12"><p class="docText1">The process is not in state <tt class="calibre25">EXIT_ZOMBIE</tt>, <tt class="calibre25">EXIT_DEAD</tt>, <tt class="calibre25">TASK_TRACED</tt>, or <tt class="calibre25">TASK_STOPPED</tt> (as an exception, the process can be in the <tt class="calibre25">TASK_TRACED</tt> or <tt class="calibre25">TASK_STOPPED</tt> states if the signal is <tt class="calibre25">SIGKILL</tt>).</p></li><li class="calibre12"><p class="docText1">The process is not being killedthat is, its <tt class="calibre25">PF_EXITING</tt> flag is not set.</p></li><li class="calibre12"><p class="docText1">Either the process is currently in execution on a CPU, or its <tt class="calibre25">TIF_SIGPENDING</tt> flag is not already set. (In fact, there is no point in awakening a process that has pending signals: in general, this operation has been already performed by the kernel control path that set the <tt class="calibre25">TIF_SIGPENDING</tt> flag. On the other hand, if a process is currently in execution, it should be notified of the new pending signal.)</p></li></ul>
<p class="docText1">A thread group might include many processes that satisfy the above conditions. The function selects one of them as follows:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">If the process identified by <tt class="calibre25">p</tt>the descriptor address passed as parameter of the <tt class="calibre25">group_send_sig_info( )</tt> functionsatisfies all the prior rules and can thus receive the signal, the function selects it.</p></li><li class="calibre12"><p class="docText1">Otherwise, the function searches for a suitable process by scanning the members of the thread group, starting from the process that received the last thread group's signal (<tt class="calibre25">p-&gt;signal-&gt;curr_target</tt>).</p></li></ul>
<p class="docText1">If <tt class="calibre25">_ _group_complete_signal( )</tt> succeeds in finding a suitable process, it sets up the delivery of the signal to the selected process. First, the function checks whether the signal is fatal: in this case, the whole thread group is killed by sending <tt class="calibre25">SIGKILL</tt> signals to each lightweight process in the group. Otherwise, if the signal is not fatal, the function invokes the <tt class="calibre25">signal_wake_up( )</tt> function to notify the selected process that it has a new pending signal (see step 4 in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-11-SECT-2.1">The specific_send_sig_info( ) Function</a>").</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

