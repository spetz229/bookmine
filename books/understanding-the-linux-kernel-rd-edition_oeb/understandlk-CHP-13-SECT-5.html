---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-13-SECT-4.html
next: understandlk-CHP-14.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-13-SECT-5"></a>
<h3 class="docSection1Title">13.5. Character Device Drivers</h3><a name="IDX-CHP-13-3566"></a>
<a name="IDX-CHP-13-3567"></a>
<a name="IDX-CHP-13-3568"></a>
<a name="IDX-CHP-13-3569"></a>
<a name="IDX-CHP-13-3570"></a>
<a name="IDX-CHP-13-3571"></a>
<p class="docText1">Handling a character device is relatively easy, because usually sophisticated buffering strategies are not needed and disk caches are not involved. Of course, character devices differ in their requirements: some of them must implement a sophisticated communication protocol to drive the hardware device, while others just have to read a few values from a couple of I/O ports of the hardware devices. For instance, the device driver of a multiport serial card device (a hardware device offering many serial ports) is much more complicated than the device driver of a bus mouse.</p>
<p class="docText1">Block device drivers, on the other hand, are inherently more complex than character device drivers<a name="IDX-CHP-13-3572"></a> 
. In fact, applications are entitled to ask repeatedly to read or write the same block of data. Furthermore, accesses to these devices are usually very slow. These peculiarities have a profound impact on the structure of the disk drivers. As we 'll see in the next chapters, however, the kernel provides sophisticated componentssuch as the page cache and the block I/O subsystemto handle them. In the rest of this chapter we focus our attention on the character device drivers.</p>
<p class="docText1">A character device driver is described by a <tt class="calibre25">cdev</tt> structure, whose fields are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-TABLE-8">Table 13-8</a>.</p>
<a name="understandlk-CHP-13-TABLE-8"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 13-8. The fields of the cdev structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct kobject</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">kobj</tt></p></td><td class="docTableCell"><p class="docText2">Embedded kobject</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct module *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">owner</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the module implementing the driver, if any</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct file_operations *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">ops</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the file operations table of the device driver</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">list</tt></p></td><td class="docTableCell"><p class="docText2">Head of the list of inodes relative to device files for this character device</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">dev_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">dev</tt></p></td><td class="docTableCell"><p class="docText2">Initial major and minor numbers assigned to the device driver</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">count</tt></p></td><td class="docTableCell"><p class="docText2">Size of the range of device numbers assigned to the device driver</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">list</tt> field is the head of a doubly linked circular list collecting inodes of character device files that refer to the same character device driver. There could be many device files having the same device number, and all of them refer to the same character device. Moreover, a device driver can be associated with a range of device numbers, not just a single one; all device files whose numbers fall in the range are handled by the same character device driver. The size of the range is stored in the <tt class="calibre25">count</tt> field.</p>
<p class="docText1">The <tt class="calibre25">cdev_alloc( )</tt> function allocates dynamically a <tt class="calibre25">cdev</tt> descriptor and initializes the embedded kobject so that the descriptor is automatically freed when the reference counter becomes zero.</p>
<p class="docText1">The <tt class="calibre25">cdev_add( )</tt> function registers a <tt class="calibre25">cdev</tt> descriptor in the device driver model. The function initializes the <tt class="calibre25">dev</tt> and <tt class="calibre25">count</tt> fields of the <tt class="calibre25">cdev</tt> descriptor, then invokes the <tt class="calibre25">kobj_map( )</tt> function. This function, in turn, sets up the device driver model's data structures that glue the interval of device numbers to the device driver descriptor.</p>
<p class="docText1">The device driver model defines a <span class="docEmphasis">kobject mapping domain</span><a name="IDX-CHP-13-3573"></a> 
 for the character devices, which is represented by a descriptor of type <tt class="calibre25">kobj_map</tt> and is referenced by the <tt class="calibre25">cdev_map</tt> global variable. The <tt class="calibre25">kobj_map</tt> descriptor includes a hash table of 255 entries indexed by the major number of the intervals. The hash table stores objects of type <tt class="calibre25">probe</tt>, one for each registered range of major and minor numbers, whose fields are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-TABLE-9">Table 13-9</a>.</p>
<a name="understandlk-CHP-13-TABLE-9"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 13-9. The fields of the probe object</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct probe *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">next</tt></p></td><td class="docTableCell"><p class="docText2">Next element in hash collision list</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">dev_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">dev</tt></p></td><td class="docTableCell"><p class="docText2">Initial device number (major and minor) of the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">range</tt></p></td><td class="docTableCell"><p class="docText2">Size of the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct module *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">owner</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the module that implements the device driver, if any</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct kobject *(*)</tt></p><p class="docText2"><tt class="calibre25">(dev_t, int *, void *)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">get</tt></p></td><td class="docTableCell"><p class="docText2">Method for probing the owner of the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int (*)(dev_t, void *)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">lock</tt></p></td><td class="docTableCell"><p class="docText2">Method for increasing the reference counter of the owner of the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">data</tt></p></td><td class="docTableCell"><p class="docText2">Private data for the owner of the interval</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">When the <tt class="calibre25">kobj_map( )</tt> function is invoked, the specified interval of device numbers is added to the hash table. The <tt class="calibre25">data</tt> field of the corresponding <tt class="calibre25">probe</tt> object points to the <tt class="calibre25">cdev</tt> descriptor of the device driver. The value of this field is passed to the <tt class="calibre25">get</tt> and <tt class="calibre25">lock</tt> methods when they are executed. In this case, the <tt class="calibre25">get</tt> method is implemented by a short function that returns the address of the kobject embedded in the <tt class="calibre25">cdev</tt> descriptor; the <tt class="calibre25">lock</tt> method, instead, essentially increases the reference counter in the embedded kobject.</p>
<p class="docText1">The <tt class="calibre25">kobj_lookup( )</tt> function receives as input parameters a kobject mapping domain and a device number; it searches the hash table and returns the address of the kobject of the owner of the interval including the number, if it was found. When applied to the mapping domain of the character devices, the function returns the address of the kobject embedded in the <tt class="calibre25">cdev</tt> descriptor of the device driver that owns the interval of device numbers.</p>
<a name="understandlk-CHP-13-SECT-5.1"></a>
<h4 class="docSection2Title">13.5.1. Assigning Device Numbers</h4><a name="IDX-CHP-13-3574"></a>
<a name="IDX-CHP-13-3575"></a>
<a name="IDX-CHP-13-3576"></a>
<p class="docText1">To keep track of which character device numbers are currently assigned, the kernel uses a hash table <tt class="calibre25">chrdevs</tt>, which contains intervals of device numbers. Two intervals may share the same major number, but they cannot overlap, thus their minor numbers should be all different. The table includes 255 entries, and the hash function masks out the four higher-order bits of the major numbertherefore, major numbers less than 255 are hashed in different entries. Each entry points to the first element of a collision list ordered by increasing major and minor numbers.</p>
<p class="docText1">Each list element is a <tt class="calibre25">char_device_struct</tt> structure, whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-TABLE-10">Table 13-10</a>.</p>
<a name="understandlk-CHP-13-TABLE-10"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 13-10. The fields of the char_device_struct descriptor</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned char_device_struct *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">next</tt></p></td><td class="docTableCell"><p class="docText2">The pointer to next element in hash collision list</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">major</tt></p></td><td class="docTableCell"><p class="docText2">The major number of the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">baseminor</tt></p></td><td class="docTableCell"><p class="docText2">The initial minor number of the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">minorct</tt></p></td><td class="docTableCell"><p class="docText2">The interval size</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">const char *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">name</tt></p></td><td class="docTableCell"><p class="docText2">The name of the device driver that handles the interval</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct file_operations *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fops</tt></p></td><td class="docTableCell"><p class="docText2">Not used</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct cdev *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">cdev</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the character device driver descriptor</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">There are essentially two methods for assigning a range of device numbers to a character device driver. The first method, which should be used for all new device drivers, relies on the <tt class="calibre25">register_chrdev_region( )</tt> and <tt class="calibre25">alloc_chrdev_region( )</tt> functions, and assigns an arbitrary range of device numbers. For instance, to get an interval of numbers starting from the <tt class="calibre25">dev_t</tt> value <tt class="calibre25">dev</tt> and of size <tt class="calibre25">size</tt>:</p>
<pre class="calibre27">
    register_chrdev_region(dev, size, "foo");</pre><br class="calibre7"/>
<p class="docText1">These functions do not execute <tt class="calibre25">cdev_add( )</tt>, so the device driver must execute <tt class="calibre25">cdev_add( )</tt> after the requested interval has been successfully assigned.</p>
<p class="docText1">The second method makes use of the <tt class="calibre25">register_chrdev( )</tt> function and assigns a fixed interval of device numbers including a single major number and minor numbers from 0 to 255. In this case, the device driver must not invoke <tt class="calibre25">cdev_add( )</tt>.</p>
<a name="understandlk-CHP-13-SECT-5.1.1"></a>
<h5 class="docSection3Title">13.5.1.1. The register_chrdev_region( ) and alloc_chrdev_region( ) functions</h5><a name="IDX-CHP-13-3577"></a>
<a name="IDX-CHP-13-3578"></a>
<a name="IDX-CHP-13-3579"></a>
<p class="docText1">The <tt class="calibre25">register_chrdev_region( )</tt> function receives three parameters: the initial device number (major and minor numbers), the size of the requested range of device numbers (as the number of minor numbers), and the name of the device driver that is requesting the device numbers. The function checks whether the requested range spans several major numbers and, if so, determines the major numbers and the corresponding intervals that cover the whole range; then, the function invokes <tt class="calibre25">_ _register_chrdev_region( )</tt> (described below) on each of these intervals.</p>
<p class="docText1">The <tt class="calibre25">alloc_chrdev_region( )</tt> function is similar, but it is used to allocate dynamically a major number; thus, it receives as its parameters the initial minor number of the interval, the size of the interval, and the name of the device driver. This function also ends up invoking <tt class="calibre25">_ _register_chrdev_region( )</tt>.</p>
<p class="docText1">The <tt class="calibre25">_ _register_chrdev_region( )</tt> function executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a new <tt class="calibre25">char_device_struct</tt> structure, and fills it with zeros.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the major number of the interval is zero, then the device driver has requested the dynamic allocation of the major number. Starting from the last hash table entry and proceeding backward, the function looks for an empty collision list (<tt class="calibre25">NULL</tt> pointer), which corresponds to a yet unused major number. If no empty entry is found, the function returns an error code.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-FN6">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-13-FN6">[*]</a></sup> Notice that the kernel can dynamically allocate only major numbers less than 255, and that in some cases allocation can fail even if there is a unused major number less than 255. We might expect that these constraints will be removed in the future.</p></blockquote></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the fields of the <tt class="calibre25">char_device_struct</tt> structure with the initial device number of the interval, the interval size, and the name of the device driver.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the hash function to compute the hash table index corresponding to the major number.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Walks the collision list, looking for the correct position of the new <tt class="calibre25">char_device_struct</tt> structure. Meanwhile, if an interval overlapping with the requested one is found, it returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Inserts the new <tt class="calibre25">char_device_struct</tt> descriptor in the collision list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address of the new <tt class="calibre25">char_device_struct</tt> descriptor.</p></div></li></ol></div>
<a name="understandlk-CHP-13-SECT-5.1.2"></a>
<h5 class="docSection3Title">13.5.1.2. The register_chrdev( ) function</h5><a name="IDX-CHP-13-3580"></a>
<a name="IDX-CHP-13-3581"></a>
<p class="docText1">The <tt class="calibre25">register_chrdev( )</tt> function is used by drivers that require an old-style interval of device numbers: a single major number and minor numbers ranging from 0 to 255. The function receives as its parameters the requested major number <tt class="calibre25">major</tt> (zero for dynamic allocation), the name of the device driver <tt class="calibre25">name</tt>, and a pointer <tt class="calibre25">fops</tt> to a table of file operations specific to the character device files in the interval. It executes the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">_ _register_chrdev_region( )</tt> function to allocate the requested interval. If the function returns an error code (the interval cannot be assigned), it terminates.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a new <tt class="calibre25">cdev</tt> structure for the device driver.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">cdev</tt> structure:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Sets the type of the embedded kobject to the <tt class="calibre25">ktype_cdev_dynamic</tt> type descriptor (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.2">Kobjects</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">owner</tt> field with the contents of <tt class="calibre25">fops-&gt;owner</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">ops</tt> field with the address <tt class="calibre25">fops</tt> of the table of file operations.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the characters of the device driver name into the <tt class="calibre25">name</tt> field of the embedded kobject.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">cdev_add( )</tt> function (explained previously).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">cdev</tt> field of the <tt class="calibre25">char_device_struct</tt> descriptor <tt class="calibre25">_ _register_chrdev_region( )</tt> returned in step 1 with the address of the <tt class="calibre25">cdev</tt> descriptor of the device driver.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the major number of the assigned interval.</p></div></li></ol></div>
<a name="understandlk-CHP-13-SECT-5.2"></a>
<h4 class="docSection2Title">13.5.2. Accessing a Character Device Driver</h4><a name="IDX-CHP-13-3582"></a>
<a name="IDX-CHP-13-3583"></a>
<p class="docText1">We mentioned in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-3.html#understandlk-CHP-13-SECT-3.2">VFS Handling of Device Files</a>" that the <tt class="calibre25">dentry_open( )</tt> function triggered by the <tt class="calibre25">open( )</tt><a name="IDX-CHP-13-3584"></a> 
 system call service routine customizes the <tt class="calibre25">f_op</tt> field in the file object of the character device file so that it points to the <tt class="calibre25">def_chr_fops</tt> table. This table is almost empty; it only defines the <tt class="calibre25">chrdev_open( )</tt> function as the <tt class="calibre25">open</tt> method of the device file. This method is immediately invoked by <tt class="calibre25">dentry_open( )</tt>.</p>
<p class="docText1">The <tt class="calibre25">chrdev_open( )</tt> function receives as its parameters the addresses <tt class="calibre25">inode</tt> and <tt class="calibre25">filp</tt> of the inode and file objects relative to the device file being opened. It executes essentially the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks the <tt class="calibre25">inode-&gt;i_cdev</tt> pointer to the device driver's <tt class="calibre25">cdev</tt> descriptor. If this field is not <tt class="calibre25">NULL</tt>, then the inode has already been accessed: increases the reference counter of the <tt class="calibre25">cdev</tt> descriptor and jumps to step 6.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">kobj_lookup( )</tt> function to search the interval including the number. If such interval does not exists, it returns an error code; otherwise, it computes the address of the <tt class="calibre25">cdev</tt> descriptor associated with the interval.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">inode-&gt;i_cdev</tt> field of the inode object to the address of the <tt class="calibre25">cdev</tt> descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">inode-&gt;i_cindex</tt> field to the relative index of the device number inside the interval of the device driver (index zero for the first minor number in the interval, one for the second, and so on).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds the inode object into the list pointed to by the <tt class="calibre25">list</tt> field of the <tt class="calibre25">cdev</tt> descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">filp-&gt;f_ops</tt> file operations pointer with the contents of the <tt class="calibre25">ops</tt> field of the <tt class="calibre25">cdev</tt> descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">filp-&gt;f_ops-&gt;open</tt> method is defined, the function executes it. If the device driver handles more than one device number, typically this function sets the file operations of the file object once again, so as to install the file operations suitable for the accessed device file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Terminates by returning zero (success).</p></div></li></ol></div>
<a name="understandlk-CHP-13-SECT-5.3"></a>
<h4 class="docSection2Title">13.5.3. Buffering Strategies for Character Devices</h4><a name="IDX-CHP-13-3585"></a>
<a name="IDX-CHP-13-3586"></a>
<a name="IDX-CHP-13-3587"></a>
<p class="docText1">Traditionally, Unix-like operating systems divide hardware devices into block and character devices. However, this classification does not tell the whole story. Some devices are capable of transferring sizeable amounts of data in a single I/O operation, while others transfer only a few characters.</p>
<p class="docText1">For instance, a PS/2 mouse driver gets a few bytes in each read operation corresponding to the status of the mouse button and to the position of the mouse pointer on the screen. This kind of device is the easiest to handle. Input data is first read one character at a time from the device input register and stored in a proper kernel data structure; the data is then copied at leisure into the process address space. Similarly, output data is first copied from the process address space to a proper kernel data structure and then written one at a time into the I/O device output register. Clearly, I/O drivers for such devices do not use the DMA, because the CPU time spent to set up a DMA I/O operation is comparable to the time spent to move the data to or from the I/O ports.</p>
<p class="docText1">On the other hand, the kernel must also be ready to deal with devices that yield a large number of bytes in each I/O operation, either sequential devices such as sound cards or network cards, or random access devices such as disks of all kinds (floppy, CD-ROM, SCSI disk, etc.).</p>
<p class="docText1">Suppose, for instance, that you have set up the sound card of your computer so that you are able to record sounds coming from a microphone. The sound card samples the electrical signal coming from the microphone at a fixed rate, say 44.14 kHz, and produces a stream of 16-bit numbers divided into blocks of input data. The sound card driver must be able to cope with this avalanche of data in all possible situations, even when the CPU is temporarily busy running some other process.</p>
<p class="docText1">This can be done by combining two different techniques:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Use of DMA to transfer blocks of data.</p></li><li class="calibre12"><p class="docText1">Use of a circular buffer of two or more elements, each element having the size of a block of data. When an interrupt occurs signaling that a new block of data has been read, the interrupt handler advances a pointer to the elements of the circular buffer so that further data will be stored in an empty element. Conversely, whenever the driver succeeds in copying a block of data into user address space, it releases an element of the circular buffer so that it is available for saving new data from the hardware device.</p></li></ul>
<p class="docText1">The role of the circular buffer is to smooth out the peaks of CPU load; even if the User Mode application receiving the data is slowed down because of other higher-priority tasks, the DMA is able to continue filling elements of the circular buffer because the interrupt handler executes on behalf of the currently running process.</p>
<p class="docText1">A similar situation occurs when receiving packets from a network card, except that in this case, the flow of incoming data is asynchronous. Packets are received independently from each other and the time interval that occurs between two consecutive packet arrivals is unpredictable.</p>
<p class="docText1">All considered, buffer handling for sequential devices is easy because the same buffer is <span class="docEmphasis">never reused</span>: an audio application cannot ask the microphone to retransmit the same block of data.</p>
<p class="docText1">We'll see in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a> that buffering for random access devices (all kinds of disks) is much more complicated.</p>

<br class="calibre7"/>

</div>

{% endraw %}

