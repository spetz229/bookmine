---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-7-SECT-3.html
next: understandlk-CHP-7-SECT-5.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-7-SECT-4"></a>
<h3 class="docSection1Title">7.4. Functions Used by the Scheduler</h3><a name="IDX-CHP-7-1874"></a>
<a name="IDX-CHP-7-1875"></a>
<a name="IDX-CHP-7-1876"></a>
<p class="docText1">The scheduler relies on several functions in order to do its work; the most important are:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">scheduler_tick( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Keeps the <tt class="calibre25">time_slice</tt> counter of <tt class="calibre25">current</tt> up-to-date</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">try_to_wake_up( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Awakens a sleeping process</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">recalc_task_prio( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Updates the dynamic priority of a process</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">schedule( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Selects a new process to be executed</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">load_balance()</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Keeps the runqueues of a multiprocessor system balanced</p></dd>
</dl>
<a name="understandlk-CHP-7-SECT-4.1"></a>
<h4 class="docSection2Title">7.4.1. The scheduler_tick( ) Function</h4>
<p class="docText1">We have already explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-4.html#understandlk-CHP-6-SECT-4.1">Updating Local CPU Statistics</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6.html#understandlk-CHP-6">Chapter 6</a> how <tt class="calibre25">scheduler_tick( )</tt> is invoked once every tick to perform some operations related to scheduling. It executes the following main steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Stores in the <tt class="calibre25">timestamp_last_tick</tt> field of the local runqueue the current value of the TSC converted to nanoseconds; this timestamp is obtained from the <tt class="calibre25">sched_clock( )</tt> function (see the previous section).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the current process is the <span class="docEmphasis">swapper</span> process of the local CPU. If so, it performs the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the local runqueue includes another runnable process besides <span class="docEmphasis">swapper</span>, it sets the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of the current process to force rescheduling. As we'll see in the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-SECT-4.4">The schedule( ) Function</a>" later in this chapter, if the kernel supports the hyper-threading technology (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-5.html#understandlk-CHP-7-SECT-5">Runqueue Balancing in Multiprocessor Systems</a>" later in this chapter), a logical CPU might be idle even if there are runnable processes in its runqueue, as long as those processes have significantly lower priorities than the priority of a process already executing on another logical CPU associated with the same physical CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Jumps to step 7 (there is no need to update the time slice counter of the <span class="docEmphasis">swapper</span> process).</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether <tt class="calibre25">current-&gt;array</tt> points to the active list of the local runqueue. If not, the process has expired its time quantum, but it has not yet been replaced: sets the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag to force rescheduling, and jumps to step 7.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">this_rq()-&gt;lock</tt> spin lock.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Decreases the time slice counter of the current process, and checks whether the quantum is exhausted. The operations performed by the function are quite different according to the scheduling class of the process; we will discuss them in a moment.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">this_rq( )-&gt;lock</tt> spin lock.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">rebalance_tick( )</tt> function, which should ensure that the runqueues of the various CPUs contain approximately the same number of runnable processes. We will discuss runqueue balancing in the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-5.html#understandlk-CHP-7-SECT-5">Runqueue Balancing in Multiprocessor Systems</a>."</p></div></li></ol></div>
<a name="understandlk-CHP-7-SECT-4.1.1"></a>
<h5 class="docSection3Title">7.4.1.1. Updating the time slice of a real-time process</h5><a name="IDX-CHP-7-1877"></a>
<a name="IDX-CHP-7-1878"></a>
<p class="docText1">If the current process is a FIFO real-time process, <tt class="calibre25">scheduler_tick( )</tt> has nothing to do. In this case, in fact, <tt class="calibre25">current</tt> cannot be preempted by lower or equal priority processes, thus it does not make sense to keep its time slice counter up-to-date.</p>
<p class="docText1">If <tt class="calibre25">current</tt> is a Round Robin real-time process, <tt class="calibre25">scheduler_tick( )</tt> decreases its time slice counter and checks whether the quantum is exhausted:</p>
<pre class="calibre27">
if (current-&gt;policy == SCHED_RR &amp;&amp; !--current-&gt;time_slice) {
    current-&gt;time_slice = task_timeslice(current);
    current-&gt;first_time_slice = 0;
    set_tsk_need_resched(current);
    list_del(&amp;current-&gt;run_list);
    list_add_tail(&amp;current-&gt;run_list,
                  this_rq( )-&gt;active-&gt;queue+current-&gt;prio);
}</pre><br class="calibre7"/>
<p class="docText1">If the function determines that the time quantum is effectively exhausted, it performs a few operations aimed to ensure that <tt class="calibre25">current</tt> will be preempted, if necessary, as soon as possible.</p>
<p class="docText1">The first operation consists of refilling the time slice counter of the process by invoking <tt class="calibre25">task_timeslice( )</tt>. This function considers the static priority of the process and returns the corresponding base time quantum, according to the formula (1) shown in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-SECT-2.1">Scheduling of Conventional Processes</a>." Moreover, the <tt class="calibre25">first_time_slice</tt> field of <tt class="calibre25">current</tt> is cleared: this flag is set by <tt class="calibre25">copy_process( )</tt> in the service routine of the <tt class="calibre25">fork( )</tt><a name="IDX-CHP-7-1879"></a> 
 system call, and should be cleared as soon as the first time quantum of the process elapses.</p>
<p class="docText1">Next, <tt class="calibre25">scheduler_tick( )</tt> invokes the <tt class="calibre25">set_tsk_need_resched( )</tt> function to set the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of the process. As described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, this flag forces the invocation of the <tt class="calibre25">schedule( )</tt> function, so that <tt class="calibre25">current</tt> can be replaced by another real-time process having equal (or higher) priority, if any.</p>
<p class="docText1">The last operation of <tt class="calibre25">scheduler_tick( )</tt> consists of moving the process descriptor to the last position of the runqueue active list corresponding to the priority of <tt class="calibre25">current</tt>. Placing <tt class="calibre25">current</tt> in the last position ensures that it will not be selected again for execution until every real-time runnable process having the same priority as <tt class="calibre25">current</tt> will get a slice of the CPU time. This is the meaning of round-robin scheduling. The descriptor is moved by first invoking <tt class="calibre25">list_del( )</tt> to remove the process from the runqueue active list, then by invoking <tt class="calibre25">list_add_tail( )</tt> to insert back the process in the last position of the same list.</p>
<a name="understandlk-CHP-7-SECT-4.1.2"></a>
<h5 class="docSection3Title">7.4.1.2. Updating the time slice of a conventional process</h5><a name="IDX-CHP-7-1880"></a>
<a name="IDX-CHP-7-1881"></a>
<p class="docText1">If the current process is a conventional process, the <tt class="calibre25">scheduler_tick( )</tt> function performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Decreases the time slice counter (<tt class="calibre25">current-&gt;time_slice</tt>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the time slice counter. If the time quantum is exhausted, the function performs the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">dequeue_task( )</tt> to remove <tt class="calibre25">current</tt> from the <tt class="calibre25">this_rq( )-&gt;active</tt> set of runnable processes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">set_tsk_need_resched( )</tt> to set the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the dynamic priority of <tt class="calibre25">current</tt>:</p><pre class="calibre60">
    current-&gt;prio = effective_prio(current);
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">effective_prio( )</tt> function reads the <tt class="calibre25">static_prio</tt> and <tt class="calibre25">sleep_avg</tt> fields of <tt class="calibre25">current</tt>, and computes the dynamic priority of the process according to the formula (2) shown in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-SECT-2.1">Scheduling of Conventional Processes</a>."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Refills the time quantum of the process:</p><pre class="calibre60">
    current-&gt;time_slice = task_timeslice(current);
    current-&gt;first_time_slice = 0;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">expired_timestamp</tt> field of the local runqueue data structure is equal to zero (that is, the set of expired processes is empty), writes into the field the value of the current tick:</p><pre class="calibre60">
    if (!this_rq( )-&gt;expired_timestamp)
        this_rq( )-&gt;expired_timestamp = jiffies;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Inserts the current process either in the active set or in the expired set:</p><pre class="calibre60">
    if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq( )) {
        enqueue_task(current, this_rq( )-&gt;expired);
        if (current-&gt;static_prio &lt; this_rq( )-&gt;best_expired_prio)
            this_rq( )-&gt;best_expired_prio = current-&gt;static_prio;
    } else
        enqueue_task(current, this_rq( )-&gt;active);
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">TASK_INTERACTIVE</tt> macro yields the value one if the process is recognized as interactive using the formula (3) shown in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-SECT-2.1">Scheduling of Conventional Processes</a>." The <tt class="calibre25">EXPIRED_STARVING</tt> macro checks whether the first expired process in the runqueue had to wait for more than 1000 ticks times the number of runnable processes in the runqueue plus one; if so, the macro yields the value one. The <tt class="calibre25">EXPIRED_STARVING</tt> macro also yields the value one if the static priority value of the current process is greater than the static priority value of an already expired process.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the time quantum is not exhausted (<tt class="calibre25">current-&gt;time_slice</tt> is not zero), checks whether the remaining time slice of the current process is too long:</p><pre class="calibre60">
if (TASK_INTERACTIVE(p) &amp;&amp; !((task_timeslice(p) -
         p-&gt;time_slice) % TIMESLICE_GRANULARITY(p)) &amp;&amp;
        (p-&gt;time_slice &gt;= TIMESLICE_GRANULARITY(p)) &amp;&amp;
        (p-&gt;array == rq-&gt;active)) {
    list_del(&amp;current-&gt;run_list);
    list_add_tail(&amp;current-&gt;run_list,
                  this_rq( )-&gt;active-&gt;queue+current-&gt;prio);
    set_tsk_need_resched(p);
}
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">TIMESLICE_GRANULARITY</tt> macro yields the product of the number of CPUs in the system and a constant proportional to the bonus of the current process (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-TABLE-3">Table 7-3</a> earlier in the chapter). Basically, the time quantum of interactive processes with high static priorities is split into several pieces of <tt class="calibre25">TIMESLICE_GRANULARITY</tt> size, so that they do not monopolize the CPU.</p></div></li></ol></div>
<a name="understandlk-CHP-7-SECT-4.2"></a>
<h4 class="docSection2Title">7.4.2. The try_to_wake_up( ) Function</h4><a name="IDX-CHP-7-1882"></a>
<a name="IDX-CHP-7-1883"></a>
<a name="IDX-CHP-7-1884"></a>
<a name="IDX-CHP-7-1885"></a>
<a name="IDX-CHP-7-1886"></a>
<p class="docText1">The <tt class="calibre25">TRy_to_wake_up( )</tt> function awakes a sleeping or stopped process by setting its state to <tt class="calibre25">TASK_RUNNING</tt> and inserting it into the runqueue of the local CPU. For instance, the function is invoked to wake up processes included in a wait queue (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.4">How Processes Are Organized</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>) or to resume execution of processes waiting for a signal (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>). The function receives as its parameters:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The descriptor pointer (<tt class="calibre25">p</tt>) of the process to be awakened</p></li><li class="calibre12"><p class="docText1">A mask of the process states (<tt class="calibre25">state</tt>) that can be awakened</p></li><li class="calibre12"><p class="docText1">A flag (<tt class="calibre25">sync</tt>) that forbids the awakened process to preempt the process currently running on the local CPU</p></li></ul>
<p class="docText1">The function performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">task_rq_lock( )</tt> function to disable local interrupts and to acquire the lock of the runqueue <tt class="calibre25">rq</tt> owned by the CPU that was last executing the process (it could be different from the local CPU). The logical number of that CPU is stored in the <tt class="calibre25">p-&gt;thread_info-&gt;cpu</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks if the state of the process <tt class="calibre25">p-&gt;state</tt> belongs to the mask of states <tt class="calibre25">state</tt> passed as argument to the function; if this is not the case, it jumps to step 9 to terminate the function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">p-&gt;array</tt> field is not <tt class="calibre25">NULL</tt>, the process already belongs to a runqueue; therefore, it jumps to step 8.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">In multiprocessor systems, it checks whether the process to be awakened should be migrated from the runqueue of the lastly executing CPU to the runqueue of another CPU. Essentially, the function selects a target runqueue according to some heuristic rules. For example:</p><ul class="calibre61"><li class="calibre12"><p class="docList">If some CPU in the system is idle, it selects its runqueue as the target. Preference is given to the previously executing CPU and to the local CPU, in this order.</p></li><li class="calibre12"><p class="docList">If the workload of the previously executing CPU is significantly lower than the workload of the local CPU, it selects the old runqueue as the target.</p></li><li class="calibre12"><p class="docList">If the process has been executed recently, it selects the old runqueue as the target (the hardware cache might still be filled with the data of the process).</p></li><li class="calibre12"><p class="docList">If moving the process to the local CPU reduces the unbalance between the CPUs, the target is the local runqueue (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-5.html#understandlk-CHP-7-SECT-5">Runqueue Balancing in Multiprocessor Systems</a>" later in this chapter).</p></li></ul><p class="docList">After this step has been executed, the function has identified a target CPU that will execute the awakened process and, correspondingly, a target runqueue <tt class="calibre25">rq</tt> in which to insert the process.</p></div></li></ol></div>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If the process is in the <tt class="calibre25">TASK_UNINTERRUPTIBLE</tt> state, it decreases the <tt class="calibre25">nr_uninterruptible</tt> field of the target runqueue, and sets the <tt class="calibre25">p-&gt;activated</tt> field of the process descriptor to <tt class="calibre25">-</tt>1. See the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-SECT-4.3">The recalc_task_prio( ) Function</a>" for an explanation of the <tt class="calibre25">activated</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">activate_task( )</tt> function, which in turn performs the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">sched_clock( )</tt> to get the current timestamp in nanoseconds. If the target CPU is not the local CPU, it compensates for the drift of the local timer interrupts by using the timestamps relative to the last occurrences of the timer interrupts on the local and target CPUs:</p><pre class="calibre60">
    now = (sched_clock( ) - this_rq( )-&gt;timestamp_last_tick)
          + rq-&gt;timestamp_last_tick;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">recalc_task_prio( )</tt>, passing to it the process descriptor pointer and the timestamp computed in the previous step. The <tt class="calibre25">recalc_task_prio( )</tt> function is described in the next section.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the value of the <tt class="calibre25">p-&gt;activated</tt> field according to <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-TABLE-6">Table 7-6</a> later in this chapter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">p-&gt;timestamp</tt> field with the timestamp computed in step 6a.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Inserts the process descriptor in the active set:</p><pre class="calibre60">
enqueue_task(p, rq-&gt;active);
rq-&gt;nr_running++;
</pre><br class="calibre7"/>
</div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If either the target CPU is not the local CPU or if the <tt class="calibre25">sync</tt> flag is not set, it checks whether the new runnable process has a dynamic priority higher than that of the current process of the <tt class="calibre25">rq</tt> runqueue (<tt class="calibre25">p-&gt;prio &lt; rq-&gt;curr-&gt;prio</tt>); if so, invokes <tt class="calibre25">resched_task( )</tt> to preempt <tt class="calibre25">rq-&gt;curr</tt>. In uniprocessor systems the latter function just executes <tt class="calibre25">set_tsk_need_resched( )</tt> to set the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of the <tt class="calibre25">rq-&gt;curr</tt> process. In multiprocessor systems <tt class="calibre25">resched_task( )</tt> also checks whether the old value of whether <tt class="calibre25">TIF_NEED_RESCHED</tt> flag was zero, the target CPU is different from the local CPU, and whether the <tt class="calibre25">TIF_POLLING_NRFLAG</tt> flag of the <tt class="calibre25">rq-&gt;curr</tt> process is clear (the target CPU is not actively polling the status of the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of the process). If so, <tt class="calibre25">resched_task( )</tt> invokes <tt class="calibre25">smp_send_reschedule( )</tt> to raise an IPI and force rescheduling on the target CPU (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.2">Interprocessor Interrupt Handling</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">p-&gt;state</tt> field of the process to <tt class="calibre25">TASK_RUNNING</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">task_rq_unlock( )</tt> to unlock the <tt class="calibre25">rq</tt> runqueue and reenable the local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 1 (if the process has been successfully awakened) or 0 (if the process has not been awakened).</p></div></li></ol></div>
<a name="understandlk-CHP-7-SECT-4.3"></a>
<h4 class="docSection2Title">7.4.3. The recalc_task_prio( ) Function</h4><a name="IDX-CHP-7-1887"></a>
<a name="IDX-CHP-7-1888"></a>
<a name="IDX-CHP-7-1889"></a>
<p class="docText1">The <tt class="calibre25">recalc_task_prio( )</tt> function updates the average sleep time and the dynamic priority of a process. It receives as its parameters a process descriptor pointer <tt class="calibre25">p</tt> and a timestamp <tt class="calibre25">now</tt> computed by the <tt class="calibre25">sched_clock( )</tt> function.</p>
<p class="docText1">The function executes the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Stores in the <tt class="calibre25">sleep_time</tt> local variable the result of:</p><pre class="calibre60">
     min (now    -   p-&gt;timestamp, 10<sup class="calibre37">9</sup> )
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">p-&gt;timestamp</tt> field contains the timestamp of the process switch that put the process to sleep; therefore, <tt class="calibre25">sleep_time</tt> stores the number of nanoseconds that the process spent sleeping since its last execution (or the equivalent of 1 second, if the process slept more).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">sleep_time</tt> is not greater than zero, it jumps to step 8 so as to skip updating the average sleep time of the process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList"><span class="calibre5">Checks whether the process is not a kernel thread, whether it is awakening from the <tt class="calibre25">TASK_UNINTERRUPTIBLE</tt> state (<tt class="calibre25">p-&gt;activated</tt> field equal to -1; see step 5 in the previous section), and whether it has been continuously asleep beyond a given sleep time threshold. If these three conditions are fulfilled, the function sets the <tt class="calibre25">p-&gt;sleep_avg</tt> field to the equivalent of 900 ticks (an empirical value obtained by subtracting the duration of the base time quantum of a standard process from the maximum average sleep time). Then, it jumps to step 8</span>.</p><p class="docList">The sleep time threshold depends on the static priority of the process; some typical values are shown in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-TABLE-2">Table 7-2</a>. In short, the goal of this empirical rule is to ensure that processes that have been asleep for a long time in uninterruptible modeusually waiting for disk I/O operationsget a predefined sleep average value that is large enough to allow them to be quickly serviced, but it is also not so large to cause starvation for other processes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">CURRENT_BONUS</tt> macro to compute the <span class="docEmphasis">bonus</span><a name="IDX-CHP-7-1890"></a> 
 value of the previous average sleep time of the process (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-TABLE-3">Table 7-3</a>). If (10 <tt class="calibre25">-</tt> <span class="docEmphasis">bonus</span>) is greater than zero, the function multiplies <tt class="calibre25">sleep_time</tt> by this value. Since <tt class="calibre25">sleep_time</tt> will be added to the average sleep time of the process (see step 6 below), the lower the current average sleep time is, the more rapidly it will rise.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the process is in <tt class="calibre25">TASK_UNINTERRUPTIBLE</tt> mode and it is not a kernel thread, it performs the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the average sleep time <tt class="calibre25">p-&gt;sleep_avg</tt> is greater than or equal to its sleep time threshold (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-TABLE-2">Table 7-2</a> earlier in this chapter). If so, it resets the <tt class="calibre25">sleep_avg</tt> local variable to zerothus skipping the adjustment of the average sleep timeand jumps to step 6.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the sum <tt class="calibre25">sleep_avg + p-&gt;sleep_avg</tt> is greater than or equal to the sleep time threshold, it sets the <tt class="calibre25">p-&gt;sleep_avg</tt> field to the sleep time threshold, and sets <tt class="calibre25">sleep_avg</tt> to zero.</p></div></li></ol></div><p class="docList">By somewhat limiting the increment of the average sleep time of the process, the function does not reward too much batch processes that sleep for a long time.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds <tt class="calibre25">sleep_time</tt> to the average sleep time of the process (<tt class="calibre25">p-&gt;sleep_avg</tt>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether <tt class="calibre25">p-&gt;sleep_avg</tt> exceeds 1000 ticks (in nanoseconds); if so, the function cuts it down to 1000 ticks (in nanoseconds).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the dynamic priority of the process:</p><pre class="calibre60">
p-&gt;prio = effective_prio(p);
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">effective_prio( )</tt> function has already been discussed in the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-SECT-4.1">The scheduler_tick( ) Function</a>" earlier in this chapter.</p></div></li></ol></div>
<a name="understandlk-CHP-7-SECT-4.4"></a>
<h4 class="docSection2Title">7.4.4. The schedule( ) Function</h4><a name="IDX-CHP-7-1891"></a>
<a name="IDX-CHP-7-1892"></a>
<p class="docText1">The <tt class="calibre25">schedule( )</tt> function implements the scheduler. Its objective is to find a process in the runqueue list and then assign the CPU to it. It is invoked, directly or in a lazy (deferred) way, by several kernel routines.</p>
<a name="understandlk-CHP-7-SECT-4.4.1"></a>
<h5 class="docSection3Title">7.4.4.1. Direct invocation</h5><a name="IDX-CHP-7-1893"></a>
<a name="IDX-CHP-7-1894"></a>
<a name="IDX-CHP-7-1895"></a>
<a name="IDX-CHP-7-1896"></a>
<p class="docText1">The scheduler is invoked directly when the <tt class="calibre25">current</tt> process must be blocked right away because the resource it needs is not available. In this case, the kernel routine that wants to block it proceeds as follows:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Inserts <tt class="calibre25">current</tt> in the proper wait queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Changes the state of <tt class="calibre25">current</tt> either to <tt class="calibre25">TASK_INTERRUPTIBLE</tt> or to <tt class="calibre25">TASK_UNINTERRUPTIBLE</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">schedule( ).</tt></p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the resource is available; if not, goes to step 2.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Once the resource is available, removes <tt class="calibre25">current</tt> from the wait queue.</p></div></li></ol></div>
<p class="docText1">The kernel routine checks repeatedly whether the resource needed by the process is available; if not, it yields the CPU to some other process by invoking <tt class="calibre25">schedule( )</tt>. Later, when the scheduler once again grants the CPU to the process, the availability of the resource is rechecked. These steps are similar to those performed by <tt class="calibre25">wait_event( )</tt> and similar functions described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.4">How Processes Are Organized</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>.</p>
<p class="docText1">The scheduler is also directly invoked by many device drivers that execute long iterative tasks. At each iteration cycle, the driver checks the value of the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag and, if necessary, invokes <tt class="calibre25">schedule( )</tt> to voluntarily relinquish the CPU.</p>
<a name="understandlk-CHP-7-SECT-4.4.2"></a>
<h5 class="docSection3Title">7.4.4.2. Lazy invocation</h5>
<p class="docText1">The scheduler can also be invoked in a lazy way by setting the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of <tt class="calibre25">current</tt> to 1. Because a check on the value of this flag is always made before resuming the execution of a User Mode process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>), <tt class="calibre25">schedule( )</tt> will definitely be invoked at some time in the near future.</p>
<p class="docText1">Typical examples of lazy invocation<a name="IDX-CHP-7-1897"></a> 
 of the scheduler are:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">When <tt class="calibre25">current</tt> has used up its quantum of CPU time; this is done by the <tt class="calibre25">scheduler_tick( )</tt> function.</p></li><li class="calibre12"><p class="docText1">When a process is woken up and its priority is higher than that of the current process; this task is performed by the <tt class="calibre25">try_to_wake_up( )</tt> function.</p></li><li class="calibre12"><p class="docText1">When a <tt class="calibre25">sched_setscheduler( )</tt> system call is issued (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-6.html#understandlk-CHP-7-SECT-6">System Calls Related to Scheduling</a>" later in this chapter).</p></li></ul>
<a name="understandlk-CHP-7-SECT-4.4.3"></a>
<h5 class="docSection3Title">7.4.4.3. Actions performed by schedule( ) before a process switch</h5><a name="IDX-CHP-7-1898"></a>
<a name="IDX-CHP-7-1899"></a>
<a name="IDX-CHP-7-1900"></a>
<a name="IDX-CHP-7-1901"></a>
<a name="IDX-CHP-7-1902"></a>
<a name="IDX-CHP-7-1903"></a>
<p class="docText1">The goal of the <tt class="calibre25">schedule( )</tt> function consists of replacing the currently executing process with another one. Thus, the key outcome of the function is to set a local variable called <tt class="calibre25">next</tt>, so that it points to the descriptor of the process selected to replace <tt class="calibre25">current</tt>. If no runnable process in the system has priority greater than the priority of <tt class="calibre25">current</tt>, at the end, <tt class="calibre25">next</tt> coincides with <tt class="calibre25">current</tt> and no process switch takes place.</p>
<p class="docText1">The <tt class="calibre25">schedule( )</tt> function starts by disabling kernel preemption and initializing a few local variables:</p>
<pre class="calibre27">
need_resched:

preempt_disable( );
prev = current;
rq = this_rq( );</pre><br class="calibre7"/>
<p class="docText1">As you see, the pointer returned by <tt class="calibre25">current</tt> is saved in <tt class="calibre25">prev</tt>, and the address of the runqueue data structure corresponding to the local CPU is saved in <tt class="calibre25">rq</tt>.</p>
<p class="docText1">Next, <tt class="calibre25">schedule( )</tt> makes sure that <tt class="calibre25">prev</tt> doesn't hold the big kernel lock<a name="IDX-CHP-7-1904"></a> 
 (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-4.html#understandlk-CHP-5-SECT-4.2">The Big Kernel Lock</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>):</p>
<pre class="calibre27">
if (prev-&gt;lock_depth &gt;= 0)
    up(&amp;kernel_sem);</pre><br class="calibre7"/>
<p class="docText1">Notice that <tt class="calibre25">schedule( )</tt> doesn't change the value of the <tt class="calibre25">lock_depth</tt> field; when <tt class="calibre25">prev</tt> resumes its execution, it reacquires the <tt class="calibre25">kernel_flag</tt> spin lock if the value of this field is not negative. Thus, the big kernel lock is automatically released and reacquired across a process switch.</p>
<p class="docText1">The <tt class="calibre25">sched_clock( )</tt> function is invoked to read the TSC and convert its value to nanoseconds; the timestamp obtained is saved in the <tt class="calibre25">now</tt> local variable. Then, <tt class="calibre25">schedule( )</tt> computes the duration of the CPU time slice used by <tt class="calibre25">prev</tt>:</p>
<pre class="calibre27">
now = sched_clock( );
run_time = now - prev-&gt;timestamp;
if (run_time &gt; 1000000000)
    run_time = 1000000000;</pre><br class="calibre7"/>
<p class="docText1">The usual cut-off at 1 second (converted to nanoseconds) applies. The <tt class="calibre25">run_time</tt> value is used to charge the process for the CPU usage. However, a process having a high average sleep time is favored:</p>
<pre class="calibre27">
run_time /= (CURRENT_BONUS(prev) ? : 1);</pre><br class="calibre7"/>
<p class="docText1">Remember that <tt class="calibre25">CURRENT_BONUS</tt> returns a value between 0 and 10 that is proportional to the average sleep time of the process.</p>
<p class="docText1">Before starting to look at the runnable processes, <tt class="calibre25">schedule( )</tt> must disable the local interrupts and acquire the spin lock that protects the runqueue:</p>
<pre class="calibre27">
spin_lock_irq(&amp;rq-&gt;lock);</pre><br class="calibre7"/>
<p class="docText1">As explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-5.html#understandlk-CHP-3-SECT-5.1">Process Termination</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>, <tt class="calibre25">prev</tt> might be a process that is being terminated. To recognize this case, <tt class="calibre25">schedule( )</tt> looks at the <tt class="calibre25">PF_DEAD</tt> flag:</p>
<pre class="calibre27">
if (prev-&gt;flags &amp; PF_DEAD)
    prev-&gt;state = EXIT_DEAD;</pre><br class="calibre7"/>
<p class="docText1">Next, <tt class="calibre25">schedule( )</tt> examines the state of <tt class="calibre25">prev</tt>. If it is not runnable and it has not been preempted in Kernel Mode (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>), then it should be removed from the runqueue. However, if it has nonblocked pending signals<a name="IDX-CHP-7-1905"></a> 
 and its state is <tt class="calibre25">TASK_INTERRUPTIBLE</tt>, the function sets the process state to <tt class="calibre25">TASK_RUNNING</tt> and leaves it into the runqueue. This action is not the same as assigning the processor to <tt class="calibre25">prev</tt>; it just gives <tt class="calibre25">prev</tt> a chance to be selected for execution:</p>
<pre class="calibre27">
if (prev-&gt;state != TASK_RUNNING &amp;&amp;
    !(preempt_count() &amp; PREEMPT_ACTIVE)) {
    if (prev-&gt;state == TASK_INTERRUPTIBLE &amp;&amp; signal_pending(prev))
        prev-&gt;state = TASK_RUNNING;
    else {
        if (prev-&gt;state == TASK_UNINTERRUPTIBLE)
            rq-&gt;nr_uninterruptible++;
        deactivate_task(prev, rq);
    }
}</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">deactivate_task( )</tt> function removes the process from the runqueue:</p>
<pre class="calibre27">
rq-&gt;nr_running--;
dequeue_task(p, p-&gt;array);
p-&gt;array = NULL;</pre><br class="calibre7"/>
<p class="docText1">Now, <tt class="calibre25">schedule( )</tt> checks the number of runnable processes left in the runqueue. If there are some runnable processes, the function invokes the <tt class="calibre25">dependent_sleeper( )</tt> function. In most cases, this function immediately returns zero. If, however, the kernel supports the hyper-threading technology (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-5.html#understandlk-CHP-7-SECT-5">Runqueue Balancing in Multiprocessor Systems</a>" later in this chapter), the function checks whether the process that is going to be selected for execution has significantly lower priority than a sibling process already running on a logical CPU of the same physical CPU; in this particular case, <tt class="calibre25">schedule( )</tt> refuses to select the lower privilege process and executes the <span class="docEmphasis">swapper</span> process instead.</p>
<pre class="calibre27">
if (rq-&gt;nr_running) {
    if (dependent_sleeper(smp_processor_id( ), rq)) {
        next = rq-&gt;idle;
        goto switch_tasks;
    }
}</pre><br class="calibre7"/>
<p class="docText1">If no runnable process exists, the function invokes <tt class="calibre25">idle_balance( )</tt> to move some runnable process from another runqueue to the local runqueue; <tt class="calibre25">idle_balance( )</tt> is similar to <tt class="calibre25">load_balance( )</tt>, which is described in the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-5.html#understandlk-CHP-7-SECT-5.3">The load_balance( ) Function</a>."</p>
<pre class="calibre27">
if (!rq-&gt;nr_running) {
    idle_balance(smp_processor_id( ), rq);
    if (!rq-&gt;nr_running) {
        next = rq-&gt;idle;
        rq-&gt;expired_timestamp = 0;
        wake_sleeping_dependent(smp_processor_id( ), rq);
        if (!rq-&gt;nr_running)
            goto switch_tasks;
    }
}</pre><br class="calibre7"/>
<p class="docText1">If <tt class="calibre25">idle_balance( )</tt> fails in moving some process in the local runqueue, <tt class="calibre25">schedule( )</tt> invokes <tt class="calibre25">wake_sleeping_dependent( )</tt> to reschedule runnable processes in <span class="docEmphasis">idle CPUs</span> (that is, in every CPU that runs the <span class="docEmphasis">swapper</span> process). As explained earlier when discussing the <tt class="calibre25">dependent_sleeper( )</tt> function, this unusual case might happen when the kernel supports the hyper-threading technology. However, in uniprocessor systems, or when all attempts to move a runnable process in the local runqueue have failed, the function picks the <span class="docEmphasis">swapper</span> process as <tt class="calibre25">next</tt> and continues with the next phase.</p>
<p class="docText1">Let's suppose that the <tt class="calibre25">schedule( )</tt> function has determined that the runqueue includes some runnable processes; now it has to check that at least one of these runnable processes is active. If not, the function exchanges the contents of the <tt class="calibre25">active</tt> and <tt class="calibre25">expired</tt> fields of the runqueue data structure; thus, all expired processes become active, while the empty set is ready to receive the processes that will expire in the future.</p>
<pre class="calibre27">
array = rq-&gt;active;
if (!array-&gt;nr_active) {
    rq-&gt;active = rq-&gt;expired;
    rq-&gt;expired = array;
    array = rq-&gt;active;
    rq-&gt;expired_timestamp = 0;
    rq-&gt;best_expired_prio = 140;
}</pre><br class="calibre7"/>
<p class="docText1">It is time to look up a runnable process in the active <tt class="calibre25">prio_array_t</tt> data structure (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). First of all, <tt class="calibre25">schedule( )</tt> searches for the first nonzero bit in the bitmask of the active set. Remember that a bit in the bitmask is set when the corresponding priority list is not empty. Thus, the index of the first nonzero bit indicates the list containing the best process to run. Then, the first process descriptor in that list is retrieved:</p>
<pre class="calibre27">
idx = sched_find_first_bit(array-&gt;bitmap);
next = list_entry(array-&gt;queue[idx].next, task_t, run_list);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">sched_find_first_bit( )</tt> function is based on the <tt class="calibre25">bsfl</tt><a name="IDX-CHP-7-1906"></a> 
 assembly language instruction, which returns the bit index of the least significant bit set to one in a 32-bit word.</p>
<p class="docText1">The <tt class="calibre25">next</tt> local variable now stores the descriptor pointer of the process that will replace <tt class="calibre25">prev</tt>. The <tt class="calibre25">schedule( )</tt> function looks at the <tt class="calibre25">next-&gt;activated</tt> field. This field encodes the state of the process when it was awakened, as illustrated in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-TABLE-6">Table 7-6</a>.</p>
<a name="understandlk-CHP-7-TABLE-6"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 7-6. The meaning of the activated field in the process descriptor</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Value</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">The process was in <tt class="calibre25">TASK_RUNNING</tt> state.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">The process was in <tt class="calibre25">TASK_INTERRUPTIBLE</tt> or <tt class="calibre25">TASK_STOPPED</tt> state, and it is being awakened by a system call service routine or a kernel thread.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">2</p></td><td class="docTableCell"><p class="docText2">The process was in <tt class="calibre25">TASK_INTERRUPTIBLE</tt> or <tt class="calibre25">TASK_STOPPED</tt> state, and it is being awakened by an interrupt handler or a deferrable function.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">-1</p></td><td class="docTableCell"><p class="docText2">The process was in <tt class="calibre25">TASK_UNINTERRUPTIBLE</tt> state and it is being awakened.</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">If <tt class="calibre25">next</tt> is a conventional process and it is being awakened from the <tt class="calibre25">TASK_INTERRUPTIBLE</tt> or <tt class="calibre25">TASK_STOPPED</tt> state, the scheduler adds to the average sleep time of the process the nanoseconds elapsed since the process was inserted into the runqueue. In other words, the sleep time of the process is increased to cover also the time spent by the process in the runqueue waiting for the CPU:</p>
<pre class="calibre27">
if (next-&gt;prio &gt;= 100 &amp;&amp; next-&gt;activated &gt; 0) {
    unsigned long long delta = now - next-&gt;timestamp;
    if (next-&gt;activated == 1)
        delta = (delta * 38) / 128;
    array = next-&gt;array;
    dequeue_task(next, array);
    recalc_task_prio(next, next-&gt;timestamp + delta);
    enqueue_task(next, array);
}
next-&gt;activated = 0;</pre><br class="calibre7"/>
<p class="docText1">Observe that the scheduler makes a distinction between a process awakened by an interrupt handler or deferrable function, and a process awakened by a system call service routine or a kernel thread. In the former case, the scheduler adds the whole runqueue waiting time, while in the latter it adds just a fraction of that time. This is because interactive processes are more likely to be awakened by asynchronous events (think of the user pressing keys on the keyboard) rather than by synchronous ones.</p>
<a name="understandlk-CHP-7-SECT-4.4.4"></a>
<h5 class="docSection3Title">7.4.4.4. Actions performed by schedule( ) to make the process switch</h5><a name="IDX-CHP-7-1907"></a>
<a name="IDX-CHP-7-1908"></a>
<a name="IDX-CHP-7-1909"></a>
<a name="IDX-CHP-7-1910"></a>
<p class="docText1">Now the <tt class="calibre25">schedule( )</tt> function has determined the next process to run. In a moment, the kernel will access the <tt class="calibre25">tHRead_info</tt> data structure of <tt class="calibre25">next</tt>, whose address is stored close to the top of <tt class="calibre25">next</tt>'s process descriptor:</p>
<pre class="calibre27">
switch_tasks:

prefetch(next);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">prefetch</tt> macro is a hint to the CPU control unit to bring the contents of the first fields of <tt class="calibre25">next</tt>'s process descriptor in the hardware cache. It is here just to improve the performance of <tt class="calibre25">schedule( )</tt>, because the data are moved in parallel to the execution of the following instructions, which do not affect <tt class="calibre25">next</tt>.</p>
<p class="docText1">Before replacing <tt class="calibre25">prev</tt>, the scheduler should do some administrative work:</p>
<pre class="calibre27">
clear_tsk_need_resched(prev);
rcu_qsctr_inc(prev-&gt;thread_info-&gt;cpu);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">clear_tsk_need_resched( )</tt> function clears the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of <tt class="calibre25">prev</tt>, just in case <tt class="calibre25">schedule( )</tt> has been invoked in the lazy way. Then, the function records that the CPU is going through a quiescent state (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.7">Read-Copy Update (RCU)</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>).</p>
<p class="docText1">The <tt class="calibre25">schedule( )</tt> function must also decrease the average sleep time of <tt class="calibre25">prev</tt>, charging to it the slice of CPU time used by the process:</p>
<pre class="calibre27">
prev-&gt;sleep_avg -= run_time;
if ((long)prev-&gt;sleep_avg &lt;= 0)
    prev-&gt;sleep_avg = 0;
prev-&gt;timestamp = prev-&gt;last_ran = now;</pre><br class="calibre7"/>
<p class="docText1">The timestamps of the process are then updated.</p>
<p class="docText1">It is quite possible that <tt class="calibre25">prev</tt> and <tt class="calibre25">next</tt> are the same process: this happens if no other higher or equal priority active process is present in the runqueue. In this case, the function skips the process switch:</p>
<pre class="calibre27">
if (prev == next) {
    spin_unlock_irq(&amp;rq-&gt;lock);
    goto finish_schedule;
}</pre><br class="calibre7"/>
<p class="docText1">At this point, <tt class="calibre25">prev</tt> and <tt class="calibre25">next</tt> are different processes, and the process switch is for real:</p>
<pre class="calibre27">
next-&gt;timestamp = now;
rq-&gt;nr_switches++;
rq-&gt;curr = next;
prev = context_switch(rq, prev, next);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">context_switch( )</tt> function sets up the address space of <tt class="calibre25">next</tt>. As we'll see in "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-2.html#understandlk-CHP-9-SECT-2.1">Memory Descriptor of Kernel Threads</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>, the <tt class="calibre25">active_mm</tt> field of the process descriptor points to the memory descriptor that is used by the process, while the <tt class="calibre25">mm</tt> field points to the memory descriptor owned by the process. For normal processes, the two fields hold the same address; however, a kernel thread does not have its own address space and its <tt class="calibre25">mm</tt> field is always set to <tt class="calibre25">NULL</tt>. The <tt class="calibre25">context_switch( )</tt> function ensures that if <tt class="calibre25">next</tt> is a kernel thread, it uses the address space used by <tt class="calibre25">prev</tt>:</p>
<pre class="calibre27">
if (!next-&gt;mm) {
    next-&gt;active_mm = prev-&gt;active_mm;
    atomic_inc(&amp;prev-&gt;active_mm-&gt;mm_count);
    enter_lazy_tlb(prev-&gt;active_mm, next);
}</pre><br class="calibre7"/>
<p class="docText1">Up to Linux version 2.2, kernel threads had their own address space. That design choice was suboptimal, because the Page Tables had to be changed whenever the scheduler selected a new process, even if it was a kernel thread. Because kernel threads run in Kernel Mode, they use only the fourth gigabyte of the linear address space, whose mapping is the same for all processes in the system. Even worse, writing into the <tt class="calibre25">cr3</tt><a name="IDX-CHP-7-1911"></a> 
 register invalidates all TLB entries (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-4.html#understandlk-CHP-2-SECT-4.8">Translation Lookaside Buffers (TLB)</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>), which leads to a significant performance penalty. Linux is nowadays much more efficient because Page Tables aren't touched at all if <tt class="calibre25">next</tt> is a kernel thread. As further optimization, if <tt class="calibre25">next</tt> is a kernel thread, the <tt class="calibre25">schedule( )</tt> function sets the process into lazy TLB mode (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-4.html#understandlk-CHP-2-SECT-4.8">Translation Lookaside Buffers (TLB)</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>).</p>
<p class="docText1">Conversely, if <tt class="calibre25">next</tt> is a regular process, the <tt class="calibre25">context_switch( )</tt> function replaces the address space of <tt class="calibre25">prev</tt> with the one of <tt class="calibre25">next</tt>:</p>
<pre class="calibre27">
if (next-&gt;mm)
    switch_mm(prev-&gt;active_mm, next-&gt;mm, next);</pre><br class="calibre7"/>
<p class="docText1">If <tt class="calibre25">prev</tt> is a kernel thread or an exiting process, the <tt class="calibre25">context_switch( )</tt> function saves the pointer to the memory descriptor used by <tt class="calibre25">prev</tt> in the runqueue's <tt class="calibre25">prev_mm</tt> field, then resets <tt class="calibre25">prev-&gt;active_mm</tt>:</p>
<pre class="calibre27">
if (!prev-&gt;mm) {
    rq-&gt;prev_mm = prev-&gt;active_mm;
    prev-&gt;active_mm = NULL;
}</pre><br class="calibre7"/>
<p class="docText1">Now <tt class="calibre25">context_switch( )</tt> can finally invoke <tt class="calibre25">switch_to( )</tt> to perform the process switch between <tt class="calibre25">prev</tt> and <tt class="calibre25">next</tt> (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-3.html#understandlk-CHP-3-SECT-3.3">Performing the Process Switch</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>):</p>
<pre class="calibre27">
switch_to(prev, next, prev);
return prev;
</pre><br class="calibre7"/>
<a name="understandlk-CHP-7-SECT-4.4.5"></a>
<h5 class="docSection3Title">7.4.4.5. Actions performed by schedule( ) after a process switch</h5><a name="IDX-CHP-7-1912"></a>
<p class="docText1">The instructions of the <tt class="calibre25">context_switch( )</tt> and <tt class="calibre25">schedule( )</tt> functions following the <tt class="calibre25">switch_to</tt> macro invocation will not be performed right away by the <tt class="calibre25">next</tt> process, but at a later time by <tt class="calibre25">prev</tt> when the scheduler selects it again for execution. However, at that moment, the <tt class="calibre25">prev</tt> local variable does not point to our original process that was to be replaced when we started the description of <tt class="calibre25">schedule( )</tt>, but rather to the process that was replaced by our original <tt class="calibre25">prev</tt> when it was scheduled again. (If you are confused, go back and read the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-3.html#understandlk-CHP-3-SECT-3.3">Performing the Process Switch</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>.) The first instructions after a process switch are:</p>
<pre class="calibre27">
barrier( );
finish_task_switch(prev);</pre><br class="calibre7"/>
<p class="docText1">Right after the invocation of the <tt class="calibre25">context_switch( )</tt> function in <tt class="calibre25">schedule( )</tt>, the <tt class="calibre25">barrier( )</tt> macro yields an optimization barrier for the code (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.3">Optimization and Memory Barriers</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>). Then, the <tt class="calibre25">finish_task_switch( )</tt> function is executed:</p>
<pre class="calibre27">
mm = this_rq( )-&gt;prev_mm;
this_rq( )-&gt;prev_mm = NULL;
prev_task_flags = prev-&gt;flags;
spin_unlock_irq(&amp;this_rq( )-&gt;lock);
if (mm)
    mmdrop(mm);
if (prev_task_flags &amp; PF_DEAD)
    put_task_struct(prev);</pre><br class="calibre7"/>
<p class="docText1">If <tt class="calibre25">prev</tt> is a kernel thread, the <tt class="calibre25">prev_mm</tt> field of the runqueue stores the address of the memory descriptor that was lent to <tt class="calibre25">prev</tt>. As we'll see in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>, <tt class="calibre25">mmdrop( )</tt> decreases the usage counter of the memory descriptor; if the counter reaches 0 (likely because <tt class="calibre25">prev</tt> is a zombie process), the function also frees the descriptor together with the associated Page Tables and virtual memory regions.</p>
<p class="docText1">The <tt class="calibre25">finish_task_switch( )</tt> function also releases the spin lock of the runqueue and enables the local interrupts. Then, it checks whether <tt class="calibre25">prev</tt> is a zombie task that is being removed from the system (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-5.html#understandlk-CHP-3-SECT-5.1">Process Termination</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>); if so, it invokes <tt class="calibre25">put_task_struct( )</tt> to free the process descriptor reference counter and drop all remaining references to the process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-5.html#understandlk-CHP-3-SECT-5.2">Process Removal</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>).</p>
<p class="docText1">The very last instructions of the <tt class="calibre25">schedule( )</tt> function are:</p>
<pre class="calibre27">
finish_schedule:

prev = current;
if (prev-&gt;lock_depth &gt;= 0)
    _ _reacquire_kernel_lock( );
preempt_enable_no_resched();
if (test_bit(TIF_NEED_RESCHED, &amp;current_thread_info( )-&gt;flags)
   goto need_resched;
return;</pre><br class="calibre7"/>
<p class="docText1">As you see, <tt class="calibre25">schedule( )</tt> reacquires the big kernel lock<a name="IDX-CHP-7-1913"></a> 
 if necessary, reenables kernel preemption, and checks whether some other process has set the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of the current process. In this case, the whole <tt class="calibre25">schedule( )</tt> function is reexecuted from the beginning; otherwise, the function terminates.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

