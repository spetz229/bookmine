---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-4-SECT-7.html
next: understandlk-CHP-4-SECT-9.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-4-SECT-8"></a>
<h3 class="docSection1Title">4.8. Work Queues</h3><a name="IDX-CHP-4-1349"></a>
<a name="IDX-CHP-4-1350"></a>
<p class="docText1">The <span class="docEmphasis">work queues</span><a name="IDX-CHP-4-1351"></a> 
 have been introduced in Linux 2.6 and replace a similar construct called "task queue" used in Linux 2.4. They allow kernel functions to be activated (much like deferrable functions) and later executed by special kernel threads<a name="IDX-CHP-4-1352"></a> 
 called <span class="docEmphasis">worker threads</span><a name="IDX-CHP-4-1353"></a> 
.</p>
<p class="docText1">Despite their similarities, deferrable functions and work queues are quite different. The main difference is that deferrable functions run in interrupt context while functions in work queues run in process context. Running in process context is the only way to execute functions that can block (for instance, functions that need to access some block of data on disk) because, as already observed in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-3.html#understandlk-CHP-4-SECT-3">Nested Execution of Exception and Interrupt Handlers</a>" earlier in this chapter, no process switch can take place in interrupt context. Neither deferrable functions nor functions in a work queue can access the User Mode address space of a process. In fact, a deferrable function cannot make any assumption about the process that is currently running when it is executed. On the other hand, a function in a work queue is executed by a kernel thread, so there is no User Mode address space to access.</p>
<a name="understandlk-CHP-4-SECT-8.1"></a>
<h4 class="docSection2Title">4.8.1. </h4>
<a name="understandlk-CHP-4-SECT-8.1.1"></a>
<h5 class="docSection3Title">4.8.1.1. Work queue data structures</h5>
<p class="docText1">The main data structure associated with a work queue is a descriptor called <tt class="calibre25">workqueue_struct</tt>, which contains, among other things, an array of <tt class="calibre25">NR_CPUS</tt> elements, the maximum number of CPUs in the system.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-FN16">[*]</a></sup> Each element is a descriptor of type <tt class="calibre25">cpu_workqueue_struct</tt>, whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-12">Table 4-12</a>.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-4-FN16">[*]</a></sup> The reason for duplicating the work queue data structures in multiprocessor systems is that per-CPU local data structures yield a much more efficient code (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.1">Per-CPU Variables</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>).</p></blockquote>
<a name="understandlk-CHP-4-TABLE-12"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 4-12. The fields of the cpu_workqueue_struct structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">lock</tt></p></td><td class="docTableCell"><p class="docText2">Spin lock used to protect the structure</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">remove_sequence</tt></p></td><td class="docTableCell"><p class="docText2">Sequence number used by <tt class="calibre25">flush_workqueue( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">insert_sequence</tt></p></td><td class="docTableCell"><p class="docText2">Sequence number used by <tt class="calibre25">flush_workqueue( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">worklist</tt></p></td><td class="docTableCell"><p class="docText2">Head of the list of pending functions</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">more_work</tt></p></td><td class="docTableCell"><p class="docText2">Wait queue where the worker thread waiting for more work to be done sleeps</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">work_done</tt></p></td><td class="docTableCell"><p class="docText2">Wait queue where the processes waiting for the work queue to be flushed sleep</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">wq</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the <tt class="calibre25">workqueue_struct</tt> structure containing this descriptor</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">tHRead</tt></p></td><td class="docTableCell"><p class="docText2">Process descriptor pointer of the worker thread of the structure</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">run_depth</tt></p></td><td class="docTableCell"><p class="docText2">Current execution depth of <tt class="calibre25">run_workqueue( )</tt> (this field may become greater than one when a function in the work queue list blocks)</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">worklist</tt> field of the <tt class="calibre25">cpu_workqueue_struct</tt> structure is the head of a doubly linked list collecting the pending functions of the work queue. Every pending function is represented by a <tt class="calibre25">work_struct</tt> data structure, whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-13">Table 4-13</a>.</p>
<a name="understandlk-CHP-4-TABLE-13"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 4-13. The fields of the work_struct structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">pending</tt></p></td><td class="docTableCell"><p class="docText2">Set to 1 if the function is already in a work queue list, 0 otherwise</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">entry</tt></p></td><td class="docTableCell"><p class="docText2">Pointers to next and previous elements in the list of pending functions</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">func</tt></p></td><td class="docTableCell"><p class="docText2">Address of the pending function</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">data</tt></p></td><td class="docTableCell"><p class="docText2">Pointer passed as a parameter to the pending function</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">wq_data</tt></p></td><td class="docTableCell"><p class="docText2">Usually points to the parent <tt class="calibre25">cpu_workqueue_struct</tt> descriptor</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer</tt></p></td><td class="docTableCell"><p class="docText2">Software timer used to delay the execution of the pending function</p></td></tr></table></p><br class="calibre7"/>
<a name="understandlk-CHP-4-SECT-8.1.2"></a>
<h5 class="docSection3Title">4.8.1.2. Work queue functions</h5><a name="IDX-CHP-4-1354"></a>
<a name="IDX-CHP-4-1355"></a>
<a name="IDX-CHP-4-1356"></a>
<a name="IDX-CHP-4-1357"></a>
<a name="IDX-CHP-4-1358"></a>
<a name="IDX-CHP-4-1359"></a>
<a name="IDX-CHP-4-1360"></a>
<a name="IDX-CHP-4-1361"></a>
<a name="IDX-CHP-4-1362"></a>
<a name="IDX-CHP-4-1363"></a>
<a name="IDX-CHP-4-1364"></a>
<a name="IDX-CHP-4-1365"></a>
<p class="docText1">The <tt class="calibre25">create_workqueue("foo" )</tt> function receives as its parameter a string of characters and returns the address of a <tt class="calibre25">workqueue_struct</tt> descriptor for the newly created work queue. The function also creates <span class="docEmphasis">n</span> worker threads (where <span class="docEmphasis">n</span> is the number of CPUs effectively present in the system), named after the string passed to the function: <span class="docEmphasis">foo/0</span>, <span class="docEmphasis">foo/1</span>, and so on. The <tt class="calibre25">create_singlethread_workqueue( )</tt> function is similar, but it creates just one worker thread, no matter what the number of CPUs in the system is. To destroy a work queue the kernel invokes the <tt class="calibre25">destroy_workqueue( )</tt> function, which receives as its parameter a pointer to a <tt class="calibre25">workqueue_struct</tt> array.</p>
<p class="docText1"><tt class="calibre25">queue_work( )</tt> inserts a function (already packaged inside a <tt class="calibre25">work_struct</tt> descriptor) in a work queue; it receives a pointer <tt class="calibre25">wq</tt> to the <tt class="calibre25">workqueue_struct</tt> descriptor and a pointer <tt class="calibre25">work</tt> to the <tt class="calibre25">work_struct</tt> descriptor. <tt class="calibre25">queue_work( )</tt> essentially performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the function to be inserted is already present in the work queue (<tt class="calibre25">work-&gt;pending</tt> field equal to 1); if so, terminates.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds the <tt class="calibre25">work_struct</tt> descriptor to the work queue list, and sets <tt class="calibre25">work-&gt;pending</tt> to 1.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If a worker thread is sleeping in the <tt class="calibre25">more_work</tt> wait queue of the local CPU's <tt class="calibre25">cpu_workqueue_struct</tt> descriptor, the function wakes it up.</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">queue_delayed_work( )</tt> function is nearly identical to <tt class="calibre25">queue_work( )</tt>, except that it receives a third parameter representing a time delay in system ticks (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6.html#understandlk-CHP-6">Chapter 6</a>). It is used to ensure a minimum delay before the execution of the pending function. In practice, <tt class="calibre25">queue_delayed_work( )</tt> relies on the software timer in the <tt class="calibre25">timer</tt> field of the <tt class="calibre25">work_struct</tt> descriptor to defer the actual insertion of the <tt class="calibre25">work_struct</tt> descriptor in the work queue list. <tt class="calibre25">cancel_delayed_work( )</tt> cancels a previously scheduled work queue function, provided that the corresponding <tt class="calibre25">work_struct</tt> descriptor has not already been inserted in the work queue list.</p>
<p class="docText1">Every worker thread continuously executes a loop inside the <tt class="calibre25">worker_thread( )</tt> function; most of the time the thread is sleeping and waiting for some work to be queued. Once awakened, the worker thread invokes the <tt class="calibre25">run_workqueue( )</tt> function, which essentially removes every <tt class="calibre25">work_struct</tt> descriptor from the work queue list of the worker thread and executes the corresponding pending function. Because work queue functions can block, the worker thread can be put to sleep and even migrated to another CPU when resumed.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-FN17">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-4-FN17">[*]</a></sup> Strangely enough, a worker thread can be executed by every CPU, not just the CPU corresponding to the <tt class="calibre42">cpu_workqueue_struct</tt> descriptor to which the worker thread belongs. Therefore, <tt class="calibre42">queue_work( )</tt> inserts a function in the queue of the local CPU, but that function may be executed by any CPU in the systems.</p></blockquote>
<p class="docText1">Sometimes the kernel has to wait until all pending functions in a work queue have been executed. The <tt class="calibre25">flush_workqueue( )</tt> function receives a <tt class="calibre25">workqueue_struct</tt> descriptor address and blocks the calling process until all functions that are pending in the work queue terminate. The function, however, does not wait for any pending function that was added to the work queue following <tt class="calibre25">flush_workqueue( )</tt> invocation; the <tt class="calibre25">remove_sequence</tt> and <tt class="calibre25">insert_sequence</tt> fields of every <tt class="calibre25">cpu_workqueue_struct</tt> descriptor are used to recognize the newly added pending functions.</p>
<a name="understandlk-CHP-4-SECT-8.1.3"></a>
<h5 class="docSection3Title">4.8.1.3. The predefined work queue</h5><a name="IDX-CHP-4-1366"></a>
<a name="IDX-CHP-4-1367"></a>
<a name="IDX-CHP-4-1368"></a>
<a name="IDX-CHP-4-1369"></a>
<a name="IDX-CHP-4-1370"></a>
<a name="IDX-CHP-4-1371"></a>
<a name="IDX-CHP-4-1372"></a>
<p class="docText1">In most cases, creating a whole set of worker threads in order to run a function is overkill. Therefore, the kernel offers a predefined work queue called <span class="docEmphasis">events</span>, which can be freely used by every kernel developer. The predefined work queue is nothing more than a standard work queue that may include functions of different kernel layers and I/O drivers; its <tt class="calibre25">workqueue_struct</tt> descriptor is stored in the <tt class="calibre25">keventd_wq</tt> array. To make use of the predefined work queue, the kernel offers the functions listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-14">Table 4-14</a>.</p>
<a name="understandlk-CHP-4-TABLE-14"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 4-14. Helper functions for the predefined work queue</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Predefined work queue function</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Equivalent standard work queue function</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">schedule_work(w)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">queue_work(keventd_wq,w)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">schedule_delayed_work(w,d)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">queue_delayed_work(keventd_wq,w,d)</tt> (on any CPU)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">schedule_delayed_work_on(cpu,w,d)</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">queue_delayed_work(keventd_wq,w,d)</tt> (on a given CPU)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">flush_scheduled_work( )</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">flush_workqueue(keventd_wq)</tt></p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The predefined work queue saves significant system resources when the function is seldom invoked. On the other hand, functions executed in the predefined work queue should not block for a long time: because the execution of the pending functions in the work queue list is serialized on each CPU, a long delay negatively affects the other users of the predefined work queue.</p>
<p class="docText1">In addition to the general <span class="docEmphasis">events</span> queue, you'll find a few specialized work queues in Linux 2.6. The most significant is the <span class="docEmphasis">kblockd</span> work queue used by the block device layer (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14.html#understandlk-CHP-14">Chapter 14</a>).</p>

<br class="calibre7"/>

</div>

{% endraw %}

