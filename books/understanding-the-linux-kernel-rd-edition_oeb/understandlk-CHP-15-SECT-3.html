---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-15-SECT-2.html
next: understandlk-CHP-15-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-15-SECT-3"></a>
<h3 class="docSection1Title" id="534871-961">15.3. Writing Dirty Pages to Disk</h3><a name="IDX-CHP-15-3841"></a>
<a name="IDX-CHP-15-3842"></a>
<a name="IDX-CHP-15-3843"></a>
<p class="docText1">As we have seen, the kernel keeps filling the page cache with pages containing data of block devices. Whenever a process modifies some data, the corresponding page is marked as dirtythat is, its <tt class="calibre25">PG_dirty</tt> flag is set.</p>
<p class="docText1">Unix systems allow the deferred writes of dirty pages into block devices, because this noticeably improves system performance. Several write operations on a page in cache could be satisfied by just one slow physical update of the corresponding disk sectors. Moreover, write operations are less critical than read operations, because a process is usually not suspended due to delayed writings, while it is most often suspended because of delayed reads. Thanks to deferred writes, each physical block device will service, on the average, many more read requests than write ones.</p>
<p class="docText1">A dirty page might stay in main memory until the last possible moment  that is, until system shutdown. However, pushing the delayed-write strategy to its limits has two major drawbacks:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">If a hardware or power supply failure occurs, the contents of RAM can no longer be retrieved, so many file updates that were made since the system was booted are lost.</p></li><li class="calibre12"><p class="docText1">The size of the page cache, and hence of the RAM required to contain it, would have to be hugeat least as big as the size of the accessed block devices.</p></li></ul>
<p class="docText1">Therefore, dirty pages are <span class="docEmphasis">flushed</span> (written) to disk under the following conditions:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The page cache gets too full and more pages are needed, or the number of dirty pages becomes too large.</p></li><li class="calibre12"><p class="docText1">Too much time has elapsed since a page has stayed dirty.</p></li><li class="calibre12"><p class="docText1">A process requests all pending changes of a block device or of a particular file to be flushed; it does this by invoking a <tt class="calibre25">sync( )</tt>, <tt class="calibre25">fsync( )</tt>, or <tt class="calibre25">fdatasync( )</tt> system call (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-4.html#understandlk-CHP-15-SECT-4">The sync( ), fsync( ), and fdatasync( ) 
 System Calls</a>" later in this chapter).</p></li></ul>
<p class="docText1">Buffer pages introduce a further complication. The buffer heads associated with each buffer page allow the kernel to keep track of the status of each individual block buffer. The <tt class="calibre25">PG_dirty</tt> flag of the buffer page should be set if at least one of the associated buffer heads has the <tt class="calibre25">BH_Dirty</tt> flag set. When the kernel selects a dirty buffer page for flushing, it scans the associated buffer heads and effectively writes to disk only the contents of the dirty blocks. As soon as the kernel flushes all dirty blocks in a buffer page to disk, it clears the <tt class="calibre25">PG_dirty</tt> flag of the page.</p>
<a name="understandlk-CHP-15-SECT-3.1"></a>
<h4 class="docSection2Title">15.3.1. The pdflush Kernel Threads</h4><a name="IDX-CHP-15-3845"></a>
<a name="IDX-CHP-15-3846"></a>
<a name="IDX-CHP-15-3847"></a>
<a name="IDX-CHP-15-3848"></a>
<a name="IDX-CHP-15-3849"></a>
<a name="IDX-CHP-15-3850"></a>
<a name="IDX-CHP-15-3851"></a>
<a name="IDX-CHP-15-3852"></a>
<a name="IDX-CHP-15-3853"></a>
<a name="IDX-CHP-15-3854"></a>
<a name="IDX-CHP-15-3855"></a>
<p class="docText1">Earlier versions of Linux used a kernel thread called <span class="docEmphasis">bdflush</span><a name="IDX-CHP-15-3856"></a> 
 to systematically scan the page cache looking for dirty pages to flush, and they used a second kernel thread called <span class="docEmphasis">kupdate</span><a name="IDX-CHP-15-3857"></a> 
 to ensure that no page remains dirty for too long. Linux 2.6 has replaced both of them with a group of general purpose kernel threads called <span class="docEmphasis">pdflush</span>.</p>
<p class="docText1">These kernel threads have a flexible structure. They act on two parameters: a pointer to a function to be executed by the thread and a parameter for the function. The number of <i class="docEmphasis">pdflush</i> kernel threads in the system is dynamically adjusted: new threads are created when they are too few and existing threads are killed when they are too many. Because the functions executed by these kernel threads can block, creating several <span class="docEmphasis">pdflush</span> kernel threads instead of a single one, leads to better system performance.</p>
<p class="docText1">Births and deaths are governed by the following rules:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">There must be at least two <span class="docEmphasis">pdflush</span> kernel threads and at most eight.</p></li><li class="calibre12"><p class="docText1">If there were no idle <span class="docEmphasis">pdflush</span> during the last second, a new <span class="docEmphasis">pdflush</span> should be created.</p></li><li class="calibre12"><p class="docText1">If more than one second elapsed since the last <span class="docEmphasis">pdflush</span> became idle, a <span class="docEmphasis">pdflush</span> should be removed.</p></li></ul>
<p class="docText1">Each <span class="docEmphasis">pdflush</span> kernel thread has a <tt class="calibre25">pdflush_work</tt> descriptor (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-15-TABLE-6">Table 15-6</a>). The descriptors of idle <span class="docEmphasis">pdflush</span> kernel threads are collected in the <tt class="calibre25">pdflush_list</tt> list; the <tt class="calibre25">pdflush_lock</tt> spin lock protects that list from concurrent accesses in multiprocessor systems. The <tt class="calibre25">nr_pdflush_threads</tt> variable<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-15-FN5">[*]</a></sup> stores the total number of <span class="docEmphasis">pdflush</span> kernel threads (idle and busy). Finally, the <tt class="calibre25">last_empty_jifs</tt> variable stores the last time (in jiffies) since the <tt class="calibre25">pdflush_list</tt> list of <span class="docEmphasis">pdflush</span> threads became empty.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-15-FN5">[*]</a></sup> The value of this variable can be read from the <span class="docEmphasis">/proc/sys/vm/nr_pdflush_threads</span> file.</p></blockquote>
<a name="understandlk-CHP-15-TABLE-6"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 15-6. The fields of the pdflush_work descriptor</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct task_struct *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">who</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to kernel thread descriptor</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void(*)(unsigned long)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fn</tt></p></td><td class="docTableCell"><p class="docText2">Callback function to be executed by the kernel thread</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">arg0</tt></p></td><td class="docTableCell"><p class="docText2">Argument to callback function</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">list</tt></p></td><td class="docTableCell"><p class="docText2">Links for the <tt class="calibre25">pdflush_list</tt> list</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">when_i_went_to_sleep</tt></p></td><td class="docTableCell"><p class="docText2">Time in jiffies when kernel thread became available</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Each <span class="docEmphasis">pdflush</span> kernel thread executes the <tt class="calibre25">_ _pdflush( )</tt> function, which essentially loops in an endless cycle until the kernel thread dies. Let's suppose that the <span class="docEmphasis">pdflush</span> kernel thread is idle; then, the process is sleeping in <tt class="calibre25">TASK_INTERRUPTIBLE</tt> state. As soon as the kernel thread is woken up, <tt class="calibre25">_ _pdflush( )</tt> accesses its <tt class="calibre25">pdflush_work</tt> descriptor and executes the callback function stored in the <tt class="calibre25">fn</tt> field, passing to it the argument stored in the <tt class="calibre25">arg0</tt> field. When the callback function terminates, <tt class="calibre25">_ _pdflush( )</tt> checks the value of the <tt class="calibre25">last_empty_jifs</tt> variable: if there was no idle <span class="docEmphasis">pdflush</span> kernel thread for more than one second and if there are less than eight <span class="docEmphasis">pdflush</span> kernel threads, <tt class="calibre25">_ _pdflush( )</tt> starts another kernel thread. Otherwise, if the last entry in the <tt class="calibre25">pdflush_list</tt> list is idle for more than one second, and there are more than two <span class="docEmphasis">pdflush</span> kernel threads, <tt class="calibre25">_ _pdflush( )</tt> terminates: as explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.2">Kernel Threads</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>, the corresponding kernel thread executes the <tt class="calibre25">_exit( )</tt><a name="IDX-CHP-15-3858"></a> 
 system call and it is thus destroyed. Otherwise, <tt class="calibre25">_ _pdflush( )</tt> reinserts the <tt class="calibre25">pdflush_work</tt> descriptor of the kernel thread in the <tt class="calibre25">pdflush_list</tt> list and puts the kernel thread to sleep.</p>
<p class="docText1">The <tt class="calibre25">pdflush_operation( )</tt> function is used to activate an idle <span class="docEmphasis">pdflush</span> kernel thread. This function acts on two parameters: a pointer <tt class="calibre25">fn</tt> to the function that must be executed and an argument <tt class="calibre25">arg0</tt>; it performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Extracts from the <tt class="calibre25">pdflush_list</tt> list a pointer <tt class="calibre25">pdf</tt> to the <tt class="calibre25">pdflush_work</tt> descriptor of an idle <span class="docEmphasis">pdflush</span> kernel thread. If the list is empty, it returns <tt class="calibre25">-</tt>1. If the list contained just one element, it sets the value of the <tt class="calibre25">last_empty_jifs</tt> variable to <tt class="calibre25">jiffies</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Stores in <tt class="calibre25">pdf-&gt;fn</tt> and in <tt class="calibre25">pdf-&gt;arg0</tt> the parameters <tt class="calibre25">fn</tt> and <tt class="calibre25">arg0</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">wake_up_process( )</tt> to wake up the idle <span class="docEmphasis">pdflush</span><a name="IDX-CHP-15-3859"></a> 
 kernel thread, that is, <tt class="calibre25">pdf-&gt;who</tt>.</p></div></li></ol></div>
<p class="docText1">What kinds of jobs are delegated to the <span class="docEmphasis">pdflush</span> kernel threads? There are a few of them, all related to flushing of dirty data. In particular, <span class="docEmphasis">pdflush</span> usually executes one of the following callback functions:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1"><tt class="calibre25">background_writeout( )</tt>: systematically walks the page cache looking for dirty pages to be flushed (see the next section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-15-SECT-3.2">Looking for Dirty Pages To Be Flushed</a>").</p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">wb_kupdate( )</tt>: checks that no page in the page cache remains dirty for too long (see the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-15-SECT-3.3">Retrieving Old Dirty Pages</a>" later in this chapter).</p></li></ul>
<a name="understandlk-CHP-15-SECT-3.2"></a>
<h4 class="docSection2Title">15.3.2. Looking for Dirty Pages To Be Flushed</h4><a name="IDX-CHP-15-3860"></a>
<a name="IDX-CHP-15-3861"></a>
<a name="IDX-CHP-15-3862"></a>
<a name="IDX-CHP-15-3863"></a>
<a name="IDX-CHP-15-3864"></a>
<a name="IDX-CHP-15-3865"></a>
<a name="IDX-CHP-15-3866"></a>
<a name="IDX-CHP-15-3867"></a>
<a name="IDX-CHP-15-3868"></a>
<a name="IDX-CHP-15-3869"></a>
<a name="IDX-CHP-15-3870"></a>
<p class="docText1">Every radix tree could include dirty pages to be flushed. Retrieving all of them thus involves an exhaustive search among all <tt class="calibre25">address_space</tt> objects associated with inodes having an image on disk. Because the page cache might include a large number of pages, scanning the whole cache in a single run might keep the CPU and the disks busy for a long time. Therefore, Linux adopts a sophisticated mechanism that splits the page cache scanning in several runs of execution.</p>
<p class="docText1">The <tt class="calibre25">wakeup_bdflush( )</tt> function receives as argument the number of dirty pages in the page cache that should be flushed; the value zero means that all dirty pages in the cache should be written back to disk. The function invokes <tt class="calibre25">pdflush_operation( )</tt> to wake up a <span class="docEmphasis">pdflush</span> kernel thread (see the previous section) and delegate to it the execution of the <tt class="calibre25">background_writeout( )</tt> callback function. The latter function effectively retrieves the specified number of dirty pages from the page cache and writes them back to disk.</p>
<p class="docText1">The <tt class="calibre25">wakeup_bdflush( )</tt> function is executed when either memory is scarce or a user makes an explicit request for a flush operation. In particular, the function is invoked when:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The User Mode process issues a <tt class="calibre25">sync( )</tt><a name="IDX-CHP-15-3871"></a> 
 system call (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-4.html#understandlk-CHP-15-SECT-4">The sync( ), fsync( ), and fdatasync( ) System Calls</a>" later in this chapter).</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">grow_buffers( )</tt> function fails to allocate a new buffer page (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-2.html#understandlk-CHP-15-SECT-2.4">Allocating Block Device Buffer Pages</a>").</p></li><li class="calibre12"><p class="docText1">The page frame reclaiming algorithm invokes <tt class="calibre25">free_more_memory( )</tt> or <tt class="calibre25">TRy_to_free_pages( )</tt> (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17.html#understandlk-CHP-17">Chapter 17</a>).</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">mempool_alloc( )</tt> function fails to allocate a new memory pool element (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-2.html#understandlk-CHP-8-SECT-2.15">Memory Pools</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>).</p></li></ul>
<p class="docText1">Moreover, a <span class="docEmphasis">pdflush</span> kernel thread executing the <tt class="calibre25">background_writeout( )</tt> callback function is woken up by every process that modifies the contents of pages in the page cache and causes the fraction of dirty pages to rise above some <span class="docEmphasis">dirty background threshold</span>. The background threshold is typically set to 10% of all pages in the system, but its value can be adjusted by writing in the <i class="docEmphasis">/proc/sys/vm/dirty_background_ratio</i> file.</p>
<p class="docText1">The <tt class="calibre25">background_writeout( )</tt> function relies on a <tt class="calibre25">writeback_control</tt> structure, which acts as a two-way communication device: on one hand, it tells an auxiliary function called <tt class="calibre25">writeback_inodes( )</tt> what to do; on the other hand, it stores some statistics about the number of pages written to disk. The most important fields of this structure are the following:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sync_mode</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Specifies the synchronization mode: <tt class="calibre25">WB_SYNC_ALL</tt> means that if a locked inode is encountered, it must be waited upon and not just skipped over; <tt class="calibre25">WB_SYNC_HOLD</tt> means that locked inodes are put in a list for later consideration; and <tt class="calibre25">WB_SYNC_NONE</tt> means that locked inodes are simply skipped.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bdi</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">If not <tt class="calibre25">NULL</tt>, it points to a <tt class="calibre25">backing_dev_info</tt> structure; in this case, only dirty pages belonging to the underlying block device will be flushed.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">older_than_this</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">If not null, it means that inodes younger than the specified value should be skipped.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">nr_to_write</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Number of dirty pages yet to be written in this run of execution.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">nonblocking</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">If this flag is set, the process cannot be blocked.</p></dd></dl>
<p class="docText1">The <tt class="calibre25">background_writeout( )</tt> function acts on a single parameter: <tt class="calibre25">nr_pages</tt>, the minimum number of pages that should be flushed to disk. It essentially executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Reads from the <tt class="calibre25">page_state</tt> per-CPU variable the number of pages and dirty pages currently stored in the page cache. If the fraction of dirty pages is below a given threshold and at least <tt class="calibre25">nr_pages</tt> have been flushed to disk, the function terminates. The value of this threshold is typically set to about 40% of the number of pages in the system; it could be adjusted by writing into the <i class="docEmphasis">/proc/sys/vm/dirty_ratio</i> file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">writeback_inodes( )</tt> to try to write 1, 024 dirty pages (see below).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the number of pages effectively written and decreases the number of pages yet to be written.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If less than 1,024 pages have been written or if pages have been skipped, probably the request queue of the block device is congested: the function puts the current process to sleep in a special wait queue for 100 milliseconds or until the queue becomes uncongested.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Goes back to step 1.</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">writeback_inodes( )</tt> function acts on a single parameter, namely a pointer <tt class="calibre25">wbc</tt> to a <tt class="calibre25">writeback_control</tt> descriptor. The <tt class="calibre25">nr_to_write</tt> field of this descriptor contains the number of pages to be flushed to disk. When the function returns, the same field contains the number of pages remaining to be flushed; if everything went smoothly, this field will be set to 0.</p>
<p class="docText1">Let us suppose that <tt class="calibre25">writeback_inodes( )</tt> is called with the <tt class="calibre25">wbc-&gt;bdi</tt> and <tt class="calibre25">wbc-&gt;older_than_this</tt> pointers set to <tt class="calibre25">NULL</tt>, the <tt class="calibre25">WB_SYNC_NONE</tt> synchronization mode, and the <tt class="calibre25">wbc-&gt;nonblocking</tt> flag setthese are the values set by <tt class="calibre25">background_writeout( )</tt>. The function scans the list of superblocks rooted at the <tt class="calibre25">super_blocks</tt> variable (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.1">Superblock Objects</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>). The scanning ends when either the whole list has been traversed, or the target number of pages to be flushed has been reached. For each superblock <tt class="calibre25">sb</tt>, the function executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the <tt class="calibre25">sb-&gt;s_dirty</tt> or <tt class="calibre25">sb-&gt;s_io</tt> lists are empty: the first list collects the dirty inodes of the superblock, while the second list collects the inodes waiting to be transferred to disk (see below). If both lists are empty, the inodes on this filesystem have no dirty pages, so the function considers the next superblock in the list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Here the superblock has dirty inodes. Invokes <tt class="calibre25">sync_sb_inodes( )</tt> on the <tt class="calibre25">sb</tt> superblock. This function:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Puts all the inodes of <tt class="calibre25">sb-&gt;s_dirty</tt> into the list pointed to by <tt class="calibre25">sb-&gt;s_io</tt> and clears the list of dirty inodes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets the next <tt class="calibre25">inode</tt> pointer from <tt class="calibre25">sb-&gt;s_io</tt>. If this list is empty, it returns.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the inode was dirtied after <tt class="calibre25">sync_sb_inodes( )</tt> started, it skips the inode's dirty pages and returns. Notice that some dirty inodes might remain in the <tt class="calibre25">sb-&gt;s_io</tt> list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the current process is a <span class="docEmphasis">pdflush</span><a name="IDX-CHP-15-3872"></a> 
 kernel thread, it checks whether another <span class="docEmphasis">pdflush</span> kernel thread running on another CPU is already trying to flush dirty pages for files belonging to this block device. This can be done by an atomic test and set operation on the <tt class="calibre25">BDI_pdflush</tt> flag of the inode's <tt class="calibre25">backing_dev_info</tt>. Essentially, it is pointless to have more than one <span class="docEmphasis">pdflush</span> kernel thread on the same request queue (see the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-15-SECT-3.1">The pdflush Kernel Threads</a>" earlier in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases by one the inode's usage counter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">_ _writeback_single_inode( )</tt> to write back the dirty buffers associated with the selected inode:</p><div class="calibre44"><ol class="docList4" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If the inode is locked, it moves <tt class="calibre25">inode</tt> into the list of dirty inodes (<tt class="calibre25">inode-&gt;i_sb-&gt;s_dirty</tt>) and returns 0. (Since we are assuming that the <tt class="calibre25">wbc-&gt;sync_mode</tt> field is not <tt class="calibre25">WB_SYNC_ALL</tt>, the function does not block waiting for the inode to unlock.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Uses the <tt class="calibre25">writepages</tt> method of the inode's address space, or the <tt class="calibre25">mpage_writepages( )</tt> function if no such method exists, to write up to <tt class="calibre25">wbc-&gt;nr_to_write</tt> dirty pages. This function uses the <tt class="calibre25">find_get_pages_tag( )</tt> function to retrieve quickly all dirty pages in the inode's address space (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-1.html#understandlk-CHP-15-SECT-1.4">The Tags of the Radix Tree</a>" earlier in this chapter). Details will be given in the next chapter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the inode is dirty, it uses the superblock's <tt class="calibre25">write_inode</tt> method to write the inode to disk. The functions that implement this method usually rely on <tt class="calibre25">submit_bh( )</tt> to transfer a single block of data (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-2.html#understandlk-CHP-15-SECT-2.7">Submitting Buffer Heads to the Generic Block Layer</a>" earlier in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the status of the inode; accordingly, moves the inode back into the <tt class="calibre25">sb-&gt;s_dirty</tt> list if some page of the inode is still dirty, or in the <tt class="calibre25">inode_unused</tt> list if the inode's reference counter is zero, or in the <tt class="calibre25">inode_in_use</tt> list otherwise (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.2">Inode Objects</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the error code of the function invoked in step 2f2.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Back into the <tt class="calibre25">sync_sb_inodes( )</tt> function. If the current process is the <span class="docEmphasis">pdflush</span><a name="IDX-CHP-15-3873"></a> 
 kernel thread, it clears the <tt class="calibre25">BDI_pdflush</tt> flag set in step 2d.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If some pages were skipped in the inode just processed, then the inode includes locked buffers: moves all inodes remaining in the <tt class="calibre25">sb-&gt;s_io</tt> list back into the <tt class="calibre25">sb-&gt;s_dirty</tt> list: they will be reconsidered at a later time.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Decreases by one the usage counter of the inode.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">wbc-&gt;nr_to_write</tt> is greater than 0, goes back to step 2b to look for other dirty inodes of the same superblock. Otherwise, the <tt class="calibre25">sync_sb_inodes( )</tt> function terminates.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Back into the <tt class="calibre25">writeback_inodes( )</tt> function. If <tt class="calibre25">wbc-&gt;nr_to_write</tt> is greater than zero, it jumps to step 1 and continues with the next superblock in the global list. Otherwise, it returns.</p></div></li></ol></div>
<a name="understandlk-CHP-15-SECT-3.3"></a>
<h4 class="docSection2Title">15.3.3. Retrieving Old Dirty Pages</h4><a name="IDX-CHP-15-3874"></a>
<a name="IDX-CHP-15-3875"></a>
<a name="IDX-CHP-15-3876"></a>
<p class="docText1">As stated earlier, the kernel tries to avoid the risk of starvation that occurs when some pages are not flushed for a long period of time. Hence, if a page remains dirty for a predefined amount of time, the kernel explicitly starts an I/O data transfer that writes its contents to disk.</p>
<p class="docText1">The job of retrieving old dirty pages is delegated to a <span class="docEmphasis">pdflush</span> kernel thread that is periodically woken up. During the kernel initialization, the <tt class="calibre25">page_writeback_init( )</tt> function sets up the <tt class="calibre25">wb_timer</tt> dynamic timer so that it decays after <tt class="calibre25">dirty_writeback_centisecs</tt> hundreds of a second (usually 500, but this value can be adjusted by writing in the <i class="docEmphasis">/proc/sys/vm/dirty_writeback_centisecs</i> file). The timer function, which is called <tt class="calibre25">wb_timer_fn( )</tt>, essentially invokes the <tt class="calibre25">pdflush_operation( )</tt> function passing to it the address of the <tt class="calibre25">wb_kupdate( )</tt> callback function.</p>
<p class="docText1">The <tt class="calibre25">wb_kupdate( )</tt> function walks the page cache looking for "old" dirty inodes; it executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">sync_supers( )</tt> function to write the dirty superblocks to disk (see the next section). Although not strictly related to the flushing of the pages in the page cache, this invocation ensures that no superblock remains dirty for more than, usually, five seconds.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Stores in the <tt class="calibre25">older_than_this</tt> field of a <tt class="calibre25">writeback_control</tt> descriptor a pointer to a value in jiffies corresponding to the current time minus 30 seconds. Thirty seconds is the longest time for which a page is allowed to remain dirty.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Determines from the per-CPU <tt class="calibre25">page_state</tt> variable the rough number of dirty pages currently in the page cache.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes repeatedly <tt class="calibre25">writeback_inodes( )</tt> until either the number of pages written to disk reaches the value determined in the previous step, or all pages older than 30 seconds have been written. During this cycle the function might sleep if some request queue becomes congested.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Uses <tt class="calibre25">mod_timer( )</tt> to restart the <tt class="calibre25">wb_timer</tt> dynamic timer: it will decay once again <tt class="calibre25">dirty_writeback_centisecs</tt> hundreds of seconds since the invocation of this function (or one second since now if this execution lasted too long).</p></div></li></ol></div>

<br class="calibre7"/>

</div>

{% endraw %}

