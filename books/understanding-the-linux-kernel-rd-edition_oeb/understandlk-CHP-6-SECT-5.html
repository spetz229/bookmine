---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-6-SECT-4.html
next: understandlk-CHP-6-SECT-6.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-6-SECT-5"></a>
<h3 class="docSection1Title">6.5. Software Timers and Delay Functions</h3><a name="IDX-CHP-6-1731"></a>
<a name="IDX-CHP-6-1732"></a>
<a name="IDX-CHP-6-1733"></a>
<p class="docText1">A <span class="docEmphasis">timer</span> is a software facility that allows functions to be invoked at some future moment, after a given time interval has elapsed; a <span class="docEmphasis">time-out</span> denotes a moment at which the time interval associated with a timer has elapsed.</p>
<p class="docText1">Timers are widely used both by the kernel and by processes. Most device drivers use timers<a name="IDX-CHP-6-1734"></a> 
 to detect anomalous conditions  floppy disk drivers, for instance, use timers to switch off the device motor after the floppy has not been accessed for a while, and parallel printer drivers use them to detect erroneous printer conditions.</p>
<p class="docText1">Timers are also used quite often by programmers to force the execution of specific functions at some future time (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6.3">The setitimer( ) and alarm( ) System Calls</a>").</p>
<p class="docText1">Implementing a timer is relatively easy. Each timer contains a field that indicates how far in the future the timer should expire. This field is initially calculated by adding the right number of ticks to the current value of <tt class="calibre25">jiffies</tt>. The field does not change. Every time the kernel checks a timer, it compares the expiration field to the value of <tt class="calibre25">jiffies</tt> at the current moment, and the timer expires when <tt class="calibre25">jiffies</tt> is greater than or equal to the stored value.</p>
<p class="docText1">Linux considers two types of timers called <span class="docEmphasis">dynamic timers</span><a name="IDX-CHP-6-1735"></a> 
 and <span class="docEmphasis">interval timers</span><a name="IDX-CHP-6-1736"></a> 
. The first type is used by the kernel, while interval timers may be created by processes in User Mode.</p>
<p class="docText1">One word of caution about Linux timers: since checking for timer functions is always done by deferrable functions that may be executed a long time after they have been activated, the kernel cannot ensure that timer functions will start right at their expiration times. It can only ensure that they are executed either at the proper time or after with a delay of up to a few hundreds of milliseconds. For this reason, timers are not appropriate for real-time applications in which expiration times must be strictly enforced.</p>
<p class="docText1">Besides software timers<a name="IDX-CHP-6-1737"></a> 
, the kernel also makes use of <span class="docEmphasis">delay functions</span><a name="IDX-CHP-6-1738"></a> 
, which execute a tight instruction loop until a given time interval elapses. We will discuss them in the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-SECT-5.3">Delay Functions</a>."</p>
<a name="understandlk-CHP-6-SECT-5.1"></a>
<h4 class="docSection2Title">6.5.1. Dynamic Timers</h4><a name="IDX-CHP-6-1739"></a>
<a name="IDX-CHP-6-1740"></a>
<a name="IDX-CHP-6-1741"></a>
<p class="docText1"><span class="docEmphasis">Dynamic timers</span> may be dynamically created and destroyed. No limit is placed on the number of currently active dynamic timers.</p>
<p class="docText1">A dynamic timer is stored in the following <tt class="calibre25">timer_list</tt> structure:</p>
<pre class="calibre27">
    struct timer_list {
        struct list_head entry;
        unsigned long expires;
        spinlock_t lock;
        unsigned long magic;
        void (*function)(unsigned long);
        unsigned long data;
        tvec_base_t *base;
    };
</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">function</tt> field contains the address of the function to be executed when the timer expires. The <tt class="calibre25">data</tt> field specifies a parameter to be passed to this timer function. Thanks to the <tt class="calibre25">data</tt> field, it is possible to define a single general-purpose function that handles the time-outs of several device drivers; the <tt class="calibre25">data</tt> field could store the device ID or other meaningful data that could be used by the function to differentiate the device.</p>
<p class="docText1">The <tt class="calibre25">expires</tt> field specifies when the timer expires; the time is expressed as the number of ticks that have elapsed since the system started up. All timers that have an <tt class="calibre25">expires</tt> value smaller than or equal to the value of <tt class="calibre25">jiffies</tt> are considered to be expired or decayed.</p>
<p class="docText1">The <tt class="calibre25">entry</tt> field is used to insert the software timer into one of the doubly linked circular lists that group together the timers according to the value of their <tt class="calibre25">expires</tt> field. The algorithm that uses these lists is described later in this chapter.</p>
<p class="docText1">To create and activate a dynamic timer, the kernel must:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Create, if necessary, a new <tt class="calibre25">timer_list</tt> object  for example, <tt class="calibre25">t</tt>. This can be done in several ways by:</p><ul class="calibre61"><li class="calibre12"><p class="docList">Defining a static global variable in the code.</p></li><li class="calibre12"><p class="docList">Defining a local variable inside a function; in this case, the object is stored on the Kernel Mode stack.</p></li><li class="calibre12"><p class="docList">Including the object in a dynamically allocated descriptor.</p></li></ul></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initialize the object by invoking the <tt class="calibre25">init_timer(&amp;t)</tt> function. This essentially sets the <tt class="calibre25">t.base</tt> pointer field to <tt class="calibre25">NULL</tt> and sets the <tt class="calibre25">t.lock</tt> spin lock to "open."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Load the <tt class="calibre25">function</tt> field with the address of the function to be activated when the timer decays. If required, load the <tt class="calibre25">data</tt> field with a parameter value to be passed to the function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the dynamic timer is not already inserted in a list, assign a proper value to the <tt class="calibre25">expires</tt> field and invoke the <tt class="calibre25">add_timer(&amp;t)</tt> function to insert the <tt class="calibre25">t</tt> element in the proper list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the dynamic timer is already inserted in a list, update the <tt class="calibre25">expires</tt> field by invoking the <tt class="calibre25">mod_timer( )</tt> function, which also takes care of moving the object into the proper list (discussed next).</p></div></li></ol></div>
<p class="docText1">Once the timer has decayed, the kernel automatically removes the <tt class="calibre25">t</tt> element from its list. Sometimes, however, a process should explicitly remove a timer from its list using the <tt class="calibre25">del_timer( )</tt>, <tt class="calibre25">del_timer_sync( )</tt>, or <tt class="calibre25">del_singleshot_timer_sync( )</tt> functions. Indeed, a sleeping process may be woken up before the time-out is over; in this case, the process may choose to destroy the timer. Invoking <tt class="calibre25">del_timer( )</tt> on a timer already removed from a list does no harm, so removing the timer within the timer function is considered a good practice.</p>
<p class="docText1">In Linux 2.6, a dynamic timer is bound to the CPU that activated itthat is, the timer function will always run on the same CPU that first executed the <tt class="calibre25">add_timer( )</tt> or later the <tt class="calibre25">mod_timer( )</tt> function. The <tt class="calibre25">del_timer( )</tt> and companion functions, however, can deactivate every dynamic timer, even if it is not bound to the local CPU.</p>
<a name="understandlk-CHP-6-SECT-5.1.1"></a>
<h5 class="docSection3Title">6.5.1.1. Dynamic timers and race conditions</h5><a name="IDX-CHP-6-1742"></a>
<a name="IDX-CHP-6-1743"></a>
<a name="IDX-CHP-6-1744"></a>
<a name="IDX-CHP-6-1745"></a>
<a name="IDX-CHP-6-1746"></a>
<a name="IDX-CHP-6-1747"></a>
<p class="docText1">Being asynchronously activated, dynamic timers are prone to race conditions. For instance, consider a dynamic timer whose function acts on a discardable resource (e.g., a kernel module or a file data structure). Releasing the resource without stopping the timer may lead to data corruption if the timer function got activated when the resource no longer exists. Thus, a rule of thumb is to stop the timer <span class="docEmphasis">before</span> releasing the resource:</p>
<pre class="calibre27">
    ...
    del_timer(&amp;t);
    X_Release_Resources( );
    ...
</pre><br class="calibre7"/>
<p class="docText1">In multiprocessor systems, however, this code is not safe because the timer function might already be running on another CPU when <tt class="calibre25">del_timer( )</tt> is invoked. As a result, resources may be released while the timer function is still acting on them. To avoid this kind of race condition, the kernel offers the <tt class="calibre25">del_timer_sync( )</tt> function. It removes the timer from the list, and then it checks whether the timer function is executed on another CPU; in such a case, <tt class="calibre25">del_timer_sync( )</tt> waits until the timer function terminates.</p>
<p class="docText1">The <tt class="calibre25">del_timer_sync( )</tt> function is rather complex and slow, because it has to carefully take into consideration the case in which the timer function reactivates itself. If the kernel developer knows that the timer function never reactivates the timer, she can use the simpler and faster <tt class="calibre25">del_singleshot_timer_sync( )</tt> function to deactivate a timer and wait until the timer function terminates.</p>
<p class="docText1">Other types of race conditions exist, of course. For instance, the right way to modify the <tt class="calibre25">expires</tt> field of an already activated timer consists of using <tt class="calibre25">mod_timer( )</tt>, rather than deleting the timer and re-creating it thereafter. In the latter approach, two kernel control paths that want to modify the <tt class="calibre25">expires</tt> field of the same timer may mix each other up badly. The implementation of the timer functions is made SMP-safe by means of the <tt class="calibre25">lock</tt> spin lock included in every <tt class="calibre25">timer_list</tt> object: every time the kernel must access a dynamic timer, it disables the interrupts and acquires this spin lock.</p>
<a name="understandlk-CHP-6-SECT-5.1.2"></a>
<h5 class="docSection3Title">6.5.1.2. Data structures for dynamic timers</h5><a name="IDX-CHP-6-1748"></a>
<a name="IDX-CHP-6-1749"></a>
<a name="IDX-CHP-6-1750"></a>
<a name="IDX-CHP-6-1751"></a>
<a name="IDX-CHP-6-1752"></a>
<p class="docText1">Choosing the proper data structure to implement dynamic timers is not easy. Stringing together all timers in a single list would degrade system performance, because scanning a long list of timers at every tick is costly. On the other hand, maintaining a sorted list would not be much more efficient, because the insertion and deletion operations would also be costly.</p>
<p class="docText1">The adopted solution is based on a clever data structure that partitions the <tt class="calibre25">expires</tt> values into blocks of ticks and allows dynamic timers to percolate efficiently from lists with larger <tt class="calibre25">expires</tt> values to lists with smaller ones. Moreover, in multiprocessor systems the set of active dynamic timers is split among the various CPUs.</p>
<p class="docText1">The main data structure for dynamic timers is a per-CPU variable (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.1">Per-CPU Variables</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>) named <tt class="calibre25">tvec_bases</tt>: it includes <tt class="calibre25">NR_CPUS</tt> elements, one for each CPU in the system. Each element is a <tt class="calibre25">tvec_base_t</tt> structure, which includes all data needed to handle the dynamic timers bound to the corresponding CPU:</p>
<pre class="calibre27">
    typedef struct tvec_t_base_s {
        spinlock_t lock;
        unsigned long timer_jiffies;
        struct timer_list *running_timer;
        tvec_root_t tv1;
        tvec_t tv2;
        tvec_t tv3;
        tvec_t tv4;
        tvec_t tv5;
    } tvec_base_t;
</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">tv1</tt> field is a structure of type <tt class="calibre25">tvec_root_t</tt>, which includes a <tt class="calibre25">vec</tt> array of 256 <tt class="calibre25">list_head</tt> elements  that is, lists of dynamic timers. It contains all dynamic timers, if any, that will decay within the next 255 ticks.</p>
<p class="docText1">The <tt class="calibre25">tv2</tt>, <tt class="calibre25">tv3</tt>, and <tt class="calibre25">tv4</tt> fields are structures of type <tt class="calibre25">tvec_t</tt> consisting of a <tt class="calibre25">vec</tt> array of 64 <tt class="calibre25">list_head</tt> elements. These lists contain all dynamic timers that will decay within the next 2<sup class="calibre37">14</sup>-1, 2<sup class="calibre37">20</sup>-1, and 2<sup class="calibre37">26</sup>-1 ticks, respectively.</p>
<p class="docText1">The <tt class="calibre25">tv5</tt> field is identical to the previous ones, except that the last entry of the <tt class="calibre25">vec</tt> array is a list that includes dynamic timers with extremely large <tt class="calibre25">expires</tt> fields. It never needs to be replenished from another array. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-FIG-1">Figure 6-1</a> illustrates in a schematic way the five groups of lists.</p>
<p class="docText1">The <tt class="calibre25">timer_jiffies</tt> field represents the earliest expiration time of the dynamic timers yet to be checked: if it coincides with the value of <tt class="calibre25">jiffies</tt>, no backlog of deferrable functions has accumulated; if it is smaller than <tt class="calibre25">jiffies</tt>, then lists of dynamic timers that refer to previous ticks must be dealt with. The field is set to <tt class="calibre25">jiffies</tt> at system startup and is increased only by the <tt class="calibre25">run_timer_softirq( )</tt> function described in the next section. Notice that the <tt class="calibre25">timer_jiffies</tt> field might drop a long way behind <tt class="calibre25">jiffies</tt> when the deferrable functions that handle dynamic timers are not executed for a long timefor instance because these functions have been disabled or because a large number of interrupt handlers have been executed.</p>
<a name="understandlk-CHP-6-FIG-1"></a><p class="calibre14"><center class="calibre8">
<h5 class="docFigureTitle">Figure 6-1. The groups of lists associated with dynamic timers</h5>
<img border="0" alt="" src="understandlk_0601.jpg" class="calibre71"/></center></p><br class="calibre7"/>
<p class="docText1">In multiprocessor systems, the <tt class="calibre25">running_timer</tt> field points to the <tt class="calibre25">timer_list</tt> structure of the dynamic timer that is currently handled by the local CPU.</p>
<a name="understandlk-CHP-6-SECT-5.1.3"></a>
<h5 class="docSection3Title">6.5.1.3. Dynamic timer handling</h5><a name="IDX-CHP-6-1753"></a>
<a name="IDX-CHP-6-1754"></a>
<p class="docText1">Despite the clever data structures, handling software timers is a time-consuming activity that should not be performed by the timer interrupt handler. In Linux 2.6 this activity is carried on by a deferrable function, namely the <tt class="calibre25">TIMER_SOFTIRQ</tt> softirq.</p>
<p class="docText1">The <tt class="calibre25">run_timer_softirq( )</tt> function is the deferrable function associated with the <tt class="calibre25">TIMER_SOFTIRQ</tt> softirq. It essentially performs the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Stores in the <tt class="calibre25">base</tt> local variable the address of the <tt class="calibre25">tvec_base_t</tt> data structure associated with the local CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">base-&gt;lock</tt> spin lock and disables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Starts a <tt class="calibre25">while</tt> loop, which ends when <tt class="calibre25">base-&gt;timer_jiffies</tt> becomes greater than the value of <tt class="calibre25">jiffies</tt>. In every single execution of the cycle, performs the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Computes the index of the list in <tt class="calibre25">base-&gt;tv1</tt> that holds the next timers to be handled:</p><pre class="calibre60">
    index = base-&gt;timer_jiffies &amp; 255;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">index</tt> is zero, all lists in <tt class="calibre25">base-&gt;tv1</tt> have been checked, so they are empty: the function therefore percolates the dynamic timers by invoking <tt class="calibre25">cascade( )</tt>:</p><pre class="calibre60">
    if (!index &amp;&amp;
      (!cascade(base, &amp;base-&gt;tv2, (base-&gt;timer_jiffies&gt;&gt; 8)&amp;63)) &amp;&amp;
      (!cascade(base, &amp;base-&gt;tv3, (base-&gt;timer_jiffies&gt;&gt;14)&amp;63)) &amp;&amp;
      (!cascade(base, &amp;base-&gt;tv4, (base-&gt;timer_jiffies&gt;&gt;20)&amp;63)))
        cascade(base, &amp;base-&gt;tv5, (base-&gt;timer_jiffies&gt;&gt;26)&amp;63);
</pre><br class="calibre7"/>
<p class="docList">Consider the first invocation of the <tt class="calibre25">cascade( )</tt> function: it receives as arguments the address in <tt class="calibre25">base</tt>, the address of <tt class="calibre25">base-&gt;tv2</tt>, and the index of the list in <tt class="calibre25">base-&gt;tv2</tt> including the timers that will decay in the next 256 ticks. This index is determined by looking at the proper bits of the <tt class="calibre25">base-&gt;timer_jiffies</tt> value. <tt class="calibre25">cascade( )</tt> moves all dynamic timers in the <tt class="calibre25">base-&gt;tv2</tt> list into the proper lists of <tt class="calibre25">base-&gt;tv1</tt>; then, it returns a positive value, unless all <tt class="calibre25">base-&gt;tv2</tt> lists are now empty. If so, <tt class="calibre25">cascade( )</tt> is invoked once more to replenish <tt class="calibre25">base-&gt;tv2</tt> with the timers included in a list of <tt class="calibre25">base-&gt;tv3</tt>, and so on.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases by one <tt class="calibre25">base-&gt;timer_jiffies</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">For each dynamic timer in the <tt class="calibre25">base-&gt;tv1.vec[index]</tt> list, executes the corresponding timer function. In particular, for each <tt class="calibre25">timer_list</tt> element <tt class="calibre25">t</tt> in the list essentially performs the following steps:</p><div class="calibre44"><ol class="docList4" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Removes <tt class="calibre25">t</tt> from the <tt class="calibre25">base-&gt;tv1</tt>'s list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">In multiprocessor systems, sets <tt class="calibre25">base-&gt;running_timer</tt> to <tt class="calibre25">&amp;t</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">t.base</tt> to <tt class="calibre25">NULL</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">base-&gt;lock</tt> spin lock, and enables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the timer function <tt class="calibre25">t.function</tt> passing as argument <tt class="calibre25">t.data</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">base-&gt;lock</tt> spin lock, and disables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Continues with the next timer in the list, if any.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">All timers in the list have been handled. Continues with the next iteration of the outermost <tt class="calibre25">while</tt> cycle.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The outermost <tt class="calibre25">while</tt> cycle is terminated, which means that all decayed timers have been handled. In multiprocessor systems, sets <tt class="calibre25">base-&gt;running_timer</tt> to <tt class="calibre25">NULL</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">base-&gt;lock</tt> spin lock and enables local interrupts.</p></div></li></ol></div>
<p class="docText1">Because the values of <tt class="calibre25">jiffies</tt> and <tt class="calibre25">timer_jiffies</tt> usually coincide, the outermost <tt class="calibre25">while</tt> cycle is often executed only once. In general, the outermost loop is executed <tt class="calibre25">jiffies - base-&gt;timer_jiffies + 1</tt> consecutive times. Moreover, if a timer interrupt occurs while <tt class="calibre25">run_timer_softirq( )</tt> is being executed, dynamic timers that decay at this tick occurrence are also considered, because the <tt class="calibre25">jiffies</tt> variable is asynchronously increased by the global timer interrupt handler (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.2.2">The timer interrupt handler</a>").</p>
<p class="docText1">Notice that <tt class="calibre25">run_timer_softirq( )</tt> disables interrupts and acquires the <tt class="calibre25">base-&gt;lock</tt> spin lock just before entering the outermost loop; interrupts are enabled and the spin lock is released right before invoking each dynamic timer function, until its termination. This ensures that the dynamic timer data structures are not corrupted by interleaved kernel control paths.</p>
<p class="docText1">To sum up, this rather complex algorithm ensures excellent performance. To see why, assume for the sake of simplicity that the <tt class="calibre25">TIMER_SOFTIRQ</tt> softirq is executed right after the corresponding timer interrupt occurs. Then, in 255 timer interrupt occurrences out of 256 (in 99.6% of the cases), the <tt class="calibre25">run_timer_softirq( )</tt> function just runs the functions of the decayed timers, if any. To replenish <tt class="calibre25">base-&gt;tv1.vec</tt> periodically, it is sufficient 63 times out of 64 to partition one list of <tt class="calibre25">base-&gt;tv2</tt> into the 256 lists of <tt class="calibre25">base-&gt;tv1</tt>. The <tt class="calibre25">base-&gt;tv2.vec</tt> array, in turn, must be replenished in 0.006 percent of the cases (that is, once every 16.4 seconds). Similarly, <tt class="calibre25">base-&gt;tv3.vec</tt> is replenished every 17 minutes and 28 seconds, and <tt class="calibre25">base-&gt;tv4.vec</tt> is replenished every 18 hours and 38 minutes. <tt class="calibre25">base-&gt;tv5.vec</tt> doesn't need to be replenished.</p>
<a name="understandlk-CHP-6-SECT-5.2"></a>
<h4 class="docSection2Title">6.5.2. An Application of Dynamic Timers: the nanosleep( ) System Call</h4><a name="IDX-CHP-6-1755"></a>
<a name="IDX-CHP-6-1756"></a>
<a name="IDX-CHP-6-1757"></a>
<a name="IDX-CHP-6-1758"></a>
<a name="IDX-CHP-6-1759"></a>
<p class="docText1">To show how the outcomes of all the previous activities are actually used in the kernel, we'll show an example<a name="IDX-CHP-6-1760"></a> 
 of the creation and use of a <span class="docEmphasis">process time-out</span>.</p>
<p class="docText1">Let's consider the service routine of the <tt class="calibre25">nanosleep()</tt> system call, that is, <tt class="calibre25">sys_nanosleep()</tt>, which receives as its parameter a pointer to a <tt class="calibre25">timespec</tt> structure and suspends the invoking process until the specified time interval elapses. The service routine first invokes <tt class="calibre25">copy_from_user()</tt> to copy the values contained in the User Mode <tt class="calibre25">timespec</tt> structure into the local variable <tt class="calibre25">t</tt>. Assuming that the <tt class="calibre25">timespec</tt> structure defines a non-null delay, the function then executes the following code:</p>
<pre class="calibre27">
    current-&gt;state = TASK_INTERRUPTIBLE;
    remaining = schedule_timeout(timespec_to_jiffies(&amp;t)+1);
</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">timespec_to_jiffies( )</tt> function converts in ticks the time interval stored in the <tt class="calibre25">timespec</tt> structure. To be on the safe side, <tt class="calibre25">sys_nanosleep( )</tt> adds one tick to the value computed by <tt class="calibre25">timespec_to_jiffies( )</tt>.</p>
<p class="docText1">The kernel implements process time-outs<a name="IDX-CHP-6-1761"></a> 
 by using dynamic timers. They appear in the <tt class="calibre25">schedule_timeout( )</tt> function, which essentially executes the following statements:</p>
<pre class="calibre27">
    struct timer_list timer;
    unsigned long expire = timeout + jiffies;
    init_timer(&amp;timer);
    timer.expires = expire;
    timer.data = (unsigned long) current;
    timer.function = process_timeout;
    add_timer(&amp;timer);
    schedule( );     /* process suspended until timer expires */
    del_singleshot_timer_sync(&amp;timer);
    timeout = expire - jiffies;
    return (timeout &lt; 0 ? 0 : timeout);
</pre><br class="calibre7"/>
<p class="docText1">When <tt class="calibre25">schedule( )</tt> is invoked, another process is selected for execution; when the former process resumes its execution, the function removes the dynamic timer. In the last statement, the function either returns 0, if the time-out is expired, or the number of ticks left to the time-out expiration if the process was awakened for some other reason.</p>
<p class="docText1">When the time-out expires, the timer's function is executed:</p>
<pre class="calibre27">
    void process_timeout(unsigned long __data)
    {
        wake_up_process((task_t *)__data);
    }
</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">process_timeout( )</tt> receives as its parameter the process descriptor pointer stored in the <tt class="calibre25">data</tt> field of the <tt class="calibre25">timer</tt> object. As a result, the suspended process is awakened.</p>
<p class="docText1">Once awakened, the process continues the execution of the <tt class="calibre25">sys_nanosleep( )</tt> system call. If the value returned by <tt class="calibre25">schedule_timeout( )</tt> specifies that the process time-out is expired (value zero), the system call terminates. Otherwise, the system call is automatically restarted, as explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-3.html#understandlk-CHP-11-SECT-3.3">Reexecution of System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>.</p>
<a name="understandlk-CHP-6-SECT-5.3"></a>
<h4 class="docSection2Title">6.5.3. Delay Functions</h4><a name="IDX-CHP-6-1762"></a>
<a name="IDX-CHP-6-1763"></a>
<a name="IDX-CHP-6-1764"></a>
<p class="docText1">Software timers are useless when the kernel must wait for a short time intervallet's say, less than a few milliseconds. For instance, often a device driver has to wait for a predefined number of microseconds until the hardware completes some operation. Because a dynamic timer has a significant setup overhead and a rather large minimum wait time (1 millisecond), the device driver cannot conveniently use it.</p>
<p class="docText1">In these cases, the kernel makes use of the <tt class="calibre25">udelay( )</tt> and <tt class="calibre25">ndelay( )</tt> functions: the former receives as its parameter a time interval in microseconds and returns after the specified delay has elapsed; the latter is similar, but the argument specifies the delay in nanoseconds.</p>
<p class="docText1">Essentially, the two functions are defined as follows:</p>
<pre class="calibre27">
void udelay(unsigned long usecs)
    {
        unsigned long loops;
        loops = (usecs*HZ*current_cpu_data.loops_per_jiffy)/1000000;
        cur_timer-&gt;delay(loops);
    }

    void ndelay(unsigned long nsecs)
    {
        unsigned long loops;
        loops = (nsecs*HZ*current_cpu_data.loops_per_jiffy)/1000000000;
        cur_timer-&gt;delay(loops);
    }

</pre><br class="calibre7"/>
<p class="docText1">Both functions rely on the <tt class="calibre25">delay</tt> method of the <tt class="calibre25">cur_timer</tt> timer object (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.1">Data Structures of the Timekeeping Architecture</a>"), which receives as its parameter a time interval in "loops." The exact duration of one "loop," however, depends on the timer object referred by <tt class="calibre25">cur_timer</tt> (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-TABLE-2">Table 6-2</a> earlier in this chapter):</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">If <tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_hpet</tt>, <tt class="calibre25">timer_pmtmr</tt>, and <tt class="calibre25">timer_tsc</tt> objects, one "loop" corresponds to one CPU cyclethat is, the time interval between two consecutive CPU clock signals (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-1.html#understandlk-CHP-6-SECT-1.2">Time Stamp Counter (TSC)</a>").</p></li><li class="calibre12"><p class="docText1">If <tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_none</tt> or <tt class="calibre25">timer_pit</tt> objects, one "loop" corresponds to the time duration of a single iteration of a tight instruction loop.</p></li></ul>
<p class="docText1">During the initialization phase, after <tt class="calibre25">cur_timer</tt> has been set up by <tt class="calibre25">select_timer( )</tt>, the kernel executes the <tt class="calibre25">calibrate_delay( )</tt> function, which determines how many "loops" fit in a tick. This value is then saved in the <tt class="calibre25">current_cpu_data.loops_per_jiffy</tt> variable, so that it can be used by <tt class="calibre25">udelay( )</tt> and <tt class="calibre25">ndelay( )</tt> to convert microseconds and nanoseconds, respectively, to "loops."</p>
<p class="docText1">Of course, the <tt class="calibre25">cur_timer-&gt;delay( )</tt> method makes use of the HPET or TSC hardware circuitry, if available, to get an accurate measurement of time. Otherwise, if no HPET or TSC is available, the method executes <tt class="calibre25">loops</tt> iterations of a tight instruction loop.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

