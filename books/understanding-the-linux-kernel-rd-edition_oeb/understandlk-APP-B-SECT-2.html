---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-APP-B-SECT-1.html
next: understandlk-APP-B-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-APP-B-SECT-2"></a>
<h3 class="docSection1Title">B.2. Module Implementation</h3><a name="IDX-APP-B-0049"></a>
<a name="IDX-APP-B-0050"></a>
<a name="IDX-APP-B-0051"></a>
<a name="IDX-APP-B-0052"></a>
<a name="IDX-APP-B-0053"></a>
<p class="docText1">Modules are stored in the filesystem as ELF object files and are linked to the kernel by executing the <i class="docEmphasis">insmod</i> program (see the later section, "<a class="pcalibre5 docLink pcalibre1" href="understandlk-APP-B-SECT-3.html#understandlk-APP-B-SECT-3">Linking and Unlinking Modules</a>"). For each module, the kernel allocates a memory area containing the following data:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">A <tt class="calibre25">module</tt> object</p></li><li class="calibre12"><p class="docText1">A null-terminated string that represents the name of the module (all modules must have unique names)</p></li><li class="calibre12"><p class="docText1">The code that implements the functions of the module</p></li></ul>
<p class="docText1">The <tt class="calibre25">module</tt> object describes a module; its fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-APP-B-TABLE-1">Table B-1</a>. A doubly linked circular list collects all <tt class="calibre25">module</tt> objects; the list head is stored in the <tt class="calibre25">modules</tt> variable, while the pointers to the adjacent elements are stored in the <tt class="calibre25">list</tt> field of each <tt class="calibre25">module</tt> object.</p>
<a name="understandlk-APP-B-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table B-1. The module object</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">enum module_state</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">state</tt></p></td><td class="docTableCell"><p class="docText2">The internal state of the module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">list</tt></p></td><td class="docTableCell"><p class="docText2">Pointers for the list of modules</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">char [60]</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">name</tt></p></td><td class="docTableCell"><p class="docText2">The module name</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">module_kobject</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mkobj</tt></p></td><td class="docTableCell"><p class="docText2">Includes a <tt class="calibre25">kobject</tt> data structure and a pointer to this module object</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">module_param_attrs *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">param_attrs</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of module parameter descriptors</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">const struct</tt></p><p class="docText2"><tt class="calibre25">kernel_symbol *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">syms</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of exported symbols</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">num_syms</tt></p></td><td class="docTableCell"><p class="docText2">Number of exported symbols</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">const unsigned long *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">crcs</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of CRC values for the exported symbols</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">const struct</tt></p><p class="docText2"><tt class="calibre25">kernel_symbol *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">gpl_syms</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of GPL-exported symbols</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">num_gpl_syms</tt></p></td><td class="docTableCell"><p class="docText2">Number of GPL-exported symbols</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">const unsigned long *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">gpl_crcs</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of CRC values for the GPL-exported symbols</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">num_exenTRies</tt></p></td><td class="docTableCell"><p class="docText2">Number of entries in the module's exception table</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">const struct</tt></p><p class="docText2"><tt class="calibre25">exception_table_entry *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">extable</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the module's exception table</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int (*)(void)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">init</tt></p></td><td class="docTableCell"><p class="docText2">The initialization method of the module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">module_init</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the dynamic memory area allocated for module's initialization</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">module_core</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the dynamic memory area allocated for module's core functions and data structures</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">init_size</tt></p></td><td class="docTableCell"><p class="docText2">Size of the dynamic memory area required for module's initialization</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">core_size</tt></p></td><td class="docTableCell"><p class="docText2">Size of the dynamic memory area required for module's core functions and data structures</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">init_text_size</tt></p></td><td class="docTableCell"><p class="docText2">Size of the executable code used for module's initialization; used only when linking the module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">core_text_size</tt></p></td><td class="docTableCell"><p class="docText2">Size of the core executable code of the module; used only when linking the module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">mod_arch_specific</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">arch</tt></p></td><td class="docTableCell"><p class="docText2">Architecture-dependent fields (none in the</p><p class="docText2">80 x 86 architecture)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsafe</tt></p></td><td class="docTableCell"><p class="docText2">Flag set if the module cannot be safely unloaded</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">license_gplok</tt></p></td><td class="docTableCell"><p class="docText2">Flag set if the module license is GPL-compatible</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">module_ref [NR_CPUS]</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">ref</tt></p></td><td class="docTableCell"><p class="docText2">Per-CPU usage counters</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">modules_which_use_me</tt></p></td><td class="docTableCell"><p class="docText2">List of modules that rely on this module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct task_struct *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">waiter</tt></p></td><td class="docTableCell"><p class="docText2">The process that is trying to unload the module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void (*)(void)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">exit</tt></p></td><td class="docTableCell"><p class="docText2">Exit method of the module</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">Elf_Sym *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">symtab</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of module's ELF symbols for the <span class="docEmphasis">/proc/kallsyms</span> file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">num_symtab</tt></p></td><td class="docTableCell"><p class="docText2">Number of module's ELF symbols shown in <span class="docEmphasis">/proc/kallsyms</span></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">char *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">strtab</tt></p></td><td class="docTableCell"><p class="docText2">The string table for the module's ELF symbols shown in <span class="docEmphasis">/proc/kallsyms</span></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">module_sect_attrs *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">sect_attrs</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to an array of module's section attribute descriptors (displayed in the <span class="docEmphasis">sysfs</span><a name="IDX-APP-B-0054"></a> 
 filesystem)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">percpu</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to CPU-specific memory areas</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">char *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">args</tt></p></td><td class="docTableCell"><p class="docText2">Command line arguments used when linking the module</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">state</tt> field encodes the internal state of the module: it can be <tt class="calibre25">MODULE_STATE_LIVE</tt> (the module is active), <tt class="calibre25">MODULE_STATE_COMING</tt> (the module is being initialized), and <tt class="calibre25">MODULE_STATE_GOING</tt> (the module is being removed).</p>
<p class="docText1">As already mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10-SECT-4.html#understandlk-CHP-10-SECT-4.3">Dynamic Address Checking: The Fix-up Code</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>, each module has its own exception table. The table includes the addresses of the fixup code of the module, if any. The table is copied into RAM when the module is linked, and its starting address is stored in the <tt class="calibre25">extable</tt> field of the <tt class="calibre25">module</tt> object.</p>
<a name="understandlk-APP-B-SECT-2.1"></a>
<h4 class="docSection2Title">B.2.1. Module Usage Counters</h4>
<p class="docText1">Each module has a set of usage counters, one for each CPU, stored in the <tt class="calibre25">ref</tt> field of the corresponding <tt class="calibre25">module</tt> object. The counter is increased when an operation involving the module's functions is started and decreased when the operation terminates. A module can be unlinked only if the sum of all usage counters is 0.</p>
<p class="docText1">For example, suppose that the MS-DOS<a name="IDX-APP-B-0055"></a>
<a name="IDX-APP-B-0056"></a> 
 filesystem layer is compiled as a module and the module is linked at runtime. Initially, the module usage counters<a name="IDX-APP-B-0057"></a> 
 are set to 0. If the user mounts an MS-DOS floppy disk, one of the module usage counters is increased by 1. Conversely, when the user unmounts the floppy disk, one of the counterseven different from the one that was increasedis decreased by 1. The total usage counter of the module is the sum of all CPU counters.</p>
<a name="understandlk-APP-B-SECT-2.2"></a>
<h4 class="docSection2Title">B.2.2. Exporting Symbols</h4><a name="IDX-APP-B-0058"></a>
<a name="IDX-APP-B-0059"></a>
<a name="IDX-APP-B-0060"></a>
<a name="IDX-APP-B-0061"></a>
<p class="docText1">When linking a module, all references to global kernel symbols (variables and functions) in the module's object code must be replaced with suitable addresses. This operation, which is very similar to that performed by the linker while compiling a User Mode program (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.3">Libraries</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>), is delegated to the <i class="docEmphasis">insmod</i> external program (described later in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-APP-B-SECT-3.html#understandlk-APP-B-SECT-3">Linking and Unlinking Modules</a>").</p>
<p class="docText1">Some special <span class="docEmphasis">kernel symbol tables</span><a name="IDX-APP-B-0062"></a> 
 are used by the kernel to store the symbols that can be accessed by modules together with their corresponding addresses. They are contained in three sections of the kernel code segment: the <tt class="calibre25">_ _kstrtab</tt> section includes the names of the symbols, the <tt class="calibre25">_ _ksymtab</tt> section includes the addresses of the symbols that can be used by all kind of modules, and the <tt class="calibre25">_ _ksymtab_gpl</tt> section includes the addresses of the symbols that can be used by the modules released under a GPL-compatible license. The <tt class="calibre25">EXPORT_SYMBOL</tt> macro and the <tt class="calibre25">EXPORT_SYMBOL_GPL</tt> macro, when used inside the statically linked kernel code, force the C compiler to add a specified symbol to the <tt class="calibre25">_ _ksymtab</tt> and <tt class="calibre25">_ _ksymtab_gpl</tt> sections, respectively.</p>
<p class="docText1">Only the kernel symbols actually used by some existing module are included in the table. Should a system programmer need, within some module, to access a kernel symbol that is not already exported, he can simply add the corresponding <tt class="calibre25">EXPORT_SYMBOL_GPL</tt> macro into the Linux source code. Of course, he cannot legally export a new symbol for a module whose license is not GPL-compatible.</p>
<p class="docText1">Linked modules can also export their own symbols so that other modules can access them. The <span class="docEmphasis">module symbol tables</span><a name="IDX-APP-B-0063"></a> 
 are contained in the <tt class="calibre25">_ _ksymtab</tt>, <tt class="calibre25">_ _ksymtab_gpl</tt>, and <tt class="calibre25">_ _kstrtab</tt> sections of the module code segment. To export a subset of symbols from the module, the programmer can use the <tt class="calibre25">EXPORT_SYMBOL</tt> and <tt class="calibre25">EXPORT_SYMBOL_GPL</tt> macros described above. The exported symbols of the module are copied into two memory arrays when the module is linked, and their addresses are stored in the <tt class="calibre25">syms</tt> and <tt class="calibre25">gpl_syms</tt> fields of the <tt class="calibre25">module</tt> object.</p>
<a name="understandlk-APP-B-SECT-2.3"></a>
<h4 class="docSection2Title">B.2.3. Module Dependency</h4>
<p class="docText1">A module (B) can refer to the symbols exported by another module (A); in this case, we say that B is loaded on top of A, or equivalently that A is used by B. To link module B, module A must have already been linked; otherwise, the references to the symbols exported by A cannot be properly linked in B. In short, there is a <span class="docEmphasis">dependency</span> between modules.</p>
<p class="docText1">The <tt class="calibre25">modules_which_use_me</tt> field of the <tt class="calibre25">module</tt> object of A is the head of a dependency list containing all modules that are used by A; each element of the list is a small <tt class="calibre25">module_use</tt> descriptor containing the pointers to the adjacent elements in the list and a pointer to the corresponding <tt class="calibre25">module</tt> object; in our example, a <tt class="calibre25">module_use</tt> descriptor pointing to the B's <tt class="calibre25">module</tt> object would appear in the <tt class="calibre25">modules_which_use_me</tt> list of A. The <tt class="calibre25">modules_which_use_me</tt> list must be updated dynamically whenever a module is loaded on top of A. The module A cannot be unloaded if its dependency list is not empty.</p>
<p class="docText1">Beside A and B there could be, of course, another module (C) loaded on top of B, and so on. Stacking modules is an effective way to modularize the kernel source code, thus speeding up its development.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

