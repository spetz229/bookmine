---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-10-SECT-2.html
next: understandlk-CHP-10-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-10-SECT-3"></a>
<h3 class="docSection1Title" id="534869-883">10.3. Entering and Exiting a System Call</h3><a name="IDX-CHP-10-2507"></a>
<a name="IDX-CHP-10-2508"></a>
<a name="IDX-CHP-10-2509"></a>
<a name="IDX-CHP-10-2510"></a>
<p class="docText1">Native applications<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-10-FN1">[*]</a></sup> can invoke a system call in two different ways:</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-10-FN1">[*]</a></sup> As we will see in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-3.html#understandlk-CHP-20-SECT-3">Execution Domains</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>, Linux can execute programs compiled for "foreign" operating systems. Therefore, the kernel offers a compatibility mode to enter a system call: User Mode processes executing iBCS and Solaris<a name="IDX-CHP-10-2511"></a> 
/x86 programs can enter the kernel by jumping into suitable call gates included in the default Local Descriptor Table (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-3.html#understandlk-CHP-2-SECT-3.2">The Linux LDTs</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>).</p></blockquote>
<ul class="calibre11"><li class="calibre12"><p class="docText1">By executing the <tt class="calibre25">int<a name="IDX-CHP-10-2512"></a> 
 $0x80</tt> assembly language instruction; in older versions of the Linux kernel, this was the only way to switch from User Mode to Kernel Mode.</p></li><li class="calibre12"><p class="docText1">By executing the <tt class="calibre25">sysenter</tt><a name="IDX-CHP-10-2513"></a> 
 assembly language instruction, introduced in the Intel Pentium II microprocessors; this instruction is now supported by the Linux 2.6 kernel.</p></li></ul>
<p class="docText1">Similarly, the kernel can exit from a system callthus switching the CPU back to User Modein two ways:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">By executing the <tt class="calibre25">iret</tt><a name="IDX-CHP-10-2514"></a> 
 assembly language instruction.</p></li><li class="calibre12"><p class="docText1">By executing the <tt class="calibre25">sysexit</tt><a name="IDX-CHP-10-2515"></a> 
 assembly language instruction, which was introduced in the Intel Pentium II microprocessors together with the <tt class="calibre25">sysenter</tt> instruction.</p></li></ul>
<p class="docText1">However, supporting two different ways to enter the kernel is not as simple as it might look, because:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The kernel must support both older libraries that only use the <tt class="calibre25">int $0x80</tt> instruction and more recent ones that also use the <tt class="calibre25">sysenter</tt> instruction.</p></li><li class="calibre12"><p class="docText1">A standard library that makes use of the <tt class="calibre25">sysenter</tt> instruction must be able to cope with older kernels that support only the <tt class="calibre25">int $0x80</tt> instruction.</p></li><li class="calibre12"><p class="docText1">The kernel and the standard library must be able to run both on older processors that do not include the <tt class="calibre25">sysenter</tt> instruction and on more recent ones that include it.</p></li></ul>
<p class="docText1">We will see in the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-10-SECT-3.2">Issuing a System Call via the sysenter Instruction</a>" later in this chapter how the Linux kernel solves these compatibility problems.</p>
<a name="understandlk-CHP-10-SECT-3.1"></a>
<h4 class="docSection2Title">10.3.1. Issuing a System Call via the int $0x80 Instruction</h4>
<p class="docText1">The "traditional" way to invoke a system call makes use of the <tt class="calibre25">int</tt> assembly language instruction, which was discussed in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.4">Hardware Handling of Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>.</p>
<p class="docText1">The vector 128in hexadecimal, <tt class="calibre25">0x80</tt>is associated with the kernel entry point. The <tt class="calibre25">trap_init( )</tt> function, invoked during kernel initialization, sets up the Interrupt Descriptor Table entry corresponding to vector 128 as follows:</p>
<pre class="calibre27">
    set_system_gate(0x80, &amp;system_call);</pre><br class="calibre7"/>
<p class="docText1">The call loads the following values into the gate descriptor fields (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-4.html#understandlk-CHP-4-SECT-4.1">Interrupt, Trap, and System Gates</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>):</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Segment Selector</span></span></p></dt>
<dd class="calibre20"><p class="docList">The <tt class="calibre25">_ _KERNEL_CS</tt> Segment Selector of the kernel code segment.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Offset</span></span></p></dt>
<dd class="calibre20"><p class="docList">The pointer to the <tt class="calibre25">system_call( )</tt> system call handler.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Type</span></span></p></dt>
<dd class="calibre20"><p class="docList">Set to 15. Indicates that the exception is a Trap and that the corresponding handler does not disable maskable interrupts.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">DPL (Descriptor Privilege Level)</span></span></p></dt>
<dd class="calibre20"><p class="docList">Set to 3. This allows processes in User Mode to invoke the exception handler (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.4">Hardware Handling of Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></dd></dl>
<p class="docText1">Therefore, when a User Mode process issues an <tt class="calibre25">int $0x80</tt> instruction, the CPU switches into Kernel Mode and starts executing instructions from the <tt class="calibre25">system_call</tt> address.</p>
<a name="understandlk-CHP-10-SECT-3.1.1"></a>
<h5 class="docSection3Title">10.3.1.1. The system_call( ) function</h5>
<p class="docText1">The <tt class="calibre25">system_call( )</tt> function starts by saving the system call number and all the CPU registers that may be used by the exception handler on the stackexcept for <tt class="calibre25">eflags</tt>, <tt class="calibre25">cs</tt>, <tt class="calibre25">eip</tt>, <tt class="calibre25">ss</tt>, and <tt class="calibre25">esp</tt>, which have already been saved automatically by the control unit (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.4">Hardware Handling of Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). The <tt class="calibre25">SAVE_ALL</tt> macro, which was already discussed in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.1">I/O Interrupt Handling</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, also loads the Segment Selector of the kernel data segment in <tt class="calibre25">ds</tt> and <tt class="calibre25">es</tt>:</p>
<pre class="calibre27">
    system_call:
      pushl %eax
      SAVE_ALL
      movl $0xffffe000, %ebx /* or 0xfffff000 for 4-KB stacks */
      andl %esp, %ebx</pre><br class="calibre7"/>
<p class="docText1">The function then stores the address of the <tt class="calibre25">thread_info</tt> data structure of the current process in <tt class="calibre25">ebx</tt> (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). This is done by taking the value of the kernel stack pointer and rounding it up to a multiple of 4 or 8 KB (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>).</p>
<p class="docText1">Next, the <tt class="calibre25">system_call( )</tt> function checks whether either one of the <tt class="calibre25">TIF_SYSCALL_TRACE</tt> and <tt class="calibre25">TIF_SYSCALL_AUDIT</tt> flags included in the <tt class="calibre25">flags</tt> field of the <tt class="calibre25">thread_info</tt> structure is setthat is, whether the system call invocations of the executed program are being traced by a debugger. If this is the case, <tt class="calibre25">system_call( )</tt> invokes the <tt class="calibre25">do_syscall_trace( )</tt> function twice: once right before and once right after the execution of the system call service routine (as described later). This function stops <tt class="calibre25">current</tt> and thus allows the debugging process to collect information about it.</p>
<p class="docText1">A validity check is then performed on the system call number passed by the User Mode process. If it is greater than or equal to the number of entries in the system call dispatch table, the system call handler terminates:</p>
<pre class="calibre27">
      cmpl $NR_syscalls, %eax
      jb nobadsys
      movl $(-ENOSYS), 24(%esp)
      jmp resume_userspace
    nobadsys:</pre><br class="calibre7"/>
<p class="docText1">If the system call number is not valid, the function stores the <tt class="calibre25">-ENOSYS</tt> value in the stack location where the <tt class="calibre25">eax</tt> register has been savedthat is, at offset 24 from the current stack top. It then jumps to <tt class="calibre25">resume_userspace</tt> (see below). In this way, when the process resumes its execution in User Mode, it will find a negative return code in <tt class="calibre25">eax</tt>.</p>
<p class="docText1">Finally, the specific service routine associated with the system call number contained in <tt class="calibre25">eax</tt> is invoked:</p>
<pre class="calibre27">
      call *sys_call_table(0, %eax, 4)</pre><br class="calibre7"/>
<p class="docText1">Because each entry in the dispatch table is 4 bytes long, the kernel finds the address of the service routine to be invoked by multiplying the system call number by 4, adding the initial address of the <tt class="calibre25">sys_call_table</tt> dispatch table, and extracting a pointer to the service routine from that slot in the table.</p>
<a name="understandlk-CHP-10-SECT-3.1.2"></a>
<h5 class="docSection3Title">10.3.1.2. Exiting from the system call</h5><a name="IDX-CHP-10-2516"></a>
<p class="docText1">When the system call service routine terminates, the <tt class="calibre25">system_call( )</tt> function gets its return code from <tt class="calibre25">eax</tt> and stores it in the stack location where the User Mode value of the <tt class="calibre25">eax</tt> register is saved:</p>
<pre class="calibre27">
      movl %eax, 24(%esp)</pre><br class="calibre7"/>
<p class="docText1">Thus, the User Mode process will find the return code of the system call in the <tt class="calibre25">eax</tt> register.</p>
<p class="docText1">Then, the <tt class="calibre25">system_call( )</tt> function disables the local interrupts and checks the flags in the <tt class="calibre25">thread_info</tt> structure of <tt class="calibre25">current</tt>:</p>
<pre class="calibre27">
      cli
      movl 8(%ebp), %ecx
      testw $0xffff, %cx
      je restore_all</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">flags</tt> field is at offset 8 in the <tt class="calibre25">tHRead_info</tt> structure; the mask <tt class="calibre25">0xffff</tt> selects the bits corresponding to all flags listed in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-TABLE-15">Table 4-15</a> except <tt class="calibre25">TIF_POLLING_NRFLAG</tt>. If none of these flags is set, the function jumps to the <tt class="calibre25">restore_all</tt> label: as described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, this code restores the contents of the registers saved on the Kernel Mode stack and executes an <tt class="calibre25">iret</tt><a name="IDX-CHP-10-2517"></a> 
 assembly language instruction to resume the User Mode process. (You might refer to the flow diagram in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-FIG-6">Figure 4-6</a>.)</p>
<p class="docText1">If any of the flags is set, then there is some work to be done before returning to User Mode. If the <tt class="calibre25">TIF_SYSCALL_TRACE</tt> flag is set, the <tt class="calibre25">system_call( )</tt> function invokes for the second time the <tt class="calibre25">do_syscall_trace( )</tt> function, then jumps to the <tt class="calibre25">resume_userspace</tt> label. Otherwise, if the <tt class="calibre25">TIF_SYSCALL_TRACE</tt> flag is not set, the function jumps to the <tt class="calibre25">work_pending</tt> label.</p>
<p class="docText1">As explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, that code at the <tt class="calibre25">resume_userspace</tt> and <tt class="calibre25">work_pending</tt> labels checks for rescheduling requests, virtual-8086 mode, pending signals, and single stepping; then eventually a jump is done to the <tt class="calibre25">restore_all</tt> label to resume the execution of the User Mode process.</p>
<a name="understandlk-CHP-10-SECT-3.2"></a>
<h4 class="docSection2Title">10.3.2. Issuing a System Call via the sysenter Instruction</h4><a name="IDX-CHP-10-2518"></a>
<a name="IDX-CHP-10-2519"></a>
<a name="IDX-CHP-10-2520"></a>
<a name="IDX-CHP-10-2521"></a>
<a name="IDX-CHP-10-2522"></a>
<a name="IDX-CHP-10-2523"></a>
<a name="IDX-CHP-10-2524"></a>
<p class="docText1">The <tt class="calibre25">int</tt> assembly language instruction is inherently slow because it performs several consistency and security checks. (The instruction is described in detail in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.4">Hardware Handling of Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>.)</p>
<p class="docText1">The <tt class="calibre25">sysenter</tt> instruction, dubbed in Intel documentation as "Fast System Call," provides a faster way to switch from User Mode to Kernel Mode.</p>
<a name="understandlk-CHP-10-SECT-3.2.1"></a>
<h5 class="docSection3Title">10.3.2.1. The sysenter instruction</h5><a name="IDX-CHP-10-2525"></a>
<a name="IDX-CHP-10-2526"></a>
<p class="docText1">The <tt class="calibre25">sysenter</tt> assembly language instruction makes use of three special registers that must be loaded with the following information:<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-10-FN2">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-10-FN2">[*]</a></sup> "MSR" is an acronym for "Model-Specific Register" and denotes a register that is present only in some models of 80 x 86 microprocessors.</p></blockquote>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SYSENTER_CS_MSR</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The Segment Selector of the kernel code segment</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SYSENTER_EIP_MSR</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The linear address of the kernel entry point</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SYSENTER_ESP_MSR</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The kernel stack pointer</p></dd></dl>
<p class="docText1">When the <tt class="calibre25">sysenter</tt> instruction is executed, the CPU control unit:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Copies the content of <tt class="calibre25">SYSENTER_CS_MSR</tt> into <tt class="calibre25">cs</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the content of <tt class="calibre25">SYSENTER_EIP_MSR</tt> into <tt class="calibre25">eip</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the content of <tt class="calibre25">SYSENTER_ESP_MSR</tt> into <tt class="calibre25">esp</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds 8 to the value of <tt class="calibre25">SYSENTER_CS_MSR</tt>, and loads this value into <tt class="calibre25">ss</tt>.</p></div></li></ol></div>
<p class="docText1">Therefore, the CPU switches to Kernel Mode and starts executing the first instruction of the kernel entry point. As we have seen in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-3.html#understandlk-CHP-2-SECT-3.1">The Linux GDT</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>, the kernel stack segment coincides with the kernel data segment, and the corresponding descriptor follows the descriptor of the kernel code segment in the Global Descriptor Table; therefore, step 4 loads the proper Segment Selector in the <tt class="calibre25">ss</tt> register.</p>
<p class="docText1">The three model-specific registers are initialized by the <tt class="calibre25">enable_sep_cpu( )</tt> function, which is executed once by every CPU in the system during the initialization of the kernel. The function performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Writes the Segment Selector of the kernel code (<tt class="calibre25">_ _KERNEL_CS</tt>) in the <tt class="calibre25">SYSENTER_CS_MSR</tt> register.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Writes in the <tt class="calibre25">SYSENTER_CS_EIP</tt> register the linear address of the <tt class="calibre25">sysenter_entry( )</tt> function described below.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Computes the linear address of the end of the local TSS, and writes this value in the <tt class="calibre25">SYSENTER_CS_ESP</tt> register.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-10-FN3">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-10-FN3">[*]</a></sup> The encoding of the local TSS address written in <tt class="calibre42">SYSENTER_ESP_MSR</tt> is due to the fact that the register should point to a real stack, which grows towards lower address. In practice, initializing the register with any value would work, provided that it is possible to get the address of the local TSS from such a value.</p></blockquote></div></li></ol></div>
<p class="docText1">The setting of the <tt class="calibre25">SYSENTER_CS_ESP</tt> register deserves some comments. When a system call starts, the kernel stack is empty, thus the <tt class="calibre25">esp</tt> register should point to the end of the 4- or 8-KB memory area that includes the kernel stack and the descriptor of the current process (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-FIG-2">Figure 3-2</a>). The User Mode wrapper routine cannot properly set this register, because it does not know the address of this memory area; on the other hand, the value of the register must be set before switching to Kernel Mode. Therefore, the kernel initializes the register so as to encode the address of the Task State Segment of the local CPU. As we have described in step 3 of the <tt class="calibre25">_ _switch_to( )</tt> function (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-3.html#understandlk-CHP-3-SECT-3.3">Performing the Process Switch</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>), at every process switch the kernel saves the kernel stack pointer of the current process in the <tt class="calibre25">esp0</tt> field of the local TSS. Thus, the system call handler reads the <tt class="calibre25">esp</tt> register, computes the address of the <tt class="calibre25">esp0</tt> field of the local TSS, and loads into the same <tt class="calibre25">esp</tt> register the proper kernel stack pointer.</p>
<a name="understandlk-CHP-10-SECT-3.2.2"></a>
<h5 class="docSection3Title">10.3.2.2. The vsyscall page</h5><a name="IDX-CHP-10-2527"></a>
<p class="docText1">A wrapper function in the <span class="docEmphasis">libc</span> standard library can make use of the <tt class="calibre25">sysenter</tt> instruction only if both the CPU and the Linux kernel support it.</p>
<p class="docText1">This compatibility problem calls for a quite sophisticated solution. Essentially, in the initialization phase the <tt class="calibre25">sysenter_setup( )</tt> function builds a page frame called <span class="docEmphasis">vsyscall page</span><a name="IDX-CHP-10-2528"></a> 
 containing a small ELF shared object (i.e., a tiny ELF dynamic library). When a process issues an <tt class="calibre25">execve( )</tt><a name="IDX-CHP-10-2529"></a> 
 system call to start executing an ELF program, the code in the vsyscall page is dynamically linked to the process address space (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-4.html#understandlk-CHP-20-TABLE-7">The exec Functions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>). The code in the vsyscall page makes use of the best available instruction to issue a system call.</p>
<p class="docText1">The <tt class="calibre25">sysenter_setup( )</tt> function allocates a new page frame for the vsyscall page and associates its physical address with the <tt class="calibre25">FIX_VSYSCALL</tt> fix-mapped linear address (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-5.html#understandlk-CHP-2-SECT-5.6">Fix-Mapped Linear Addresses</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>). Then, the function copies in the page either one of two predefined ELF shared objects:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">If the CPU does not support <tt class="calibre25">sysenter</tt>, the function builds a vsyscall page that includes the code:</p><pre class="calibre27">
    _ _kernel_vsyscall:
      int<a name="IDX-CHP-10-2530"></a> 
 $0x80
      ret</pre><br class="calibre7"/>
</li><li class="calibre12"><p class="docText1">Otherwise, if the CPU does support <tt class="calibre25">sysenter</tt>, the function builds a vsyscall page that includes the code:</p><pre class="calibre27">
    _ _kernel_vsyscall:
      pushl %ecx
      pushl %edx
      pushl %ebp
      movl %esp, %ebp
      sysenter</pre><br class="calibre7"/>
</li></ul>
<p class="docText1">When a wrapper routine in the standard library must invoke a system call, it calls the <tt class="calibre25">_ _kernel_vsyscall( )</tt> function, whatever it may be.</p>
<p class="docText1">A final compatibility problem is due to old versions of the Linux kernel that do not support the <tt class="calibre25">sysenter</tt> instruction; in this case, of course, the kernel does not build the vsyscall page and the <tt class="calibre25">_ _kernel_vsyscall( )</tt> function is not linked to the address space of the User Mode processes. When recent standard libraries recognize this fact, they simply execute the <tt class="calibre25">int $0x80</tt> instruction to invoke the system calls.</p>
<a name="understandlk-CHP-10-SECT-3.2.3"></a>
<h5 class="docSection3Title">10.3.2.3. Entering the system call</h5><a name="IDX-CHP-10-2531"></a>
<a name="IDX-CHP-10-2532"></a>
<p class="docText1">The sequence of steps performed when a system call is issued via the <tt class="calibre25">sysenter</tt> instruction is the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">The wrapper routine in the standard library loads the system call number into the <tt class="calibre25">eax</tt> register and calls the <tt class="calibre25">_ _kernel_vsyscall( )</tt> function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">_ _kernel_vsyscall( )</tt> function saves on the User Mode stack the contents of <tt class="calibre25">ebp</tt>, <tt class="calibre25">edx</tt>, and <tt class="calibre25">ecx</tt> (these registers are going to be used by the system call handler), copies the user stack pointer in <tt class="calibre25">ebp</tt>, then executes the <tt class="calibre25">sysenter</tt> instruction.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The CPU switches from User Mode to Kernel Mode, and the kernel starts executing the <tt class="calibre25">sysenter_entry( )</tt> function (pointed to by the <tt class="calibre25">SYSENTER_EIP_MSR</tt> register).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">sysenter_entry( )</tt> assembly language function performs the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Sets up the kernel stack pointer:</p><pre class="calibre60">
    movl -508(%esp), %esp
</pre><br class="calibre7"/>
<p class="docList">Initially, the <tt class="calibre25">esp</tt> register points to the first location after the local TSS, which is 512bytes long. Therefore, the instruction loads in the <tt class="calibre25">esp</tt> register the contents of the field at offset 4 in the local TSS, that is, the contents of the <tt class="calibre25">esp0</tt> field. As already explained, the <tt class="calibre25">esp0</tt> field always stores the kernel stack pointer of the current process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Enables local interrupts:</p><pre class="calibre60">
    sti
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Saves in the Kernel Mode stack the Segment Selector of the user data segment, the current user stack pointer, the <tt class="calibre25">eflags</tt><a name="IDX-CHP-10-2533"></a> 
 register, the Segment Selector of the user code segment, and the address of the instruction to be executed when exiting from the system call:</p><pre class="calibre60">
    pushl $(__USER_DS)
    pushl %ebp
    pushfl
    pushl $(__USER_CS)
    pushl $SYSENTER_RETURN
</pre><br class="calibre7"/>
<p class="docList">Observe that these instructions emulate some operations performed by the <tt class="calibre25">int</tt> assembly language instruction (steps 5c and 7 in the description of <tt class="calibre25">int</tt> in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.4">Hardware Handling of Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Restores in <tt class="calibre25">ebp</tt> the original value of the register passed by the wrapper routine:</p><pre class="calibre60">
    movl (%ebp), %ebp</pre><br class="calibre7"/>
<p class="docList">This instruction does the job, because <tt class="calibre25">_ _kernel_vsyscall( )</tt> saved on the User Mode stack the original value of <tt class="calibre25">ebp</tt> and then loaded in <tt class="calibre25">ebp</tt> the current value of the user stack pointer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the system call handler by executing a sequence of instructions identical to that starting at the <tt class="calibre25">system_call</tt> label described in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-10-SECT-3.1">Issuing a System Call via the int $0x80 Instruction</a>."</p></div></li></ol></div></div></li></ol></div>
<a name="understandlk-CHP-10-SECT-3.2.4"></a>
<h5 class="docSection3Title">10.3.2.4. Exiting from the system call</h5><a name="IDX-CHP-10-2534"></a>
<p class="docText1">When the system call service routine terminates, the <tt class="calibre25">sysenter_entry( )</tt> function executes essentially the same operations as the <tt class="calibre25">system_call( )</tt> function (see previous section). First, it gets the return code of the system call service routine from <tt class="calibre25">eax</tt> and stores it in the kernel stack location where the User Mode value of the <tt class="calibre25">eax</tt> register is saved. Then, the function disables the local interrupts and checks the flags in the <tt class="calibre25">thread_info</tt> structure of <tt class="calibre25">current</tt>.</p>
<p class="docText1">If any of the flags is set, then there is some work to be done before returning to User Mode. In order to avoid code duplication, this case is handled exactly as in the <tt class="calibre25">system_call( )</tt> function, thus the function jumps to the <tt class="calibre25">resume_userspace</tt> or <tt class="calibre25">work_pending</tt> labels (see flow diagram in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-FIG-6">Figure 4-6</a> in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). Eventually, the <tt class="calibre25">iret</tt><a name="IDX-CHP-10-2535"></a> 
 assembly language instruction fetches from the Kernel Mode stack the five arguments saved in step 4c by the <tt class="calibre25">sysenter_entry( )</tt> function, and thus switches the CPU back to User Mode and starts executing the code at the <tt class="calibre25">SYSENTER_RETURN</tt> label (see below).</p>
<p class="docText1">If the <tt class="calibre25">sysenter_entry( )</tt> function determines that the flags are cleared, it performs a quick return to User Mode:</p>
<pre class="calibre27">
    movl 40(%esp), %edx
    movl 52(%esp), %ecx
    xorl %ebp, %ebp
    sti
    sysexit</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">edx</tt> and <tt class="calibre25">ecx</tt> registers are loaded with a couple of the stack values saved by <tt class="calibre25">sysenter_entry( )</tt> in step 4c in the previos section: <tt class="calibre25">edx</tt> gets the address of the <tt class="calibre25">SYSENTER_RETURN</tt> label, while <tt class="calibre25">ecx</tt> gets the current user data stack pointer.</p>
<a name="understandlk-CHP-10-SECT-3.2.5"></a>
<h5 class="docSection3Title">10.3.2.5. The sysexit instruction</h5>
<p class="docText1">The <tt class="calibre25">sysexit</tt> assembly language instruction is the companion of <tt class="calibre25">sysenter</tt>: it allows a fast switch from Kernel Mode to User Mode. When the instruction is executed, the CPU control unit performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Adds 16 to the value in the <tt class="calibre25">SYSENTER_CS_MSR</tt> register, and loads the result in the <tt class="calibre25">cs</tt> register.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the content of the <tt class="calibre25">edx</tt> register into the <tt class="calibre25">eip</tt> register.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds 24 to the value in the <tt class="calibre25">SYSENTER_CS_MSR</tt> register, and loads the result in the <tt class="calibre25">ss</tt> register.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the content of the <tt class="calibre25">ecx</tt> register into the <tt class="calibre25">esp</tt> register.</p></div></li></ol></div>
<p class="docText1">Because the <tt class="calibre25">SYSENTER_CS_MSR</tt> register is loaded with the Segment Selector of the kernel code, the <tt class="calibre25">cs</tt> register is loaded with the Segment Selector of the user code, while the <tt class="calibre25">ss</tt> register is loaded with the Segment Selector of the user data segment (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-3.html#understandlk-CHP-2-SECT-3.1">The Linux GDT</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>).</p>
<p class="docText1">As a result, the CPU switches from Kernel Mode to User Mode and starts executing the instruction whose address is stored in the <tt class="calibre25">edx</tt> register.</p>
<a name="understandlk-CHP-10-SECT-3.2.6"></a>
<h5 class="docSection3Title">10.3.2.6. The SYSENTER_RETURN code</h5>
<p class="docText1">The code at the <tt class="calibre25">SYSENTER_RETURN</tt> label is stored in the vsyscall page, and it is executed when a system call entered via <tt class="calibre25">sysenter</tt> is being terminated, either by the <tt class="calibre25">iret</tt> instruction or the <tt class="calibre25">sysexit</tt> instruction.</p>
<p class="docText1">The code simply restores the original contents of the <tt class="calibre25">ebp</tt>, <tt class="calibre25">edx</tt>, and <tt class="calibre25">ecx</tt> registers saved in the User Mode stack, and returns the control to the wrapper routine in the standard library:</p>
<pre class="calibre27">
    SYSENTER_RETURN:
      popl %ebp
      popl %edx
      popl %ecx
      ret</pre><br class="calibre7"/>

<br class="calibre7"/>

</div>

{% endraw %}

