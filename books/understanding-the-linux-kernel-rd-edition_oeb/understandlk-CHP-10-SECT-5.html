---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-10-SECT-4.html
next: understandlk-CHP-11.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-10-SECT-5"></a>
<h3 class="docSection1Title">10.5. Kernel Wrapper Routines</h3><a name="IDX-CHP-10-2584"></a>
<a name="IDX-CHP-10-2585"></a>
<a name="IDX-CHP-10-2586"></a>
<p class="docText1">Although system calls are used mainly by User Mode processes, they can also be invoked by kernel threads<a name="IDX-CHP-10-2587"></a> 
, which cannot use library functions. To simplify the declarations of the corresponding wrapper routines<a name="IDX-CHP-10-2588"></a> 
, Linux defines a set of seven macros called <tt class="calibre25">_syscall0</tt> through <tt class="calibre25">_syscall6</tt>.</p>
<p class="docText1">In the name of each macro, the numbers 0 through 6 correspond to the number of parameters used by the system call (excluding the system call number). The macros are used to declare wrapper routines that are not already included in the <span class="docEmphasis">libc</span> standard library (for instance, because the Linux system call is not yet supported by the library); however, they cannot be used to define wrapper routines for system calls that have more than six parameters (excluding the system call number) or for system calls that yield nonstandard return values.</p>
<p class="docText1">Each macro requires exactly 2 + 2 x <span class="docEmphasis">n</span> parameters, with <span class="docEmphasis">n</span> being the number of parameters of the system call. The first two parameters specify the return type and the name of the system call; each additional pair of parameters specifies the type and the name of the corresponding system call parameter. Thus, for instance, the wrapper routine of the <tt class="calibre25">fork( )</tt><a name="IDX-CHP-10-2589"></a> 
 system call may be generated by:</p>
<pre class="calibre27">
    _syscall0(int,fork)</pre><br class="calibre7"/>
<p class="docText1">while the wrapper routine of the <tt class="calibre25">write( )</tt><a name="IDX-CHP-10-2590"></a> 
 system call may be generated by:</p>
<pre class="calibre27">
    _syscall3(int,write,int,fd,const char *,buf,unsigned int,count)</pre><br class="calibre7"/>
<p class="docText1">In the latter case, the macro yields the following code:</p>
<pre class="calibre27">
    int write(int fd,const char * buf,unsigned int count)
    {
        long _ _res;
        asm("int $0x80"
            : "=a" (_ _res)
            : "0" (_ _NR_write), "b" ((long)fd),
              "c" ((long)buf), "d" ((long)count));
        if ((unsigned long)_ _res &gt;= (unsigned long)-129) {
            errno = -_ _res;
            _ _res = -1;
        }
        return (int) _ _res;
    }</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">_ _NR_write</tt> macro is derived from the second parameter of <tt class="calibre25">_syscall3</tt>; it expands into the system call number of <tt class="calibre25">write( )</tt>. When compiling the preceding function, the following assembly language code is produced:</p>
<pre class="calibre27">
    write:
         pushl %ebx              ; push ebx into stack
         movl 8(%esp), %ebx      ; put first parameter in ebx
         movl 12(%esp), %ecx     ; put second parameter in ecx
         movl 16(%esp), %edx     ; put third parameter in edx
         movl $4, %eax           ; put _ _NR_write in eax
         int<a name="IDX-CHP-10-2591"></a> 
 $0x80               ; invoke system call
         cmpl $-125, %eax        ; check return code
         jbe .L1                 ; if no error, jump
         negl %eax               ; complement the value of eax
         movl %eax, errno        ; put result in errno
         movl $-1, %eax          ; set eax to -1
    .L1: popl %ebx               ; pop ebx from stack
         ret                     ; return to calling program</pre><br class="calibre7"/>
<p class="docText1">Notice how the parameters of the <tt class="calibre25">write( )</tt> function are loaded into the CPU registers before the <tt class="calibre25">int $0x80</tt> instruction is executed. The value returned in <tt class="calibre25">eax</tt> must be interpreted as an error code if it lies between -1 and -129 (the kernel assumes that the largest error code defined in <span class="docEmphasis">include/generic/errno.h</span> is 129). If this is the case, the wrapper routine stores the value of <tt class="calibre25">-eax</tt> in <tt class="calibre25">errno</tt> and returns the value -1; otherwise, it returns the value of <tt class="calibre25">eax</tt>.</p>

<br class="calibre7"/>

</div>

{% endraw %}

