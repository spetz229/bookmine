---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-19.html
next: understandlk-CHP-19-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-19-SECT-1"></a>
<h3 class="docSection1Title" id="534871-937">19.1. Pipes</h3>
<p class="docText1">Pipes are an interprocess communication mechanism that is provided in all flavors of Unix. A <span class="docEmphasis">pipe</span> is a one-way flow of data between processes: all data written by a process to the pipe is routed by the kernel to another process, which can thus read it.</p>
<p class="docText1">In Unix command shells, pipes<a name="IDX-CHP-19-4519"></a> 
 can be created by means of the <tt class="calibre25">|</tt> operator. For instance, the following statement instructs the shell to create two processes connected by a pipe:</p>
<pre class="calibre27">
$ ls | more</pre><br class="calibre7"/>
<p class="docText1">The standard output of the first process, which executes the <i class="docEmphasis">ls</i> program, is redirected to the pipe; the second process, which executes the <i class="docEmphasis">more</i> program, reads its input from the pipe.</p>
<p class="docText1">Note that the same results can also be obtained by issuing two commands such as the following:</p>
<pre class="calibre27">
$ ls &gt; temp
$ more &lt; temp</pre><br class="calibre7"/>
<p class="docText1">The first command redirects the output of <i class="docEmphasis">ls</i> into a regular file; then the second command forces <i class="docEmphasis">more</i> to read its input from the same file. Of course, using pipes instead of temporary files is usually more convenient due to the following reasons:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The shell statement is much shorter and simpler.</p></li><li class="calibre12"><p class="docText1">There is no need to create temporary regular files, which must be deleted later.</p></li></ul>
<a name="understandlk-CHP-19-SECT-1.1"></a>
<h4 class="docSection2Title">19.1.1. Using a Pipe</h4><a name="IDX-CHP-19-4520"></a>
<a name="IDX-CHP-19-4521"></a>
<a name="IDX-CHP-19-4522"></a>
<a name="IDX-CHP-19-4523"></a>
<a name="IDX-CHP-19-4524"></a>
<a name="IDX-CHP-19-4525"></a>
<a name="IDX-CHP-19-4526"></a>
<a name="IDX-CHP-19-4527"></a>
<a name="IDX-CHP-19-4528"></a>
<a name="IDX-CHP-19-4529"></a>
<a name="IDX-CHP-19-4530"></a>
<a name="IDX-CHP-19-4531"></a>
<p class="docText1">Pipes may be considered open files that have no corresponding image in the mounted filesystems. A process creates a new pipe by means of the <tt class="calibre25">pipe( )</tt> system call, which returns a pair of file descriptors<a name="IDX-CHP-19-4532"></a> 
; the process may then pass these descriptors to its descendants through <tt class="calibre25">fork( )</tt><a name="IDX-CHP-19-4533"></a> 
, thus sharing the pipe with them. The processes can read from the pipe by using the <tt class="calibre25">read( )</tt> system call with the first file descriptor; likewise, they can write into the pipe by using the <tt class="calibre25">write( )</tt> system call with the second file descriptor.</p>
<p class="docText1">POSIX defines only <span class="docEmphasis">half-duplex pipes</span><a name="IDX-CHP-19-4534"></a> 
, so even though the <tt class="calibre25">pipe( )</tt> system call returns two file descriptors, each process must close one before using the other. If a two-way flow of data is required, the processes must use two different pipes by invoking <tt class="calibre25">pipe( )</tt> twice.</p>
<p class="docText1">Several Unix systems, such as System V<a name="IDX-CHP-19-4535"></a> 
 Release 4, implement full-duplex pipes<a name="IDX-CHP-19-4536"></a> 
. In a <span class="docEmphasis">full-duplex pipe</span>, both descriptors can be written into and read from, thus there are two bidirectional channels of information. Linux adopts yet another approach: each pipe's file descriptors are still one-way, but it is not necessary to close one of them before using the other.</p>
<p class="docText1">Let's resume the previous example. When the command shell interprets the <tt class="calibre25">ls|more</tt> statement, it essentially performs the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">pipe( )</tt> system call; let's assume that <tt class="calibre25">pipe( )</tt> returns the file descriptors 3 (the pipe's <span class="docEmphasis">read channel</span>) and 4 (the <span class="docEmphasis">write channel</span>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">fork( )</tt> system call twice.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">close( )</tt> system call twice to release file descriptors 3 and 4.</p></div></li></ol></div>
<p class="docText1">The first child process, which must execute the <i class="docEmphasis">ls</i> program, performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">dup2(4,1)</tt> to copy file descriptor 4 to file descriptor 1. From now on, file descriptor 1 refers to the pipe's write channel.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">close( )</tt> system call twice to release file descriptors 3 and 4.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">execve( )</tt> system call to execute the <i class="docEmphasis">ls</i> program (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-4.html#understandlk-CHP-20-SECT-4">The exec Functions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>). The program writes its output to the file that has file descriptor 1 (the standard output); i.e., it writes into the pipe.</p></div></li></ol></div>
<p class="docText1">The second child process must execute the <i class="docEmphasis">more</i> program; therefore, it performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">dup2(3,0)</tt> to copy file descriptor 3 to file descriptor 0. From now on, file descriptor 0 refers to the pipe's read channel.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">close( )</tt> system call twice to release file descriptors 3 and 4.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">execve( )</tt> system call to execute <i class="docEmphasis">more</i>. By default, that program reads its input from the file that has file descriptor 0 (the standard input); i.e., it reads from the pipe.</p></div></li></ol></div>
<p class="docText1">In this simple example, the pipe is used by exactly two processes. Because of its implementation, though, a pipe can be used by an arbitrary number of processes.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-FN1">[*]</a></sup> Clearly, if two or more processes read or write the same pipe, they must explicitly synchronize their accesses by using file locking (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-7.html#understandlk-CHP-12-SECT-7.1">Linux File Locking</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>) or IPC semaphores (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19-SECT-3.html#understandlk-CHP-19-SECT-3.3">IPC Semaphores</a>" later in this chapter).</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-19-FN1">[*]</a></sup> Because most shells offer pipes that connect only two processes, applications requiring pipes used by more than two processes must be coded in a programming language such as C.</p></blockquote>
<p class="docText1">Many Unix systems provide, besides the <tt class="calibre25">pipe( )</tt> system call, two wrapper functions named <tt class="calibre25">popen( )</tt> and <tt class="calibre25">pclose( )</tt> that handle all the dirty work usually done when using pipes. Once a pipe has been created by means of the <tt class="calibre25">popen( )</tt> function, it can be used with the high-level I/O functions included in the C library (<tt class="calibre25">fprintf( )</tt>, <tt class="calibre25">fscanf( )</tt>, and so on.</p>
<p class="docText1">In Linux, <tt class="calibre25">popen( )</tt> and <tt class="calibre25">pclose( )</tt> are included in the C library. The <tt class="calibre25">popen( )</tt> function receives two parameters: the <tt class="calibre25">filename</tt> pathname of an executable file and a <tt class="calibre25">type</tt> string specifying the direction of the data transfer. It returns the pointer to a <tt class="calibre25">FILE</tt> data structure. The <tt class="calibre25">popen( )</tt> function essentially performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Creates a new pipe by using the <tt class="calibre25">pipe( )</tt> system call.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Forks a new process, which in turn executes the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">type</tt> is <tt class="calibre25">r</tt>, it duplicates the file descriptor associated with the pipe's write channel as file descriptor 1 (standard output); otherwise, if <tt class="calibre25">type</tt> is <tt class="calibre25">w</tt>, it duplicates the file descriptor associated with the pipe's read channel as file descriptor 0 (standard input).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Closes the file descriptors returned by <tt class="calibre25">pipe( ).</tt></p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">execve( )</tt> system call to execute the program specified by <tt class="calibre25">filename.</tt></p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">type</tt> is <tt class="calibre25">r</tt>, it closes the file descriptor associated with the pipe's write channel; otherwise, if <tt class="calibre25">type</tt> is <tt class="calibre25">w</tt>, it closes the file descriptor associated with the pipe's read channel.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address of the <tt class="calibre25">FILE</tt> file pointer that refers to whichever file descriptor for the pipe is still open.</p></div></li></ol></div>
<p class="docText1">After the <tt class="calibre25">popen( )</tt> invocation, parent and child can exchange information through the pipe: the parent can read (if <tt class="calibre25">type</tt> is <tt class="calibre25">r</tt>) or write (if <tt class="calibre25">type</tt> is <tt class="calibre25">w</tt>) data by using the <tt class="calibre25">FILE</tt> pointer returned by the function. The data is written to the standard output or read from the standard input, respectively, by the program executed by the child process.</p>
<p class="docText1">The <tt class="calibre25">pclose( )</tt> function (which receives the file pointer returned by <tt class="calibre25">popen( )</tt> as its parameter) simply invokes the <tt class="calibre25">wait4( )</tt> system call and waits for the termination of the process created by <tt class="calibre25">popen( )</tt>.</p>
<a name="understandlk-CHP-19-SECT-1.2"></a>
<h4 class="docSection2Title">19.1.2. Pipe Data Structures</h4><a name="IDX-CHP-19-4537"></a>
<a name="IDX-CHP-19-4538"></a>
<a name="IDX-CHP-19-4539"></a>
<a name="IDX-CHP-19-4540"></a>
<a name="IDX-CHP-19-4541"></a>
<a name="IDX-CHP-19-4542"></a>
<a name="IDX-CHP-19-4543"></a>
<a name="IDX-CHP-19-4544"></a>
<a name="IDX-CHP-19-4545"></a>
<a name="IDX-CHP-19-4546"></a>
<p class="docText1">We now have to start thinking again at the system call level. Once a pipe is created, a process uses the <tt class="calibre25">read( )</tt> and <tt class="calibre25">write( )</tt> VFS system calls to access it. Therefore, for each pipe, the kernel creates an inode object plus two file objectsone for reading and the other for writing. When a process wants to read from or write to the pipe, it must use the proper file descriptor.</p>
<p class="docText1">When the inode object refers to a pipe, its <tt class="calibre25">i_pipe</tt> field points to a <tt class="calibre25">pipe_inode_info</tt> structure shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-1">Table 19-1</a>.</p>
<a name="understandlk-CHP-19-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 19-1. The pipe_inode_info structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct wait_queue *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">wait</tt></p></td><td class="docTableCell"><p class="docText2">Pipe/FIFO wait queue</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">nrbufs</tt></p></td><td class="docTableCell"><p class="docText2">Number of buffers containing data to be read</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">curbuf</tt></p></td><td class="docTableCell"><p class="docText2">Index of first buffer containing data to be read</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct pipe_buffer [16]</p></td><td class="docTableCell"><p class="docText2">bufs</p></td><td class="docTableCell"><p class="docText2">Array of pipe's buffer descriptors</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct page *</p></td><td class="docTableCell"><p class="docText2">tmp_page</p></td><td class="docTableCell"><p class="docText2">Pointer to a cached page frame</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">start</tt></p></td><td class="docTableCell"><p class="docText2">Read position in current pipe buffer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">readers</tt></p></td><td class="docTableCell"><p class="docText2">Flag for (or number of) reading processes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">writers</tt></p></td><td class="docTableCell"><p class="docText2">Flag for (or number of) writing processes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">waiting_writers</tt></p></td><td class="docTableCell"><p class="docText2">Number of writing processes sleeping in the wait queue</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">r_counter</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">readers</tt>, but used when waiting for a process that reads from the FIFO</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">w_counter</tt></p></td><td class="docTableCell"><p class="docText2">Like <tt class="calibre25">writers</tt>, but used when waiting for a process that writes into the FIFO</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct</p><p class="docText2">fasync_struct *</p></td><td class="docTableCell"><p class="docText2">fasync_readers</p></td><td class="docTableCell"><p class="docText2">Used for asynchronous I/O notification via signals</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct</p><p class="docText2">fasync_struct *</p></td><td class="docTableCell"><p class="docText2">fasync_writers</p></td><td class="docTableCell"><p class="docText2">Used for asynchronous I/O notification via signals</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Besides one inode and two file objects, each pipe has its own set of <span class="docEmphasis">pipe buffers</span><a name="IDX-CHP-19-4547"></a> 
. Essentially, a pipe buffer is a page frame that contains data written into the pipe and yet to be read. Up to Linux 2.6.10, each pipe had just one pipe buffer. In the 2.6.11 kernel, however, data buffering for pipes (and FIFOs) has been heavily revised, and now each pipe makes use of 16 pipe buffers. This change greatly enhances the performance of User Mode applications that write large chunks of data in a pipe.</p>
<p class="docText1">The <tt class="calibre25">bufs</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure stores an array of 16 <tt class="calibre25">pipe_buffer</tt> objects, each of which describes a pipe buffer. The fields of this object are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-2">Table 19-2</a>.</p>
<a name="understandlk-CHP-19-TABLE-2"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 19-2. The fields of the pipe_buffer object</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct page *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">page</tt></p></td><td class="docTableCell"><p class="docText2">Address of the descriptor of the page frame for the pipe buffer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">offset</tt></p></td><td class="docTableCell"><p class="docText2">Current position of the significant data inside the page frame</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">len</tt></p></td><td class="docTableCell"><p class="docText2">Length of the significant data in the pipe buffer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">pipe_buf_operations *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">ops</tt></p></td><td class="docTableCell"><p class="docText2">Address of a table of methods relative to the pipe buffer (<tt class="calibre25">NULL</tt> if the pipe buffer is empty)</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">ops</tt> field points to the <tt class="calibre25">anon_pipe_buf_ops</tt> table of the pipe buffer's methods, which is a data structure of type <tt class="calibre25">pipe_buf_operations</tt>. Essentially, the table includes three methods:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">map</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Invoked before accessing data in the pipe buffer. It simply invokes <tt class="calibre25">kmap( )</tt> on the pipe buffer's page frame, just in case the pipe buffer is stored in high memory (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-1.html#understandlk-CHP-8-SECT-1.6">Kernel Mappings of High-Memory Page Frames</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>).</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unmap</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Invoked when no longer accessing data in the pipe buffer. It invokes <tt class="calibre25">kunmap( )</tt> on the pipe buffer's page frame.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">release</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Invoked when a pipe buffer is being released. The method implements a one-page memory cache: the page frame released is not the one storing the buffer, but a cached page frame pointed to by the <tt class="calibre25">tmp_page</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure (if not <tt class="calibre25">NULL</tt>). The page frame that stored the buffer becomes the new cached page frame.</p></dd></dl>
<p class="docText1">The 16 pipe buffers can be seen as a global, circular buffer: writing processes keep adding data to this large buffer, while reading process keep removing them. The number of bytes currently written in all pipe buffers and yet to be read is the so-called <span class="docEmphasis">pipe size</span>. For reasons of efficiency, the data yet to be read can be spread among several partially filled pipe buffers: in fact, each write operation may copy the data in a fresh, empty pipe buffer if the previous pipe buffer has not enough free space to store the new data. Hence, the kernel must keep track of:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The pipe buffer that includes the next byte to be read, and the corresponding offset inside the page frame. The index of this pipe buffer is stored in the <tt class="calibre25">curbuf</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure, while the offset is stored in the <tt class="calibre25">offset</tt> field of the corresponding <tt class="calibre25">pipe_buffer</tt> object.</p></li><li class="calibre12"><p class="docText1">The first empty pipe buffer. Its index can be computed by adding (modulo 16) the index of the current pipe buffer, which is stored in the <tt class="calibre25">curbuf</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure, and the number of pipe buffers with significant data, which is stored in the <tt class="calibre25">nrbufs</tt> field.</p></li></ul>
<p class="docText1">To avoid race conditions on the pipe's data structures, the kernel makes use of the <tt class="calibre25">i_sem</tt> semaphore included in the inode object.</p>
<a name="understandlk-CHP-19-SECT-1.2.1"></a>
<h5 class="docSection3Title">19.1.2.1. The pipefs special filesystem</h5><a name="IDX-CHP-19-4548"></a>
<a name="IDX-CHP-19-4549"></a>
<a name="IDX-CHP-19-4550"></a>
<a name="IDX-CHP-19-4551"></a>
<a name="IDX-CHP-19-4552"></a>
<a name="IDX-CHP-19-4553"></a>
<a name="IDX-CHP-19-4554"></a>
<a name="IDX-CHP-19-4555"></a>
<a name="IDX-CHP-19-4556"></a>
<p class="docText1">A pipe is implemented as a set of VFS objects, which have no corresponding disk images. In Linux 2.6, these VFS objects are organized into the <span class="docEmphasis">pipefs</span> special filesystem to expedite their handling (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-3.html#understandlk-CHP-12-SECT-3.1">Special Filesystems</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>). Because this filesystem has no mount point in the system directory tree, users never see it. However, thanks to <span class="docEmphasis">pipefs</span>, the pipes are fully integrated in the VFS layer, and the kernel can handle them in the same way as named pipes or FIFOs, which truly exist as files recognizable to end users (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19-SECT-2.html#understandlk-CHP-19-SECT-2">FIFOs</a>").</p>
<p class="docText1">The <tt class="calibre25">init_pipe_fs( )</tt> function, typically executed during kernel initialization, registers the <span class="docEmphasis">pipefs</span> filesystem and mounts it (refer to the discussion in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-4.html#understandlk-CHP-12-SECT-4.3">Mounting a Generic Filesystem</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>):</p>
<pre class="calibre27">
struct file_system_type pipe_fs_type;
pipe_fs_type.name = "pipefs";
pipe_fs_type.get_sb = pipefs_get_sb;
pipe_fs.kill_sb = kill_anon_super;
register_filesystem(&amp;pipe_fs_type);
pipe_mnt = do_kern_mount("pipefs", 0, "pipefs", NULL);</pre><br class="calibre7"/>
<p class="docText1">The mounted filesystem object that represents the root directory of <span class="docEmphasis">pipefs</span> is stored in the <tt class="calibre25">pipe_mnt</tt> variable.</p>
<a name="understandlk-CHP-19-SECT-1.3"></a>
<h4 class="docSection2Title">19.1.3. Creating and Destroying a Pipe</h4><a name="IDX-CHP-19-4557"></a>
<a name="IDX-CHP-19-4558"></a>
<a name="IDX-CHP-19-4559"></a>
<a name="IDX-CHP-19-4560"></a>
<p class="docText1">The <tt class="calibre25">pipe( )</tt> system call is serviced by the <tt class="calibre25">sys_pipe( )</tt> function, which in turn invokes the <tt class="calibre25">do_pipe( )</tt> function. To create a new pipe, <tt class="calibre25">do_pipe( )</tt> performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">get_pipe_inode( )</tt> function, which allocates and initializes an inode object for the pipe in the <span class="docEmphasis">pipefs</span> filesystem. In particular, this function executes the following actions:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a new inode in the <span class="docEmphasis">pipefs</span> filesystem.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a <tt class="calibre25">pipe_inode_info</tt> data structure and stores its address in the <tt class="calibre25">i_pipe</tt> field of the inode.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">curbuf</tt> and <tt class="calibre25">nrbufs</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> structure to 0; also, fills with zeros all fields of the pipe buffer objects in the <tt class="calibre25">bufs</tt> array.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">r_counter</tt> and <tt class="calibre25">w_counter</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> structure to 1.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">readers</tt> and <tt class="calibre25">writers</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> structure to 1.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a file object and a file descriptor for the read channel of the pipe, sets the <tt class="calibre25">f_flag</tt> field of the file object to <tt class="calibre25">O_RDONLY</tt>, and initializes the <tt class="calibre25">f_op</tt> field with the address of the <tt class="calibre25">read_ pipe_fops</tt> table.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a file object and a file descriptor for the write channel of the pipe, sets the <tt class="calibre25">flag</tt> field of the file object to <tt class="calibre25">O_WRONLY</tt>, and initializes the <tt class="calibre25">f_op</tt> field with the address of the <tt class="calibre25">write_ pipe_fops</tt> table.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a dentry object and uses it to link the two file objects and the inode object (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-1.html#understandlk-CHP-12-SECT-1.1">The Common File Model</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>); then inserts the new inode in the <span class="docEmphasis">pipefs</span> special filesystem.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the two file descriptors<a name="IDX-CHP-19-4561"></a> 
 to the User Mode process.</p></div></li></ol></div>
<p class="docText1">The process that issues a <tt class="calibre25">pipe( )</tt> system call is initially the only process that can access the new pipe, both for reading and writing. To represent that the pipe has both a reader and a writer, the <tt class="calibre25">readers</tt> and <tt class="calibre25">writers</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> data structure are initialized to 1. In general, each of these two fields is set to 1 only if the corresponding pipe's file object is still opened by a process; the field is set to 0 if the corresponding file object has been released, because it is no longer accessed by any process.</p>
<p class="docText1">Forking a new process does not increase the value of the <tt class="calibre25">readers</tt> and <tt class="calibre25">writers</tt> fields, so they never rise above 1;<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-FN2">[*]</a></sup> however, it does increase the value of the usage counters of all file objects still used by the parent process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.1">The clone( ), fork( ), and vfork( ) System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). Thus, the objects are not released even when the parent dies, and the pipe stays open for use by the children.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-19-FN2">[*]</a></sup> As we'll see, the <tt class="calibre42">readers</tt> and <tt class="calibre42">writers</tt> fields act as counters instead of flags when associated with FIFOs.</p></blockquote>
<p class="docText1">Whenever a process invokes the <tt class="calibre25">close( )</tt> system call on a file descriptor associated with a pipe, the kernel executes the <tt class="calibre25">fput( )</tt> function on the corresponding file object, which decreases the usage counter. If the counter becomes 0, the function invokes the <tt class="calibre25">release</tt> method of the file operations (see the sections "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-6.html#understandlk-CHP-12-SECT-6.3">The close( ) System Call</a>" and "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.6">Files Associated with a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>).</p>
<p class="docText1">Depending on whether the file is associated with the read or write channel, the <tt class="calibre25">release</tt> method is implemented by either <tt class="calibre25">pipe_read_release( )</tt> or <tt class="calibre25">pipe_write_release( )</tt>; both functions invoke <tt class="calibre25">pipe_release( )</tt>, which sets either the <tt class="calibre25">readers</tt> field or the <tt class="calibre25">writers</tt> field of the <tt class="calibre25">pipe_inode_info</tt> structure to 0. The function checks whether both the <tt class="calibre25">readers</tt> and <tt class="calibre25">writers</tt> fields are equal to 0; in this case, it invokes the pipe buffer's <tt class="calibre25">release</tt> method of all pipe buffers, thus releasing to the buddy system all pipe's page frames; moreover, the function releases the cached page frame pointed to by the <tt class="calibre25">tmp_page</tt> field. Otherwise, if either the <tt class="calibre25">readers</tt> field or the <tt class="calibre25">writers</tt> field is not zero, the function wakes up the processes sleeping in the pipe's wait queue so they can recognize the change in the pipe state.</p>
<a name="understandlk-CHP-19-SECT-1.4"></a>
<h4 class="docSection2Title">19.1.4. Reading from a Pipe</h4><a name="IDX-CHP-19-4562"></a>
<a name="IDX-CHP-19-4563"></a>
<a name="IDX-CHP-19-4564"></a>
<a name="IDX-CHP-19-4565"></a>
<a name="IDX-CHP-19-4566"></a>
<a name="IDX-CHP-19-4567"></a>
<a name="IDX-CHP-19-4568"></a>
<a name="IDX-CHP-19-4569"></a>
<p class="docText1">A process wishing to get data from a pipe issues a <tt class="calibre25">read( )</tt> system call, specifying the file descriptor associated with the pipe's reading end. As described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-6.html#understandlk-CHP-12-SECT-6.2">The read( ) and write( ) System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>, the kernel ends up invoking the <tt class="calibre25">read</tt> method found in the file operation table associated with the proper file object. In the case of a pipe, the entry for the read method in the <tt class="calibre25">read_pipe_fops</tt> table points to the <tt class="calibre25">pipe_read( )</tt> function.</p>
<p class="docText1">The <tt class="calibre25">pipe_read( )</tt> function is quite involved, because the POSIX standard specifies several requirements for the pipe's read operations. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-3">Table 19-3</a> summarizes the expected behavior of a <tt class="calibre25">read( )</tt> system call that requests <span class="docEmphasis">n</span> bytes from a pipe that has a pipe size (number of bytes in the pipe buffers yet to be read) equal to <span class="docEmphasis">p</span>.</p>
<p class="docText1">The system call might block the current process in two cases:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The pipe buffer is empty when the system call starts.</p></li><li class="calibre12"><p class="docText1">The pipe buffer does not include all requested bytes, and a writing process was previously put to sleep while waiting for space in the buffer.</p></li></ul>
<p class="docText1">Notice that the read operation can be nonblocking: in this case, it completes as soon as all available bytes (even none) are copied into the user address space.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-FN3">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-19-FN3">[*]</a></sup> Nonblocking operations are usually requested by specifying the <tt class="calibre42">O_NONBLOCK</tt> flag in the <tt class="calibre42">open( )</tt> system call. This method does not work for pipes, because they cannot be opened. A process can, however, require a nonblocking operation on a pipe by issuing a <tt class="calibre42">fcntl( )</tt> system call on the corresponding file descriptor.</p></blockquote>
<p class="docText1">Notice also that the value 0 is returned by the <tt class="calibre25">read( )</tt> system call only if the pipe is empty and no process is currently using the file object associated with the pipe's write channel.</p>
<a name="understandlk-CHP-19-TABLE-3"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 19-3. Reading n bytes from a pipe</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead2" scope="col"> </th><th class="thead" scope="col" colspan="3"><p class="docText1">At least one writing process</p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">No writing process</span></p></th></tr><tr class="calibre34"><th class="thead2" scope="col"> </th><th class="thead" scope="col" colspan="2"><p class="docText1">Blocking read</p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Nonblocking read</span></p></th><th class="thead2" scope="col"> </th></tr><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Pipe Size <span class="docEmphasis">p</span></span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Sleeping writer</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">No sleeping writer</span></p></th><th class="thead2" scope="col"> </th><th class="thead2" scope="col"> </th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><span class="docEmphasis">p</span> = 0</p></td><td class="docTableCell"><p class="docText2">Copy <span class="docEmphasis">n</span> bytes and return <span class="docEmphasis">n</span>, waiting for data when the pipe buffer is empty.</p></td><td class="docTableCell"><p class="docText2">Wait for some data, copy it, and return its size.</p></td><td class="docTableCell"><p class="docText2">Return</p><p class="docText2"><tt class="calibre25">-EAGAIN</tt>.</p></td><td class="docTableCell"><p class="docText2">Return 0.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">0 &lt; <span class="docEmphasis">p</span> &lt; <span class="docEmphasis">n</span></p></td><td class="docTableCell1"> </td><td class="docTableCell" colspan="3"><p class="docText2">Copy <span class="docEmphasis">p</span> bytes and return <span class="docEmphasis">p</span>: 0 bytes are left in the pipe buffer.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><span class="docEmphasis">p</span> <img src="u2265.jpg" border="0" class="calibre10"/> <span class="docEmphasis">n</span></p></td><td class="docTableCell" colspan="4"><p class="docText2">Copy <span class="docEmphasis">n</span> bytes and return <span class="docEmphasis">n</span>: <span class="docEmphasis">p</span>-<span class="docEmphasis">n</span> bytes are left in the pipe buffer.</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The function performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">i_sem</tt> semaphore of the inode.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Determines whether the pipe size is 0 by reading the <tt class="calibre25">nrbufs</tt> field of the <tt class="calibre25">pipe_inode_info</tt> structure; if the field is equal to zero, all pipe buffers are empty. In this case, it determines whether the function must return or whether the process must be blocked while waiting until another process writes some data in the pipe (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-3">Table 19-3</a>). The type of I/O operation (blocking or nonblocking) is specified by the <tt class="calibre25">O_NONBLOCK</tt> flag in the <tt class="calibre25">f_flags</tt> field of the file object. If the current process must be blocked, the function performs the following actions:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">prepare_to_wait( )</tt> to add <tt class="calibre25">current</tt> to the wait queue of the pipe (the <tt class="calibre25">wait</tt> field of the <tt class="calibre25">pipe_inode_info</tt> structure).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the inode semaphore.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">schedule( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Once awake, invokes <tt class="calibre25">finish_wait( )</tt> to remove <tt class="calibre25">current</tt> from the wait queue, acquires again the <tt class="calibre25">i_sem</tt> inode semaphore, and then jumps back to step 2.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets the index of the current pipe buffer from the <tt class="calibre25">curbuf</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">map</tt> method of the pipe buffer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the requested number of bytesor the number of available bytes in the pipe buffer, if it is smallerfrom the pipe's buffer to the user address space.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">unmap</tt> method of the pipe buffer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the <tt class="calibre25">offset</tt> and <tt class="calibre25">len</tt> fields of the corresponding <tt class="calibre25">pipe_buffer</tt> object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the pipe buffer has been emptied (<tt class="calibre25">len</tt> fields of the <tt class="calibre25">pipe_buffer</tt> object now equal to zero), it invokes the pipe buffer's <tt class="calibre25">release</tt> method to free the corresponding page frame, sets the <tt class="calibre25">ops</tt> field in the <tt class="calibre25">pipe_buffer</tt> object to <tt class="calibre25">NULL</tt>, advances the index of the current pipe buffer stored in the <tt class="calibre25">curbuf</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure, and decreases the counter of nonempty pipe buffers in the <tt class="calibre25">nrbufs</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If all requested bytes have been copied, it jumps to step 12.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Here not all requested bytes have been copied to the User Mode address space. If the pipe size is greater than zero (<tt class="calibre25">nrbufs</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure not null), it goes back to step 3.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">There are no more bytes left in the pipe buffers. If there is at least one writing process currently sleeping (that is, the <tt class="calibre25">waiting_writers</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure is greater than 0), and the read operation is blocking, it invokes <tt class="calibre25">wake_up_interruptible_sync( )</tt> to wake up all processes sleeping on the pipe's wait queue, and jumps back to step 2.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">i_sem</tt> semaphore of the inode.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">wake_up_interruptible_sync( )</tt> to wake up all writer processes sleeping on the pipe's wait queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the number of bytes copied into the user address space.</p></div></li></ol></div>
<a name="understandlk-CHP-19-SECT-1.5"></a>
<h4 class="docSection2Title">19.1.5. Writing into a Pipe</h4><a name="IDX-CHP-19-4570"></a>
<a name="IDX-CHP-19-4571"></a>
<a name="IDX-CHP-19-4572"></a>
<a name="IDX-CHP-19-4573"></a>
<a name="IDX-CHP-19-4574"></a>
<a name="IDX-CHP-19-4575"></a>
<p class="docText1">A process wishing to put data into a pipe issues a <tt class="calibre25">write( )</tt> system call, specifying the file descriptor for the writing end of the pipe. The kernel satisfies this request by invoking the <tt class="calibre25">write</tt> method of the proper file object; the corresponding entry in the <tt class="calibre25">write_pipe_fops</tt> table points to the <tt class="calibre25">pipe_write( )</tt> function.</p>
<p class="docText1"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-4">Table 19-4</a> summarizes the behavior, specified by the POSIX standard, of a <tt class="calibre25">write( )</tt> system call that requested to write <span class="docEmphasis">n</span> bytes into a pipe having <span class="docEmphasis">u</span> unused bytes in its buffer. In particular, the standard requires that write operations involving a small number of bytes must be atomically executed. More precisely, if two or more processes are concurrently writing into<a name="IDX-CHP-19-4576"></a> 
 a pipe, each write operation involving fewer than 4,096 bytes (the pipe buffer size) must finish without being interleaved with write operations of other processes to the same pipe. However, write operations involving more than 4,096 bytes may be nonatomic and may also force the calling process to sleep.</p>
<a name="understandlk-CHP-19-TABLE-4"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 19-4. Writing n bytes to a pipe</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead2" scope="col"> </th><th class="thead" scope="col" colspan="2"><p class="docText1">At least one reading process</p></th><th class="thead2" scope="col"> </th></tr><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Available buffer space u</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Blocking write</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Nonblocking write</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">No reading process</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><span class="docEmphasis">u</span>&lt;<span class="docEmphasis">n</span><img src="u2264.jpg" border="0" class="calibre10"/> 4,096</p></td><td class="docTableCell"><p class="docText2">Wait until <span class="docEmphasis">n</span>-<span class="docEmphasis">u</span> bytes are freed, copy <span class="docEmphasis">n</span> bytes, and return <span class="docEmphasis">n</span>.</p></td><td class="docTableCell"><p class="docText2">Return <tt class="calibre25">-EAGAIN</tt>.</p></td><td class="docTableCell"><p class="docText2">Send <tt class="calibre25">SIGPIPE</tt> signal and return <tt class="calibre25">-EPIPE</tt>.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><span class="docEmphasis">n</span>&gt;4,096</p></td><td class="docTableCell"><p class="docText2">Copy <span class="docEmphasis">n</span> bytes (waiting when necessary) and return <span class="docEmphasis">n</span>.</p></td><td class="docTableCell"><p class="docText2">If <span class="docEmphasis">u</span>&gt;0, copy <span class="docEmphasis">u</span> bytes and return <span class="docEmphasis">u</span>; return <tt class="calibre25">-EAGAIN</tt>.</p></td><td class="docTableCell1"> </td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><span class="docEmphasis">u</span><img src="u2265.jpg" border="0" class="calibre10"/> <span class="docEmphasis">n</span></p></td><td class="docTableCell"><p class="docText2">Copy <span class="docEmphasis">n</span> bytes and return <span class="docEmphasis">n</span>.</p></td><td class="docTableCell1"> </td><td class="docTableCell1"> </td></tr></table></p><br class="calibre7"/>
<p class="docText1">Moreover, each write operation to a pipe must fail if the pipe does not have a reading process (that is, if the <tt class="calibre25">readers</tt> field of the pipe's inode object has the value 0). In this case, the kernel sends a <tt class="calibre25">SIGPIPE</tt> signal to the writing process and terminates the <tt class="calibre25">write( )</tt> system call with the <tt class="calibre25">-EPIPE</tt> error code, which usually leads to the familiar "Broken pipe" message.</p>
<p class="docText1">The <tt class="calibre25">pipe_write( )</tt> function performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">i_sem</tt> semaphore of the inode.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the pipe has at least one reading process. If not, it sends a <tt class="calibre25">SIGPIPE</tt> signal to the <tt class="calibre25">current</tt> process, releases the inode semaphore, and returns an <tt class="calibre25">-EPIPE</tt> value.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Determines the index of the last written pipe buffers by adding the <tt class="calibre25">curbuf</tt> and <tt class="calibre25">nrbufs</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> data structure and subtracting 1. If this pipe buffer has enough free space to store all the bytes to be written, then it copies the data into it:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">map</tt> method of the pipe buffer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies all the bytes in the pipe buffer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">unmap</tt> method of the pipe buffer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the <tt class="calibre25">len</tt> field of the corresponding <tt class="calibre25">pipe_buffer</tt> object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Jumps to step 11.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">nrbufs</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure is equal to 16, there is no empty pipe buffer to store the bytes (yet) to be written. In this case:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the write operation is nonblocking, it jumps to step 11 to terminate by returning the <tt class="calibre25">-EAGAIN</tt> error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the write operation is blocking, it adds 1 to the <tt class="calibre25">waiting_writers</tt> field of the <tt class="calibre25">pipe_inode_info</tt> structure, invokes <tt class="calibre25">prepare_to_wait( )</tt> to add <tt class="calibre25">current</tt> to the wait queue of the pipe (the <tt class="calibre25">wait</tt> field of the <tt class="calibre25">pipe_inode_info</tt> structure), releases the inode semaphore, and invokes <tt class="calibre25">schedule( )</tt>. Once awake, it invokes <tt class="calibre25">finish_wait( )</tt> to remove <tt class="calibre25">current</tt> from the wait queue, again acquires the inode semaphore, decreases the <tt class="calibre25">waiting_writers</tt> field, and then jumps back to step 4.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Now there is at least one empty pipe buffer. Determines the index of the first empty pipe buffer by adding the <tt class="calibre25">curbuf</tt> and <tt class="calibre25">nrbufs</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> data structure.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a new page frame from the buddy system, unless the <tt class="calibre25">tmp_page</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure is not <tt class="calibre25">NULL</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies up to 4,096 bytes from the User Mode address space into the page frame (temporarily mapping it in the Kernel Mode linear address space, if necessary).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the fields of the <tt class="calibre25">pipe_buffer</tt> object associated with the pipe buffer by setting the page field to the address of the page frame descriptor, the <tt class="calibre25">ops</tt> field to the address of the <tt class="calibre25">anon_pipe_buf_ops</tt> table, the <tt class="calibre25">offset</tt> field to 0, and the <tt class="calibre25">len</tt> field to the number of written bytes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases the counter of nonempty pipe buffers stored in the <tt class="calibre25">nrbufs</tt> field of the <tt class="calibre25">pipe_inode_info</tt> data structure.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If not all requested bytes were written, it jumps back to step 4.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the inode semaphore.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Wakes up all reader processes sleeping on the pipe's wait queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the number of bytes written into the pipe's buffer (or an error code if writing was not possible).</p></div></li></ol></div>

<br class="calibre7"/>

</div>

{% endraw %}

