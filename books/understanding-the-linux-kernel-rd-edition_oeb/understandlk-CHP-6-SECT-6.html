---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-6-SECT-5.html
next: understandlk-CHP-7.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-6-SECT-6"></a>
<h3 class="docSection1Title">6.6. System Calls Related to Timing Measurements</h3><a name="IDX-CHP-6-1765"></a>
<a name="IDX-CHP-6-1766"></a>
<a name="IDX-CHP-6-1767"></a>
<a name="IDX-CHP-6-1768"></a>
<a name="IDX-CHP-6-1769"></a>
<p class="docText1">Several system calls allow User Mode processes to read and modify the time and date and to create timers. Let's briefly review these and discuss how the kernel handles them.</p>
<a name="understandlk-CHP-6-SECT-6.1"></a>
<h4 class="docSection2Title">6.6.1. The time( ) and gettimeofday( ) System Calls</h4><a name="IDX-CHP-6-1770"></a>
<a name="IDX-CHP-6-1771"></a>
<a name="IDX-CHP-6-1772"></a>
<p class="docText1">Processes in User Mode can get the current time and date by means of several system calls:</p>
<a name="IDX-CHP-6-1773"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">time( )</span></span></span></p></dt><a name="IDX-CHP-6-1773"></a>
<dd class="calibre20"><p class="docList">Returns the number of elapsed seconds since midnight at the start of January 1, 1970 (UTC).</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">gettimeofday( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Returns, in a data structure named <tt class="calibre25">timeval</tt>, the number of elapsed seconds since midnight of January 1, 1970 (UTC) and the number of elapsed microseconds in the last second (a second data structure named <tt class="calibre25">timezone</tt> is not currently used).</p></dd></dl>
<p class="docText1">The <tt class="calibre25">time( )</tt> system call is superseded by <tt class="calibre25">gettimeofday( )</tt>, but it is still included in Linux for backward compatibility. Another widely used function, <tt class="calibre25">ftime( )</tt>, which is no longer implemented as a system call, returns the number of elapsed seconds since midnight of January 1, 1970 (UTC) and the number of elapsed milliseconds in the last second.</p>
<p class="docText1">The <tt class="calibre25">gettimeofday( )</tt> system call is implemented by the <tt class="calibre25">sys_gettimeofday( )</tt> function. To compute the current date and time of the day, this function invokes <tt class="calibre25">do_gettimeofday( )</tt>, which executes the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">xtime_lock</tt> seqlock for reading.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Determines the number of microseconds elapsed since the last timer interrupt by invoking the <tt class="calibre25">get_offset</tt> method of the <tt class="calibre25">cur_timer</tt> timer object:</p><pre class="calibre60">
    usec = cur_timer-&gt;getoffset( );
</pre><br class="calibre7"/>
<p class="docList">As explained in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.1">Data Structures of the Timekeeping Architecture</a>," there are four possible cases:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_hpet</tt> object, the method compares the current value of the HPET counter with the value of the same counter saved in the last execution of the timer interrupt handler.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_pmtmr</tt> object, the method compares the current value of the ACPI PMT counter with the value of the same counter saved in the last execution of the timer interrupt handler.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_tsc</tt> object, the method compares the current value of the Time Stamp Counter with the value of the TSC saved in the last execution of the timer interrupt handler.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">cur_timer</tt> points to the <tt class="calibre25">timer_pit</tt> object, the method reads the current value of the PIT counter to compute the number of microseconds elapsed since the last PIT's timer interrupt.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If some timer interrupt has been lost (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-3.html#understandlk-CHP-6-SECT-3">Updating the Time and Date</a>" earlier in this chapter), the function adds to <tt class="calibre25">usec</tt> the corresponding delay:</p><pre class="calibre60">
    usec += (jiffies - wall_jiffies) * 1000;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds to <tt class="calibre25">usec</tt> the microseconds elapsed in the last second:</p><pre class="calibre60">
    usec += (xtime.tv_nsec / 1000);
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the contents of <tt class="calibre25">xtime</tt> into the user-space buffer specified by the system call parameter <tt class="calibre25">tv</tt>, adding to the microseconds field the value of <tt class="calibre25">usec</tt>:</p><pre class="calibre60">
    tv-&gt;tv_sec = xtime-&gt;tv_sec;
    tv-&gt;tv_usec = xtime-&gt;tv_usec + usec;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">read_seqretry( )</tt> on the <tt class="calibre25">xtime_lock</tt> seqlock, and jumps back to step 1 if another kernel control path has concurrently acquired <tt class="calibre25">xtime_lock</tt> for writing.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks for an overflow in the microseconds field, adjusting both that field and the second field if necessary:</p><pre class="calibre60">
    while (tv-&gt;tv_usec &gt;= 1000000) {
        tv-&gt;tv_usec -= 1000000;
        tv-&gt;tv_sec++;
    }
</pre><br class="calibre7"/>
</div></li></ol></div>
<p class="docText1">Processes in User Mode with root privilege may modify the current date and time by using either the obsolete <tt class="calibre25">stime( )</tt> or the <tt class="calibre25">settimeofday( )</tt> system call. The <tt class="calibre25">sys_settimeofday( )</tt> function invokes <tt class="calibre25">do_settimeofday( )</tt>, which executes operations complementary to those of <tt class="calibre25">do_gettimeofday( )</tt>.</p>
<p class="docText1">Notice that both system calls modify the value of <tt class="calibre25">xtime</tt> while leaving the RTC registers unchanged. Therefore, the new time is lost when the system shuts down, unless the user executes the <i class="docEmphasis">clock</i> program to change the RTC value.</p>
<a name="understandlk-CHP-6-SECT-6.2"></a>
<h4 class="docSection2Title">6.6.2. The adjtimex( ) System Call</h4><a name="IDX-CHP-6-1774"></a>
<a name="IDX-CHP-6-1775"></a>
<a name="IDX-CHP-6-1776"></a>
<a name="IDX-CHP-6-1777"></a>
<a name="IDX-CHP-6-1778"></a>
<a name="IDX-CHP-6-1779"></a>
<a name="IDX-CHP-6-1780"></a>
<p class="docText1">Although clock drift ensures that all systems eventually move away from the correct time, changing the time abruptly is both an administrative nuisance and risky behavior. Imagine, for instance, programmers trying to build a large program and depending on file timestamps to make sure that out-of-date object files are recompiled. A large change in the system's time could confuse the <tt class="calibre25">make</tt> program and lead to an incorrect build. Keeping the clocks tuned is also important when implementing a distributed filesystem on a network of computers. In this case, it is wise to adjust the clocks of the interconnected PCs, so that the timestamp values associated with the inodes of the accessed files are coherent. Thus, systems are often configured to run a time synchronization protocol such as Network Time Protocol (NTP) on a regular basis to change the time gradually at each tick. This utility depends on the <tt class="calibre25">adjtimex( )</tt> system call in Linux.</p>
<p class="docText1">This system call is present in several Unix variants, although it should not be used in programs intended to be portable. It receives as its parameter a pointer to a <tt class="calibre25">timex</tt> structure, updates kernel parameters from the values in the <tt class="calibre25">timex</tt> fields, and returns the same structure with current kernel values. Such kernel values are used by <tt class="calibre25">update_wall_time_one_tick( )</tt> to slightly adjust the number of microseconds added to <tt class="calibre25">xtime.tv_usec</tt> at each tick.</p>
<a name="understandlk-CHP-6-SECT-6.3"></a>
<h4 class="docSection2Title">6.6.3. The setitimer( ) and alarm( ) System Calls</h4><a name="IDX-CHP-6-1781"></a>
<a name="IDX-CHP-6-1782"></a>
<a name="IDX-CHP-6-1783"></a>
<a name="IDX-CHP-6-1784"></a>
<a name="IDX-CHP-6-1785"></a>
<a name="IDX-CHP-6-1786"></a>
<a name="IDX-CHP-6-1787"></a>
<a name="IDX-CHP-6-1788"></a>
<a name="IDX-CHP-6-1789"></a>
<a name="IDX-CHP-6-1790"></a>
<a name="IDX-CHP-6-1791"></a>
<a name="IDX-CHP-6-1792"></a>
<p class="docText1">Linux allows User Mode processes to activate special timers called <span class="docEmphasis">interval timers</span><a name="IDX-CHP-6-1793"></a> 
.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-FN5">[*]</a></sup> The timers cause Unix signals (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>) to be sent periodically to the process. It is also possible to activate an interval timer so that it sends just one signal after a specified delay. Each interval timer is therefore characterized by:</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-6-FN5">[*]</a></sup> These software constructs have nothing in common with the Programmable Interval Timer chip described earlier in this chapter.</p></blockquote>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The frequency at which the signals must be emitted, or a null value if just one signal has to be generated</p></li><li class="calibre12"><p class="docText1">The time remaining until the next signal is to be generated</p></li></ul>
<p class="docText1">The earlier warning about accuracy applies to these timers. They are guaranteed to execute after the requested time has elapsed, but it is impossible to predict exactly when they will be delivered.</p>
<p class="docText1">Interval timers are activated by means of the POSIX <tt class="calibre25">setitimer( )</tt> system call. The first parameter specifies which of the following policies should be adopted:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ITIMER_REAL</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The actual elapsed time; the process receives <tt class="calibre25">SIGALRM</tt> signals.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ITIMER_VIRTUAL</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The time spent by the process in User Mode; the process receives <tt class="calibre25">SIGVTALRM</tt> signals.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ITIMER_PROF</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The time spent by the process both in User and in Kernel Mode; the process receives <tt class="calibre25">SIGPROF</tt> signals.</p></dd></dl>
<p class="docText1">The interval timers can be either single-shot or periodic. The second parameter of <tt class="calibre25">setitimer( )</tt><a name="IDX-CHP-6-1794"></a> 
 points to a structure of type <tt class="calibre25">itimerval</tt> that specifies the initial duration of the timer (in seconds and nanoseconds) and the duration to be used when the timer is automatically reactivated (or zero for single-shot timers).The third parameter of <tt class="calibre25">setitimer( )</tt> is an optional pointer to an <tt class="calibre25">itimerval</tt> structure that is filled by the system call with the previous timer parameters.</p>
<p class="docText1">To implement an interval timer for each of the preceding policies, the process descriptor includes three pairs of fields:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1"><tt class="calibre25">it_real_incr</tt> and <tt class="calibre25">it_real_value</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">it_virt_incr</tt> and <tt class="calibre25">it_virt_value</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">it_prof_incr</tt> and <tt class="calibre25">it_prof_value</tt></p></li></ul>
<p class="docText1">The first field of each pair stores the interval in ticks between two signals; the other field stores the current value of the timer.</p>
<p class="docText1">The <tt class="calibre25">ITIMER_REAL</tt> interval timer is implemented by using dynamic timers because the kernel must send signals to the process even when it is not running on the CPU. Therefore, each process descriptor includes a dynamic timer object called <tt class="calibre25">real_timer</tt>. The <tt class="calibre25">setitimer( )</tt> system call initializes the <tt class="calibre25">real_timer</tt> fields and then invokes <tt class="calibre25">add_timer( )</tt> to insert the dynamic timer in the proper list. When the timer expires, the kernel executes the <tt class="calibre25">it_real_fn( )</tt> timer function. In turn, the <tt class="calibre25">it_real_fn( )</tt> function sends a <tt class="calibre25">SIGALRM</tt> signal to the process; then, if <tt class="calibre25">it_real_incr</tt> is not null, it sets the <tt class="calibre25">expires</tt> field again, reactivating the timer.</p>
<p class="docText1">The <tt class="calibre25">ITIMER_VIRTUAL</tt> and <tt class="calibre25">ITIMER_PROF</tt> interval timers do not require dynamic timers, because they can be updated while the process is running. The <tt class="calibre25">account_it_virt( )</tt> and <tt class="calibre25">account_it_prof( )</tt> functions are invoked by <tt class="calibre25">update_ process_times( )</tt>, which is called either by the PIT's timer interrupt handler (UP) or by the local timer interrupt handlers (SMP). Therefore, the two interval timers are updated once every tick, and if they are expired, the proper signal is sent to the current process.</p>
<p class="docText1">The <tt class="calibre25">alarm( )</tt> system call sends a <tt class="calibre25">SIGALRM</tt> signal to the calling process when a specified time interval has elapsed. It is very similar to <tt class="calibre25">setitimer( )</tt> when invoked with the <tt class="calibre25">ITIMER_REAL</tt> parameter, because it uses the <tt class="calibre25">real_timer</tt> dynamic timer included in the process descriptor. Therefore, <tt class="calibre25">alarm( )</tt> and <tt class="calibre25">setitimer( )</tt> with parameter <tt class="calibre25">ITIMER_REAL</tt> cannot be used at the same time.</p>
<a name="understandlk-CHP-6-SECT-6.4"></a>
<h4 class="docSection2Title">6.6.4. System Calls for POSIX Timers</h4><a name="IDX-CHP-6-1795"></a>
<a name="IDX-CHP-6-1796"></a>
<a name="IDX-CHP-6-1797"></a>
<a name="IDX-CHP-6-1798"></a>
<a name="IDX-CHP-6-1799"></a>
<a name="IDX-CHP-6-1800"></a>
<a name="IDX-CHP-6-1801"></a>
<p class="docText1">The POSIX 1003.1b standard introduced a new type of software timers for User Mode programsin particular, for multithreaded and real-time applications. These timers are often referred to as <span class="docEmphasis">POSIX timers</span><a name="IDX-CHP-6-1802"></a> 
.</p>
<p class="docText1">Every implementation of the POSIX timers must offer to the User Mode programs a few <span class="docEmphasis">POSIX clocks</span><a name="IDX-CHP-6-1803"></a> 
, that is, virtual time sources having predefined resolutions and properties. Whenever an application wants to make use of a POSIX timer, it creates a new timer resource specifying one of the existing POSIX clocks as the timing base. The system calls that allow users to handle POSIX clocks and timers are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-TABLE-3">Table 6-3</a>.</p>
<a name="understandlk-CHP-6-TABLE-3"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 6-3. System calls for POSIX timers and clocks</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">System call</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">clock_gettime()</tt></p></td><td class="docTableCell"><p class="docText2">Gets the current value of a POSIX clock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">clock_settime( )</tt><a name="IDX-CHP-6-1804"></a>
</p></td><td class="docTableCell"><p class="docText2">Sets the current value of a POSIX clock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">clock_getres( )</tt><a name="IDX-CHP-6-1805"></a>
</p></td><td class="docTableCell"><p class="docText2">Gets the resolution of a POSIX clock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_create( )</tt><a name="IDX-CHP-6-1806"></a>
</p></td><td class="docTableCell"><p class="docText2">Creates a new POSIX timer based on a specified POSIX clock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_gettime( )</tt><a name="IDX-CHP-6-1807"></a>
</p></td><td class="docTableCell"><p class="docText2">Gets the current value and increment of a POSIX timer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_settime( )</tt><a name="IDX-CHP-6-1808"></a>
</p></td><td class="docTableCell"><p class="docText2">Sets the current value and increment of a POSIX timer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_getoverrun( )</tt><a name="IDX-CHP-6-1809"></a>
</p></td><td class="docTableCell"><p class="docText2">Gets the number of overruns of a decayed POSIX timer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">timer_delete( )</tt></p></td><td class="docTableCell"><p class="docText2">Destroys a POSIX timer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">clock_nanosleep()</p></td><td class="docTableCell"><p class="docText2">Puts the process to sleep using a POSIX clock as time source</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The Linux 2.6 kernel offers two types of POSIX clocks:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CLOCK_REALTIME</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">This virtual clock represents the real-time clock of the systemessentially the value of the <tt class="calibre25">xtime</tt> variable (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-3.html#understandlk-CHP-6-SECT-3">Updating the Time and Date</a>"). The resolution returned by the <tt class="calibre25">clock_getres( )</tt> system call is 999,848 nanoseconds, which corresponds to roughly 1000 updates of <tt class="calibre25">xtime</tt> in a second.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CLOCK_MONOTONIC</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">This virtual clock represents the real-time clock of the system purged of every time warp due to the synchronization with an external time source. Essentially, this virtual clock is represented by the sum of the two variables <tt class="calibre25">xtime</tt> and <tt class="calibre25">wall_to_monotonic</tt> (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.2">Timekeeping Architecture in Uniprocessor Systems</a>"). The resolution of this POSIX clock, returned by <tt class="calibre25">clock_getres( )</tt>, is 999,848 nanoseconds.</p></dd></dl>
<p class="docText1">The Linux kernel implements the POSIX timers by means of dynamic timers. Thus, they are similar to the traditional <tt class="calibre25">ITIMER_REAL</tt> interval timers we described in the previous section. POSIX timers, however, are much more flexible and reliable than traditional interval timers. A couple of significant differences between them are:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">When a traditional interval timer decays, the kernel always sends a <tt class="calibre25">SIGALRM</tt> signal to the process that activated the timer. Instead, when a POSIX timer decays, the kernel can send every kind of signal, either to the whole multithreaded application or to a single specified thread. The kernel can also force the execution of a notifier function in a thread of the application, or it can even do nothing (it is up to a User Mode library to handle the event).</p></li><li class="calibre12"><p class="docText1">If a traditional interval timer decays many times but the User Mode process cannot receive the <tt class="calibre25">SIGALRM</tt> signal (for instance because the signal is blocked or the process is not running), only the first signal is received: all other occurrences of <tt class="calibre25">SIGALRM</tt> are lost. The same holds for POSIX timers, but the process can invoke the <tt class="calibre25">timer_getoverrun( )</tt> system call to get the number of times the timer decayed since the generation of the first signal.</p></li></ul>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

