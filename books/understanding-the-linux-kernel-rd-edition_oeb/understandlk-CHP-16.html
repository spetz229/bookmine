---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-15-SECT-4.html
next: understandlk-CHP-16-SECT-1.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-16"></a>
<div class="calibre23"></div><h2 class="docPrefaceTitle">Chapter 16. Accessing Files</h2>
<p class="docText1">Accessing a disk-based file is a complex activity that involves the VFS abstraction layer (<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>), handling block devices (<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14.html#understandlk-CHP-14">Chapter 14</a>), and the use of the page cache (<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>). This chapter shows how the kernel builds on all those facilities to carry out file reads and writes. The topics covered in this chapter apply both to regular files stored in disk-based filesystems and to block device files; these two kinds of files will be referred to simply as "files."</p>
<p class="docText1">The stage we are working at in this chapter starts after the proper read or write method of a particular file has been called (as described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>). We show here how each read ends with the desired data delivered to a User Mode process and how each write ends with data marked ready for transfer to disk. The rest of the transfer is handled by the facilities described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14.html#understandlk-CHP-14">Chapter 14</a> and <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>.</p>
<p class="docText1">There are many different ways to access a file. In this chapter we will consider the following cases:</p>
<a name="IDX-CHP-16-3894"></a><a name="IDX-CHP-16-3895"></a><a name="IDX-CHP-16-3896"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Canonical mode</span></span></p></dt>
<dd class="calibre20"><p class="docList">The file is opened with the <tt class="calibre25">O_SYNC</tt> and <tt class="calibre25">O_DIRECT</tt> flags cleared, and its content is accessed by means of the <tt class="calibre25">read( )</tt> and <tt class="calibre25">write( )</tt> system calls. In this case, the <tt class="calibre25">read( )</tt> system call blocks the calling process until the data is copied into the User Mode address space (however, the kernel is always allowed to return fewer bytes than requested!). The <tt class="calibre25">write( )</tt> system call is different, because it terminates as soon as the data is copied into the page cache (deferred write). This case is covered in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-SECT-1">Reading and Writing a File</a>."</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Synchronous mode</span></span></p></dt>
<dd class="calibre20"><p class="docList">The file is opened with the <tt class="calibre25">O_SYNC</tt> flag setor the flag is set at a later time by the <tt class="calibre25">fcntl( )</tt><a name="IDX-CHP-16-3894"></a> 
 system call. This flag affects only the write operation (read operations are always blocking), which blocks the calling process until the data is effectively written to disk. The section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-SECT-1">Reading and Writing a File</a>" covers this case, too.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Memory mapping mode</span></span></p></dt>
<dd class="calibre20"><p class="docList">After opening the file, the application issues an <tt class="calibre25">mmap( )</tt><a name="IDX-CHP-16-3895"></a> 
 system call to map the file into memory. As a result, the file appears as an array of bytes in RAM, and the application accesses directly the array elements instead of using <tt class="calibre25">read( )</tt><a name="IDX-CHP-16-3896"></a> 
, <tt class="calibre25">write( )</tt>, or <tt class="calibre25">lseek( )</tt>. This case is discussed in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-2.html#understandlk-CHP-16-SECT-2">Memory Mapping</a>."</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Direct I/O mode</span></span></p></dt>
<dd class="calibre20"><p class="docList">The file is opened with the <tt class="calibre25">O_DIRECT</tt> flag set. Any read or write operation transfers data directly from the User Mode address space to disk, or vice versa, bypassing the page cache. We discuss this case in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-3.html#understandlk-CHP-16-SECT-3">Direct I/O Transfers</a>." (The values of the <tt class="calibre25">O_SYNC</tt> and <tt class="calibre25">O_DIRECT</tt> flags can be combined in four meaningful ways.)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Asynchronous mode</span></span></p></dt>
<dd class="calibre20"><p class="docList">The file is accessedeither through a group of POSIX APIs or by means of Linux-specific system callsin such a way to perform "asynchronous I/O:" this means the requests for data transfers never block the calling process; rather, they are carried on "in the background" while the application continues its normal execution. We discuss this case in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-4.html#understandlk-CHP-16-SECT-4">Asynchronous I/O</a>."</p></dd></dl>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

