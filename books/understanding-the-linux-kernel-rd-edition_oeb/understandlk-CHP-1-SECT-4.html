---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-1-SECT-3.html
next: understandlk-CHP-1-SECT-5.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-1-SECT-4"></a>
<h3 class="docSection1Title">1.4. Basic Operating System Concepts</h3><a name="IDX-CHP-1-0144"></a>
<a name="IDX-CHP-1-0145"></a>
<p class="docText1">Each computer system includes a basic set of programs called the <span class="docEmphasis">operating system</span>. The most important program in the set is called the <span class="docEmphasis">kernel</span>. It is loaded into RAM when the system boots and contains many critical procedures that are needed for the system to operate. The other programs are less crucial utilities; they can provide a wide variety of interactive experiences for the useras well as doing all the jobs the user bought the computer forbut the essential shape and capabilities of the system are determined by the kernel. The kernel provides key facilities to everything else on the system and determines many of the characteristics of higher software. Hence, we often use the term "operating system" as a synonym for "kernel."</p>
<p class="docText1">The operating system must fulfill two main objectives:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform.</p></li><li class="calibre12"><p class="docText1">Provide an execution environment to the applications that run on the computer system (the so-called user programs).</p></li></ul>
<p class="docText1">Some operating systems<a name="IDX-CHP-1-0146"></a> 
 allow all user programs to directly play with the hardware components (a typical example is MS-DOS<a name="IDX-CHP-1-0147"></a> 
). In contrast, a Unix-like operating system hides all low-level details concerning the physical organization of the computer from applications run by the user. When a program wants to use a hardware resource, it must issue a request to the operating system. The kernel evaluates the request and, if it chooses to grant the resource, interacts with the proper hardware components on behalf of the user program.</p>
<p class="docText1">To enforce this mechanism, modern operating systems rely on the availability of specific hardware features that forbid user programs to directly interact with low-level hardware components or to access arbitrary memory locations. In particular, the hardware introduces at least two different <span class="docEmphasis">execution modes</span> for the CPU: a nonprivileged mode for user programs and a privileged mode for the kernel. Unix calls these <span class="docEmphasis">User Mode</span><a name="IDX-CHP-1-0148"></a> 
 and <span class="docEmphasis">Kernel Mode</span><a name="IDX-CHP-1-0149"></a> 
, respectively.</p>
<p class="docText1">In the rest of this chapter, we introduce the basic concepts that have motivated the design of Unix over the past two decades, as well as Linux and other operating systems. While the concepts are probably familiar to you as a Linux user, these sections try to delve into them a bit more deeply than usual to explain the requirements they place on an operating system kernel. These broad considerations refer to virtually all Unix-like systems. The other chapters of this book will hopefully help you understand the Linux kernel internals.</p>
<a name="understandlk-CHP-1-SECT-4.1"></a>
<h4 class="docSection2Title">1.4.1. Multiuser Systems</h4><a name="IDX-CHP-1-0150"></a>
<a name="IDX-CHP-1-0151"></a>
<p class="docText1">A <span class="docEmphasis">multiuser system</span> is a computer that is able to concurrently and independently execute several applications belonging to two or more users. <span class="docEmphasis">Concurrently</span> means that applications can be active at the same time and contend for the various resources such as CPU, memory, hard disks, and so on. <span class="docEmphasis">Independently</span> means that each application can perform its task with no concern for what the applications of the other users are doing. Switching from one application to another, of course, slows down each of them and affects the response time seen by the users. Many of the complexities of modern operating system kernels, which we will examine in this book, are present to minimize the delays enforced on each program and to provide the user with responses that are as fast as possible.</p>
<p class="docText1">Multiuser operating systems must include several features:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">An authentication mechanism for verifying the user's identity</p></li><li class="calibre12"><p class="docText1">A protection mechanism against buggy user programs that could block other applications running in the system</p></li><li class="calibre12"><p class="docText1">A protection mechanism against malicious user programs that could interfere with or spy on the activity of other users</p></li><li class="calibre12"><p class="docText1">An accounting mechanism that limits the amount of resource units assigned to each user</p></li></ul>
<p class="docText1">To ensure safe protection mechanisms, operating systems must use the hardware protection associated with the CPU privileged mode. Otherwise, a user program would be able to directly access the system circuitry and overcome the imposed bounds. Unix is a multiuser system that enforces the hardware protection of system resources.</p>
<a name="understandlk-CHP-1-SECT-4.2"></a>
<h4 class="docSection2Title">1.4.2. Users and Groups</h4>
<p class="docText1">In a multiuser system, each user has a private space on the machine; typically, he owns some quota of the disk space to store files, receives private mail messages, and so on. The operating system must ensure that the private portion of a user space is visible only to its owner. In particular, it must ensure that no user can exploit a system application for the purpose of violating the private space of another user.</p>
<p class="docText1">All users are identified by a unique number called the <span class="docEmphasis">User ID</span>, or <span class="docEmphasis">UID</span>. Usually only a restricted number of persons are allowed to make use of a computer system. When one of these users starts a working session, the system asks for a <span class="docEmphasis">login name</span><a name="IDX-CHP-1-0152"></a> 
 and a <span class="docEmphasis">password</span>. If the user does not input a valid pair, the system denies access. Because the password is assumed to be secret, the user's privacy is ensured.</p>
<p class="docText1">To selectively share material with other users, each user is a member of one or more <span class="docEmphasis">user groups</span><a name="IDX-CHP-1-0153"></a> 
, which are identified by a unique number called a <span class="docEmphasis">user group ID</span><a name="IDX-CHP-1-0154"></a> 
. Each file is associated with exactly one group. For example, access can be set so the user owning the file has read and write privileges, the group has read-only privileges, and other users on the system are denied access to the file.</p>
<p class="docText1">Any Unix-like operating system has a special user called <span class="docEmphasis">root</span> or <span class="docEmphasis">superuser</span><a name="IDX-CHP-1-0155"></a> 
. The system administrator must log in as root to handle user accounts, perform maintenance tasks such as system backups and program upgrades, and so on. The root user can do almost everything, because the operating system does not apply the usual protection mechanisms to her. In particular, the root user can access every file on the system and can manipulate every running user program.</p>
<a name="understandlk-CHP-1-SECT-4.3"></a>
<h4 class="docSection2Title">1.4.3. Processes</h4><a name="IDX-CHP-1-0156"></a>
<a name="IDX-CHP-1-0157"></a>
<a name="IDX-CHP-1-0158"></a>
<a name="IDX-CHP-1-0159"></a>
<p class="docText1">All operating systems use one fundamental abstraction: the <span class="docEmphasis">process</span>. A process can be defined either as "an instance of a program in execution" or as the "execution context" of a running program. In traditional operating systems, a process executes a single sequence of instructions in an <span class="docEmphasis">address space</span>; the address space is the set of memory addresses that the process is allowed to reference. Modern operating systems allow processes<a name="IDX-CHP-1-0160"></a> 
 with multiple execution flows  that is, multiple sequences of instructions executed in the same address space.</p>
<p class="docText1">Multiuser systems must enforce an execution environment in which several processes can be active concurrently and contend for system resources, mainly the CPU. Systems that allow concurrent active processes are said to be <span class="docEmphasis">multiprogramming</span><a name="IDX-CHP-1-0161"></a> 
 or <span class="docEmphasis">multiprocessing</span><a name="IDX-CHP-1-0162"></a> 
.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-1-FN5">[*]</a></sup> It is important to distinguish programs from processes; several processes can execute the same program concurrently, while the same process can execute several programs sequentially.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-1-FN5">[*]</a></sup> Some multiprocessing operating systems are not multiuser; an example is Microsoft Windows<a name="IDX-CHP-1-0163"></a> 
 98.</p></blockquote>
<p class="docText1">On uniprocessor systems, just one process can hold the CPU, and hence just one execution flow can progress at a time. In general, the number of CPUs is always restricted, and therefore only a few processes can progress at once. An operating system component called the <span class="docEmphasis">scheduler</span> chooses the process that can progress. Some operating systems allow only <span class="docEmphasis">nonpreemptable</span> processes, which means that the scheduler is invoked only when a process voluntarily relinquishes the CPU. But processes of a multiuser system must be <span class="docEmphasis">preemptable</span>; the operating system tracks how long each process holds the CPU and periodically activates the scheduler.</p>
<p class="docText1">Unix is a multiprocessing operating system with preemptable processes<a name="IDX-CHP-1-0164"></a> 
. Even when no user is logged in and no application is running, several system processes monitor the peripheral devices. In particular, several processes listen at the system terminals waiting for user logins. When a user inputs a login name, the listening process runs a program that validates the user password. If the user identity is acknowledged, the process creates another process that runs a shell into which commands are entered. When a graphical display is activated, one process runs the window manager, and each window on the display is usually run by a separate process. When a user creates a graphics shell, one process runs the graphics windows and a second process runs the shell into which the user can enter the commands. For each user command, the shell process creates another process that executes the corresponding program.</p>
<p class="docText1">Unix-like operating systems adopt a <span class="docEmphasis">process/kernel model</span><a name="IDX-CHP-1-0165"></a> 
. Each process has the illusion that it's the only process on the machine, and it has exclusive access to the operating system services. Whenever a process makes a system call (i.e., a request to the kernel, see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>), the hardware changes the privilege mode from User Mode to Kernel Mode, and the process starts the execution of a kernel procedure with a strictly limited purpose. In this way, the operating system acts within the execution context of the process in order to satisfy its request. Whenever the request is fully satisfied, the kernel procedure forces the hardware to return to User Mode and the process continues its execution from the instruction following the system call.</p>
<a name="understandlk-CHP-1-SECT-4.4"></a>
<h4 class="docSection2Title">1.4.4. Kernel Architecture</h4><a name="IDX-CHP-1-0166"></a>
<a name="IDX-CHP-1-0167"></a>
<p class="docText1">As stated before, most Unix kernels are monolithic: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process. In contrast, <span class="docEmphasis">microkernel</span> operating systems demand a very small set of functions from the kernel, generally including a few synchronization primitives, a simple scheduler, and an interprocess communication mechanism. Several system processes that run on top of the microkernel implement other operating system-layer functions, like memory allocators, device drivers, and system call handlers.</p>
<p class="docText1">Although academic research on operating systems is oriented toward microkernels<a name="IDX-CHP-1-0168"></a> 
, such operating systems are generally slower than monolithic ones, because the explicit message passing between the different layers of the operating system has a cost. However, microkernel operating systems might have some theoretical advantages over monolithic ones. Microkernels force the system programmers to adopt a modularized approach, because each operating system layer is a relatively independent program that must interact with the other layers through well-defined and clean software interfaces. Moreover, an existing microkernel operating system can be easily ported to other architectures fairly easily, because all hardware-dependent components are generally encapsulated in the microkernel code. Finally, microkernel operating systems tend to make better use of random access memory (RAM) than monolithic ones, because system processes that aren't implementing needed functionalities might be swapped out or destroyed.</p>
<p class="docText1">To achieve many of the theoretical advantages of microkernels without introducing performance penalties, the Linux kernel offers <span class="docEmphasis">modules</span><a name="IDX-CHP-1-0169"></a> 
. A module is an object file whose code can be linked to (and unlinked from) the kernel at runtime. The object code usually consists of a set of functions that implements a filesystem, a device driver, or other features at the kernel's upper layer. The module, unlike the external layers of microkernel operating systems, does not run as a specific process. Instead, it is executed in Kernel Mode on behalf of the current process, like any other statically linked kernel function.</p>
<p class="docText1">The main advantages of using modules include:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">modularized approach</span></span></p></dt>
<dd class="calibre20"><p class="docList">Because any module can be linked and unlinked at runtime, system programmers must introduce well-defined software interfaces to access the data structures handled by modules. This makes it easy to develop new modules.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Platform independence</span></span></p></dt>
<dd class="calibre20"><p class="docList">Even if it may rely on some specific hardware features, a module doesn't depend on a fixed hardware platform. For example, a disk driver module that relies on the SCSI standard works as well on an IBM-compatible PC as it does on Hewlett-Packard's Alpha.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Frugal main memory usage</span></span></p></dt>
<dd class="calibre20"><p class="docList">A module can be linked to the running kernel when its functionality is required and unlinked when it is no longer useful; this is quite useful for small embedded systems.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor">No performance penalty</span></p></dt>
<dd class="calibre20"><p class="docList">Once linked in, the object code of a module is equivalent to the object code of the statically linked kernel. Therefore, no explicit message passing is required when the functions of the module are invoked.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-1-FN6">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-1-FN6">[*]</a></sup> A small performance penalty occurs when the module is linked and unlinked. However, this penalty can be compared to the penalty caused by the creation and deletion of system processes in microkernel operating systems.</p></blockquote></dd></dl>

<br class="calibre7"/>

</div>

{% endraw %}

