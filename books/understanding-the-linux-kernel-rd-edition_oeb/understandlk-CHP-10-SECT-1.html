---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-10.html
next: understandlk-CHP-10-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-10-SECT-1"></a>
<h3 class="docSection1Title">10.1. POSIX APIs and System Calls</h3><a name="IDX-CHP-10-2493"></a>
<p class="docText1">Let's start by stressing the difference between an application programmer interface (API) and a system call. The former is a function definition that specifies how to obtain a given service, while the latter is an explicit request to the kernel made via a software interrupt.</p>
<p class="docText1">Unix systems include several libraries of functions that provide APIs to programmers. Some of the APIs defined by the <span class="docEmphasis">libc</span> standard C library refer to <span class="docEmphasis">wrapper routines</span><a name="IDX-CHP-10-2494"></a> 
 (routines whose only purpose is to issue a system call). Usually, each system call has a corresponding wrapper routine, which defines the API that application programs should employ.</p>
<p class="docText1">The converse is not true, by the wayan API does not necessarily correspond to a specific system call. First of all, the API could offer its services directly in User Mode. (For something abstract such as math functions, there may be no reason to make system calls.) Second, a single API function could make several system calls. Moreover, several API functions could make the same system call, but wrap extra functionality around it. For instance, in Linux, the <tt class="calibre25">malloc( )</tt><a name="IDX-CHP-10-2495"></a> 
, <tt class="calibre25">calloc( )</tt><a name="IDX-CHP-10-2496"></a> 
, and <tt class="calibre25">free( )</tt><a name="IDX-CHP-10-2497"></a> 
 APIs are implemented in the <span class="docEmphasis">libc</span> library. The code in this library keeps track of the allocation and deallocation requests and uses the <tt class="calibre25">brk( )</tt><a name="IDX-CHP-10-2498"></a> 
 system call to enlarge or shrink the process heap (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-6.html#understandlk-CHP-9-SECT-6">Managing the Heap</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>).</p>
<p class="docText1">The POSIX standard refers to APIs and not to system calls. A system can be certified as POSIX-compliant if it offers the proper set of APIs to the application programs, no matter how the corresponding functions are implemented. As a matter of fact, several non-Unix systems have been certified as POSIX-compliant, because they offer all traditional Unix services in User Mode libraries.</p>
<p class="docText1">From the programmer's point of view, the distinction between an API and a system call is irrelevantthe only things that matter are the function name, the parameter types, and the meaning of the return code. From the kernel designer's point of view, however, the distinction does matter because system calls belong to the kernel, while User Mode libraries don't.</p>
<p class="docText1">Most wrapper routines return an integer value, whose meaning depends on the corresponding system call. A return value of -1 usually indicates that the kernel was unable to satisfy the process request. A failure in the system call handler may be caused by invalid parameters, a lack of available resources, hardware problems, and so on. The specific error code is contained in the <tt class="calibre25">errno</tt> variable, which is defined in the <span class="docEmphasis">libc</span> library.</p>
<p class="docText1">Each error code is defined as a macro constant, which yields a corresponding positive integer value. The POSIX standard specifies the macro names of several error codes. In Linux, on 80 x 86 systems, these macros are defined in the header file <i class="docEmphasis">include/asm-i386/errno.h</i>. To allow portability of C programs among Unix systems, the <i class="docEmphasis">include/asm-i386/errno.h</i> header file is included, in turn, in the standard <i class="docEmphasis">/usr/include/errno.h</i> C library header file. Other systems have their own specialized subdirectories of header files.</p>

<br class="calibre7"/>

</div>

{% endraw %}

