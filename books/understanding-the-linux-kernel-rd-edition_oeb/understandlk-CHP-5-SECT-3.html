---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-5-SECT-2.html
next: understandlk-CHP-5-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-5-SECT-3"></a>
<h3 class="docSection1Title">5.3. Synchronizing Accesses to Kernel Data Structures</h3><a name="IDX-CHP-5-1570"></a>
<a name="IDX-CHP-5-1571"></a>
<a name="IDX-CHP-5-1572"></a>
<a name="IDX-CHP-5-1573"></a>
<p class="docText1">A shared data structure can be protected against race conditions by using some of the synchronization primitives shown in the previous section. Of course, system performance may vary considerably, depending on the kind of synchronization primitive selected. Usually, the following rule of thumb is adopted by kernel developers: <span class="docEmphasis">always keep the concurrency level<a name="IDX-CHP-5-1574"></a> 
 as high as possible in the system</span>.</p>
<p class="docText1">In turn, the concurrency level in the system depends on two main factors:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The number of I/O devices that operate concurrently</p></li><li class="calibre12"><p class="docText1">The number of CPUs that do productive work</p></li></ul>
<p class="docText1">To maximize I/O throughput, interrupts should be disabled for very short periods of time. As described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2.1">IRQs and Interrupts</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, when interrupts are disabled, IRQs issued by I/O devices are temporarily ignored by the PIC, and no new activity can start on such devices.</p>
<p class="docText1">To use CPUs efficiently, synchronization primitives based on spin locks should be avoided whenever possible. When a CPU is executing a tight instruction loop waiting for the spin lock to open, it is wasting precious machine cycles. Even worse, as we have already said, spin locks have negative effects on the overall performance of the system because of their impact on the hardware caches.</p>
<p class="docText1">Let's illustrate a couple of cases in which synchronization can be achieved while still maintaining a high concurrency level:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">A shared data structure consisting of a single integer value can be updated by declaring it as an <tt class="calibre25">atomic_t</tt> type and by using atomic operations. An atomic operation is faster than spin locks and interrupt disabling, and it slows down only kernel control paths that concurrently access the data structure.</p></li><li class="calibre12"><p class="docText1">Inserting an element into a shared linked list is never atomic, because it consists of at least two pointer assignments. Nevertheless, the kernel can sometimes perform this insertion operation without using locks or disabling interrupts. As an example of why this works, we'll consider the case where a system call service routine (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10-SECT-2.html#understandlk-CHP-10-SECT-2">System Call Handler and Service Routines</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>) inserts new elements in a singly linked list, while an interrupt handler or deferrable function asynchronously looks up the list.</p><p class="docText1">In the C language, insertion is implemented by means of the following pointer assignments:</p><pre class="calibre27">
    new-&gt;next = list_element-&gt;next;
    list_element-&gt;next = new;
</pre><br class="calibre7"/>
<p class="docText1">In assembly language, insertion reduces to two consecutive atomic instructions. The first instruction sets up the <tt class="calibre25">next</tt> pointer of the <tt class="calibre25">new</tt> element, but it does not modify the list. Thus, if the interrupt handler sees the list between the execution of the first and second instructions, it sees the list without the new element. If the handler sees the list after the execution of the second instruction, it sees the list with the new element. The important point is that in either case, the list is consistent and in an uncorrupted state. However, this integrity is assured only if the interrupt handler does not modify the list. If it does, the <tt class="calibre25">next</tt> pointer that was just set within the <tt class="calibre25">new</tt> element might become invalid.</p><p class="docText1">However, developers must ensure that the order of the two assignment operations cannot be subverted by the compiler or the CPU's control unit; otherwise, if the system call service routine is interrupted by the interrupt handler between the two assignments, the handler finds a corrupted list. Therefore, a write memory barrier primitive is required:</p><pre class="calibre27">
    new-&gt;next = list_element-&gt;next;
    wmb( );
    list_element-&gt;next = new;
</pre><br class="calibre7"/>
</li></ul>
<a name="understandlk-CHP-5-SECT-3.1"></a>
<h4 class="docSection2Title">5.3.1. Choosing Among Spin Locks, Semaphores, and Interrupt Disabling</h4><a name="IDX-CHP-5-1575"></a>
<a name="IDX-CHP-5-1576"></a>
<p class="docText1">Unfortunately, access patterns to most kernel data structures are a lot more complex than the simple examples just shown, and kernel developers are forced to use semaphores, spin locks, interrupts, and softirq disabling. Generally speaking, choosing the synchronization primitives depends on what kinds of kernel control paths access the data structure, as shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-5-TABLE-8">Table 5-8</a>. Remember that whenever a kernel control path acquires a spin lock (as well as a read/write lock, a seqlock, or a RCU "read lock"), disables the local interrupts, or disables the local softirqs, kernel preemption is automatically disabled.</p>
<a name="understandlk-CHP-5-TABLE-8"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 5-8. Protection required by data structures accessed by kernel control paths</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Kernel control paths accessing the data structure</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">UP protection</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">MP further protection</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2">Exceptions</p></td><td class="docTableCell"><p class="docText2">Semaphore</p></td><td class="docTableCell"><p class="docText2">None</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Interrupts</p></td><td class="docTableCell"><p class="docText2">Local interrupt disabling</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Deferrable functions</p></td><td class="docTableCell"><p class="docText2">None</p></td><td class="docTableCell"><p class="docText2">None or spin lock (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-5-TABLE-9">Table 5-9</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Exceptions + Interrupts</p></td><td class="docTableCell"><p class="docText2">Local interrupt disabling</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Exceptions + Deferrable functions</p></td><td class="docTableCell"><p class="docText2">Local softirq disabling</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Interrupts + Deferrable functions</p></td><td class="docTableCell"><p class="docText2">Local interrupt disabling</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Exceptions + Interrupts + Deferrable functions</p></td><td class="docTableCell"><p class="docText2">Local interrupt disabling</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr></table></p><br class="calibre7"/>
<a name="understandlk-CHP-5-SECT-3.1.1"></a>
<h5 class="docSection3Title">5.3.1.1. Protecting a data structure accessed by exceptions</h5>
<p class="docText1">When a data structure is accessed only by exception handlers, race conditions are usually easy to understand and prevent. The most common exceptions that give rise to synchronization problems are the system call service routines (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10-SECT-2.html#understandlk-CHP-10-SECT-2">System Call Handler and Service Routines</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>) in which the CPU operates in Kernel Mode to offer a service to a User Mode program. Thus, a data structure accessed only by an exception usually represents a resource that can be assigned to one or more processes.</p>
<p class="docText1">Race conditions are avoided through semaphores, because these primitives allow the process to sleep until the resource becomes available. Notice that semaphores work equally well both in uniprocessor and multiprocessor systems.</p>
<p class="docText1">Kernel preemption does not create problems either. If a process that owns a semaphore is preempted, a new process running on the same CPU could try to get the semaphore. When this occurs, the new process is put to sleep, and eventually the old process will release the semaphore. The only case in which kernel preemption must be explicitly disabled is when accessing per-CPU variables, as explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.1">Per-CPU Variables</a>" earlier in this chapter.</p>
<a name="understandlk-CHP-5-SECT-3.1.2"></a>
<h5 class="docSection3Title">5.3.1.2. Protecting a data structure accessed by interrupts</h5><a name="IDX-CHP-5-1577"></a>
<p class="docText1">Suppose that a data structure is accessed by only the "top half" of an interrupt handler. We learned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6">Interrupt Handling</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a> that each interrupt handler is serialized with respect to itself  that is, it cannot execute more than once concurrently. Thus, accessing the data structure does not require synchronization primitives.</p>
<p class="docText1">Things are different, however, if the data structure is accessed by several interrupt handlers. A handler may interrupt another handler, and different interrupt handlers may run concurrently in multiprocessor systems. Without synchronization, the shared data structure might easily become corrupted.</p>
<p class="docText1">In uniprocessor systems, race conditions must be avoided by disabling interrupts in all critical regions of the interrupt handler. Nothing less will do because no other synchronization primitives accomplish the job. A semaphore can block the process, so it cannot be used in an interrupt handler. A spin lock, on the other hand, can freeze the system: if the handler accessing the data structure is interrupted, it cannot release the lock; therefore, the new interrupt handler keeps waiting on the tight loop of the spin lock.</p>
<p class="docText1">Multiprocessor systems, as usual, are even more demanding. Race conditions cannot be avoided by simply disabling local interrupts. In fact, even if interrupts are disabled on a CPU, interrupt handlers can still be executed on the other CPUs. The most convenient method to prevent the race conditions is to disable local interrupts (so that other interrupt handlers running on the same CPU won't interfere) <span class="docEmphasis">and</span> to acquire a spin lock or a read/write spin lock that protects the data structure. Notice that these additional spin locks cannot freeze the system because even if an interrupt handler finds the lock closed, eventually the interrupt handler on the other CPU that owns the lock will release it.</p>
<p class="docText1">The Linux kernel uses several macros that couple the enabling and disabling of local interrupts with spin lock handling. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-5-TABLE-9">Table 5-9</a> describes all of them. In uniprocessor systems, these macros just enable or disable local interrupts and kernel preemption.</p>
<a name="understandlk-CHP-5-TABLE-9"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 5-9. Interrupt-aware spin lock macros</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Macro</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_lock_irq(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_irq_disable( ); spin_lock(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_unlock_irq(l)</tt></p></td><td class="docTableCell"><p class="docText2">spin_unlock<tt class="calibre25">(l); local_irq_enable()</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_lock_bh(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_bh_disable( ); spin_lock(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_unlock_bh(l)</tt></p></td><td class="docTableCell"><p class="docText2">spin_unlock<tt class="calibre25">(l); local_bh_enable()</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_lock_irqsave(l,f)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_irq_save(f); spin_lock(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_unlock_irqrestore(l,f)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">spin_unlock(l); local_irq_restore(f)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">read_lock_irq<tt class="calibre25">(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_irq_disable( );</tt> read_lock<tt class="calibre25">(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_unlock_irq(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_unlock(l); local_irq_enable( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">read_lock_bh<tt class="calibre25">(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_bh_disable( );</tt> read_lock<tt class="calibre25">(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_unlock_bh(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_unlock(l); local_bh_enable( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_lock_irq(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_irq_disable( ); write_lock(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_unlock_irq(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_unlock(l); local_irq_enable( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_lock_bh(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_bh_disable( ); write_lock(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_unlock_bh(l)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_unlock(l); local_bh_enable( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_lock_irqsave(l,f)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_irq_save(f); read_lock(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_unlock_irqrestore(l,f)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_unlock(l); local_irq_restore(f)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_lock_irqsave(l,f)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">local_irq_save(f);</tt> write_lock<tt class="calibre25">(l)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_unlock_irqrestore(l,f)</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_unlock(l); local_irq_restore(f)</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">read_seqbegin_irqsave(l,f)</p></td><td class="docTableCell"><p class="docText2">local_irq_save(f); read_seqbegin(l)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">read_seqretry_irqrestore(l,v,f)</p></td><td class="docTableCell"><p class="docText2">read_seqretry(l,v); local_irq_restore(f)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">write_seqlock_irqsave(l,f)</p></td><td class="docTableCell"><p class="docText2">local_irq_save(f); write_seqlock(l)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">write_sequnlock_irqrestore(l,f)</p></td><td class="docTableCell"><p class="docText2">write_sequnlock(l); local_irq_restore(f)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">write_seqlock_irq(l)</p></td><td class="docTableCell"><p class="docText2">local_irq_disable( ); write_seqlock(l)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">write_sequnlock_irq(l)</p></td><td class="docTableCell"><p class="docText2">write_sequnlock(l); local_irq_enable( )</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">write_seqlock_bh(l)</p></td><td class="docTableCell"><p class="docText2">local_bh_disable( ); write_seqlock(l);</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">write_sequnlock_bh(l)</p></td><td class="docTableCell"><p class="docText2">write_sequnlock(l); local_bh_enable( )</p></td></tr></table></p><br class="calibre7"/>
<a name="understandlk-CHP-5-SECT-3.1.3"></a>
<h5 class="docSection3Title">5.3.1.3. Protecting a data structure accessed by deferrable functions</h5><a name="IDX-CHP-5-1578"></a>
<a name="IDX-CHP-5-1579"></a>
<a name="IDX-CHP-5-1580"></a>
<a name="IDX-CHP-5-1581"></a>
<a name="IDX-CHP-5-1582"></a>
<a name="IDX-CHP-5-1583"></a>
<a name="IDX-CHP-5-1584"></a>
<a name="IDX-CHP-5-1585"></a>
<a name="IDX-CHP-5-1586"></a>
<a name="IDX-CHP-5-1587"></a>
<a name="IDX-CHP-5-1588"></a>
<a name="IDX-CHP-5-1589"></a>
<a name="IDX-CHP-5-1590"></a>
<a name="IDX-CHP-5-1591"></a>
<a name="IDX-CHP-5-1592"></a>
<a name="IDX-CHP-5-1593"></a>
<a name="IDX-CHP-5-1594"></a>
<a name="IDX-CHP-5-1595"></a>
<a name="IDX-CHP-5-1596"></a>
<a name="IDX-CHP-5-1597"></a>
<a name="IDX-CHP-5-1598"></a>
<a name="IDX-CHP-5-1599"></a>
<a name="IDX-CHP-5-1600"></a>
<a name="IDX-CHP-5-1601"></a>
<a name="IDX-CHP-5-1602"></a>
<a name="IDX-CHP-5-1603"></a>
<a name="IDX-CHP-5-1604"></a>
<p class="docText1">What kind of protection is required for a data structure accessed only by deferrable functions? Well, it mostly depends on the kind of deferrable function. In the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-7.html#understandlk-CHP-4-SECT-7">Softirqs and Tasklets</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, we explained that softirqs and tasklets essentially differ in their degree of concurrency.</p>
<p class="docText1">First of all, no race condition may exist in uniprocessor systems. This is because execution of deferrable functions is always serialized on a CPU  that is, a deferrable function cannot be interrupted by another deferrable function. Therefore, no synchronization primitive is ever required.</p>
<p class="docText1">Conversely, in multiprocessor systems, race conditions do exist because several deferrable functions may run concurrently. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-5-TABLE-10">Table 5-10</a> lists all possible cases.</p>
<a name="understandlk-CHP-5-TABLE-10"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 5-10. Protection required by data structures accessed by deferrable functions in SMP</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Deferrable functions accessing the data structure</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Protection</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2">Softirqs</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">One tasklet</p></td><td class="docTableCell"><p class="docText2">None</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Many tasklets</p></td><td class="docTableCell"><p class="docText2">Spin lock</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">A data structure accessed by a softirq must always be protected, usually by means of a spin lock, because the same softirq may run concurrently on two or more CPUs. Conversely, a data structure accessed by just one kind of tasklet need not be protected, because tasklets of the same kind cannot run concurrently. However, if the data structure is accessed by several kinds of tasklets, then it must be protected.</p>
<a name="understandlk-CHP-5-SECT-3.1.4"></a>
<h5 class="docSection3Title">5.3.1.4. Protecting a data structure accessed by exceptions and interrupts</h5><a name="IDX-CHP-5-1605"></a>
<a name="IDX-CHP-5-1606"></a>
<p class="docText1">Let's consider now a data structure that is accessed both by exceptions (for instance, system call service routines) and interrupt handlers.</p>
<p class="docText1">On uniprocessor systems, race condition prevention is quite simple, because interrupt handlers are not reentrant and cannot be interrupted by exceptions. As long as the kernel accesses the data structure with local interrupts disabled, the kernel cannot be interrupted when accessing the data structure. However, if the data structure is accessed by just one kind of interrupt handler, the interrupt handler can freely access the data structure without disabling local interrupts.</p>
<p class="docText1">On multiprocessor systems, we have to take care of concurrent executions of exceptions and interrupts on other CPUs. Local interrupt disabling must be coupled with a spin lock, which forces the concurrent kernel control paths to wait until the handler accessing the data structure finishes its work.</p>
<p class="docText1">Sometimes it might be preferable to replace the spin lock with a semaphore. Because interrupt handlers cannot be suspended, they must acquire the semaphore using a tight loop and the <tt class="calibre25">down_trylock( )</tt> function; for them, the semaphore acts essentially as a spin lock. System call service routines, on the other hand, may suspend the calling processes when the semaphore is busy. For most system calls, this is the expected behavior. In this case, semaphores are preferable to spin locks, because they lead to a higher degree of concurrency of the system.</p>
<a name="understandlk-CHP-5-SECT-3.1.5"></a>
<h5 class="docSection3Title">5.3.1.5. Protecting a data structure accessed by exceptions and deferrable functions</h5>
<p class="docText1">A data structure accessed both by exception handlers and deferrable functions can be treated like a data structure accessed by exception and interrupt handlers. In fact, deferrable functions are essentially activated by interrupt occurrences, and no exception can be raised while a deferrable function is running. Coupling local interrupt disabling with a spin lock is therefore sufficient.</p>
<p class="docText1">Actually, this is much more than sufficient: the exception handler can simply disable deferrable functions instead of local interrupts by using the <tt class="calibre25">local_bh_disable( )</tt> macro (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-7.html#understandlk-CHP-4-SECT-7.1">Softirqs</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). Disabling only the deferrable functions is preferable to disabling interrupts, because interrupts continue to be serviced by the CPU. Execution of deferrable functions on each CPU is serialized, so no race condition exists.</p>
<p class="docText1">As usual, in multiprocessor systems, spin locks are required to ensure that the data structure is accessed at any time by just one kernel control.</p>
<a name="understandlk-CHP-5-SECT-3.1.6"></a>
<h5 class="docSection3Title">5.3.1.6. Protecting a data structure accessed by interrupts and deferrable functions</h5><a name="IDX-CHP-5-1607"></a>
<a name="IDX-CHP-5-1608"></a>
<a name="IDX-CHP-5-1609"></a>
<a name="IDX-CHP-5-1610"></a>
<a name="IDX-CHP-5-1611"></a>
<a name="IDX-CHP-5-1612"></a>
<a name="IDX-CHP-5-1613"></a>
<a name="IDX-CHP-5-1614"></a>
<p class="docText1">This case is similar to that of a data structure accessed by interrupt and exception handlers. An interrupt might be raised while a deferrable function is running, but no deferrable function can stop an interrupt handler. Therefore, race conditions must be avoided by disabling local interrupts during the deferrable function. However, an interrupt handler can freely touch the data structure accessed by the deferrable function without disabling interrupts, provided that no other interrupt handler accesses that data structure.</p>
<p class="docText1">Again, in multiprocessor systems, a spin lock is always required to forbid concurrent accesses to the data structure on several CPUs.</p>
<a name="understandlk-CHP-5-SECT-3.1.7"></a>
<h5 class="docSection3Title">5.3.1.7. Protecting a data structure accessed by exceptions, interrupts, and deferrable functions</h5>
<p class="docText1">Similarly to previous cases, disabling local interrupts and acquiring a spin lock is almost always necessary to avoid race conditions. Notice that there is no need to explicitly disable deferrable functions, because they are essentially activated when terminating the execution of interrupt handlers; disabling local interrupts is therefore sufficient.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

