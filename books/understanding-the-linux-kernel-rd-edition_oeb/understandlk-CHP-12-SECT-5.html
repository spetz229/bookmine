---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-12-SECT-4.html
next: understandlk-CHP-12-SECT-6.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-12-SECT-5"></a>
<h3 class="docSection1Title">12.5. Pathname Lookup</h3><a name="IDX-CHP-12-3232"></a>
<a name="IDX-CHP-12-3233"></a>
<a name="IDX-CHP-12-3234"></a>
<a name="IDX-CHP-12-3235"></a>
<a name="IDX-CHP-12-3236"></a>
<a name="IDX-CHP-12-3237"></a>
<a name="IDX-CHP-12-3238"></a>
<a name="IDX-CHP-12-3239"></a>
<a name="IDX-CHP-12-3240"></a>
<a name="IDX-CHP-12-3241"></a>
<a name="IDX-CHP-12-3242"></a>
<a name="IDX-CHP-12-3243"></a>
<p class="docText1">When a process must act on a file, it passes its file pathname to some VFS system call, such as <tt class="calibre25">open( )</tt><a name="IDX-CHP-12-3244"></a> 
, <tt class="calibre25">mkdir( )</tt>, <tt class="calibre25">rename( )</tt><a name="IDX-CHP-12-3245"></a> 
, or <tt class="calibre25">stat( )</tt><a name="IDX-CHP-12-3246"></a> 
. In this section, we illustrate how the VFS performs a <span class="docEmphasis">pathname lookup</span><a name="IDX-CHP-12-3247"></a> 
, that is, how it derives an inode from the corresponding file pathname.</p>
<p class="docText1">The standard procedure for performing this task consists of analyzing the pathname and breaking it into a sequence of filenames<a name="IDX-CHP-12-3248"></a> 
. All filenames except the last must identify directories.</p>
<p class="docText1">If the first character of the pathname is <i class="docEmphasis">/</i>, the pathname is absolute, and the search starts from the directory identified by <tt class="calibre25">current-&gt;fs-&gt;root</tt> (the process root directory). Otherwise, the pathname is relative, and the search starts from the directory identified by <tt class="calibre25">current-&gt;fs-&gt;pwd</tt> (the process-current directory).</p>
<p class="docText1">Having in hand the dentry, and thus the inode, of the initial directory, the code examines the entry matching the first name to derive the corresponding inode. Then the directory file that has that inode is read from disk and the entry matching the second name is examined to derive the corresponding inode. This procedure is repeated for each name included in the path.</p>
<p class="docText1">The dentry cache<a name="IDX-CHP-12-3249"></a> 
 considerably speeds up the procedure, because it keeps the most recently used dentry objects in memory. As we saw before, each such object associates a filename in a specific directory to its corresponding inode. In many cases, therefore, the analysis of the pathname can avoid reading the intermediate directories from disk.</p>
<p class="docText1">However, things are not as simple as they look, because the following Unix and VFS filesystem features must be taken into consideration:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The access rights of each directory must be checked to verify whether the process is allowed to read the directory's content.</p></li><li class="calibre12"><p class="docText1">A filename can be a symbolic link that corresponds to an arbitrary pathname; in this case, the analysis must be extended to all components of that pathname.</p></li><li class="calibre12"><p class="docText1">Symbolic links may induce circular references; the kernel must take this possibility into account and break endless loops when they occur.</p></li><li class="calibre12"><p class="docText1">A filename can be the mount point of a mounted filesystem. This situation must be detected, and the lookup operation must continue into the new filesystem.</p></li><li class="calibre12"><p class="docText1">Pathname lookup has to be done inside the namespace of the process that issued the system call. The same pathname used by two processes with different namespaces may specify different files.</p></li></ul>
<p class="docText1">Pathname lookup is performed by the <tt class="calibre25">path_lookup( )</tt> function, which receives three parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">name</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">A pointer to the file pathname to be resolved.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">flags</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The value of flags that represent how the looked-up file is going to be accessed. The allowed values are included later in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-16">Table 12-16</a>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">nd</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The address of a <tt class="calibre25">nameidata</tt> data structure, which stores the results of the lookup operation and whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-15">Table 12-15</a>.</p></dd></dl>
<p class="docText1">When <tt class="calibre25">path_lookup( )</tt> returns, the <tt class="calibre25">nameidata</tt> structure pointed to by <tt class="calibre25">nd</tt> is filled with data pertaining to the pathname lookup operation.</p>
<a name="understandlk-CHP-12-TABLE-15"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-15. The fields of the nameidata data structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct dentry *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">dentry</tt></p></td><td class="docTableCell"><p class="docText2">Address of the dentry object</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct vfs_mount *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt</tt></p></td><td class="docTableCell"><p class="docText2">Address of the mounted filesystem object</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct qstr</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">last</tt></p></td><td class="docTableCell"><p class="docText2">Last component of the pathname (used when the <tt class="calibre25">LOOKUP_PARENT</tt> flag is set)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">flags</tt></p></td><td class="docTableCell"><p class="docText2">Lookup flags</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">last_type</tt></p></td><td class="docTableCell"><p class="docText2">Type of last component of the pathname (used when the <tt class="calibre25">LOOKUP_PARENT</tt> flag is set)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned int</p></td><td class="docTableCell"><p class="docText2">depth</p></td><td class="docTableCell"><p class="docText2">Current level of symbolic link nesting (see below); it must be smaller than 6</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">char[ ] *</p></td><td class="docTableCell"><p class="docText2">saved_names</p></td><td class="docTableCell"><p class="docText2">Array of pathnames associated with nested symbolic links</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">union</p></td><td class="docTableCell"><p class="docText2">intent</p></td><td class="docTableCell"><p class="docText2">One-member union specifying how the file will be accessed</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">dentry</tt> and <tt class="calibre25">mnt</tt> fields point respectively to the dentry object and the mounted filesystem object of the last resolved component in the pathname. These two fields "describe" the file that is identified by the given pathname.</p>
<p class="docText1">Because the dentry object and the mounted filesystem object returned by the <tt class="calibre25">path_lookup( )</tt> function in the <tt class="calibre25">nameidata</tt> structure represent the result of a lookup operation, both objects should not be freed until the caller of <tt class="calibre25">path_lookup( )</tt> finishes using them. Therefore, <tt class="calibre25">path_lookup( )</tt> increases the usage counters of both objects. If the caller wants to release these objects, it invokes the <tt class="calibre25">path_release( )</tt> function passing as parameter the address of a <tt class="calibre25">nameidata</tt> structure.</p>
<p class="docText1">The <tt class="calibre25">flags</tt> field stores the value of some flags used in the lookup operation; they are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-16">Table 12-16</a>. Most of these flags can be set by the caller in the <tt class="calibre25">flags</tt> parameter of <tt class="calibre25">path_lookup( )</tt>.</p>
<a name="understandlk-CHP-12-TABLE-16"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-16. The flags of the lookup operation</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Macro</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_FOLLOW</tt></p></td><td class="docTableCell"><p class="docText2">If the last component is a symbolic link, interpret (follow) it</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_DIRECTORY</tt></p></td><td class="docTableCell"><p class="docText2">The last component must be a directory</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_CONTINUE</tt></p></td><td class="docTableCell"><p class="docText2">There are still filenames to be examined in the pathname</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_PARENT</tt></p></td><td class="docTableCell"><p class="docText2">Look up the directory that includes the last component of the pathname</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_NOALT</tt></p></td><td class="docTableCell"><p class="docText2">Do not consider the emulated root directory (useless in the 80x86 architecture)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_OPEN</tt></p></td><td class="docTableCell"><p class="docText2">Intent is to open a file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_CREATE</tt></p></td><td class="docTableCell"><p class="docText2">Intent is to create a file (if it doesn't exist)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LOOKUP_ACCESS</tt></p></td><td class="docTableCell"><p class="docText2">Intent is to check user's permission for a file</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">path_lookup( )</tt> function executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes some fields of the <tt class="calibre25">nd</tt> parameter as follows:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">last_type</tt> field to <tt class="calibre25">LAST_ROOT</tt> (this is needed if the pathname is a slash or a sequence of slashes; see the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5.2">Parent Pathname Lookup</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">flags</tt> field to the value of the <tt class="calibre25">flags</tt> parameter</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">depth</tt> field to 0.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acquires for reading the <tt class="calibre25">current-&gt;fs-&gt;lock</tt> read/write semaphore of the current process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the first character in the pathname is a slash (<i class="docEmphasis">/</i> ), the lookup operation must start from the root directory of <tt class="calibre25">current</tt>: the function gets the addresses of the corresponding mounted filesystem object (<tt class="calibre25">current-&gt;fs-&gt;rootmnt</tt>) and dentry object (<tt class="calibre25">current-&gt;fs-&gt;root</tt>), increases their usage counters, and stores the addresses in <tt class="calibre25">nd-&gt;mnt</tt> and <tt class="calibre25">nd-&gt;dentry</tt>, respectively.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the first character in the pathname is not a slash, the lookup operation must start from the current working directory of <tt class="calibre25">current</tt>: the function gets the addresses of the corresponding mounted filesystem object (<tt class="calibre25">current-&gt;fs-&gt;pwdmnt</tt>) and dentry object (<tt class="calibre25">current-&gt;fs-&gt;pwd</tt>), increases their usage counters, and stores the addresses in <tt class="calibre25">nd-&gt;mnt</tt> and <tt class="calibre25">nd-&gt;dentry</tt>, respectively.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">current-&gt;fs-&gt;lock</tt> read/write semaphore of the current process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">total_link_count</tt> field in the descriptor of the current process to 0 (see the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5.3">Lookup of Symbolic Links</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">link_path_walk( )</tt> function to take care of the undergoing lookup operation:</p><pre class="calibre60">
    return link_path_walk(name, nd);</pre><br class="calibre7"/>
</div></li></ol></div>
<p class="docText1">We are now ready to describe the core of the pathname lookup operation, namely the <tt class="calibre25">link_path_walk( )</tt> function. It receives as its parameters a pointer <tt class="calibre25">name</tt> to the pathname to be resolved and the address <tt class="calibre25">nd</tt> of a <tt class="calibre25">nameidata</tt> data structure.</p>
<p class="docText1">To make things a bit easier, we first describe what <tt class="calibre25">link_path_walk( )</tt> does when <tt class="calibre25">LOOKUP_PARENT</tt> is not set and the pathname does not contain symbolic links (standard pathname lookup). Next, we discuss the case in which <tt class="calibre25">LOOKUP_PARENT</tt> is set: this type of lookup is required when creating, deleting, or renaming a directory entry, that is, during a parent pathname lookup. Finally, we explain how the function resolves symbolic links.</p>
<a name="understandlk-CHP-12-SECT-5.1"></a>
<h4 class="docSection2Title">12.5.1. Standard Pathname Lookup</h4><a name="IDX-CHP-12-3250"></a>
<a name="IDX-CHP-12-3251"></a>
<a name="IDX-CHP-12-3252"></a>
<a name="IDX-CHP-12-3253"></a>
<a name="IDX-CHP-12-3254"></a>
<p class="docText1">When the <tt class="calibre25">LOOKUP_PARENT</tt> flag is cleared, <tt class="calibre25">link_path_walk( )</tt> performs the following steps.</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">lookup_flags</tt> local variable with <tt class="calibre25">nd-&gt;flags</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Skips all leading slashes (/) before the first component of the pathname.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the remaining pathname is empty, it returns the value 0. In the <tt class="calibre25">nameidata</tt> data structure, the <tt class="calibre25">dentry</tt> and <tt class="calibre25">mnt</tt> fields point to the objects relative to the last resolved component of the original pathname.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">depth</tt> field of the <tt class="calibre25">nd</tt> descriptor is positive, it sets the <tt class="calibre25">LOOKUP_FOLLOW</tt> flag in the <tt class="calibre25">lookup_flags</tt> local variable (see the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5.3">Lookup of Symbolic Links</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes a cycle that breaks the pathname passed in the <tt class="calibre25">name</tt> parameter into components (the intermediate slashes are treated as filename separators); for each component found, the function:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Retrieves the address of the inode object of the last resolved component from <tt class="calibre25">nd-&gt;dentry-&gt;d_inode</tt>. (In the first iteration, the inode refers to the directory from where to start the pathname lookup.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks that the permissions of the last resolved component stored into the inode allow execution (in Unix, a directory can be traversed only if it is executable). If the inode has a custom <tt class="calibre25">permission</tt> method, the function executes it; otherwise, it executes the <tt class="calibre25">exec_permission_lite( )</tt> function, which examines the access mode stored in the <tt class="calibre25">i_mode</tt> inode field and the privileges of the running process. In both cases, if the last resolved component does not allow execution, <tt class="calibre25">link_path_walk( )</tt> breaks out of the cycle and returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Considers the next component to be resolved. From its name, the function computes a 32-bit hash value to be used when looking in the dentry cache hash table.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Skips any trailing slash (/) after the slash that terminates the name of the component to be resolved.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the component to be resolved is the last one in the original pathname, it jumps to step 6.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the name of the component is "." (a single dot), it continues with the next component ( "." refers to the current directory, so it has no effect inside a pathname).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the name of the component is ".." (two dots), it tries to climb to the parent directory:</p><div class="calibre44"><ol class="docList4" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is the process's root directory (<tt class="calibre25">nd-&gt;dentry</tt> is equal to <tt class="calibre25">current-&gt;fs-&gt;root</tt> and <tt class="calibre25">nd-&gt;mnt</tt> is equal to <tt class="calibre25">current-&gt;fs-&gt;rootmnt</tt>), then climbing is not allowed: it invokes <tt class="calibre25">follow_mount( )</tt> on the last resolved component (see below) and continues with the next component.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is the root directory of the <tt class="calibre25">nd-&gt;mnt</tt> filesystem (<tt class="calibre25">nd-&gt;dentry</tt> is equal to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_root</tt>) and the <tt class="calibre25">nd-&gt;mnt</tt> filesystem is not mounted on top of another filesystem (<tt class="calibre25">nd-&gt;mnt</tt> is equal to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_parent</tt>), then the <tt class="calibre25">nd-&gt;mnt</tt> filesystem is usually<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN7">[*]</a></sup> the namespace's root filesystem: in this case, climbing is impossible, thus invokes <tt class="calibre25">follow_mount( )</tt> on the last resolved component (see below) and continues with the next component.</p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-12-FN7">[*]</a></sup> This case can also occur for network filesystems<a name="IDX-CHP-12-3255"></a> 
 disconnected from the namespace's directory tree.</p></blockquote></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is the root directory of the <tt class="calibre25">nd-&gt;mnt</tt> filesystem and the <tt class="calibre25">nd-&gt;mnt</tt> filesystem is mounted on top of another filesystem, a filesystem switch is required. So, the function sets <tt class="calibre25">nd-&gt;dentry</tt> to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_mountpoint</tt>, and <tt class="calibre25">nd-&gt;mnt</tt> to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_parent</tt>, then restarts step 5g (recall that several filesystems can be mounted on the same mount point).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is not the root directory of a mounted filesystem, then the function must simply climb to the parent directory: it sets <tt class="calibre25">nd-&gt;dentry</tt> to <tt class="calibre25">nd-&gt;dentry-&gt;d_parent</tt>, invokes <tt class="calibre25">follow_mount( )</tt> on the parent directory, and continues with the next component.</p></div></li></ol></div><p class="docList">The <tt class="calibre25">follow_mount( )</tt> function checks whether <tt class="calibre25">nd-&gt;dentry</tt> is a mount point for some filesystem (<tt class="calibre25">nd-&gt;dentry-&gt;d_mounted</tt> is greater than zero); in this case, it invokes <tt class="calibre25">lookup_mnt( )</tt> to search the root directory of the mounted filesystem in the dentry cache<a name="IDX-CHP-12-3256"></a> 
, and updates <tt class="calibre25">nd-&gt;dentry</tt> and <tt class="calibre25">nd-&gt;mnt</tt> with the object addresses corresponding to the mounted filesystem; then, it repeats the whole operation (there can be several filesystems mounted on the same mount point). Essentially, invoking the <tt class="calibre25">follow_mount( )</tt> function when climbing to the parent directory is required because the process could start the pathname lookup from a directory included in a filesystem hidden by another filesystem mounted over the parent directory.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The component name is neither "." nor "..", so the function must look it up in the dentry cache. If the low-level filesystem has a custom <tt class="calibre25">d_hash</tt> dentry method, the function invokes it to modify the hash value already computed in step 5c.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">LOOKUP_CONTINUE</tt> flag in <tt class="calibre25">nd-&gt;flags</tt> to denote that there is a next component to be analyzed.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">do_lookup( )</tt> to derive the dentry object associated with a given parent directory (<tt class="calibre25">nd-&gt;dentry</tt>) and filename (the pathname component being resolved). The function essentially invokes <tt class="calibre25">_ _d_lookup( )</tt> first to search the dentry object of the component in the dentry cache. If no such object exists, <tt class="calibre25">do_lookup( )</tt> invokes <tt class="calibre25">real_lookup( )</tt>. This latter function reads the directory from disk by executing the <tt class="calibre25">lookup</tt> method of the inode, creates a new dentry object and inserts it in the dentry cache, then creates a new inode object and inserts it into the inode cache<a name="IDX-CHP-12-3257"></a> 
.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN8">[*]</a></sup> At the end of this step, the <tt class="calibre25">dentry</tt> and <tt class="calibre25">mnt</tt> fields of the <tt class="calibre25">next</tt> local variable will point, respectively, to the dentry object and the mounted filesystem object of the component name to be resolved in this cycle.</p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-12-FN8">[*]</a></sup> In a few cases, the function might find the required inode already in the inode cache. This happens when the pathname component is the last one and it does not refer to a directory, the corresponding file has several hard links, and finally the file has been recently accessed through a hard link different from the one used in this pathname.</p></blockquote></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">follow_mount( )</tt> function to check whether the component just resolved (<tt class="calibre25">next.dentry</tt>) refers to a directory that is a mount point for some filesystem (<tt class="calibre25">next.dentry-&gt;d_mounted</tt> is greater than zero). <tt class="calibre25">follow_mount( )</tt> updates <tt class="calibre25">next.dentry</tt> and <tt class="calibre25">next.mnt</tt> so that they point to the dentry object and mounted filesystem object of the upmost filesystem mounted on the directory specified by this pathname component (see step 5g).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the component just resolved refers to a symbolic link (<tt class="calibre25">next.dentry-&gt;d_inode</tt> has a custom <tt class="calibre25">follow_link</tt> method). We'll deal with this case in the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5.3">Lookup of Symbolic Links</a>."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the component just resolved refers to a directory (<tt class="calibre25">next.dentry-&gt;d_inode</tt> has a custom <tt class="calibre25">lookup</tt> method). If not, returns the error <tt class="calibre25">-ENOTDIR</tt>, because the component is in the middle of the original pathname.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">nd-&gt;dentry</tt> to <tt class="calibre25">next.dentry</tt> and <tt class="calibre25">nd-&gt;mnt</tt> to <tt class="calibre25">next.mnt</tt>, then continues with the next component of the pathname.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Now all components of the original pathname are resolved except the last one. Clears the <tt class="calibre25">LOOKUP_CONTINUE</tt> flag in <tt class="calibre25">nd-&gt;flags</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the pathname has a trailing slash, it sets the <tt class="calibre25">LOOKUP_FOLLOW</tt> and <tt class="calibre25">LOOKUP_DIRECTORY flags</tt> in the <tt class="calibre25">lookup_flags</tt> local variable to force the last component to be interpreted by later functions as a directory name.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the value of the <tt class="calibre25">LOOKUP_PARENT</tt> flag in the <tt class="calibre25">lookup_flags</tt> variable. In the following, we assume that the flag is set to 0, and we postpone the opposite case to the next section.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the name of the last component is "." (a single dot), terminates the execution and returns the value 0 (no error). In the <tt class="calibre25">nameidata</tt> structure that <tt class="calibre25">nd</tt> points to, the <tt class="calibre25">dentry</tt> and <tt class="calibre25">mnt</tt> fields refer to the objects relative to the next-to-last component of the pathname (each component "." has no effect inside a pathname).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the name of the last component is ".." (two dots), it tries to climb to the parent directory:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is the process's root directory (<tt class="calibre25">nd-&gt;dentry</tt> is equal to <tt class="calibre25">current-&gt;fs-&gt;root</tt> and <tt class="calibre25">nd-&gt;mnt</tt> is equal to <tt class="calibre25">current-&gt;fs-&gt;rootmnt</tt>), it invokes <tt class="calibre25">follow_mount( )</tt> on the next-to-last component and terminates the execution and returns the value 0 (no error). <tt class="calibre25">nd-&gt;dentry</tt> and <tt class="calibre25">nd-&gt;mnt</tt> refer to the objects relative to the next-to-last component of the pathnamethat is, to the root directory of the process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is the root directory of the <tt class="calibre25">nd-&gt;mnt</tt> filesystem (<tt class="calibre25">nd-&gt;dentry</tt> is equal to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_root</tt>) and the <tt class="calibre25">nd-&gt;mnt</tt> filesystem is not mounted on top of another filesystem (<tt class="calibre25">nd-&gt;mnt</tt> is equal to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_parent</tt>), then climbing is impossible, thus invokes <tt class="calibre25">follow_mount( )</tt> on the next-to-last component and terminates the execution and returns the value 0 (no error).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is the root directory of the <tt class="calibre25">nd-&gt;mnt</tt> filesystem and the <tt class="calibre25">nd-&gt;mnt</tt> filesystem is mounted on top of another filesystem, it sets <tt class="calibre25">nd-&gt;dentry</tt> to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_mountpoint</tt> and <tt class="calibre25">nd-&gt;mnt</tt> to <tt class="calibre25">nd-&gt;mnt-&gt;mnt_parent</tt>, then restarts step 10.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the last resolved directory is not the root directory of a mounted filesystem, it sets <tt class="calibre25">nd-&gt;dentry</tt> to <tt class="calibre25">nd-&gt;dentry-&gt;d_parent</tt>, invokes <tt class="calibre25">follow_mount( )</tt> on the parent directory, and terminates the execution and returns the value 0 (no error). <tt class="calibre25">nd-&gt;dentry</tt> and <tt class="calibre25">nd-&gt;mnt</tt> refer to the objects relative to the component preceding the next-to-last component of the pathname.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The name of the last component is neither "." nor "..", so the function must look it up in the dentry cache. If the low-level filesystem has a custom <tt class="calibre25">d_hash</tt> dentry method, the function invokes it to modify the hash value already computed in step 5c.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">do_lookup( )</tt> to derive the dentry object associated with the parent directory and the filename (see step 5j). At the end of this step, the <tt class="calibre25">next</tt> local variable contains the pointers to both the dentry and the mounted filesystem descriptor relative to the last component name.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">follow_mount( )</tt> to check whether the last component is a mount point for some filesystem and, if this is the case, to update the <tt class="calibre25">next</tt> local variable with the addresses of the dentry object and mounted filesystem object relative to the root directory of the upmost mounted filesystem.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the <tt class="calibre25">LOOKUP_FOLLOW</tt> flag is set in <tt class="calibre25">lookup_flags</tt> and the inode object <tt class="calibre25">next.dentry-&gt;d_inode</tt> has a custom <tt class="calibre25">follow_link</tt> method. If this is the case, the component is a symbolic link that must be interpreted, as described in the later section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5.3">Lookup of Symbolic Links</a>."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The component is not a symbolic link or the symbolic link should not be interpreted. Sets the <tt class="calibre25">nd-&gt;mnt</tt> and <tt class="calibre25">nd-&gt;dentry</tt> fields with the value stored in <tt class="calibre25">next.mnt</tt> and <tt class="calibre25">next.dentry</tt>, respectively. The final dentry object is the result of the whole lookup operation.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether <tt class="calibre25">nd-&gt;dentry-&gt;d_inode</tt> is <tt class="calibre25">NULL</tt>. This happens when there is no inode associated with the dentry object, usually because the pathname refers to a nonexistent file. In this case, the function returns the error code <tt class="calibre25">-ENOENT</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">There is an inode associated with the last component of the pathname. If the <tt class="calibre25">LOOKUP_DIRECTORY</tt> flag is set in <tt class="calibre25">lookup_flags</tt>, it checks that the inode has a custom <tt class="calibre25">lookup</tt> methodthat is, it is a directory. If not, the function returns the error code <tt class="calibre25">-ENOTDIR</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the value 0 (no error). <tt class="calibre25">nd-&gt;dentry</tt> and <tt class="calibre25">nd-&gt;mnt</tt> refer to the last component of the pathname.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-5.2"></a>
<h4 class="docSection2Title">12.5.2. Parent Pathname Lookup</h4>
<p class="docText1">In many cases, the real target of a lookup operation is not the last component of the pathname, but the next-to-last one. For example, when a file is created, the last component denotes the filename of the not yet existing file, and the rest of the pathname specifies the directory in which the new link must be inserted. Therefore, the lookup operation should fetch the dentry object of the next-to-last component. For another example, unlinking a file identified by the pathname <i class="docEmphasis">/foo/bar</i> consists of removing <i class="docEmphasis">bar</i> from the directory <i class="docEmphasis">foo</i>. Thus, the kernel is really interested in accessing the directory <i class="docEmphasis">foo</i> rather than <i class="docEmphasis">bar</i>.</p>
<p class="docText1">The <tt class="calibre25">LOOKUP_PARENT</tt> flag is used whenever the lookup operation must resolve the directory containing the last component of the pathname, rather than the last component itself.</p>
<p class="docText1">When the <tt class="calibre25">LOOKUP_PARENT</tt> flag is set, the <tt class="calibre25">link_path_walk( )</tt> function also sets up the <tt class="calibre25">last</tt> and <tt class="calibre25">last_type</tt> fields of the <tt class="calibre25">nameidata</tt> data structure. The <tt class="calibre25">last</tt> field stores the name of the last component in the pathname. The <tt class="calibre25">last_type</tt> field identifies the type of the last component; it may be set to one of the values shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-17">Table 12-17</a>.</p>
<a name="understandlk-CHP-12-TABLE-17"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-17. The values of the last_type field in the nameidata data structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Value</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LAST_NORM</tt></p></td><td class="docTableCell"><p class="docText2">Last component is a regular filename</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LAST_ROOT</tt></p></td><td class="docTableCell"><p class="docText2">Last component is "<i class="docEmphasis">/</i> " (that is, the entire pathname is "<i class="docEmphasis">/</i> ")</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LAST_DOT</tt></p></td><td class="docTableCell"><p class="docText2">Last component is "."</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LAST_DOTDOT</tt></p></td><td class="docTableCell"><p class="docText2">Last component is ".."</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">LAST_BIND</tt></p></td><td class="docTableCell"><p class="docText2">Last component is a symbolic link into a special filesystem</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">LAST_ROOT</tt> flag is the default value set by <tt class="calibre25">path_lookup( )</tt> when the whole pathname lookup operation starts (see the description at the beginning of the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5">Pathname Lookup</a>"). If the pathname turns out to be simply "<i class="docEmphasis">/</i> ", the kernel does not change the initial value of the <tt class="calibre25">last_type</tt> field.</p>
<p class="docText1">The remaining values of the <tt class="calibre25">last_type</tt> field are set by <tt class="calibre25">link_path_walk( )</tt> when the <tt class="calibre25">LOOKUP_PARENT</tt> flag is set; in this case, the function performs the same steps described in the previous section up to step 8. From step 8 onward, however, the lookup operation for the last component of the pathname is different:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">nd-&gt;last</tt> to the name of the last component.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes <tt class="calibre25">nd-&gt;last_type</tt> to <tt class="calibre25">LAST_NORM</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the name of the last component is "." (a single dot), it sets <tt class="calibre25">nd-&gt;last_type</tt> to <tt class="calibre25">LAST_DOT</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the name of the last component is ".." (two dots), it sets <tt class="calibre25">nd-&gt;last_type</tt> to <tt class="calibre25">LAST_DOTDOT</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the value 0 (no error).</p></div></li></ol></div>
<p class="docText1">As you can see, the last component is not interpreted at all. Thus, when the function terminates, the <tt class="calibre25">dentry</tt> and <tt class="calibre25">mnt</tt> fields of the <tt class="calibre25">nameidata</tt> data structure point to the objects relative to the directory that includes the last component.</p>
<a name="understandlk-CHP-12-SECT-5.3"></a>
<h4 class="docSection2Title">12.5.3. Lookup of Symbolic Links</h4><a name="IDX-CHP-12-3258"></a>
<a name="IDX-CHP-12-3259"></a>
<a name="IDX-CHP-12-3260"></a>
<a name="IDX-CHP-12-3261"></a>
<a name="IDX-CHP-12-3262"></a>
<a name="IDX-CHP-12-3263"></a>
<a name="IDX-CHP-12-3264"></a>
<p class="docText1">Recall that a symbolic link is a regular file that stores a pathname of another file. A pathname may include symbolic links, and they must be resolved by the kernel.</p>
<p class="docText1">For example, if <i class="docEmphasis">/foo/bar</i> is a symbolic link pointing to (containing the pathname) <i class="docEmphasis">../dir</i>, the pathname <i class="docEmphasis">/foo/bar/file</i> must be resolved by the kernel as a reference to the file <i class="docEmphasis">/dir/file</i>. In this example, the kernel must perform two different lookup operations. The first one resolves <i class="docEmphasis">/foo/bar</i>: when the kernel discovers that <span class="docEmphasis">bar</span> is the name of a symbolic link, it must retrieve its content and interpret it as another pathname. The second pathname operation starts from the directory reached by the first operation and continues until the last component of the symbolic link pathname has been resolved. Next, the original lookup operation resumes from the dentry reached in the second one and with the component following the symbolic link in the original pathname.</p>
<p class="docText1">To further complicate the scenario, the pathname included in a symbolic link may include other symbolic links. You might think that the kernel code that resolves the symbolic links is hard to understand, but this is not true; the code is actually quite simple because it is recursive.</p>
<p class="docText1">However, untamed recursion is intrinsically dangerous. For instance, suppose that a symbolic link points to itself. Of course, resolving a pathname including such a symbolic link may induce an endless stream of recursive invocations, which in turn quickly leads to a kernel stack overflow. The <tt class="calibre25">link_count</tt> field in the descriptor of the current process is used to avoid the problem: the field is increased before each recursive execution and decreased right after. If a sixth nested lookup operation is attempted, the whole lookup operation terminates with an error code. Therefore, the level of nesting of symbolic links can be at most 5.</p>
<p class="docText1">Furthermore, the <tt class="calibre25">total_link_count</tt> field in the descriptor of the current process keeps track of how many symbolic links (even nonnested) were followed in the original lookup operation. If this counter reaches the value 40, the lookup operation aborts. Without this counter, a malicious user could create a pathological pathname including many consecutive symbolic links that freeze the kernel in a very long lookup operation.</p>
<p class="docText1">This is how the code basically works: once the <tt class="calibre25">link_path_walk( )</tt> function retrieves the dentry object associated with a component of the pathname, it checks whether the corresponding inode object has a custom <tt class="calibre25">follow_link</tt> method (see step 5l and step 14 in the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-SECT-5.1">Standard Pathname Lookup</a>"). If so, the inode is a symbolic link that must be interpreted before proceeding with the lookup operation of the original pathname.</p>
<p class="docText1">In this case, the <tt class="calibre25">link_path_walk( )</tt> function invokes <tt class="calibre25">do_follow_link( )</tt>, passing to it the address <tt class="calibre25">dentry</tt> of the dentry object of the symbolic link and the address <tt class="calibre25">nd</tt> of the <tt class="calibre25">nameidata</tt> data structure. In turn, <tt class="calibre25">do_follow_link( )</tt> performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks that <tt class="calibre25">current-&gt;link_count</tt> is less than 5; otherwise, it returns the error code <tt class="calibre25">-ELOOP</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks that <tt class="calibre25">current-&gt;total_link_count</tt> is less than 40; otherwise, it returns the error code <tt class="calibre25">-ELOOP</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">cond_resched( )</tt> to perform a process switch if required by the current process (flag <tt class="calibre25">TIF_NEED_RESCHED</tt> in the <tt class="calibre25">tHRead_info</tt> descriptor of the current process set).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases <tt class="calibre25">current-&gt;link_count</tt>, <tt class="calibre25">current-&gt;total_link_count</tt>, and <tt class="calibre25">nd-&gt;depth</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the access time of the inode object associated with the symbolic link to be resolved.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the filesystem-dependent function that implements the <tt class="calibre25">follow_link</tt> method passing to it the <tt class="calibre25">dentry</tt> and <tt class="calibre25">nd</tt> parameters. This function extracts the pathname stored in the symbolic link's inode, and saves this pathname in the proper entry of the <tt class="calibre25">nd-&gt;saved_names</tt> array.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">_ _vfs_follow_link( )</tt> function passing to it the address <tt class="calibre25">nd</tt> and the address of the pathname in the <tt class="calibre25">nd-&gt;saved_names</tt> array (see below).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If defined, executes the <tt class="calibre25">put_link</tt> method of the inode object, thus releasing the temporary data structures allocated by the <tt class="calibre25">follow_link</tt> method.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Decreases the <tt class="calibre25">current-&gt;link_count</tt> and <tt class="calibre25">nd-&gt;depth</tt> fields.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the error code returned by the <tt class="calibre25">_ _vfs_follow_link( )</tt> function (0 for no error).</p></div></li></ol></div>
<p class="docText1">In turn, the <tt class="calibre25">_ _vfs_follow_link( )</tt> does essentially the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the first character of the pathname stored in the symbolic link is a slash: in this case an absolute pathname has been found, so there is no need to keep in memory any information about the previous path. If so, invokes <tt class="calibre25">path_release( )</tt> on the <tt class="calibre25">nameidata</tt> structure, thus releasing the objects resulting from the previous lookup steps; then, the function sets the <tt class="calibre25">dentry</tt> and <tt class="calibre25">mnt</tt> fields of the <tt class="calibre25">nameidata</tt> data structure to the current process root directory.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">link_path_walk( )</tt> to resolve the symbolic link pathname, passing to it as parameters the pathname and <tt class="calibre25">nd</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the value taken from <tt class="calibre25">link_path_walk( )</tt>.</p></div></li></ol></div>
<p class="docText1">When <tt class="calibre25">do_follow_link( )</tt> finally terminates, it has set the <tt class="calibre25">dentry</tt> field of the <tt class="calibre25">next</tt> local variable with the address of the dentry object referred to by the symbolic link to the original execution of <tt class="calibre25">link_path_walk( )</tt>. The <tt class="calibre25">link_path_walk( )</tt> function can then proceed with the next step.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

