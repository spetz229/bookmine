---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-6-SECT-3.html
next: understandlk-CHP-6-SECT-5.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-6-SECT-4"></a>
<h3 class="docSection1Title" id="534869-960">6.4. Updating System Statistics</h3><a name="IDX-CHP-6-1711"></a>
<a name="IDX-CHP-6-1712"></a>
<a name="IDX-CHP-6-1713"></a>
<a name="IDX-CHP-6-1714"></a>
<a name="IDX-CHP-6-1715"></a>
<a name="IDX-CHP-6-1716"></a>
<a name="IDX-CHP-6-1717"></a>
<p class="docText1">The kernel, among the other time-related duties, must periodically collect various data used for:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Checking the CPU resource limit of the running processes</p></li><li class="calibre12"><p class="docText1">Updating statistics about the local CPU workload</p></li><li class="calibre12"><p class="docText1">Computing the average system load</p></li><li class="calibre12"><p class="docText1">Profiling the kernel code</p></li></ul>
<a name="understandlk-CHP-6-SECT-4.1"></a>
<h4 class="docSection2Title">6.4.1. Updating Local CPU Statistics</h4>
<p class="docText1">We have mentioned that the <tt class="calibre25">update_process_times( )</tt> function is invokedeither by the global timer interrupt handler on uniprocessor systems or by the local timer interrupt handler in multiprocessor systemsto update some kernel statistics. This function performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks how long the current process has been running. Depending on whether the current process was running in User Mode or in Kernel Mode when the timer interrupt occurred, invokes either <tt class="calibre25">account_user_time( )</tt> or <tt class="calibre25">account_system_time( )</tt>. Each of these functions performs essentially the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Updates either the <tt class="calibre25">utime</tt> field (ticks spent in User Mode) or the <tt class="calibre25">stime</tt> field (ticks spent in Kernel Mode) of the current process descriptor. Two additional fields called <tt class="calibre25">cutime</tt> and <tt class="calibre25">cstime</tt> are provided in the process descriptor to count the number of CPU ticks spent by the process children in User Mode and Kernel Mode, respectively. For reasons of efficiency, these fields are not updated by <tt class="calibre25">update_process_times( )</tt>, but rather when the parent process queries the state of one of its children (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-5.html#understandlk-CHP-3-SECT-5">Destroying Processes</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the total CPU time limit has been reached; if so, sends <tt class="calibre25">SIGXCPU</tt> and <tt class="calibre25">SIGKILL</tt> signals to <tt class="calibre25">current</tt>. The section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.5">Process Resource Limits</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a> describes how the limit is controlled by the <tt class="calibre25">signal-&gt;rlim[RLIMIT_CPU].rlim_cur</tt> field of each process descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">account_it_virt( )</tt> and <tt class="calibre25">account_it_prof( )</tt> to check the process timers (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6.3">The setitimer( ) and alarm( ) System Calls</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates some kernel statistics stored in the <tt class="calibre25">kstat</tt> per-CPU variable.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">raise_softirq( )</tt> to activate the <tt class="calibre25">TIMER_SOFTIRQ</tt> tasklet on the local CPU (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-5.html#understandlk-CHP-6-SECT-5">Software Timers and Delay Functions</a>" later in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If some old version of an RCU-protected data structure has to be reclaimed, checks whether the local CPU has gone through a quiescent state and invokes <tt class="calibre25">tasklet_schedule( )</tt> to activate the <tt class="calibre25">rcu_tasklet</tt> tasklet of the local CPU (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.7">Read-Copy Update (RCU)</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">scheduler_tick( )</tt> function, which decreases the time slice counter of the current process, and checks whether its quantum is exhausted. We'll discuss in depth these operations in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.1">The scheduler_tick( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>.</p></div></li></ol></div>
<a name="understandlk-CHP-6-SECT-4.2"></a>
<h4 class="docSection2Title">6.4.2. Keeping Track of System Load</h4><a name="IDX-CHP-6-1718"></a>
<a name="IDX-CHP-6-1719"></a>
<a name="IDX-CHP-6-1720"></a>
<a name="IDX-CHP-6-1721"></a>
<a name="IDX-CHP-6-1722"></a>
<a name="IDX-CHP-6-1723"></a>
<p class="docText1">Every Unix kernel keeps track of how much CPU activity is being carried on by the system. These statistics are used by various administration utilities such as <tt class="calibre25">top</tt>. A user who enters the <tt class="calibre25">uptime</tt> command sees the statistics as the "load average" relative to the last minute, the last 5 minutes, and the last 15 minutes. On a uniprocessor system, a value of 0 means that there are no active processes (besides the <span class="docEmphasis">swapper</span> process 0) to run, while a value of 1 means that the CPU is 100 percent busy with a single process, and values greater than 1 mean that the CPU is shared among several active processes.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-FN4">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-6-FN4">[*]</a></sup> Linux includes in the load average all processes that are in the <tt class="calibre42">TASK_RUNNING</tt> and <tt class="calibre42">TASK_UNINTERRUPTIBLE</tt> states. However, under normal conditions, there are few <tt class="calibre42">TASK_UNINTERRUPTIBLE</tt> processes, so a high load usually means that the CPU is busy.</p></blockquote>
<p class="docText1">At every tick, <tt class="calibre25">update_times( )</tt> invokes the <tt class="calibre25">calc_load( )</tt> function, which counts the number of processes in the <tt class="calibre25">TASK_RUNNING</tt> or <tt class="calibre25">TASK_UNINTERRUPTIBLE</tt> state and uses this number to update the average system load.</p>
<a name="understandlk-CHP-6-SECT-4.3"></a>
<h4 class="docSection2Title">6.4.3. Profiling the Kernel Code</h4>
<p class="docText1">Linux includes a minimalist code profiler called <span class="docEmphasis">readprofile</span> used by Linux developers to discover where the kernel spends its time in Kernel Mode. The profiler identifies the <span class="docEmphasis">hot spots</span> of the kernel  the most frequently executed fragments of kernel code. Identifying the kernel hot spots is very important, because they may point out kernel functions that should be further optimized.</p>
<p class="docText1">The profiler is based on a simple Monte Carlo algorithm: at every timer interrupt occurrence, the kernel determines whether the interrupt occurred in Kernel Mode; if so, the kernel fetches the value of the <tt class="calibre25">eip</tt> register before the interruption from the stack and uses it to discover what the kernel was doing before the interrupt. In the long run, the samples accumulate on the hot spots.</p>
<p class="docText1">The <tt class="calibre25">profile_tick( )</tt> function collects the data for the code profiler. It is invoked either by the <tt class="calibre25">do_timer_interrupt( )</tt> function in uniprocessor systems (by the global timer interrupt handler) or by the <tt class="calibre25">smp_local_timer_interrupt( )</tt> function in multiprocessor systems (by the local timer interrupt handler).</p>
<p class="docText1">To enable the code profiler, the Linux kernel must be booted by passing as a parameter the string <tt class="calibre25">profile=N</tt>, where 2<sup class="calibre37">N</sup> denotes the size of the code fragments to be profiled. The collected data can be read from the <i class="docEmphasis">/proc/profile</i> file. The counters are reset by writing in the same file; in multiprocessor systems, writing into the file can also change the sample frequency (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.3">Timekeeping Architecture in Multiprocessor Systems</a>"). However, kernel developers do not usually access <i class="docEmphasis">/proc/profile</i> directly; instead, they use the <i class="docEmphasis">readprofile</i> system command.</p>
<p class="docText1">The Linux 2.6 kernel includes yet another profiler called <span class="docEmphasis">oprofile</span>. Besides being more flexible and customizable than <span class="docEmphasis">readprofile</span>, <span class="docEmphasis">oprofile</span> can be used to discover hot spots in kernel code, User Mode applications, and system libraries. When <span class="docEmphasis">oprofile</span> is being used, <tt class="calibre25">profile_tick( )</tt> invokes the <tt class="calibre25">timer_notify( )</tt> function to collect the data used by this new profiler.</p>
<a name="understandlk-CHP-6-SECT-4.4"></a>
<h4 class="docSection2Title">6.4.4. Checking the NMI Watchdogs</h4><a name="IDX-CHP-6-1724"></a>
<a name="IDX-CHP-6-1725"></a>
<a name="IDX-CHP-6-1726"></a>
<a name="IDX-CHP-6-1727"></a>
<p class="docText1">In multiprocessor systems, Linux offers yet another feature to kernel developers: a <span class="docEmphasis">watchdog system</span><a name="IDX-CHP-6-1728"></a> 
, which might be quite useful to detect kernel bugs that cause a system freeze. To activate such a watchdog, the kernel must be booted with the <tt class="calibre25">nmi_watchdog</tt> parameter.</p>
<p class="docText1">The watchdog is based on a clever hardware feature of local and I/O APICs: they can generate periodic NMI interrupts<a name="IDX-CHP-6-1729"></a> 
 on every CPU. Because NMI interrupts are not masked by the <tt class="calibre25">cli</tt><a name="IDX-CHP-6-1730"></a> 
 assembly language instruction, the watchdog can detect deadlocks even when interrupts are disabled.</p>
<p class="docText1">As a consequence, once every tick, all CPUs, regardless of what they are doing, start executing the NMI interrupt handler; in turn, the handler invokes <tt class="calibre25">do_nmi( )</tt>. This function gets the logical number <span class="docEmphasis">n</span> of the CPU, and then checks the <tt class="calibre25">apic_timer_irqs</tt> field of the <span class="docEmphasis">n</span><sup class="calibre37">th</sup> entry of <tt class="calibre25">irq_stat</tt> (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-TABLE-8">Table 4-8</a> in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). If the CPU is working properly, the value must be different from the value read at the previous NMI interrupt. When the CPU is running properly, the <span class="docEmphasis">n</span><sup class="calibre37">th</sup> entry of the <tt class="calibre25">apic_timer_irqs</tt> field is increased by the local timer interrupt handler (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.3.3">The local timer interrupt handler</a>"); if the counter is not increased, the local timer interrupt handler has not been executed in a whole tick. Not a good thing, you know.</p>
<p class="docText1">When the NMI interrupt handler detects a CPU freeze, it rings all the bells: it logs scary messages in the system logfiles, dumps the contents of the CPU registers and of the kernel stack (kernel oops), and finally kills the current process. This gives kernel developers a chance to discover what's gone wrong.</p>

<br class="calibre7"/>

</div>

{% endraw %}

