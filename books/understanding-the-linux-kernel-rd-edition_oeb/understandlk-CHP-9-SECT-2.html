---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-9-SECT-1.html
next: understandlk-CHP-9-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-9-SECT-2"></a>
<h3 class="docSection1Title" id="534869-888">9.2. The Memory Descriptor</h3><a name="IDX-CHP-9-2303"></a>
<a name="IDX-CHP-9-2304"></a>
<a name="IDX-CHP-9-2305"></a>
<a name="IDX-CHP-9-2306"></a>
<a name="IDX-CHP-9-2307"></a>
<a name="IDX-CHP-9-2308"></a>
<a name="IDX-CHP-9-2309"></a>
<a name="IDX-CHP-9-2310"></a>
<a name="IDX-CHP-9-2311"></a>
<a name="IDX-CHP-9-2312"></a>
<a name="IDX-CHP-9-2313"></a>
<a name="IDX-CHP-9-2314"></a>
<p class="docText1">All information related to the process address space is included in an object called the <span class="docEmphasis">memory descriptor</span> of type <tt class="calibre25">mm_struct</tt>. This object is referenced by the <tt class="calibre25">mm</tt> field of the process descriptor. The fields of a memory descriptor are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-9-TABLE-2">Table 9-2</a>.</p>
<a name="understandlk-CHP-9-TABLE-2"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 9-2. The fields of the memory descriptor</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">vm_area_struct *</tt></p></td><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">mmap</tt></p></td><td class="docTableCell" valign="top"><p class="docText2">Pointer to the head of the list of memory region objects</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct rb_root</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mm_rb</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the root of the red-black tree of memory region objects</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">vm_area_struct *</tt></p></td><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">mmap_cache</tt></p></td><td class="docTableCell" valign="top"><p class="docText2">Pointer to the last referenced memory region object</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long (*)( )</p></td><td class="docTableCell"><p class="docText2">get_unmapped_area</p></td><td class="docTableCell"><p class="docText2">Method that searches an available linear address interval in the process address space</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">void (*)( )</p></td><td class="docTableCell"><p class="docText2">unmap_area</p></td><td class="docTableCell"><p class="docText2">Method invoked when releasing a linear address interval</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2">unsigned long</p></td><td class="docTableCell" valign="top"><p class="docText2">mmap_base</p></td><td class="docTableCell"><p class="docText2">Identifies the linear address of the first allocated anonymous memory region or file memory mapping (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.4">Program Segments and Process Memory Regions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">free_area_cache</p></td><td class="docTableCell"><p class="docText2">Address from which the kernel will look for a free interval of linear addresses in the process address space</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">pgd_t *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">pgd</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the Page Global Directory</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">atomic_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mm_users</tt></p></td><td class="docTableCell"><p class="docText2">Secondary usage counter</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">atomic_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mm_count</tt></p></td><td class="docTableCell"><p class="docText2">Main usage counter</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">map_count</tt></p></td><td class="docTableCell"><p class="docText2">Number of memory regions</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">rw_semaphore</tt></p></td><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">mmap_sem</tt></p></td><td class="docTableCell" valign="top"><p class="docText2">Memory regions' read/write semaphore</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">spinlock_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">page_table_lock</tt></p></td><td class="docTableCell"><p class="docText2">Memory regions' and Page Tables' spin lock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">mmlist</tt></p></td><td class="docTableCell" valign="top"><p class="docText2">Pointers to adjacent elements in the list of memory descriptors</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">start_code</tt></p></td><td class="docTableCell"><p class="docText2">Initial address of executable code</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">end_code</tt></p></td><td class="docTableCell"><p class="docText2">Final address of executable code</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">start_data</tt></p></td><td class="docTableCell"><p class="docText2">Initial address of initialized data</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">end_data</tt></p></td><td class="docTableCell"><p class="docText2">Final address of initialized data</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">start_brk</tt></p></td><td class="docTableCell"><p class="docText2">Initial address of the heap</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">brk</tt></p></td><td class="docTableCell"><p class="docText2">Current final address of the heap</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">start_stack</tt></p></td><td class="docTableCell"><p class="docText2">Initial address of User Mode stack</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">arg_start</tt></p></td><td class="docTableCell"><p class="docText2">Initial address of command-line arguments</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">arg_end</tt></p></td><td class="docTableCell"><p class="docText2">Final address of command-line arguments</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">env_start</tt></p></td><td class="docTableCell"><p class="docText2">Initial address of environment variables</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">env_end</tt></p></td><td class="docTableCell"><p class="docText2">Final address of environment variables</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">rss</tt></p></td><td class="docTableCell"><p class="docText2">Number of page frames allocated to the process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">anon_rss</p></td><td class="docTableCell"><p class="docText2">Number of page frames assigned to anonymous memory mappings</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">total_vm</tt></p></td><td class="docTableCell"><p class="docText2">Size of the process address space (number of pages)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">locked_vm</tt></p></td><td class="docTableCell"><p class="docText2">Number of "locked" pages that cannot be swapped out (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17.html#understandlk-CHP-17">Chapter 17</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">shared_vm</p></td><td class="docTableCell"><p class="docText2">Number of pages in shared file memory mappings</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">exec_vm</p></td><td class="docTableCell"><p class="docText2">Number of pages in executable memory mappings</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">stack_vm</p></td><td class="docTableCell"><p class="docText2">Number of pages in the User Mode stack</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">reserved_vm</p></td><td class="docTableCell"><p class="docText2">Number of pages in reserved or special memory regions</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">def_flags</tt></p></td><td class="docTableCell"><p class="docText2">Default access flags of the memory regions</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">nr_ptes</p></td><td class="docTableCell"><p class="docText2">Number of Page Tables of this process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long []</tt></p></td><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">saved_auxv</tt></p></td><td class="docTableCell" valign="top"><p class="docText2">Used when starting the execution of an ELF program (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">dumpable</tt></p></td><td class="docTableCell"><p class="docText2">Flag that specifies whether the process can produce a core dump of the memory</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">cpumask_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">cpu_vm_mask</tt></p></td><td class="docTableCell"><p class="docText2">Bit mask for lazy TLB switches (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">mm_context_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">context</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to table for architecture-specific information (e.g., LDT's address in 80  86 platforms)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">swap_token_time</p></td><td class="docTableCell"><p class="docText2">When this process will become eligible for having the swap token (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17-SECT-3.html#understandlk-CHP-17-SECT-3.6">The Swap Token</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17.html#understandlk-CHP-17">Chapter 17</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">recent_pagein</p></td><td class="docTableCell"><p class="docText2">Flag set if a major Page Fault has recently occurred</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2">int</p></td><td class="docTableCell" valign="top"><p class="docText2">core_waiters</p></td><td class="docTableCell"><p class="docText2">Number of lightweight processes that are dumping the contents of the process address space to a core file (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-5.html#understandlk-CHP-9-SECT-5.2">Deleting a Process Address Space</a>" later in this chapter)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct completion *</p></td><td class="docTableCell"><p class="docText2">core_startup_done</p></td><td class="docTableCell"><p class="docText2">Pointer to a completion used when creating a core file (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.10">Completions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct completion</p></td><td class="docTableCell"><p class="docText2">core_done</p></td><td class="docTableCell"><p class="docText2">Completion used when creating a core file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">rwlock_t</p></td><td class="docTableCell"><p class="docText2">ioctx_list_lock</p></td><td class="docTableCell"><p class="docText2">Lock used to protect the list of asynchronous I/O contexts (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct kioctx *</p></td><td class="docTableCell"><p class="docText2">ioctx_list</p></td><td class="docTableCell"><p class="docText2">List of asynchronous I/O contexts (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct kioctx</p></td><td class="docTableCell"><p class="docText2">default_kioctx</p></td><td class="docTableCell"><p class="docText2">Default asynchronous I/O context (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">hiwater_rss</p></td><td class="docTableCell"><p class="docText2">Maximum number of page frames ever owned by the process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">hiwater_vm</p></td><td class="docTableCell"><p class="docText2">Maximum number of pages ever included in the memory regions of the process</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">All memory descriptors are stored in a doubly linked list. Each descriptor stores the address of the adjacent list items in the <tt class="calibre25">mmlist</tt> field. The first element of the list is the <tt class="calibre25">mmlist</tt> field of <tt class="calibre25">init_mm</tt>, the memory descriptor used by process 0 in the initialization phase. The list is protected against concurrent accesses in multiprocessor systems by the <tt class="calibre25">mmlist_lock</tt> spin lock.</p>
<p class="docText1">The <tt class="calibre25">mm_users</tt> field stores the number of lightweight processes that share the <tt class="calibre25">mm_struct</tt> data structure (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.1">The clone( ), fork( ), and vfork( ) System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). The <tt class="calibre25">mm_count</tt> field is the main usage counter of the memory descriptor; all "users" in <tt class="calibre25">mm_users</tt> count as one unit in <tt class="calibre25">mm_count</tt>. Every time the <tt class="calibre25">mm_count</tt> field is decreased, the kernel checks whether it becomes zero; if so, the memory descriptor is deallocated because it is no longer in use.</p>
<p class="docText1">We'll try to explain the difference between the use of <tt class="calibre25">mm_users</tt> and <tt class="calibre25">mm_count</tt> with an example. Consider a memory descriptor shared by two lightweight processes. Normally, its <tt class="calibre25">mm_users</tt> field stores the value 2, while its <tt class="calibre25">mm_count</tt> field stores the value 1 (both owner processes count as one).</p>
<p class="docText1">If the memory descriptor is temporarily lent to a kernel thread (see the next section), the kernel increases the <tt class="calibre25">mm_count</tt> field. In this way, even if both lightweight processes die and the <tt class="calibre25">mm_users</tt> field becomes zero, the memory descriptor is not released until the kernel thread finishes using it because the <tt class="calibre25">mm_count</tt> field remains greater than zero.</p>
<p class="docText1">If the kernel wants to be sure that the memory descriptor is not released in the middle of a lengthy operation, it might increase the <tt class="calibre25">mm_users</tt> field instead of <tt class="calibre25">mm_count</tt> (this is what the <tt class="calibre25">try_to_unuse( )</tt> function does; see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17-SECT-4.html#understandlk-CHP-17-SECT-4.4">Activating and Deactivating a Swap Area</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17.html#understandlk-CHP-17">Chapter 17</a>). The final result is the same because the increment of <tt class="calibre25">mm_users</tt> ensures that <tt class="calibre25">mm_count</tt> does not become zero even if all lightweight processes that own the memory descriptor die.</p>
<p class="docText1">The <tt class="calibre25">mm_alloc( )</tt> function is invoked to get a new memory descriptor. Because these descriptors are stored in a slab allocator cache, <tt class="calibre25">mm_alloc( )</tt> calls <tt class="calibre25">kmem_cache_alloc( )</tt>, initializes the new memory descriptor, and sets the <tt class="calibre25">mm_count</tt> and <tt class="calibre25">mm_users</tt> field to 1.</p>
<p class="docText1">Conversely, the <tt class="calibre25">mmput( )</tt> function decreases the <tt class="calibre25">mm_users</tt> field of a memory descriptor. If that field becomes 0, the function releases the Local Descriptor Table, the memory region descriptors (see later in this chapter), and the Page Tables referenced by the memory descriptor, and then invokes <tt class="calibre25">mmdrop( )</tt>. The latter function decreases <tt class="calibre25">mm_count</tt> and, if it becomes zero, releases the <tt class="calibre25">mm_struct</tt> data structure.</p>
<p class="docText1">The <tt class="calibre25">mmap</tt>, <tt class="calibre25">mm_rb</tt>, <tt class="calibre25">mmlist</tt>, and <tt class="calibre25">mmap_cache</tt> fields are discussed in the next section.</p>
<a name="understandlk-CHP-9-SECT-2.1"></a>
<h4 class="docSection2Title">9.2.1. Memory Descriptor of Kernel Threads</h4><a name="IDX-CHP-9-2316"></a>
<a name="IDX-CHP-9-2317"></a>
<a name="IDX-CHP-9-2318"></a>
<a name="IDX-CHP-9-2319"></a>
<a name="IDX-CHP-9-2320"></a>
<a name="IDX-CHP-9-2321"></a>
<a name="IDX-CHP-9-2322"></a>
<p class="docText1">Kernel threads run only in Kernel Mode, so they never access linear addresses below <tt class="calibre25">TASK_SIZE</tt> (same as <tt class="calibre25">PAGE_OFFSET</tt>, usually <tt class="calibre25">0xc0000000</tt>). Contrary to regular processes, kernel threads<a name="IDX-CHP-9-2323"></a> 
 do not use memory regions, therefore most of the fields of a memory descriptor are meaningless for them.</p>
<p class="docText1">Because the Page Table entries that refer to the linear address above <tt class="calibre25">TASK_SIZE</tt> should always be identical, it does not really matter what set of Page Tables a kernel thread uses. To avoid useless TLB and cache flushes, a kernel thread uses the set of Page Tables of the last previously running regular process. To that end, two kinds of memory descriptor pointers are included in every process descriptor: <tt class="calibre25">mm</tt> and <tt class="calibre25">active_mm</tt>.</p>
<p class="docText1">The <tt class="calibre25">mm</tt> field in the process descriptor points to the memory descriptor owned by the process, while the <tt class="calibre25">active_mm</tt> field points to the memory descriptor used by the process when it is in execution. For regular processes, the two fields store the same pointer. Kernel threads, however, do not own any memory descriptor, thus their <tt class="calibre25">mm</tt> field is always <tt class="calibre25">NULL</tt>. When a kernel thread is selected for execution, its <tt class="calibre25">active_mm</tt> field is initialized to the value of the <tt class="calibre25">active_mm</tt> of the previously running process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.4">The schedule( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>).</p>
<p class="docText1">There is, however, a small complication. Whenever a process in Kernel Mode modifies a Page Table entry for a "high" linear address (above <tt class="calibre25">TASK_SIZE</tt>), it should also update the corresponding entry in the sets of Page Tables of all processes in the system. In fact, once set by a process in Kernel Mode, the mapping should be effective for all other processes in Kernel Mode as well. Touching the sets of Page Tables of all processes is a costly operation; therefore, Linux adopts a deferred approach.</p>
<p class="docText1">We already mentioned this deferred approach in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-3.html#understandlk-CHP-8-SECT-3">Noncontiguous Memory Area Management</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>: every time a high linear address has to be remapped (typically by <tt class="calibre25">vmalloc( )</tt> or <tt class="calibre25">vfree( )</tt>), the kernel updates a canonical set of Page Tables rooted at the <tt class="calibre25">swapper_pg_dir</tt> master kernel Page Global Directory (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-5.html#understandlk-CHP-2-SECT-5.5">Kernel Page Tables</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>). This Page Global Directory is pointed to by the <tt class="calibre25">pgd</tt> field of a <span class="docEmphasis">master memory descriptor</span><a name="IDX-CHP-9-2324"></a> 
, which is stored in the <tt class="calibre25">init_mm</tt> variable.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-9-FN1">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-9-FN1">[*]</a></sup> We mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.2">Kernel Threads</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a> that the <span class="docEmphasis">swapper</span> process uses <tt class="calibre42">init_mm</tt> during the initialization phase. However, swapper never uses this memory descriptor once the initialization phase completes.</p></blockquote>
<p class="docText1">Later, in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-4.html#understandlk-CHP-9-SECT-4.5">Handling Noncontiguous Memory Area Accesses</a>," we'll describe how the Page Fault handler takes care of spreading the information stored in the canonical Page Tables when effectively needed.</p>

<br class="calibre7"/>

</div>

{% endraw %}

