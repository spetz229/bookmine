---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-14-SECT-4.html
next: understandlk-CHP-15.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-14-SECT-5"></a>
<h3 class="docSection1Title">14.5. Opening a Block Device File</h3><a name="IDX-CHP-14-3732"></a>
<a name="IDX-CHP-14-3733"></a>
<a name="IDX-CHP-14-3734"></a>
<a name="IDX-CHP-14-3735"></a>
<a name="IDX-CHP-14-3736"></a>
<a name="IDX-CHP-14-3737"></a>
<a name="IDX-CHP-14-3738"></a>
<a name="IDX-CHP-14-3739"></a>
<a name="IDX-CHP-14-3740"></a>
<a name="IDX-CHP-14-3741"></a>
<a name="IDX-CHP-14-3742"></a>
<a name="IDX-CHP-14-3743"></a>
<a name="IDX-CHP-14-3744"></a>
<a name="IDX-CHP-14-3745"></a>
<p class="docText1">We conclude this chapter by describing the steps performed by the VFS when opening a block device file.</p>
<p class="docText1">The kernel opens a block device file every time that a filesystem is mounted over a disk or partition, every time that a swap partition is activated, and every time that a User Mode process issues an <tt class="calibre25">open( )</tt><a name="IDX-CHP-14-3746"></a> 
 system call on a block device file. In all cases, the kernel executes essentially the same operations: it looks for the block device descriptor (possibly allocating a new descriptor if the block device is not already in use), and sets up the file operation methods for the forthcoming data transfers.</p>
<p class="docText1">In the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-3.html#understandlk-CHP-13-SECT-3.2">VFS Handling of Device Files</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>, we described how the <tt class="calibre25">dentry_open( )</tt> function customizes the methods of the file object when a device file is opened. In this case, the <tt class="calibre25">f_op</tt> field of the file object is set to the address of the <tt class="calibre25">def_blk_fops</tt> table, whose content is shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-14-TABLE-10">Table 14-10</a>.</p>
<a name="understandlk-CHP-14-TABLE-10"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 14-10. The default block device file operations (def_blk_fops table)</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Method</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Function</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">open</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">blkdev_open( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">release</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">blkdev_close( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">llseek</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">block_llseek( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">read</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">generic_file_read( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">write</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">blkdev_file_write( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_read</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">generic_file_aio_read( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">aio_write</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">blkdev_file_aio_write( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">mmap</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">generic_file_mmap( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">fsync</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">block_fsync( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">ioctl</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">block_ioctl( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">compat-ioctl</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">compat_blkdev_ioctl( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">readv</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">generic_file_readv( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">writev</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">generic_file_write_nolock( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sendfile</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">generic_file_sendfile( )</tt></p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Here we are only concerned with the <tt class="calibre25">open</tt> method, which is invoked by the <tt class="calibre25">dentry_open( )</tt> function. The <tt class="calibre25">blkdev_open( )</tt> function receives as its parameters <tt class="calibre25">inode</tt> and <tt class="calibre25">filp</tt>, which store the addresses of the inode and file objects respectively; the function essentially executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Executes <tt class="calibre25">bd_acquire(inode )</tt> to get the address <tt class="calibre25">bdev</tt><a name="IDX-CHP-14-3747"></a> 
 of the block device descriptor. In turn, this function receives the inode object address and performs the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the <tt class="calibre25">inode-&gt;i_bdev</tt> field of the inode object is not <tt class="calibre25">NULL</tt>; if it is, the block device file has been opened already, and this field stores the address of the corresponding block descriptor. In this case, the function increases the usage counter of the <tt class="calibre25">inode-&gt;i_bdev-&gt;bd_inode</tt> inode of the <span class="docEmphasis">bdev</span> special filesystem associated with the block device, and returns the address <tt class="calibre25">inode-&gt;i_bdev</tt> of the descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Here the block device file has not been opened yet. Executes <tt class="calibre25">bdget(inode-&gt;i_rdev)</tt> to get the address of the block device descriptor corresponding to the major and minor number of the block device file (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-4.html#understandlk-CHP-14-SECT-4.1">Block Devices</a>" earlier in this chapter). If the descriptor does not already exist, <tt class="calibre25">bdget( )</tt> allocates it; notice however that the descriptor might already exist, for instance because the block device is already being accessed by means of another block device file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Stores the block device descriptor address in <tt class="calibre25">inode-&gt;i_bdev</tt>, so as to speed up future opening operations on the same block device file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">inode-&gt;i_mapping</tt> field with the value of the corresponding field in the <tt class="calibre25">bdev</tt> inode. This is the pointer to the address space object, which will be explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-1.html#understandlk-CHP-15-SECT-1.1">The address_space Object</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Inserts <tt class="calibre25">inode</tt> into the list of opened inodes of the block device descriptor rooted at <tt class="calibre25">bdev-&gt;bd_inodes</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address <tt class="calibre25">bdev</tt> of the descriptor.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">filp-&gt;i_mapping</tt> field with the value of <tt class="calibre25">inode-&gt;i_mapping</tt> (see step 1(d) above).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets the address of the <tt class="calibre25">gendisk</tt> descriptor relative to this block device:</p><pre class="calibre60">
disk = get_gendisk(bdev-&gt;bd_dev, &amp;part);
</pre><br class="calibre7"/>
<p class="docList">If the block device being opened is a partition, the function also returns its index in the <tt class="calibre25">part</tt> local variable; otherwise, <tt class="calibre25">part</tt> is set to zero. The <tt class="calibre25">get_gendisk( )</tt> function simply invokes <tt class="calibre25">kobj_lookup( )</tt> on the <tt class="calibre25">bdev_map</tt> kobject mapping domain<a name="IDX-CHP-14-3748"></a> 
 passing the major and minor number of the device (see also the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-4.html#understandlk-CHP-14-SECT-4.2">Device Driver Registration and Initialization</a>" earlier in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">bdev-&gt;bd_openers</tt> is not equal to zero, the block device has already been opened. Checks the <tt class="calibre25">bdev-&gt;bd_contains</tt> field:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If it is equal to <tt class="calibre25">bdev</tt>, the block device is a whole disk: invokes the <tt class="calibre25">bdev-&gt;bd_disk-&gt;fops-&gt;open</tt> block device method, if defined, then checks the <tt class="calibre25">bdev-&gt;bd_invalidated</tt> field and invokes, if necessary, the <tt class="calibre25">rescan_partitions( )</tt> functions (see comments on steps 6a and 6c later).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If it not equal to <tt class="calibre25">bdev</tt>, the block device is a partition: increases the <tt class="calibre25">bdev-&gt;bd_contains-&gt;bd_part_count</tt> counter.</p></div></li></ol></div><p class="docList">Then, jumps to step 8.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Here the block device is being accessed for the first time. Initializes <tt class="calibre25">bdev-&gt;bd_disk</tt> with the address <tt class="calibre25">disk</tt> of the <tt class="calibre25">gendisk</tt> descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the block device is a whole disk (<tt class="calibre25">part</tt> is zero), it executes the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If defined, it executes the <tt class="calibre25">disk-&gt;fops-&gt;open</tt> block device method: it is a custom function defined by the block device driver to perform any specific last-minute initialization.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets from the <tt class="calibre25">hardsect_size</tt> field of the <tt class="calibre25">disk-&gt;queue</tt> request queue the sector size in bytes, and uses this value to set properly the <tt class="calibre25">bdev-&gt;bd_block_size</tt> and <tt class="calibre25">bdev-&gt;bd_inode-&gt;i_blkbits</tt> fields. Sets also the <tt class="calibre25">bdev-&gt;bd_inode-&gt;i_size</tt> field with the size of the disk computed from <tt class="calibre25">disk-&gt;capacity</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">bdev-&gt;bd_invalidated</tt> flag is set, it invokes <tt class="calibre25">rescan_partitions( )</tt> to scan the partition table and update the partition descriptors. The flag is set by the <tt class="calibre25">check_disk_change</tt> block device method, which applies only to removable devices.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise if the block device is a partition (<tt class="calibre25">part</tt> is not zero), it executes the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">bdget( )</tt> againthis time passing the <tt class="calibre25">disk-&gt;first_minor</tt> minor numberto get the address <tt class="calibre25">whole</tt> of the block descriptor for the whole disk.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Repeats steps from 3 to 6 for the block device descriptor of the whole disk, thus initializing it if necessary.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">bdev-&gt;bd_contains</tt> to the address of the descriptor of the whole disk.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases <tt class="calibre25">whole-&gt;bd_part_count</tt> to account for the new open operation on the partition of the disk.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets <tt class="calibre25">bdev-&gt;bd_part</tt> with the value in <tt class="calibre25">disk-&gt;part[part-1]</tt>; it is the address of the <tt class="calibre25">hd_struct</tt> descriptor of the partition. Also, executes <tt class="calibre25">kobject_get(&amp;bdev-&gt;bd_part-&gt;kobj)</tt> to increase the reference counter of the partition.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">As in step 6b, sets the inode fields that specify size and sector size of the partition.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases the <tt class="calibre25">bdev-&gt;bd_openers</tt> counter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the block device file is being opened in exclusive mode (<tt class="calibre25">O_EXCL</tt> flag in <tt class="calibre25">filp-&gt;f_flags</tt> set), it invokes <tt class="calibre25">bd_claim(bdev, filp)</tt> to set the holder of the block device (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-4.html#understandlk-CHP-14-SECT-4.1">Block Devices</a>" earlier in this chapter). In case of errorblock device has already an holderit releases the block device descriptor and returns the error code <tt class="calibre25">-EBUSY</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Terminates by returning 0 (success).</p></div></li></ol></div>
<p class="docText1">Once the <tt class="calibre25">blkdev_open( )</tt> function terminates, the <tt class="calibre25">open( )</tt> system call proceeds as usual. Every future system call issued on the opened file will trigger one of the default block device file operations. As we will see in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>, each data transfer to or from the block device is effectively implemented by submitting requests to the generic block layer.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

