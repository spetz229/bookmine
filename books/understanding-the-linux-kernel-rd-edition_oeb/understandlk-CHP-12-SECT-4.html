---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-12-SECT-3.html
next: understandlk-CHP-12-SECT-5.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-12-SECT-4"></a>
<h3 class="docSection1Title">12.4. Filesystem Handling</h3><a name="IDX-CHP-12-3138"></a>
<a name="IDX-CHP-12-3139"></a>
<a name="IDX-CHP-12-3140"></a>
<a name="IDX-CHP-12-3141"></a>
<a name="IDX-CHP-12-3142"></a>
<a name="IDX-CHP-12-3143"></a>
<a name="IDX-CHP-12-3144"></a>
<a name="IDX-CHP-12-3145"></a>
<a name="IDX-CHP-12-3146"></a>
<a name="IDX-CHP-12-3147"></a>
<a name="IDX-CHP-12-3148"></a>
<a name="IDX-CHP-12-3149"></a>
<a name="IDX-CHP-12-3150"></a>
<p class="docText1">Like every traditional Unix system, Linux makes use of a <span class="docEmphasis">system's root filesystem</span><a name="IDX-CHP-12-3151"></a> 
: it is the filesystem that is directly mounted by the kernel during the booting phase and that holds the system initialization scripts and the most essential system programs.</p>
<p class="docText1">Other filesystems can be mountedeither by the initialization scripts or directly by the userson directories of already mounted filesystems. Being a tree of directories, every filesystem has its own <span class="docEmphasis">root directory</span>. The directory on which a filesystem is mounted is called the <span class="docEmphasis">mount point</span>. A mounted filesystem is a <span class="docEmphasis">child</span> of the mounted filesystem to which the mount point directory belongs. For instance, the <i class="docEmphasis">/proc</i> virtual filesystem is a child of the system's root filesystem (and the system's root filesystem is the <span class="docEmphasis">parent</span> of <i class="docEmphasis">/proc</i>). The root directory of a mounted filesystem hides the content of the mount point directory of the parent filesystem, as well as the whole subtree of the parent filesystem below the mount point.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN5">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-12-FN5">[*]</a></sup> The root directory of a filesystem can be different from the root directory of a process: as we have seen in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.6">Files Associated with a Process</a>," the process's root directory is the directory corresponding to the "<i class="docEmphasis">/</i>" pathname. By default, the process' root directory coincides with the root directory of the system's root filesystem (or more precisely, with the root directory of the root filesystem in the namespace<a name="IDX-CHP-12-3152"></a> 
 of the process, described in the following section), but it can be changed by invoking the <tt class="calibre42">chroot( )</tt><a name="IDX-CHP-12-3153"></a> 
 system call.</p></blockquote>
<a name="understandlk-CHP-12-SECT-4.1"></a>
<h4 class="docSection2Title">12.4.1. Namespaces</h4><a name="IDX-CHP-12-3154"></a>
<a name="IDX-CHP-12-3155"></a>
<a name="IDX-CHP-12-3156"></a>
<a name="IDX-CHP-12-3157"></a>
<p class="docText1">In a traditional Unix system, there is only one tree of mounted filesystems: starting from the system's root filesystem, each process can potentially access every file in a mounted filesystem by specifying the proper pathname. In this respect, Linux 2.6 is more refined: every process might have its own tree of mounted filesystemsthe so-called <span class="docEmphasis">namespace</span> of the process.</p>
<p class="docText1">Usually most processes share the same namespace, which is the tree of mounted filesystems that is rooted at the system's root filesystem and that is used by the <span class="docEmphasis">init</span> process. However, a process gets a new namespace if it is created by the <tt class="calibre25">clone( )</tt><a name="IDX-CHP-12-3158"></a> 
 system call with the <tt class="calibre25">CLONE_NEWNS</tt> flag set (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.1">The clone( ), fork( ), and vfork( ) System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). The new namespace is then inherited by children processes if the parent creates them without the <tt class="calibre25">CLONE_NEWNS</tt> flag.</p>
<p class="docText1">When a process mountsor unmountsa filesystem, it only modifies its namespace. Therefore, the change is visible to all processes that share the same namespace, and only to them. A process can even change the root filesystem of its namespace by using the Linux-specific <tt class="calibre25">pivot_root( )</tt><a name="IDX-CHP-12-3159"></a> 
 system call.</p>
<p class="docText1">The namespace of a process is represented by a <tt class="calibre25">namespace</tt> structure pointed to by the <tt class="calibre25">namespace</tt> field of the process descriptor. The fields of the <tt class="calibre25">namespace</tt> structure are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-11">Table 12-11</a>.</p>
<a name="understandlk-CHP-12-TABLE-11"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-11. The fields of the namespace structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">atomic_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">count</tt></p></td><td class="docTableCell"><p class="docText2">Usage counter (how many processes share the namespace)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct vfsmount *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">root</tt></p></td><td class="docTableCell"><p class="docText2">Mounted filesystem descriptor for the root directory of the namespace</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">list</tt></p></td><td class="docTableCell"><p class="docText2">Head of list of all mounted filesystem descriptors</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct rw_semaphore</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">sem</tt></p></td><td class="docTableCell"><p class="docText2">Read/write semaphore protecting this structure</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">list</tt> field is the head of a doubly linked circular list collecting all mounted filesystems that belong to the namespace. The <tt class="calibre25">root</tt> field specifies the mounted filesystem that represents the root of the tree of mounted filesystems of this namespace. As we will see in the next section, mounted filesystems are represented by <tt class="calibre25">vfsmount</tt> structures.</p>
<a name="understandlk-CHP-12-SECT-4.2"></a>
<h4 class="docSection2Title">12.4.2. Filesystem Mounting</h4><a name="IDX-CHP-12-3160"></a>
<a name="IDX-CHP-12-3161"></a>
<a name="IDX-CHP-12-3162"></a>
<a name="IDX-CHP-12-3163"></a>
<p class="docText1">In most traditional Unix-like kernels, each filesystem can be mounted only once. Suppose that an Ext2 filesystem<a name="IDX-CHP-12-3164"></a> 
 stored in the <i class="docEmphasis">/dev/fd0</i> floppy disk is mounted on <i class="docEmphasis">/flp</i> by issuing the command:</p>
<pre class="calibre27">
    mount -t ext2 /dev/fd0 /flp</pre><br class="calibre7"/>
<p class="docText1">Until the filesystem is unmounted by issuing a <tt class="calibre25">umount</tt> command, every other mount command acting on <i class="docEmphasis">/dev/fd0</i> fails.</p>
<p class="docText1">However, Linux is different: it is possible to mount the same filesystem several times. Of course, if a filesystem is mounted <span class="docEmphasis">n</span> times, its root directory can be accessed through <span class="docEmphasis">n</span> mount points, one per mount operation. Although the same filesystem can be accessed by using different mount points, it is really unique. Thus, there is only one superblock object for all of them, no matter of how many times it has been mounted.</p>
<p class="docText1">Mounted filesystems form a hierarchy: the mount point of a filesystem might be a directory of a second filesystem, which in turn is already mounted over a third filesystem, and so on.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN6">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-12-FN6">[*]</a></sup> Quite surprisingly, the mount point of a filesystem might be a directory of the same filesystem, provided that it was already mounted. For instance:</p></blockquote><pre class="calibre27">
    mount -t ext2 /dev/fd0 /flp; touch /flp/foo
    mkdir /flp/mnt; mount -t ext2 /dev/fd0 /flp/mnt
</pre><br class="calibre7"/>
<blockquote class="calibre22"><p class="docFootnote1">Now, the empty <span class="docEmphasis">foo</span> file on the floppy filesystem can be accessed both as <span class="docEmphasis">/flp/foo</span> and <span class="docEmphasis">/flp/mnt/foo</span>.</p></blockquote>
<p class="docText1">It is also possible to stack multiple mounts on a single mount point. Each new mount on the same mount point hides the previously mounted filesystem, although processes already using the files and directories under the old mount can continue to do so. When the topmost mounting<a name="IDX-CHP-12-3165"></a> 
 is removed, then the next lower mount is once more made visible.</p>
<p class="docText1">As you can imagine, keeping track of mounted filesystems can quickly become a nightmare. For each mount operation, the kernel must save in memory the mount point and the mount flags, as well as the relationships between the filesystem to be mounted and the other mounted filesystems. Such information is stored in a <span class="docEmphasis">mounted filesystem descriptor</span> of type <tt class="calibre25">vfsmount</tt>. The fields of this descriptor are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-12">Table 12-12</a>.</p>
<a name="understandlk-CHP-12-TABLE-12"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-12. The fields of the vfsmount data structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_hash</tt></p></td><td class="docTableCell"><p class="docText2">Pointers for the hash table list.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct vfsmount *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_parent</tt></p></td><td class="docTableCell"><p class="docText2">Points to the parent filesystem on which this filesystem is mounted.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct dentry *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_mountpoint</tt></p></td><td class="docTableCell"><p class="docText2">Points to the <tt class="calibre25">dentry</tt> of the mount point directory where the filesystem is mounted.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct dentry *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_root</tt></p></td><td class="docTableCell"><p class="docText2">Points to the <tt class="calibre25">dentry</tt> of the root directory of this filesystem.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct super_block *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_sb</tt></p></td><td class="docTableCell"><p class="docText2">Points to the superblock object of this filesystem.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_mounts</tt></p></td><td class="docTableCell"><p class="docText2">Head of a list including all filesystem descriptors mounted on directories of this filesystem.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_child</tt></p></td><td class="docTableCell"><p class="docText2">Pointers for the <tt class="calibre25">mnt_mounts</tt> list of mounted filesystem descriptors.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">atomic_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_count</tt></p></td><td class="docTableCell"><p class="docText2">Usage counter (increased to forbid filesystem unmounting).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_flags</tt></p></td><td class="docTableCell"><p class="docText2">Flags.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">int</p></td><td class="docTableCell"><p class="docText2">mnt_expiry_mark</p></td><td class="docTableCell"><p class="docText2">Flag set to true if the filesystem is marked as expired (the filesystem can be automatically unmounted if the flag is set and no one is using it).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">char *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_devname</tt></p></td><td class="docTableCell"><p class="docText2">Device filename.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">mnt_list</tt></p></td><td class="docTableCell"><p class="docText2">Pointers for namespace's list of mounted filesystem descriptors.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2">mnt_fslink</p></td><td class="docTableCell"><p class="docText2">Pointers for the filesystem-specific expire list.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct namespace *</p></td><td class="docTableCell"><p class="docText2">mnt_namespace</p></td><td class="docTableCell"><p class="docText2">Pointer to the namespace of the process that mounted the filesystem.</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">vfsmount</tt> data structures are kept in several doubly linked circular lists:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">A hash table indexed by the address of the <tt class="calibre25">vfsmount</tt> descriptor of the parent filesystem and the address of the dentry object of the mount point directory. The hash table is stored in the <tt class="calibre25">mount_hashtable</tt> array, whose size depends on the amount of RAM in the system. Each item of the table is the head of a circular doubly linked list storing all descriptors that have the same hash value. The <tt class="calibre25">mnt_hash</tt> field of the descriptor contains the pointers to adjacent elements in this list.</p></li><li class="calibre12"><p class="docText1">For each namespace, a circular doubly linked list including all mounted filesystem descriptors belonging to the namespace. The <tt class="calibre25">list</tt> field of the <tt class="calibre25">namespace</tt> structure stores the head of the list, while the <tt class="calibre25">mnt_list</tt> field of the <tt class="calibre25">vfsmount</tt> descriptor contains the pointers to adjacent elements in the list.</p></li><li class="calibre12"><p class="docText1">For each mounted filesystem, a circular doubly linked list including all child mounted filesystems. The head of each list is stored in the <tt class="calibre25">mnt_mounts</tt> field of the mounted filesystem descriptor; moreover, the <tt class="calibre25">mnt_child</tt> field of the descriptor stores the pointers to the adjacent elements in the list.</p></li></ul>
<p class="docText1">The <tt class="calibre25">vfsmount_lock</tt> spin lock protects the lists of mounted filesystem objects from concurrent accesses.</p>
<p class="docText1">The <tt class="calibre25">mnt_flags</tt> field of the descriptor stores the value of several flags that specify how some kinds of files in the mounted filesystem are handled. These flags, which can be set through options of the <i class="docEmphasis">mount</i> command, are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-13">Table 12-13</a>.</p>
<a name="understandlk-CHP-12-TABLE-13"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-13. Mounted filesystem flags</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MNT_NOSUID</tt></p></td><td class="docTableCell"><p class="docText2">Forbid <tt class="calibre25">setuid</tt> and <tt class="calibre25">setgid</tt> flags in the mounted filesystem</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MNT_NODEV</tt></p></td><td class="docTableCell"><p class="docText2">Forbid access to device files in the mounted filesystem</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MNT_NOEXEC</tt></p></td><td class="docTableCell"><p class="docText2">Disallow program execution in the mounted filesystem</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Here are some functions that handle the mounted filesystem descriptors:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">alloc_vfsmnt(name)</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Allocates and initializes a mounted filesystem descriptor</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">free_vfsmnt(mnt)</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Frees a mounted filesystem descriptor pointed to by <tt class="calibre25">mnt</tt></p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">lookup_mnt(mnt, dentry)</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Looks up a descriptor in the hash table and returns its address</p></dd></dl>
<a name="understandlk-CHP-12-SECT-4.3"></a>
<h4 class="docSection2Title">12.4.3. Mounting a Generic Filesystem</h4><a name="IDX-CHP-12-3166"></a>
<a name="IDX-CHP-12-3167"></a>
<a name="IDX-CHP-12-3168"></a>
<a name="IDX-CHP-12-3169"></a>
<a name="IDX-CHP-12-3170"></a>
<a name="IDX-CHP-12-3171"></a>
<a name="IDX-CHP-12-3172"></a>
<a name="IDX-CHP-12-3173"></a>
<a name="IDX-CHP-12-3174"></a>
<a name="IDX-CHP-12-3175"></a>
<a name="IDX-CHP-12-3176"></a>
<a name="IDX-CHP-12-3177"></a>
<a name="IDX-CHP-12-3178"></a>
<a name="IDX-CHP-12-3179"></a>
<a name="IDX-CHP-12-3180"></a>
<a name="IDX-CHP-12-3181"></a>
<a name="IDX-CHP-12-3182"></a>
<a name="IDX-CHP-12-3183"></a>
<a name="IDX-CHP-12-3184"></a>
<a name="IDX-CHP-12-3185"></a>
<a name="IDX-CHP-12-3186"></a>
<a name="IDX-CHP-12-3187"></a>
<a name="IDX-CHP-12-3188"></a>
<a name="IDX-CHP-12-3189"></a>
<a name="IDX-CHP-12-3190"></a>
<a name="IDX-CHP-12-3191"></a>
<p class="docText1">We'll now describe the actions performed by the kernel in order to mount a filesystem. We'll start by considering a filesystem that is going to be mounted over a directory of an already mounted filesystem (in this discussion we will refer to this new filesystem as "generic").</p>
<p class="docText1">The <tt class="calibre25">mount( )</tt><a name="IDX-CHP-12-3192"></a> 
 system call is used to mount a generic filesystem; its <tt class="calibre25">sys_mount( )</tt> service routine acts on the following parameters:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The pathname of a device file containing the filesystem, or <tt class="calibre25">NULL</tt> if it is not required (for instance, when the filesystem to be mounted is network-based)</p></li><li class="calibre12"><p class="docText1">The pathname of the directory on which the filesystem will be mounted (the mount point)</p></li><li class="calibre12"><p class="docText1">The filesystem type, which must be the name of a registered filesystem</p></li><li class="calibre12"><p class="docText1">The mount flags (permitted values are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-14">Table 12-14</a>)</p></li><li class="calibre12"><p class="docText1">A pointer to a filesystem-dependent data structure (which may be <tt class="calibre25">NULL</tt>)</p></li></ul>
<a name="understandlk-CHP-12-TABLE-14"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-14. Flags used by the mount() system call</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Macro</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_RDONLY</tt></p></td><td class="docTableCell"><p class="docText2">Files can only be read</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_NOSUID</tt></p></td><td class="docTableCell"><p class="docText2">Forbid <tt class="calibre25">setuid</tt> and <tt class="calibre25">setgid</tt> flags</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_NODEV</tt></p></td><td class="docTableCell"><p class="docText2">Forbid access to device files</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_NOEXEC</tt></p></td><td class="docTableCell"><p class="docText2">Disallow program execution</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_SYNCHRONOUS</tt></p></td><td class="docTableCell"><p class="docText2">Write operations on files and directories are immediate</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_REMOUNT</tt></p></td><td class="docTableCell"><p class="docText2">Remount the filesystem changing the mount flags</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_MANDLOCK</tt></p></td><td class="docTableCell"><p class="docText2">Mandatory locking allowed</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_DIRSYNC</tt></p></td><td class="docTableCell"><p class="docText2">Write operations on directories are immediate</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_NOATIME</tt></p></td><td class="docTableCell"><p class="docText2">Do not update file access time</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_NODIRATIME</tt></p></td><td class="docTableCell"><p class="docText2">Do not update directory access time</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_BIND</tt></p></td><td class="docTableCell"><p class="docText2">Create a "bind mount," which allows making a file or directory visible at another point of the system directory tree (option <tt class="calibre25">--bind</tt> of the <span class="docEmphasis">mount</span> command)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_MOVE</tt></p></td><td class="docTableCell"><p class="docText2">Atomically move a mounted filesystem to another mount point (option <tt class="calibre25">--move</tt> of the <span class="docEmphasis">mount</span> command)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_REC</tt></p></td><td class="docTableCell"><p class="docText2">Recursively create "bind mounts" for a directory subtree</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">MS_VERBOSE</tt></p></td><td class="docTableCell"><p class="docText2">Generate kernel messages on mount errors</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">sys_mount( )</tt> function copies the value of the parameters into temporary kernel buffers, acquires the big kernel lock<a name="IDX-CHP-12-3193"></a> 
, and invokes the <tt class="calibre25">do_mount( )</tt> function. Once <tt class="calibre25">do_mount( )</tt> returns, the service routine releases the big kernel lock and frees the temporary kernel buffers.</p>
<p class="docText1">The <tt class="calibre25">do_mount( )</tt> function takes care of the actual mount operation by performing the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If some of the <tt class="calibre25">MS_NOSUID</tt>, <tt class="calibre25">MS_NODEV</tt>, or <tt class="calibre25">MS_NOEXEC</tt> mount flags are set, it clears them and sets the corresponding flag (<tt class="calibre25">MNT_NOSUID</tt>, <tt class="calibre25">MNT_NODEV</tt>, <tt class="calibre25">MNT_NOEXEC</tt>) in the mounted filesystem object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Looks up the pathname of the mount point by invoking <tt class="calibre25">path_lookup( )</tt>; this function stores the result of the pathname lookup in the local variable <tt class="calibre25">nd</tt> of type <tt class="calibre25">nameidata</tt> (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-5.html#understandlk-CHP-12-SECT-5">Pathname Lookup</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Examines the mount flags to determine what has to be done. In particular:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">MS_REMOUNT</tt> flag is specified, the purpose is usually to change the mount flags in the <tt class="calibre25">s_flags</tt> field of the superblock object and the mounted filesystem flags in the <tt class="calibre25">mnt_flags</tt> field of the mounted filesystem object. The <tt class="calibre25">do_remount( )</tt> function performs these changes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, it checks the <tt class="calibre25">MS_BIND</tt> flag. If it is specified, the user is asking to make visible a file or directory on another point of the system directory tree.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, it checks the <tt class="calibre25">MS_MOVE</tt> flag. If it is specified, the user is asking to change the mount point of an already mounted filesystem. The <tt class="calibre25">do_move_mount( )</tt> function does this atomically.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, it invokes <tt class="calibre25">do_new_mount( )</tt>. This is the most common case. It is triggered when the user asks to mount either a special filesystem or a regular filesystem stored in a disk partition. <tt class="calibre25">do_new_mount( )</tt> invokes the <tt class="calibre25">do_kern_mount( )</tt> function passing to it the filesystem type, the mount flags, and the block device name. This function, which takes care of the actual mount operation and returns the address of a new mounted filesystem descriptor, is described below. Next, <tt class="calibre25">do_new_mount( )</tt> invokes <tt class="calibre25">do_add_mount( )</tt>, which essentially performs the following actions:</p><div class="calibre44"><ol class="docList4" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Acquires for writing the <tt class="calibre25">namespace-&gt;sem</tt> semaphore of the current process, because the function is going to modify the namespace.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">do_kern_mount( )</tt> function might put the current process to sleep; meanwhile, another process might mount a filesystem on the very same mount point as ours or even change our root filesystem (<tt class="calibre25">current-&gt;namespace-&gt;root</tt>). Verifies that the lastly mounted filesystem on this mount point still refers to the <tt class="calibre25">current</tt>'s namespace; if not, releases the read/write semaphore and returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the filesystem to be mounted is already mounted on the mount point specified as parameter of the system call, or if the mount point is a symbolic link, it releases the read/write semaphore and returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the flags in the <tt class="calibre25">mnt_flags</tt> field of the new mounted filesystem object allocated by <tt class="calibre25">do_kern_mount( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">graft_tree( )</tt> to insert the new mounted filesystem object in the namespace list, in the hash table, and in the children list of the parent-mounted filesystem.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">namespace-&gt;sem</tt> read/write semaphore and returns.</p></div></li></ol></div></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">path_release( )</tt> to terminate the pathname lookup of the mount point (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-5.html#understandlk-CHP-12-SECT-5">Pathname Lookup</a>") and returns 0.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-4.3.1"></a>
<h5 class="docSection3Title">12.4.3.1. The do_kern_mount( ) function</h5><a name="IDX-CHP-12-3194"></a>
<a name="IDX-CHP-12-3195"></a>
<a name="IDX-CHP-12-3196"></a>
<a name="IDX-CHP-12-3197"></a>
<p class="docText1">The core of the mount operation is the <tt class="calibre25">do_kern_mount( )</tt> function, which checks the filesystem type flags to determine how the mount operation is to be done. This function receives the following parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">fstype</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The name of the filesystem type to be mounted</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">flags</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The mount flags (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-14">Table 12-14</a>)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">name</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The pathname of the block device storing the filesystem (or the filesystem type name for special filesystems)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">data</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Pointer to additional data to be passed to the <tt class="calibre25">read_super</tt> method of the filesystem</p></dd></dl>
<p class="docText1">The function takes care of the actual mount operation by performing essentially the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">get_fs_type( )</tt> to search in the list of filesystem types and locate the name stored in the <tt class="calibre25">fstype</tt> parameter; <tt class="calibre25">get_fs_type( )</tt> returns in the local variable <tt class="calibre25">type</tt> the address of the corresponding <tt class="calibre25">file_system_type</tt> descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">alloc_vfsmnt( )</tt> to allocate a new mounted filesystem descriptor and stores its address in the <tt class="calibre25">mnt</tt> local variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">type-&gt;get_sb( )</tt> filesystem-dependent function to allocate a new superblock and to initialize it (see below).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">mnt-&gt;mnt_sb</tt> field with the address of the new superblock object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">mnt-&gt;mnt_root</tt> field with the address of the dentry object corresponding to the root directory of the filesystem, and increases the usage counter of the dentry object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">mnt-&gt;mnt_parent</tt> field with the value in <tt class="calibre25">mnt</tt> (for generic filesystems, the proper value of <tt class="calibre25">mnt_parent</tt> will be set when the mounted filesystem descriptor is inserted in the proper lists by <tt class="calibre25">graft_tree( )</tt>; see step 3d5 of <tt class="calibre25">do_mount( )</tt>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">mnt-&gt;mnt_namespace</tt> field with the value in <tt class="calibre25">current-&gt;namespace</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">s_umount</tt> read/write semaphore of the superblock object (it was acquired when the object was allocated in step 3).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address <tt class="calibre25">mnt</tt> of the mounted filesystem object.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-4.3.2"></a>
<h5 class="docSection3Title">12.4.3.2. Allocating a superblock object</h5><a name="IDX-CHP-12-3198"></a>
<a name="IDX-CHP-12-3199"></a>
<a name="IDX-CHP-12-3200"></a>
<a name="IDX-CHP-12-3201"></a>
<p class="docText1">The <tt class="calibre25">get_sb</tt> method of the filesystem object is usually implemented by a one-line function. For instance, in the Ext2 filesystem the method is implemented as follows:</p>
<pre class="calibre27">
    struct super_block * ext2_get_sb(struct file_system_type *type,
                            int flags, const char *dev_name, void *data)
    {
        return get_sb_bdev(type, flags, dev_name, data, ext2_fill_super);
    }</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">get_sb_bdev( )</tt> VFS function allocates and initializes a new superblock suitable for disk-based filesystems<a name="IDX-CHP-12-3202"></a> 
; it receives the address of the <tt class="calibre25">ext2_fill_super( )</tt> function, which reads the disk superblock from the Ext2 disk partition.</p>
<p class="docText1">To allocate superblocks suitable for special filesystems<a name="IDX-CHP-12-3203"></a> 
, the VFS also provides the <tt class="calibre25">get_sb_pseudo( )</tt> function (for special filesystems with no mount point such as <span class="docEmphasis">pipefs</span><a name="IDX-CHP-12-3204"></a> 
), the <tt class="calibre25">get_sb_single( )</tt> function (for special filesystems with single mount point such as <span class="docEmphasis">sysfs</span><a name="IDX-CHP-12-3205"></a> 
), and the <tt class="calibre25">get_sb_nodev( )</tt> function (for special filesystems that can be mounted several times such as <span class="docEmphasis">tmpfs</span><a name="IDX-CHP-12-3206"></a> 
; see below).</p>
<p class="docText1">The most important operations performed by <tt class="calibre25">get_sb_bdev( )</tt> are the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">open_bdev_excl( )</tt> to open the block device having device file name <tt class="calibre25">dev_name</tt> (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-5.html#understandlk-CHP-13-SECT-5">Character Device Drivers</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">sget( )</tt> to search the list of superblock objects of the filesystem (<tt class="calibre25">type-&gt;fs_supers</tt>, see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-3.html#understandlk-CHP-12-SECT-3.2">Filesystem Type Registration</a>"). If a superblock relative to the block device is already present, the function returns its address. Otherwise, it allocates and initializes a new superblock object, inserts it into the filesystem list and in the global list of superblocks, and returns its address.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the superblock is not new (it was not allocated in the previous step, because the filesystem is already mounted), it jumps to step 6.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the value of the <tt class="calibre25">flags</tt> parameter into the <tt class="calibre25">s_flags</tt> field of the superblock and sets the <tt class="calibre25">s_id</tt>, <tt class="calibre25">s_old_blocksize</tt>, and <tt class="calibre25">s_blocksize</tt> fields with the proper values for the block device.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the filesystem-dependent function passed as last argument to <tt class="calibre25">get_sb_bdev( )</tt> to access the superblock information on disk and fill the other fields of the new superblock object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address of the new superblock object.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-4.4"></a>
<h4 class="docSection2Title">12.4.4. Mounting the Root Filesystem</h4><a name="IDX-CHP-12-3207"></a>
<a name="IDX-CHP-12-3208"></a>
<a name="IDX-CHP-12-3209"></a>
<a name="IDX-CHP-12-3210"></a>
<a name="IDX-CHP-12-3211"></a>
<a name="IDX-CHP-12-3212"></a>
<a name="IDX-CHP-12-3213"></a>
<a name="IDX-CHP-12-3214"></a>
<p class="docText1">Mounting the root filesystem<a name="IDX-CHP-12-3215"></a> 
 is a crucial part of system initialization. It is a fairly complex procedure, because the Linux kernel allows the root filesystem to be stored in many different places, such as a hard disk partition, a floppy disk, a remote filesystem shared via NFS, or even a <span class="docEmphasis">ramdisk</span> (a fictitious block device kept in RAM).</p>
<p class="docText1">To keep the description simple, let's assume that the root filesystem is stored in a partition of a hard disk (the most common case, after all). While the system boots, the kernel finds the major number of the disk that contains the root filesystem in the <tt class="calibre25">ROOT_DEV</tt> variable (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-APP-A.html#understandlk-APP-A">Appendix A</a>). The root filesystem can be specified as a device file in the <i class="docEmphasis">/dev</i> directory either when compiling the kernel or by passing a suitable <span class="docEmphasis">"root"</span> option to the initial bootstrap loader. Similarly, the mount flags of the root filesystem are stored in the <tt class="calibre25">root_mountflags</tt> variable. The user specifies these flags either by using the <i class="docEmphasis">rdev</i> external program on a compiled kernel image or by passing a suitable <span class="docEmphasis">rootflags</span> option to the initial bootstrap loader (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-APP-A.html#understandlk-APP-A">Appendix A</a>).</p>
<p class="docText1">Mounting the root filesystem is a two-stage procedure, shown in the following list:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">The kernel mounts the special <span class="docEmphasis">rootfs</span><a name="IDX-CHP-12-3216"></a> 
 filesystem, which simply provides an empty directory that serves as initial mount point.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The kernel mounts the real root filesystem over the empty directory.</p></div></li></ol></div>
<p class="docText1">Why does the kernel bother to mount the <span class="docEmphasis">rootfs</span> filesystem before the real one? Well, the <span class="docEmphasis">rootfs</span> filesystem allows the kernel to easily change the real root filesystem. In fact, in some cases, the kernel mounts and unmounts several root filesystems, one after the other. For instance, the initial bootstrap CD of a distribution might load in RAM a kernel with a minimal set of drivers, which mounts as root a minimal filesystem stored in a ramdisk. Next, the programs in this initial root filesystem probe the hardware of the system (for instance, they determine whether the hard disk is EIDE, SCSI, or whatever), load all needed kernel modules, and remount the root filesystem from a physical block device.</p>
<a name="understandlk-CHP-12-SECT-4.4.1"></a>
<h5 class="docSection3Title">12.4.4.1. Phase 1: Mounting the rootfs filesystem</h5><a name="IDX-CHP-12-3217"></a>
<a name="IDX-CHP-12-3218"></a>
<a name="IDX-CHP-12-3219"></a>
<a name="IDX-CHP-12-3220"></a>
<p class="docText1">The first stage is performed by the <tt class="calibre25">init_rootfs( )</tt> and <tt class="calibre25">init_mount_tree( )</tt> functions, which are executed during system initialization.</p>
<p class="docText1">The <tt class="calibre25">init_rootfs( )</tt> function registers the special filesystem type <span class="docEmphasis">rootfs</span>:</p>
<pre class="calibre27">
    struct file_system_type rootfs_fs_type = {
        .name = "rootfs";
        .get_sb = rootfs_get_sb;
        .kill_sb = kill_litter_super;
    };
    register_filesystem(&amp;rootfs_fs_type);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">init_mount_tree( )</tt> function executes the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">do_kern_mount( )</tt> passing to it the string "<tt class="calibre25">rootfs</tt>" as filesystem type, and stores the address of the mounted filesystem descriptor returned by this function in the <tt class="calibre25">mnt</tt> local variable. As explained in the previous section, <tt class="calibre25">do_kern_mount( )</tt> ends up invoking the <tt class="calibre25">get_sb</tt> method of the <span class="docEmphasis">rootfs</span> filesystem, that is, the <tt class="calibre25">rootfs_get_sb( )</tt> function:</p><pre class="calibre60">
    struct superblock *rootfs_get_sb(struct file_system_type *fs_type,
                           int flags, const char *dev_name, void *data)
    {
        return get_sb_nodev(fs_type, flags|MS_NOUSER, data,
                            ramfs_fill_super);
    }
</pre><br class="calibre7"/>
<p class="docList">The <tt class="calibre25">get_sb_nodev( )</tt> function, in turn, executes the following steps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">sget( )</tt> to allocate a new superblock passing as parameter the address of the <tt class="calibre25">set_anon_super( )</tt> function (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-3.html#understandlk-CHP-12-SECT-3.1">Special Filesystems</a>"). As a result, the <tt class="calibre25">s_dev</tt> field of the superblock is set in the appropriate way: major number 0, minor number different from those of other mounted special filesystems.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the value of the <tt class="calibre25">flags</tt> parameter into the <tt class="calibre25">s_flags</tt> field of the superblock.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">ramfs_fill_super( )</tt> to allocate an inode object and a corresponding dentry object, and to fill the superblock fields. Because <span class="docEmphasis">rootfs</span> is a special filesystem that has no disk superblock, only a couple of superblock operations need to be implemented.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the address of the new superblock.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a <tt class="calibre25">namespace</tt> object for the namespace of process 0, and inserts into it the mounted filesystem descriptor returned by <tt class="calibre25">do_kern_mount( )</tt>:</p><pre class="calibre60">
    namespace = kmalloc(sizeof(*namespace), GFP_KERNEL);
    list_add(&amp;mnt-&gt;mnt_list, &amp;namespace-&gt;list);
    namespace-&gt;root = mnt;
    mnt-&gt;mnt_namespace = init_task.namespace = namespace;
</pre><br class="calibre7"/>
</div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">namespace</tt> field of every other process in the system to the address of the namespace object; also initializes the <tt class="calibre25">namespace-&gt;count</tt> usage counter. (By default, all processes share the same, initial namespace.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the root directory and the current working directory of process 0 to the root filesystem.</p></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-4.4.2"></a>
<h5 class="docSection3Title">12.4.4.2. Phase 2: Mounting the real root filesystem</h5><a name="IDX-CHP-12-3221"></a>
<a name="IDX-CHP-12-3222"></a>
<a name="IDX-CHP-12-3223"></a>
<a name="IDX-CHP-12-3224"></a>
<p class="docText1">The second stage of the mount operation for the root filesystem is performed by the kernel near the end of the system initialization. There are several ways to mount the real root filesystem, according to the options selected when the kernel has been compiled and to the boot options passed by the kernel loader. For the sake of brevity, we consider the case of a disk-based filesystem whose device file name has been passed to the kernel by means of the "<span class="docEmphasis">root</span>" boot parameter. We also assume that no initial special filesystem is used, except the <span class="docEmphasis">rootfs</span> filesystem.</p>
<p class="docText1">The <tt class="calibre25">prepare_namespace( )</tt> function executes the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">root_device_name</tt> variable with the device filename obtained from the "<span class="docEmphasis">root</span>" boot parameter. Also, sets the <tt class="calibre25">ROOT_DEV</tt> variable with the major and minor numbers of the same device file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">mount_root( )</tt> function, which in turn:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">sys_mknod( )</tt> (the service routine of the <tt class="calibre25">mknod( )</tt><a name="IDX-CHP-12-3225"></a> 
 system call) to create a <i class="docEmphasis">/dev/root</i> device file in the <span class="docEmphasis">rootfs</span> initial root filesystem, having the major and minor numbers as in <tt class="calibre25">ROOT_DEV</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a buffer and fills it with a list of filesystem type names. This list is either passed to the kernel in the "<span class="docEmphasis">rootfstype</span>" boot parameter or built by scanning the elements in the singly linked list of filesystem types.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Scans the list of filesystem type names built in the previous step. For each name, it invokes <i class="docEmphasis">sys_mount( )</i> to try to mount the given filesystem type on the root device. Because each filesystem-specific method uses a different magic number, all <tt class="calibre25">get_sb( )</tt> invocations will fail except the one that attempts to fill the superblock by using the function of the filesystem really used on the root device. The filesystem is mounted on a directory named <i class="docEmphasis">/root</i> of the <span class="docEmphasis">rootfs</span> filesystem.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">sys_chdir("/root")</tt> to change the current directory of the process.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Moves the mount point of the mounted filesystem on the root directory of the <span class="docEmphasis">rootfs</span> filesystem:</p><pre class="calibre60">
    sys_mount(".", "/", NULL, MS_MOVE, NULL);
    sys_chroot(".");</pre><br class="calibre7"/>
</div></li></ol></div>
<p class="docText1">Notice that the <span class="docEmphasis">rootfs</span> special<a name="IDX-CHP-12-3226"></a> 
 filesystem is not unmounted: it is only hidden under the disk-based root filesystem.</p>
<a name="understandlk-CHP-12-SECT-4.5"></a>
<h4 class="docSection2Title">12.4.5. Unmounting a Filesystem</h4><a name="IDX-CHP-12-3227"></a>
<a name="IDX-CHP-12-3228"></a>
<a name="IDX-CHP-12-3229"></a>
<a name="IDX-CHP-12-3230"></a>
<p class="docText1">The <tt class="calibre25">umount( )</tt><a name="IDX-CHP-12-3231"></a> 
 system call is used to unmount a filesystem. The corresponding <tt class="calibre25">sys_umount( )</tt> service routine acts on two parameters: a filename (either a mount point directory or a block device filename) and a set of flags. It performs the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">path_lookup( )</tt> to look up the mount point pathname; this function returns the results of the lookup operation in a local variable <tt class="calibre25">nd</tt> of type <tt class="calibre25">nameidata</tt> (see next section).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the resulting directory is not the mount point of a filesystem, it sets the <tt class="calibre25">retval</tt> return code to <tt class="calibre25">-EINVAL</tt> and jumps to step 6. This check is done by verifying that <tt class="calibre25">nd-&gt;mnt-&gt;mnt_root</tt> contains the address of the dentry object pointed to by <tt class="calibre25">nd.dentry</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the filesystem to be unmounted has not been mounted in the namespace, it sets the <tt class="calibre25">retval</tt> return code to <tt class="calibre25">-EINVAL</tt> and jumps to step 6. (Recall that some special filesystems have no mount point.) This check is done by invoking the <tt class="calibre25">check_mnt( )</tt> function on <tt class="calibre25">nd-&gt;mnt</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the user does not have the privileges required to unmount the filesystem, it sets the <tt class="calibre25">retval</tt> return code to <tt class="calibre25">-EPERM</tt> and jumps to step 6.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">do_umount( )</tt> passing as parameters <tt class="calibre25">nd.mnt</tt> (the mounted filesystem object) and <tt class="calibre25">flags</tt> (the set of flags). This function performs essentially the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Retrieves the address of the <tt class="calibre25">sb</tt> superblock object from the <tt class="calibre25">mnt_sb</tt> field of the mounted filesystem object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the user asked to force the unmount operation, it interrupts any ongoing mount operation by invoking the <tt class="calibre25">umount_begin</tt> superblock operation.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the filesystem to be unmounted is the root filesystem and the user didn't ask to actually detach it, it invokes <tt class="calibre25">do_remount_sb( )</tt> to remount the root filesystem read-only and terminates.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Acquires for writing the <tt class="calibre25">namespace-&gt;sem</tt> read/write semaphore of the current process, and gets the <tt class="calibre25">vfsmount_lock</tt> spin lock.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the mounted filesystem does not include mount points for any child mounted filesystem, or if the user asked to forcibly detach the filesystem, it invokes <tt class="calibre25">umount_tree( )</tt> to unmount the filesystem (together with all children filesystems).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the <tt class="calibre25">vfsmount_lock</tt> spin lock and the <tt class="calibre25">namespace-&gt;sem</tt> read/write semaphore of the current process.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Decreases the usage counters of the dentry object corresponding to the root directory of the filesystem and of the mounted filesystem descriptor; these counters were increased by <tt class="calibre25">path_lookup( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the <tt class="calibre25">retval</tt> value.</p></div></li></ol></div>

<br class="calibre7"/>

</div>

{% endraw %}

