---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-5.html
next: understandlk-CHP-5-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-5-SECT-1"></a>
<h3 class="docSection1Title">5.1. How the Kernel Services Requests</h3>
<p class="docText1">To get a better grasp of how kernel's code is executed, we will look at the kernel as a waiter who must satisfy two types of requests: those issued by customers and those issued by a limited number of different bosses. The policy adopted by the waiter is the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If a boss calls while the waiter is idle, the waiter starts servicing the boss.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If a boss calls while the waiter is servicing a customer, the waiter stops servicing the customer and starts servicing the boss.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If a boss calls while the waiter is servicing another boss, the waiter stops servicing the first boss and starts servicing the second one. When he finishes servicing the new boss, he resumes servicing the former one.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">One of the bosses may induce the waiter to leave the customer being currently serviced. After servicing the last request of the bosses, the waiter may decide to drop temporarily his customer and to pick up a new one.</p></div></li></ol></div>
<p class="docText1">The services performed by the waiter correspond to the code executed when the CPU is in Kernel Mode. If the CPU is executing in User Mode, the waiter is considered idle.</p>
<p class="docText1">Boss requests correspond to interrupts, while customer requests correspond to system calls or exceptions raised by User Mode processes. As we shall see in detail in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>, User Mode processes that want to request a service from the kernel must issue an appropriate instruction (on the 80x86, an <tt class="calibre25">int</tt><a name="IDX-CHP-5-1397"></a>
<tt class="calibre25">$0x80</tt> or a <tt class="calibre25">sysenter</tt><a name="IDX-CHP-5-1398"></a> 
 instruction). Such instructions raise an exception that forces the CPU to switch from User Mode to Kernel Mode. In the rest of this chapter, we will generally denote as "exceptions" both the system calls and the usual exceptions.</p>
<p class="docText1">The careful reader has already associated the first three rules with the nesting of kernel control paths described in "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-3.html#understandlk-CHP-4-SECT-3">Nested Execution of Exception and Interrupt Handlers</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>. The fourth rule corresponds to one of the most interesting new features included in the Linux 2.6 kernel, namely <span class="docEmphasis">kernel preemption</span><a name="IDX-CHP-5-1399"></a> 
.</p>
<a name="understandlk-CHP-5-SECT-1.1"></a>
<h4 class="docSection2Title">5.1.1. Kernel Preemption</h4><a name="IDX-CHP-5-1400"></a>
<a name="IDX-CHP-5-1401"></a>
<a name="IDX-CHP-5-1402"></a>
<p class="docText1">It is surprisingly hard to give a good definition of kernel preemption. As a first try, we could say that a kernel is <span class="docEmphasis">preemptive</span> if a process switch may occur while the replaced process is executing a kernel function, that is, while it runs in Kernel Mode. Unfortunately, in Linux (as well as in any other real operating system) things are much more complicated:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Both in preemptive and nonpreemptive kernels, a process running in Kernel Mode can voluntarily relinquish the CPU, for instance because it has to sleep waiting for some resource. We will call this kind of process switch a <span class="docEmphasis">planned<a name="IDX-CHP-5-1403"></a> 
 process switch</span>. However, a preemptive kernel<a name="IDX-CHP-5-1404"></a> 
 differs from a nonpreemptive kernel on the way a process running in Kernel Mode reacts to asynchronous events that could induce a process switchfor instance, an interrupt handler that awakes a higher priority process. We will call this kind of process switch a <span class="docEmphasis">forced<a name="IDX-CHP-5-1405"></a> 
 process switch</span>.</p></li><li class="calibre12"><p class="docText1">All process switches are performed by the <tt class="calibre25">switch_to</tt> macro. In both preemptive and nonpreemptive kernels, a process switch occurs when a process has finished some thread of kernel activity and the scheduler is invoked. However, in nonpreemptive kernels, the current process cannot be replaced unless it is about to switch to User Mode (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-3.html#understandlk-CHP-3-SECT-3.3">Performing the Process Switch</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>).</p></li></ul>
<p class="docText1">Therefore, the main characteristic of a preemptive kernel is that a process running in Kernel Mode can be replaced by another process while in the middle of a kernel function.</p>
<p class="docText1">Let's give a couple of examples to illustrate the difference between preemptive and nonpreemptive kernels.</p>
<p class="docText1">While process A executes an exception handler (necessarily in Kernel Mode), a higher priority process B becomes runnable. This could happen, for instance, if an IRQ occurs and the corresponding handler awakens process B. If the kernel is preemptive, a forced process switch replaces process A with B. The exception handler is left unfinished and will be resumed only when the scheduler selects again process A for execution. Conversely, if the kernel is nonpreemptive, no process switch occurs until process A either finishes handling the exception handler or voluntarily relinquishes the CPU.</p>
<p class="docText1">For another example, consider a process that executes an exception handler and whose time quantum expires (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.1">The scheduler_tick( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>). If the kernel is preemptive, the process may be replaced immediately; however, if the kernel is nonpreemptive, the process continues to run until it finishes handling the exception handler or voluntarily relinquishes the CPU.</p>
<p class="docText1">The main motivation for making a kernel preemptive is to reduce the <span class="docEmphasis">dispatch latency</span><a name="IDX-CHP-5-1406"></a> 
 of the User Mode processes, that is, the delay between the time they become runnable and the time they actually begin running. Processes performing timely scheduled tasks (such as external hardware controllers, environmental monitors, movie players, and so on) really benefit from kernel preemption, because it reduces the risk of being delayed by another process running in Kernel Mode.</p>
<p class="docText1">Making the Linux 2.6 kernel preemptive did not require a drastic change in the kernel design with respect to the older nonpreemptive kernel versions. As described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, kernel preemption is disabled when the <tt class="calibre25">preempt_count</tt> field in the <tt class="calibre25">tHRead_info</tt> descriptor referenced by the <tt class="calibre25">current_thread_info( )</tt> macro is greater than zero. The field encodes three different counters, as shown in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-7.html#understandlk-CHP-4-TABLE-10">Table 4-10</a> in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, so it is greater than zero when any of the following cases occurs:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">The kernel is executing an interrupt service routine.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The deferrable functions are disabled (always true when the kernel is executing a softirq or tasklet).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The kernel preemption has been explicitly disabled by setting the preemption counter to a positive value.</p></div></li></ol></div>
<p class="docText1">The above rules tell us that the kernel can be preempted only when it is executing an exception handler (in particular a system call) and the kernel preemption has not been explicitly disabled. Furthermore, as described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-SECT-9">Returning from Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>, the local CPU must have local interrupts enabled, otherwise kernel preemption is not performed.</p>
<p class="docText1">A few simple macros listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-5-TABLE-1">Table 5-1</a> deal with the preemption counter in the <tt class="calibre25">prempt_count</tt> field.</p>
<a name="understandlk-CHP-5-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 5-1. Macros dealing with the preemption counter subfield</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Macro</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">preempt_count( )</tt></p></td><td class="docTableCell"><p class="docText2">Selects the <tt class="calibre25">preempt_count</tt> field in the <tt class="calibre25">tHRead_info</tt> descriptor</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">preempt_disable( )</tt></p></td><td class="docTableCell"><p class="docText2">Increases by one the value of the preemption counter</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">preempt_enable_no_resched( )</tt></p></td><td class="docTableCell" valign="top"><p class="docText2">Decreases by one the value of the preemption counter</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">preempt_enable( )</tt></p></td><td class="docTableCell"><p class="docText2">Decreases by one the value of the preemption counter, and invokes <tt class="calibre25">preempt_schedule( )</tt> if the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag in the <tt class="calibre25">thread_info</tt> descriptor is set</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">get_cpu( )</p></td><td class="docTableCell"><p class="docText2">Similar to <tt class="calibre25">preempt_disable( )</tt>, but also returns the number of the local CPU</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">put_cpu( )</p></td><td class="docTableCell"><p class="docText2">Same as <tt class="calibre25">preempt_enable( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">put_cpu_no_resched( )</p></td><td class="docTableCell"><p class="docText2">Same as <tt class="calibre25">preempt_enable_no_resched( )</tt></p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">preempt_enable( )</tt> macro decreases the preemption counter, then checks whether the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag is set (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-9.html#understandlk-CHP-4-TABLE-15">Table 4-15</a> in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). In this case, a process switch request is pending, so the macro invokes the <tt class="calibre25">preempt_schedule( )</tt> function, which essentially executes the following code:</p>
<pre class="calibre27">
    if (!current_thread_info-&gt;preempt_count &amp;&amp; !irqs_disabled()) {
        current_thread_info-&gt;preempt_count = PREEMPT_ACTIVE;
        schedule();
        current_thread_info-&gt;preempt_count = 0;
    }
</pre><br class="calibre7"/>
<p class="docText1">The function checks whether local interrupts are enabled and the <tt class="calibre25">preempt_count</tt> field of <tt class="calibre25">current</tt> is zero; if both conditions are true, it invokes <tt class="calibre25">schedule( )</tt> to select another process to run. Therefore, kernel preemption may happen either when a kernel control path (usually, an interrupt handler) is terminated, or when an exception handler reenables kernel preemption by means of <tt class="calibre25">preempt_enable( )</tt>. As we'll see in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.12">Disabling and Enabling Deferrable Functions</a>" later in this chapter, kernel preemption may also happen when deferrable functions are enabled.</p>
<p class="docText1">We'll conclude this section by noticing that kernel preemption introduces a nonnegligible overhead. For that reason, Linux 2.6 features a kernel configuration option that allows users to enable or disable kernel preemption when compiling the kernel.</p>
<a name="understandlk-CHP-5-SECT-1.2"></a>
<h4 class="docSection2Title">5.1.2. When Synchronization Is Necessary</h4><a name="IDX-CHP-5-1407"></a>
<a name="IDX-CHP-5-1408"></a>
<a name="IDX-CHP-5-1409"></a>
<a name="IDX-CHP-5-1410"></a>
<a name="IDX-CHP-5-1411"></a>
<a name="IDX-CHP-5-1412"></a>
<a name="IDX-CHP-5-1413"></a>
<p class="docText1"><a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-1.html#understandlk-CHP-1">Chapter 1</a> introduced the concepts of race condition and critical region for processes. The same definitions apply to kernel control paths<a name="IDX-CHP-5-1414"></a> 
. In this chapter, a race condition can occur when the outcome of a computation depends on how two or more interleaved kernel control paths are nested. A <span class="docEmphasis">critical region</span> is a section of code that must be completely executed by the kernel control path that enters it before another kernel control path can enter it.</p>
<p class="docText1">Interleaving kernel control paths complicates the life of kernel developers: they must apply special care in order to identify the critical regions<a name="IDX-CHP-5-1415"></a> 
 in exception handlers, interrupt handlers, deferrable functions, and kernel threads<a name="IDX-CHP-5-1416"></a> 
. Once a critical region has been identified, it must be suitably protected to ensure that any time at most one kernel control path is inside that region.</p>
<p class="docText1">Suppose, for instance, that two different interrupt handlers need to access the same data structure that contains several related member variables  for instance, a buffer and an integer indicating its length. All statements affecting the data structure must be put into a single critical region. If the system includes a single CPU, the critical region can be implemented by disabling interrupts while accessing the shared data structure, because nesting of kernel control paths can only occur when interrupts are enabled.</p>
<p class="docText1">On the other hand, if the same data structure is accessed only by the service routines of system calls, and if the system includes a single CPU, the critical region can be implemented quite simply by disabling kernel preemption while accessing the shared data structure.</p>
<p class="docText1">As you would expect, things are more complicated in multiprocessor systems. Many CPUs may execute kernel code at the same time, so kernel developers cannot assume that a data structure can be safely accessed just because kernel preemption is disabled and the data structure is never addressed by an interrupt, exception, or softirq handler.</p>
<p class="docText1">We'll see in the following sections that the kernel offers a wide range of different synchronization techniques. It is up to kernel designers to solve each synchronization problem by selecting the most efficient technique.</p>
<a name="understandlk-CHP-5-SECT-1.3"></a>
<h4 class="docSection2Title">5.1.3. When Synchronization Is Not Necessary</h4><a name="IDX-CHP-5-1417"></a>
<p class="docText1">Some design choices already discussed in the previous chapter simplify somewhat the synchronization of kernel control paths. Let us recall them briefly:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">All interrupt handlers acknowledge the interrupt on the PIC and also disable the IRQ line. Further occurrences of the same interrupt cannot occur until the handler terminates.</p></li><li class="calibre12"><p class="docText1">Interrupt handlers, softirqs, and tasklets are both nonpreemptable and non-blocking, so they cannot be suspended for a long time interval. In the worst case, their execution will be slightly delayed, because other interrupts occur during their execution (nested execution of kernel control paths).</p></li><li class="calibre12"><p class="docText1">A kernel control path performing interrupt handling cannot be interrupted by a kernel control path executing a deferrable function or a system call service routine.</p></li><li class="calibre12"><p class="docText1">Softirqs and tasklets cannot be interleaved on a given CPU.</p></li><li class="calibre12"><p class="docText1">The same tasklet cannot be executed simultaneously on several CPUs.</p></li></ul>
<p class="docText1">Each of the above design choices can be viewed as a constraint that can be exploited to code some kernel functions more easily. Here are a few examples of possible simplifications:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Interrupt handlers and tasklets need not to be coded as reentrant functions.</p></li><li class="calibre12"><p class="docText1">Per-CPU variables accessed by softirqs and tasklets only do not require synchronization.</p></li><li class="calibre12"><p class="docText1">A data structure accessed by only one kind of tasklet does not require synchronization.</p></li></ul>
<p class="docText1">The rest of this chapter describes what to do when synchronization <span class="docEmphasis">is</span> necessary  i.e., how to prevent data corruption due to unsafe accesses to shared data structures.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

