---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-4-SECT-6.html
next: understandlk-CHP-4-SECT-8.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-4-SECT-7"></a>
<h3 class="docSection1Title">4.7. Softirqs and Tasklets</h3><a name="IDX-CHP-4-1293"></a>
<a name="IDX-CHP-4-1294"></a>
<a name="IDX-CHP-4-1295"></a>
<a name="IDX-CHP-4-1296"></a>
<a name="IDX-CHP-4-1297"></a>
<a name="IDX-CHP-4-1298"></a>
<a name="IDX-CHP-4-1299"></a>
<a name="IDX-CHP-4-1300"></a>
<p class="docText1">We mentioned earlier in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6">Interrupt Handling</a>" that several tasks among those executed by the kernel are not critical: they can be deferred for a long period of time, if necessary. Remember that the interrupt service routines of an interrupt handler are serialized, and often there should be no occurrence of an interrupt until the corresponding interrupt handler has terminated. Conversely, the deferrable tasks can execute with all interrupts enabled. Taking them out of the interrupt handler helps keep kernel response time small. This is a very important property for many time-critical applications that expect their interrupt requests to be serviced in a few milliseconds.</p>
<p class="docText1">Linux 2.6 answers such a challenge by using two kinds of non-urgent interruptible kernel functions: the so-called <span class="docEmphasis">deferrable functions</span><sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-FN14">[*]</a></sup> (<span class="docEmphasis">softirqs</span><a name="IDX-CHP-4-1302"></a> 
 and <span class="docEmphasis">tasklets</span><a name="IDX-CHP-4-1303"></a> 
), and those executed by means of some work queues (we will describe them in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-8.html#understandlk-CHP-4-SECT-8">Work Queues</a>" later in this chapter).</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-4-FN14">[*]</a></sup> These are also called <span class="docEmphasis">software interrupt</span>s, but we denote them as "deferrable functions" to avoid confusion with programmed exceptions, which are referred to as "software interrupts<a name="IDX-CHP-4-1301"></a> 
" in Intel manuals.</p></blockquote>
<p class="docText1">Softirqs and tasklets are strictly correlated, because tasklets are implemented on top of softirqs. As a matter of fact, the term "softirq," which appears in the kernel source code, often denotes both kinds of deferrable functions. Another widely used term is <span class="docEmphasis">interrupt context</span><a name="IDX-CHP-4-1304"></a> 
: it specifies that the kernel is currently executing either an interrupt handler or a deferrable function.</p>
<p class="docText1">Softirqs are statically allocated (i.e., defined at compile time), while tasklets can also be allocated and initialized at runtime (for instance, when loading a kernel module). Softirqs can run concurrently on several CPUs, even if they are of the same type. Thus, softirqs are reentrant functions and must explicitly protect their data structures with spin locks. Tasklets do not have to worry about this, because their execution is controlled more strictly by the kernel. Tasklets of the same type are always serialized: in other words, the same type of tasklet cannot be executed by two CPUs at the same time. However, tasklets of different types can be executed concurrently on several CPUs. Serializing the tasklet simplifies the life of device driver developers, because the tasklet function needs not be reentrant.</p>
<p class="docText1">Generally speaking, four kinds of operations can be performed on deferrable functions:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Initialization</span></span></p></dt>
<dd class="calibre20"><p class="docList">Defines a new deferrable function; this operation is usually done when the kernel initializes itself or a module is loaded.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Activation</span></span></p></dt>
<dd class="calibre20"><p class="docList">Marks a deferrable function as "pending"  to be run the next time the kernel schedules a round of executions of deferrable functions. Activation can be done at any time (even while handling interrupts).</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Masking</span></span></p></dt>
<dd class="calibre20"><p class="docList">Selectively disables a deferrable function so that it will not be executed by the kernel even if activated. We'll see in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.12">Disabling and Enabling Deferrable Functions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a> that disabling deferrable functions is sometimes essential.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Execution</span></span></p></dt>
<dd class="calibre20"><p class="docList">Executes a pending deferrable function together with all other pending deferrable functions of the same type; execution is performed at well-specified times, explained later in the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-SECT-7.1">Softirqs</a>."</p></dd></dl>
<p class="docText1">Activation and execution are bound together: a deferrable function that has been activated by a given CPU must be executed on the same CPU. There is no self-evident reason suggesting that this rule is beneficial for system performance. Binding the deferrable function to the activating CPU could in theory make better use of the CPU hardware cache. After all, it is conceivable that the activating kernel thread accesses some data structures that will also be used by the deferrable function. However, the relevant lines could easily be no longer in the cache when the deferrable function is run because its execution can be delayed a long time. Moreover, binding a function to a CPU is always a potentially "dangerous" operation, because one CPU might end up very busy while the others are mostly idle.</p>
<a name="understandlk-CHP-4-SECT-7.1"></a>
<h4 class="docSection2Title">4.7.1. Softirqs</h4><a name="IDX-CHP-4-1305"></a>
<a name="IDX-CHP-4-1306"></a>
<a name="IDX-CHP-4-1307"></a>
<a name="IDX-CHP-4-1308"></a>
<a name="IDX-CHP-4-1309"></a>
<p class="docText1">Linux 2.6 uses a limited number of softirqs<a name="IDX-CHP-4-1310"></a> 
. For most purposes, tasklets are good enough and are much easier to write because they do not need to be reentrant.</p>
<p class="docText1">As a matter of fact, only the six kinds of softirqs listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-9">Table 4-9</a> are currently defined.</p>
<a name="understandlk-CHP-4-TABLE-9"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 4-9. Softirqs used in Linux 2.6</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Softirq</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Index (priority)</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">HI_SOFTIRQ</tt></p></td><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">Handles high priority tasklets</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">TIMER_SOFTIRQ</tt></p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">Tasklets related to timer interrupts</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">NET_TX_SOFTIRQ</tt></p></td><td class="docTableCell"><p class="docText2">2</p></td><td class="docTableCell"><p class="docText2">Transmits packets to network cards</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">NET_RX_SOFTIRQ</tt></p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">Receives packets from network cards</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">SCSI_SOFTIRQ</tt></p></td><td class="docTableCell"><p class="docText2">4</p></td><td class="docTableCell"><p class="docText2">Post-interrupt processing of SCSI commands</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">TASKLET_SOFTIRQ</tt></p></td><td class="docTableCell"><p class="docText2">5</p></td><td class="docTableCell"><p class="docText2">Handles regular tasklets</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The index of a sofirq determines its priority: a lower index means higher priority because softirq functions will be executed starting from index 0.</p>
<a name="understandlk-CHP-4-SECT-7.1.1"></a>
<h5 class="docSection3Title">4.7.1.1. Data structures used for softirqs</h5><a name="IDX-CHP-4-1311"></a>
<a name="IDX-CHP-4-1312"></a>
<a name="IDX-CHP-4-1313"></a>
<a name="IDX-CHP-4-1314"></a>
<a name="IDX-CHP-4-1315"></a>
<a name="IDX-CHP-4-1316"></a>
<a name="IDX-CHP-4-1317"></a>
<a name="IDX-CHP-4-1318"></a>
<p class="docText1">The main data structure used to represent softirqs is the <tt class="calibre25">softirq_vec</tt> array, which includes 32 elements of type <tt class="calibre25">softirq_action</tt>. The priority of a softirq is the index of the corresponding <tt class="calibre25">softirq_action</tt> element inside the array. As shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-9">Table 4-9</a>, only the first six entries of the array are effectively used. The <tt class="calibre25">softirq_action</tt> data structure consists of two fields: an <tt class="calibre25">action</tt> pointer to the softirq function and a <tt class="calibre25">data</tt> pointer to a generic data structure that may be needed by the softirq function.</p>
<p class="docText1">Another critical field used to keep track both of kernel preemption<a name="IDX-CHP-4-1319"></a> 
 and of nesting of kernel control paths<a name="IDX-CHP-4-1320"></a> 
 is the 32-bit <tt class="calibre25">preempt_count</tt> field stored in the <tt class="calibre25">tHRead_info</tt> field of each process descriptor (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). This field encodes three distinct counters plus a flag, as shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-10">Table 4-10</a>.</p>
<a name="understandlk-CHP-4-TABLE-10"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 4-10. Subfields of the preempt_count field (continues)</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Bits</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2">07</p></td><td class="docTableCell"><p class="docText2">Preemption counter (max value = 255)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">815</p></td><td class="docTableCell"><p class="docText2">Softirq counter (max value = 255).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">1627</p></td><td class="docTableCell"><p class="docText2">Hardirq counter (max value = 4096)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">28</p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">PREEMPT_ACTIVE</tt> flag</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The first counter keeps track of how many times kernel preemption has been explicitly disabled on the local CPU; the value zero means that kernel preemption has not been explicitly disabled at all. The second counter specifies how many levels deep the disabling of deferrable functions is (level 0 means that deferrable functions are enabled). The third counter specifies the number of nested interrupt handlers on the local CPU (the value is increased by <tt class="calibre25">irq_enter( )</tt> and decreased by <tt class="calibre25">irq_exit( )</tt>; see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-FIG-4">I/O Interrupt Handling</a>" earlier in this chapter).</p>
<p class="docText1">There is a good reason for the name of the <tt class="calibre25">preempt_count</tt> field: kernel preemptability has to be disabled either when it has been explicitly disabled by the kernel code (preemption counter not zero) or when the kernel is running in interrupt context. Thus, to determine whether the current process can be preempted, the kernel quickly checks for a zero value in the <tt class="calibre25">preempt_count</tt> field. Kernel preemption will be discussed in depth in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-1.html#understandlk-CHP-5-SECT-1.1">Kernel Preemption</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>.</p>
<p class="docText1">The <tt class="calibre25">in_interrupt( )</tt> macro checks the hardirq and softirq counters in the <tt class="calibre25">current_thread_info( )-&gt;preempt_count</tt> field. If either one of these two counters is positive, the macro yields a nonzero value, otherwise it yields the value zero. If the kernel does not make use of multiple Kernel Mode stacks, the macro always looks at the <tt class="calibre25">preempt_count</tt> field of the <tt class="calibre25">thread_info</tt> descriptor of the current process. If, however, the kernel makes use of multiple Kernel Mode stacks, the macro might look at the <tt class="calibre25">preempt_count</tt> field in the <tt class="calibre25">tHRead_info</tt> descriptor contained in a <tt class="calibre25">irq_ctx</tt> union associated with the local CPU. In this case, the macro returns a nonzero value because the field is always set to a positive value.</p>
<p class="docText1">The last crucial data structure for implementing the softirqs is a per-CPU 32-bit mask describing the pending softirqs; it is stored in the <tt class="calibre25">_ _softirq_pending</tt> field of the <tt class="calibre25">irq_cpustat_t</tt> data structure (recall that there is one such structure per each CPU in the system; see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-TABLE-8">Table 4-8</a>). To get and set the value of the bit mask, the kernel makes use of the <tt class="calibre25">local_softirq_pending( )</tt> macro that selects the softirq bit mask of the local CPU.</p>
<a name="understandlk-CHP-4-SECT-7.1.2"></a>
<h5 class="docSection3Title">4.7.1.2. Handling softirqs</h5><a name="IDX-CHP-4-1321"></a>
<a name="IDX-CHP-4-1322"></a>
<a name="IDX-CHP-4-1323"></a>
<a name="IDX-CHP-4-1324"></a>
<p class="docText1">The <tt class="calibre25">open_softirq( )</tt> function takes care of softirq initialization. It uses three parameters: the softirq index, a pointer to the softirq function to be executed, and a second pointer to a data structure that may be required by the softirq function. <tt class="calibre25">open_softirq( )</tt> limits itself to initializing the proper entry of the <tt class="calibre25">softirq_vec</tt> array.</p>
<p class="docText1">Softirqs are activated by means of the <tt class="calibre25">raise_softirq( )</tt> function. This function, which receives as its parameter the softirq index <tt class="calibre25">nr</tt>, performs the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">local_irq_save</tt> macro to save the state of the <tt class="calibre25">IF</tt> flag of the <tt class="calibre25">eflags</tt><a name="IDX-CHP-4-1325"></a> 
 register and to disable interrupts on the local CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Marks the softirq as pending by setting the bit corresponding to the index <tt class="calibre25">nr</tt> in the softirq bit mask of the local CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">in_interrupt()</tt> yields the value 1, it jumps to step 5. This situation indicates either that <tt class="calibre25">raise_softirq( )</tt> has been invoked in interrupt context, or that the softirqs are currently disabled.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, invokes <tt class="calibre25">wakeup_softirqd()</tt> to wake up, if necessary, the <span class="docEmphasis">ksoftirqd<a name="IDX-CHP-4-1326"></a> 
 kernel thread of the local CPU (see later)</span>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">local_irq_restore</tt> macro to restore the state of the <tt class="calibre25">IF</tt> flag saved in step 1.</p></div></li></ol></div>
<p class="docText1">Checks for active (pending) softirqs should be perfomed periodically, but without inducing too much overhead. They are performed in a few points of the kernel code. Here is a list of the most significant points (be warned that number and position of the softirq checkpoints change both with the kernel version and with the supported hardware architecture):</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">When the kernel invokes the <tt class="calibre25">local_bh_enable( )</tt> function<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-FN15">[*]</a></sup> to enable softirqs on the local CPU</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-4-FN15">[*]</a></sup> The name <tt class="calibre42">local_bh_enable( )</tt> refers to a special type of deferrable function called "bottom half" that no longer exists in Linux 2.6.</p></blockquote></li><li class="calibre12"><p class="docText1">When the <tt class="calibre25">do_IRQ( )</tt> function finishes handling an I/O interrupt and invokes the <tt class="calibre25">irq_exit( )</tt> macro</p></li><li class="calibre12"><p class="docText1">If the system uses an I/O APIC, when the <tt class="calibre25">smp_apic_timer_interrupt( )</tt> function finishes handling a local timer interrupt (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-SECT-2.3">Timekeeping Architecture in Multiprocessor Systems</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6.html#understandlk-CHP-6">Chapter 6</a>)</p></li><li class="calibre12"><p class="docText1">In multiprocessor systems, when a CPU finishes handling a function triggered by a <tt class="calibre25">CALL_FUNCTION_VECTOR</tt> interprocessor interrupt</p></li><li class="calibre12"><p class="docText1">When one of the special <span class="docEmphasis">ksoftirqd/n</span> kernel threads is awakened (see later)</p></li></ul>
<a name="understandlk-CHP-4-SECT-7.1.3"></a>
<h5 class="docSection3Title">4.7.1.3. The do_softirq( ) function</h5><a name="IDX-CHP-4-1327"></a>
<a name="IDX-CHP-4-1328"></a>
<p class="docText1">If pending softirqs are detected at one such checkpoint (<tt class="calibre25">local_softirq_pending()</tt> is not zero), the kernel invokes <tt class="calibre25">do_softirq( )</tt> to take care of them. This function performs the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">in_interrupt( )</tt> yields the value one, this function returns. This situation indicates either that <tt class="calibre25">do_softirq( )</tt> has been invoked in interrupt context or that the softirqs are currently disabled.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes <tt class="calibre25">local_irq_save</tt> to save the state of the <tt class="calibre25">IF</tt> flag and to disable the interrupts on the local CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the size of the <tt class="calibre25">thread_union</tt> structure is 4 KB, it switches to the soft IRQ stack, if necessary. This step is very similar to step 2 of <tt class="calibre25">do_IRQ( )</tt> in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-FIG-4">I/O Interrupt Handling</a>;" of course, the <tt class="calibre25">softirq_ctx</tt> array is used instead of <tt class="calibre25">hardirq_ctx</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">_ _do_softirq( )</tt> function (see the following section).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the soft IRQ stack has been effectively switched in step 3 above, it restores the original stack pointer into the <tt class="calibre25">esp</tt> register, thus switching back to the exception stack that was in use before.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes <tt class="calibre25">local_irq_restore</tt> to restore the state of the <tt class="calibre25">IF</tt> flag (local interrupts enabled or disabled) saved in step 2 and returns.</p></div></li></ol></div>
<a name="understandlk-CHP-4-SECT-7.1.4"></a>
<h5 class="docSection3Title">4.7.1.4. The _ _do_softirq( ) function</h5><a name="IDX-CHP-4-1329"></a>
<a name="IDX-CHP-4-1330"></a>
<p class="docText1">The <tt class="calibre25">_ _do_softirq( )</tt> function reads the softirq bit mask of the local CPU and executes the deferrable functions corresponding to every set bit. While executing a softirq function, new pending softirqs might pop up; in order to ensure a low latency time for the deferrable funtions, <tt class="calibre25">_ _do_softirq( )</tt> keeps running until all pending softirqs have been executed. This mechanism, however, could force _ _<tt class="calibre25">do_softirq( )</tt> to run for long periods of time, thus considerably delaying User Mode processes. For that reason, _ _<tt class="calibre25">do_softirq( )</tt> performs a fixed number of iterations and then returns. The remaining pending softirqs, if any, will be handled in due time by the <span class="docEmphasis">ksoftirqd</span> kernel thread described in the next section. Here is a short description of the actions performed by the function:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the iteration counter to 10.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the softirq bit mask of the local CPU (selected by <tt class="calibre25">local_softirq_pending( )</tt>) in the <tt class="calibre25">pending</tt> local variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">local_bh_disable( )</tt> to increase the softirq counter. It is somewhat counterintuitive that deferrable functions should be disabled before starting to execute them, but it really makes a lot of sense. Because the deferrable functions mostly run with interrupts enabled, an interrupt can be raised in the middle of the <tt class="calibre25">_ _do_softirq( )</tt> function. When <tt class="calibre25">do_IRQ( )</tt> executes the <tt class="calibre25">irq_exit( )</tt> macro, another instance of the <tt class="calibre25">_ _do_softirq( )</tt> function could be started. This has to be avoided, because deferrable functions must execute serially on the CPU. Thus, the first instance of <tt class="calibre25">_ _do_softirq( )</tt> disables deferrable functions, so that every new instance of the function will exit at step 1 of <tt class="calibre25">do_softirq( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Clears the softirq bitmap of the local CPU, so that new softirqs can be activated (the value of the bit mask has already been saved in the <tt class="calibre25">pending</tt> local variable in step 2).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes <tt class="calibre25">local_irq_enable( )</tt> to enable local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">For each bit set in the <tt class="calibre25">pending</tt> local variable, it executes the corresponding softirq function; recall that the function address for the softirq with index <tt class="calibre25">n</tt> is stored in <tt class="calibre25">softirq_vec[n]-&gt;action</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes <tt class="calibre25">local_irq_disable()</tt> to disable local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the softirq bit mask of the local CPU into the <tt class="calibre25">pending</tt> local variable and decreases the iteration counter one more time.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If <tt class="calibre25">pending</tt> is not zeroat least one softirq has been activated since the start of the last iterationand the iteration counter is still positive, it jumps back to step 4.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If there are more pending softirqs, it invokes <tt class="calibre25">wakeup_softirqd( )</tt> to wake up the kernel thread that takes care of the softirqs for the local CPU (see next section).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Subtracts 1 from the softirq counter, thus reenabling the deferrable functions.</p></div></li></ol></div>
<a name="understandlk-CHP-4-SECT-7.1.5"></a>
<h5 class="docSection3Title">4.7.1.5. The ksoftirqd kernel threads</h5><a name="IDX-CHP-4-1331"></a>
<a name="IDX-CHP-4-1332"></a>
<p class="docText1">In recent kernel versions, each CPU has its own <span class="docEmphasis">ksoftirqd/n</span> kernel thread (where <span class="docEmphasis">n</span> is the logical number of the CPU). Each <span class="docEmphasis">ksoftirqd/n</span> kernel thread runs the <tt class="calibre25">ksoftirqd( )</tt> function, which essentially executes the following loop:</p>
<pre class="calibre27">
    for(;;) {
        set_current_state(TASK_INTERRUPTIBLE );
        schedule( );
        /* now in TASK_RUNNING state */
        while (local_softirq_pending( )) {
            preempt_disable();
            do_softirq( );
            preempt_enable();
            cond_resched( );
        }
    }</pre><br class="calibre7"/>
<p class="docText1">When awakened, the kernel thread checks the <tt class="calibre25">local_softirq_pending()</tt> softirq bit mask and invokes, if necessary, <tt class="calibre25">do_softirq( )</tt>. If there are no softirqs pending, the function puts the current process in the <tt class="calibre25">TASK_INTERRUPTIBLE</tt> state and invokes then the <tt class="calibre25">cond_resched()</tt> function to perform a process switch if required by the current process (flag <tt class="calibre25">TIF_NEED_RESCHED</tt> of the current <tt class="calibre25">thread_info</tt> set).</p>
<p class="docText1">The <span class="docEmphasis">ksoftirqd/n</span> kernel threads represent a solution for a critical trade-off problem.</p>
<p class="docText1">Softirq functions may reactivate themselves; in fact, both the networking softirqs and the tasklet softirqs do this. Moreover, external events, such as packet flooding on a network card, may activate softirqs at very high frequency.</p>
<p class="docText1">The potential for a continuous high-volume flow of softirqs creates a problem that is solved by introducing kernel threads. Without them, developers are essentially faced with two alternative strategies.</p>
<p class="docText1">The first strategy consists of ignoring new softirqs that occur while <tt class="calibre25">do_softirq( )</tt> is running. In other words, the <tt class="calibre25">do_softirq( )</tt> function could determine what softirqs are pending when the function is started and then execute their functions. Next, it would terminate without rechecking the pending softirqs. This solution is not good enough. Suppose that a softirq function is reactivated during the execution of <tt class="calibre25">do_softirq( )</tt>. In the worst case, the softirq is not executed again until the next timer interrupt, even if the machine is idle. As a result, softirq latency time is unacceptable for networking developers.</p>
<p class="docText1">The second strategy consists of continuously rechecking for pending softirqs. The <tt class="calibre25">do_softirq( )</tt> function could keep checking the pending softirqs and would terminate only when none of them is pending. While this solution might satisfy networking developers, it can certainly upset normal users of the system: if a high-frequency flow of packets is received by a network card or a softirq function keeps activating itself, the <tt class="calibre25">do_softirq( )</tt> function never returns, and the User Mode programs are virtually stopped.</p>
<p class="docText1">The <span class="docEmphasis">ksoftirqd/n</span> kernel threads try to solve this difficult trade-off problem. The <tt class="calibre25">do_softirq( )</tt> function determines what softirqs are pending and executes their functions. After a few iterations, if the flow of softirqs does not stop, the function wakes up the kernel thread and terminates (step 10 of _ _<tt class="calibre25">do_softirq( )</tt>). The kernel thread has low priority, so user programs have a chance to run; but if the machine is idle, the pending softirqs are executed quickly.</p>
<a name="understandlk-CHP-4-SECT-7.2"></a>
<h4 class="docSection2Title">4.7.2. Tasklets</h4><a name="IDX-CHP-4-1333"></a>
<a name="IDX-CHP-4-1334"></a>
<a name="IDX-CHP-4-1335"></a>
<a name="IDX-CHP-4-1336"></a>
<a name="IDX-CHP-4-1337"></a>
<a name="IDX-CHP-4-1338"></a>
<a name="IDX-CHP-4-1339"></a>
<a name="IDX-CHP-4-1340"></a>
<a name="IDX-CHP-4-1341"></a>
<a name="IDX-CHP-4-1342"></a>
<a name="IDX-CHP-4-1343"></a>
<a name="IDX-CHP-4-1344"></a>
<a name="IDX-CHP-4-1345"></a>
<a name="IDX-CHP-4-1346"></a>
<a name="IDX-CHP-4-1347"></a>
<p class="docText1">Tasklets are the preferred way to implement deferrable functions in I/O drivers. As already explained, tasklets<a name="IDX-CHP-4-1348"></a> 
 are built on top of two softirqs named <tt class="calibre25">HI_SOFTIRQ</tt> and <tt class="calibre25">TASKLET_SOFTIRQ</tt>. Several tasklets may be associated with the same softirq, each tasklet carrying its own function. There is no real difference between the two softirqs, except that <tt class="calibre25">do_softirq( )</tt> executes <tt class="calibre25">HI_SOFTIRQ</tt>'s tasklets before <tt class="calibre25">TASKLET_SOFTIRQ</tt>'s tasklets.</p>
<p class="docText1">Tasklets and high-priority tasklets are stored in the <tt class="calibre25">tasklet_vec</tt> and <tt class="calibre25">tasklet_hi_vec</tt> arrays, respectively. Both of them include <tt class="calibre25">NR_CPUS</tt> elements of type <tt class="calibre25">tasklet_head</tt>, and each element consists of a pointer to a list of <span class="docEmphasis">tasklet descriptors</span>. The tasklet descriptor is a data structure of type <tt class="calibre25">tasklet_struct</tt>, whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-4-TABLE-11">Table 4-11</a>.</p>
<a name="understandlk-CHP-4-TABLE-11"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 4-11. The fields of the tasklet descriptor</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">next</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to next descriptor in the list</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">state</tt></p></td><td class="docTableCell"><p class="docText2">Status of the tasklet</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">count</tt></p></td><td class="docTableCell"><p class="docText2">Lock counter</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">func</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the tasklet function</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">data</tt></p></td><td class="docTableCell"><p class="docText2">An unsigned long integer that may be used by the tasklet function</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">state</tt> field of the tasklet descriptor includes two flags:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">TASKLET_STATE_SCHED</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">When set, this indicates that the tasklet is pending (has been scheduled for execution); it also means that the tasklet descriptor is inserted in one of the lists of the <tt class="calibre25">tasklet_vec</tt> and <tt class="calibre25">tasklet_hi_vec</tt> arrays.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">TASKLET_STATE_RUN</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">When set, this indicates that the tasklet is being executed; on a uniprocessor system this flag is not used because there is no need to check whether a specific tasklet is running.</p></dd></dl>
<p class="docText1">Let's suppose you're writing a device driver and you want to use a tasklet: what has to be done? First of all, you should allocate a new <tt class="calibre25">tasklet_struct</tt> data structure and initialize it by invoking <tt class="calibre25">tasklet_init( )</tt>; this function receives as its parameters the address of the tasklet descriptor, the address of your tasklet function, and its optional integer argument.</p>
<p class="docText1">The tasklet may be selectively disabled by invoking either <tt class="calibre25">tasklet_disable_nosync( )</tt> or <tt class="calibre25">tasklet_disable( )</tt>. Both functions increase the <tt class="calibre25">count</tt> field of the tasklet descriptor, but the latter function does not return until an already running instance of the tasklet function has terminated. To reenable the tasklet, use <tt class="calibre25">tasklet_enable( )</tt>.</p>
<p class="docText1">To activate the tasklet, you should invoke either the <tt class="calibre25">tasklet_schedule( )</tt> function or the <tt class="calibre25">tasklet_hi_schedule( )</tt> function, according to the priority that you require for the tasklet. The two functions are very similar; each of them performs the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks the <tt class="calibre25">TASKLET_STATE_SCHED</tt> flag; if it is set, returns (the tasklet has already been scheduled).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">local_irq_save</tt> to save the state of the <tt class="calibre25">IF</tt> flag and to disable local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adds the tasklet descriptor at the beginning of the list pointed to by <tt class="calibre25">tasklet_vec[n]</tt> or <tt class="calibre25">tasklet_hi_vec[n]</tt>, where <tt class="calibre25">n</tt> denotes the logical number of the local CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">raise_softirq_irqoff( )</tt> to activate either the <tt class="calibre25">TASKLET_SOFTIRQ</tt> or the <tt class="calibre25">HI_SOFTIRQ</tt> softirq (this function is similar to <tt class="calibre25">raise_softirq( )</tt>, except that it assumes that local interrupts are already disabled).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">local_irq_restore</tt> to restore the state of the <tt class="calibre25">IF</tt> flag.</p></div></li></ol></div>
<p class="docText1">Finally, let's see how the tasklet is executed. We know from the previous section that, once activated, softirq functions are executed by the <tt class="calibre25">do_softirq( )</tt> function. The softirq function associated with the <tt class="calibre25">HI_SOFTIRQ</tt> softirq is named <tt class="calibre25">tasklet_hi_action( )</tt>, while the function associated with <tt class="calibre25">TASKLET_SOFTIRQ</tt> is named <tt class="calibre25">tasklet_action( )</tt>. Once again, the two functions are very similar; each of them:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Disables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets the logical number <tt class="calibre25">n</tt> of the local CPU.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Stores the address of the list pointed to by <tt class="calibre25">tasklet_vec[n]</tt> or <tt class="calibre25">tasklet_hi_vec[n]</tt> in the <tt class="calibre25">list</tt> local variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Puts a <tt class="calibre25">NULL</tt> address in <tt class="calibre25">tasklet_vec[n]</tt> or <tt class="calibre25">tasklet_hi_vec[n]</tt>, thus emptying the list of scheduled tasklet descriptors.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Enables local interrupts.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">For each tasklet descriptor in the list pointed to by <tt class="calibre25">list</tt>:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">In multiprocessor systems, checks the <tt class="calibre25">TASKLET_STATE_RUN</tt> flag of the tasklet.</p><ul class="calibre67"><li class="calibre12"><p class="docList">If it is set, a tasklet of the same type is already running on another CPU, so the function reinserts the task descriptor in the list pointed to by <tt class="calibre25">tasklet_vec[n]</tt> or <tt class="calibre25">tasklet_hi_vec[n]</tt> and activates the <tt class="calibre25">TASKLET_SOFTIRQ</tt> or <tt class="calibre25">HI_SOFTIRQ</tt> softirq again. In this way, execution of the tasklet is deferred until no other tasklets of the same type are running on other CPUs.</p></li><li class="calibre12"><p class="docList">Otherwise, the tasklet is not running on another CPU: sets the flag so that the tasklet function cannot be executed on other CPUs.</p></li></ul></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the tasklet is disabled by looking at the <tt class="calibre25">count</tt> field of the tasklet descriptor. If the tasklet is disabled, it clears its <tt class="calibre25">TASKLET_STATE_RUN</tt> flag and reinserts the task descriptor in the list pointed to by <tt class="calibre25">tasklet_vec[n]</tt> or <tt class="calibre25">tasklet_hi_vec[n]</tt>; then the function activates the <tt class="calibre25">TASKLET_SOFTIRQ</tt> or <tt class="calibre25">HI_SOFTIRQ</tt> softirq again.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the tasklet is enabled, it clears the <tt class="calibre25">TASKLET_STATE_SCHED</tt> flag and executes the tasklet function.</p></div></li></ol></div></div></li></ol></div>
<p class="docText1">Notice that, unless the tasklet function reactivates itself, every tasklet activation triggers at most one execution of the tasklet function.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

