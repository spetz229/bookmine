---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-20-SECT-1.html
next: understandlk-CHP-20-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-20-SECT-2"></a>
<h3 class="docSection1Title">20.2. Executable Formats</h3><a name="IDX-CHP-20-4862"></a>
<a name="IDX-CHP-20-4863"></a>
<a name="IDX-CHP-20-4864"></a>
<a name="IDX-CHP-20-4865"></a>
<a name="IDX-CHP-20-4866"></a>
<a name="IDX-CHP-20-4867"></a>
<a name="IDX-CHP-20-4868"></a>
<a name="IDX-CHP-20-4869"></a>
<a name="IDX-CHP-20-4870"></a>
<a name="IDX-CHP-20-4871"></a>
<a name="IDX-CHP-20-4872"></a>
<a name="IDX-CHP-20-4873"></a>
<p class="docText1">The standard Linux executable format is named <span class="docEmphasis">Executable and Linking Format (</span><span class="docEmphasis">ELF</span>). It was developed by Unix System Laboratories and is now the most widely used format in the Unix world. Several well-known Unix operating systems, such as System V<a name="IDX-CHP-20-4874"></a> 
 Release 4 and Sun's Solaris<a name="IDX-CHP-20-4875"></a> 
 2, have adopted ELF as their main executable format.</p>
<p class="docText1">Older Linux versions supported another format named <span class="docEmphasis">Assembler OUTput Format</span>(<span class="docEmphasis">a.out</span>); actually, there were several versions of that format floating around the Unix world. It is seldom used now, because ELF is much more practical.</p>
<p class="docText1">Linux supports many other different formats for executable files; in this way, it can run programs compiled for other operating systems, such as MS-DOS<a name="IDX-CHP-20-4876"></a> 
 EXE programs or BSD<a name="IDX-CHP-20-4877"></a> 
 Unix's COFF executables. A few executable formats, such as Java or <span class="docEmphasis">bash</span> scripts, are platform-independent.</p>
<p class="docText1">An executable format is described by an object of type <tt class="calibre25">linux_binfmt</tt>, which essentially provides three methods:</p>
<a name="IDX-CHP-20-4878"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">load_binary</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Sets up a new execution environment for the current process by reading the information stored in an executable file.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">load_shlib</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Dynamically binds a shared library to an already running process; it is activated by the <tt class="calibre25">uselib( )</tt><a name="IDX-CHP-20-4878"></a> 
 system call.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">core_dump</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Stores the execution context of the current process in a file named <tt class="calibre25">core</tt>. This file, whose format depends on the type of executable of the program being executed, is usually created when a process receives a signal whose default action is "dump" (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-1.html#understandlk-CHP-11-SECT-1.1">Actions Performed upon Delivering a Signal</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>).</p></dd></dl>
<p class="docText1">All <tt class="calibre25">linux_binfmt</tt> objects are included in a singly linked list, and the address of the first element is stored in the <tt class="calibre25">formats</tt> variable. Elements can be inserted and removed in the list by invoking the <tt class="calibre25">register_binfmt( )</tt> and <tt class="calibre25">unregister_binfmt( )</tt> functions. The <tt class="calibre25">register_binfmt( )</tt> function is executed during system startup for each executable format compiled into the kernel. This function is also executed when a module implementing a new executable format is being loaded, while the <tt class="calibre25">unregister_binfmt( )</tt> function is invoked when the module is unloaded.</p>
<p class="docText1">The last element in the <tt class="calibre25">formats</tt> list is always an object describing the executable format for <span class="docEmphasis">interpreted scripts</span><a name="IDX-CHP-20-4879"></a> 
. This format defines only the <tt class="calibre25">load_binary</tt> method. The corresponding <tt class="calibre25">load_script( )</tt> function checks whether the executable file starts with the <tt class="calibre25">#!</tt> pair of characters. If so, it interprets the rest of the first line as the pathname of another executable file and tries to execute it by passing the name of the script file as a parameter.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-20-FN5">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-20-FN5">[*]</a></sup> It is possible to execute a script file even if it doesn't start with the <tt class="calibre42">#!</tt> characters, as long as the file is written in the language recognized by a command shell. In this case, however, the script is interpreted either by the shell on which the user types the command or by the default Bourne shell <i class="docEmphasis">sh</i>; therefore, the kernel is not directly involved.</p></blockquote>
<p class="docText1">Linux allows users to register their own custom executable formats. Each such format may be recognized either by means of a magic number stored in the first 128 bytes of the file, or by a filename extension that identifies the file type. For example, MS-DOS extensions consist of three characters separated from the filename by a dot: the <i class="docEmphasis">.exe</i> extension identifies executable programs, while the <i class="docEmphasis">.bat</i> extension identifies shell scripts.</p>
<p class="docText1">When the kernel determines that the executable file has a custom format, it starts the proper interpreter program<a name="IDX-CHP-20-4880"></a> 
. The <span class="docEmphasis">interpreter program</span> runs in User Mode, receives as its parameter the pathname of the executable file, and carries on the computation. As an example, an executable file containing a Java program is dealt by a java virtual machine such as <span class="docEmphasis">/usr/lib/java/bin/java</span>.</p>
<p class="docText1">The mechanism is similar to the script's format, but it's more powerful because it doesn't impose any restrictions on the custom format. To register a new format, the user writes into the <i class="docEmphasis">register</i> file of the <span class="docEmphasis">binfmt_misc</span><a name="IDX-CHP-20-4881"></a> 
 special filesystem (usually mounted on <i class="docEmphasis">/proc/sys/fs/binfmt_misc</i>) a string with the following format:</p>
<pre class="calibre27">
    :name:type:offset:string:mask:interpreter:flags</pre><br class="calibre7"/>
<p class="docText1">where each field has the following meaning:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">name</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">An identifier for the new format</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">type</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The type of recognition (<tt class="calibre25">M</tt> for magic number, <tt class="calibre25">E</tt> for extension)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">offset</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The starting offset of the magic number inside the file</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">string</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The byte sequence to be matched either in the magic number or in the extension</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">mask</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The string to mask out some bits in <tt class="calibre25">string</tt></p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">interpreter</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">The full pathname of the interpreter program</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">flags</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Some optional flags that control how the interpreter program has to be invoked</p></dd></dl>
<p class="docText1">For example, the following command performed by the superuser enables the kernel to recognize the Microsoft Windows<a name="IDX-CHP-20-4882"></a> 
 executable format:</p>
<pre class="calibre27">
    $ echo ':DOSWin:M:0:MZ:0xff:/usr/bin/wine:'
                                        &gt; /proc/sys/fs/binfmt_misc/register</pre><br class="calibre7"/>
<p class="docText1">A Windows executable file has the MZ magic number in the first two bytes, and it is executed by the <i class="docEmphasis">/usr/bin/wine</i> interpreter program.</p>

<br class="calibre7"/>

</div>

{% endraw %}

