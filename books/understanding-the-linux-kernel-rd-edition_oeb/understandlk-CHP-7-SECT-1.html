---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-7.html
next: understandlk-CHP-7-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-7-SECT-1"></a>
<h3 class="docSection1Title" id="534869-893">7.1. Scheduling Policy</h3><a name="IDX-CHP-7-1812"></a>
<a name="IDX-CHP-7-1813"></a>
<a name="IDX-CHP-7-1814"></a>
<a name="IDX-CHP-7-1815"></a>
<a name="IDX-CHP-7-1816"></a>
<a name="IDX-CHP-7-1817"></a>
<a name="IDX-CHP-7-1818"></a>
<a name="IDX-CHP-7-1819"></a>
<a name="IDX-CHP-7-1820"></a>
<p class="docText1">The scheduling algorithm of traditional Unix operating systems must fulfill several conflicting objectives: fast process response time, good throughput for background jobs, avoidance of process starvation, reconciliation of the needs of low- and high-priority processes, and so on. The set of rules used to determine when and how to select a new process to run is called <span class="docEmphasis">scheduling policy</span><a name="IDX-CHP-7-1821"></a> 
.</p>
<p class="docText1">Linux scheduling is based on the <span class="docEmphasis">time sharing</span> technique: several processes run in "time multiplexing" because the CPU time is divided into <span class="docEmphasis">slices</span>, one for each runnable process.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-FN1">[*]</a></sup> Of course, a single processor can run only one process at any given instant. If a currently running process is not terminated when its time slice or <span class="docEmphasis">quantum</span> expires, a process switch may take place. Time sharing relies on timer interrupts and is thus transparent to processes. No additional code needs to be inserted in the programs to ensure CPU time sharing.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-7-FN1">[*]</a></sup> Recall that stopped and suspended processes cannot be selected by the scheduling algorithm to run on a CPU.</p></blockquote>
<p class="docText1">The scheduling policy is also based on ranking processes according to their priority. Complicated algorithms are sometimes used to derive the current priority of a process, but the end result is the same: each process is associated with a value that tells the scheduler how appropriate it is to let the process run on a CPU.</p>
<p class="docText1">In Linux, process priority is dynamic. The scheduler keeps track of what processes are doing and adjusts their priorities periodically; in this way, processes that have been denied the use of a CPU for a long time interval are boosted by dynamically increasing their priority. Correspondingly, processes running for a long time are penalized by decreasing their priority.</p>
<p class="docText1">When speaking about scheduling, processes are traditionally classified as <span class="docEmphasis">I/O-bound</span> or <span class="docEmphasis">CPU-bound</span>. The former make heavy use of I/O devices and spend much time waiting for I/O operations to complete; the latter carry on number-crunching applications that require a lot of CPU time.</p>
<p class="docText1">An alternative classification distinguishes three classes of processes:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Interactive processes</span></span></p></dt>
<dd class="calibre20"><p class="docList">These interact constantly with their users, and therefore spend a lot of time waiting for keypresses and mouse operations. When input is received, the process must be woken up quickly, or the user will find the system to be unresponsive. Typically, the average delay must fall between 50 and 150 milliseconds. The variance of such delay must also be bounded, or the user will find the system to be erratic. Typical interactive programs are command shells, text editors, and graphical applications.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Batch processes</span></span></p></dt>
<dd class="calibre20"><p class="docList">These do not need user interaction, and hence they often run in the background. Because such processes do not need to be very responsive, they are often penalized by the scheduler. Typical batch programs are programming language compilers, database search engines, and scientific computations.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Real-time processes</span></span></p></dt>
<dd class="calibre20"><p class="docList">These have very stringent scheduling requirements. Such processes should never be blocked by lower-priority processes and should have a short guaranteed response time with a minimum variance. Typical real-time programs are video and sound applications, robot controllers, and programs that collect data from physical sensors.</p></dd></dl>
<p class="docText1">The two classifications we just offered are somewhat independent. For instance, a batch process can be either I/O-bound (e.g., a database server) or CPU-bound (e.g., an image-rendering program). While real-time programs are explicitly recognized as such by the scheduling algorithm in Linux, there is no easy way to distinguish between interactive and batch programs. The Linux 2.6 scheduler implements a sophisticated heuristic algorithm based on the past behavior of the processes to decide whether a given process should be considered as interactive or batch. Of course, the scheduler tends to favor interactive processes over batch ones.</p>
<p class="docText1">Programmers may change the scheduling priorities by means of the system calls illustrated in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-TABLE-1">Table 7-1</a>. More details are given in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-6.html#understandlk-CHP-7-SECT-6">System Calls Related to Scheduling</a>."</p>
<a name="understandlk-CHP-7-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 7-1. System calls related to scheduling</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">System call</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">nice( )</tt></p></td><td class="docTableCell"><p class="docText2">Change the static priority of a conventional process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">getpriority( )</tt></p></td><td class="docTableCell"><p class="docText2">Get the maximum static priority of a group of conventional processes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">setpriority( )</tt></p></td><td class="docTableCell"><p class="docText2">Set the static priority of a group of conventional processes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_getscheduler( )</tt></p></td><td class="docTableCell"><p class="docText2">Get the scheduling policy of a process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_setscheduler( )</tt></p></td><td class="docTableCell"><p class="docText2">Set the scheduling policy and the real-time priority of a process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_getparam( )</tt></p></td><td class="docTableCell"><p class="docText2">Get the real-time priority of a process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_setparam( )</tt></p></td><td class="docTableCell"><p class="docText2">Set the real-time priority of a process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_yield( )</tt></p></td><td class="docTableCell"><p class="docText2">Relinquish the processor voluntarily without blocking</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_get_ priority_min( )</tt></p></td><td class="docTableCell"><p class="docText2">Get the minimum real-time priority value for a policy</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_get_ priority_max( )</tt></p></td><td class="docTableCell"><p class="docText2">Get the maximum real-time priority value for a policy</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sched_rr_get_interval( )</tt></p></td><td class="docTableCell"><p class="docText2">Get the time quantum value for the Round Robin policy</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">sched_setaffinity( )<a name="IDX-CHP-7-1822"></a>
</p></td><td class="docTableCell"><p class="docText2">Set the CPU affinity mask of a process</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">sched_getaffinity( )<a name="IDX-CHP-7-1823"></a>
</p></td><td class="docTableCell"><p class="docText2">Get the CPU affinity mask of a process</p></td></tr></table></p><br class="calibre7"/>
<a name="understandlk-CHP-7-SECT-1.1"></a>
<h4 class="docSection2Title">7.1.1. Process Preemption</h4><a name="IDX-CHP-7-1824"></a>
<a name="IDX-CHP-7-1825"></a>
<a name="IDX-CHP-7-1826"></a>
<a name="IDX-CHP-7-1827"></a>
<a name="IDX-CHP-7-1828"></a>
<a name="IDX-CHP-7-1829"></a>
<a name="IDX-CHP-7-1830"></a>
<a name="IDX-CHP-7-1831"></a>
<a name="IDX-CHP-7-1832"></a>
<a name="IDX-CHP-7-1833"></a>
<a name="IDX-CHP-7-1834"></a>
<a name="IDX-CHP-7-1835"></a>
<a name="IDX-CHP-7-1836"></a>
<a name="IDX-CHP-7-1837"></a>
<a name="IDX-CHP-7-1838"></a>
<p class="docText1">As mentioned in the first chapter, Linux processes are <span class="docEmphasis">preemptable</span>. When a process enters the <tt class="calibre25">TASK_RUNNING</tt> state, the kernel checks whether its dynamic priority is greater than the priority of the currently running process. If it is, the execution of <tt class="calibre25">current</tt> is interrupted and the scheduler is invoked to select another process to run (usually the process that just became runnable). Of course, a process also may be preempted when its time quantum expires. When this occurs, the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag in the <tt class="calibre25">thread_info</tt> structure of the current process is set, so the scheduler is invoked when the timer interrupt handler terminates.</p>
<p class="docText1">For instance, let's consider a scenario in which only two programsa text editor and a compilerare being executed. The text editor is an interactive program, so it has a higher dynamic priority than the compiler. Nevertheless, it is often suspended, because the user alternates between pauses for think time and data entry; moreover, the average delay between two keypresses is relatively long. However, as soon as the user presses a key, an interrupt is raised and the kernel wakes up the text editor process. The kernel also determines that the dynamic priority of the editor is higher than the priority of <tt class="calibre25">current</tt>, the currently running process (the compiler), so it sets the <tt class="calibre25">TIF_NEED_RESCHED</tt> flag of this process, thus forcing the scheduler to be activated when the kernel finishes handling the interrupt. The scheduler selects the editor and performs a process switch; as a result, the execution of the editor is resumed very quickly and the character typed by the user is echoed to the screen. When the character has been processed, the text editor process suspends itself waiting for another keypress and the compiler process can resume its execution.</p>
<p class="docText1">Be aware that a preempted process is not suspended, because it remains in the <tt class="calibre25">TASK_RUNNING</tt> state; it simply no longer uses the CPU. Moreover, remember that the Linux 2.6 kernel is preemptive, which means that a process can be preempted either when executing in Kernel or in User Mode; we discussed in depth this feature in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-1.html#understandlk-CHP-5-SECT-1.1">Kernel Preemption</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>.</p>
<a name="understandlk-CHP-7-SECT-1.2"></a>
<h4 class="docSection2Title">7.1.2. How Long Must a Quantum Last?</h4><a name="IDX-CHP-7-1839"></a>
<p class="docText1">The quantum duration is critical for system performance: it should be neither too long nor too short.</p>
<p class="docText1">If the average quantum duration is too short, the system overhead caused by process switches becomes excessively high. For instance, suppose that a process switch requires 5 milliseconds; if the quantum is also set to 5 milliseconds, then at least 50 percent of the CPU cycles will be dedicated to process switching.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-FN2">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-7-FN2">[*]</a></sup> Actually, things could be much worse than this; for example, if the time required for the process switch is counted in the process quantum, all CPU time is devoted to the process switch and no process can progress toward its termination.</p></blockquote>
<p class="docText1">If the average quantum duration is too long, processes no longer appear to be executed concurrently. For instance, let's suppose that the quantum is set to five seconds; each runnable process makes progress for about five seconds, but then it stops for a very long time (typically, five seconds times the number of runnable processes).</p>
<p class="docText1">It is often believed that a long quantum duration degrades the response time of interactive applications. This is usually false. As described in the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-7-SECT-1.1">Process Preemption</a>" earlier in this chapter, interactive processes have a relatively high priority, so they quickly preempt the batch processes, no matter how long the quantum duration is.</p>
<p class="docText1">In some cases, however, a very long quantum duration degrades the responsiveness of the system. For instance, suppose two users concurrently enter two commands at the respective shell prompts; one command starts a CPU-bound process, while the other launches an interactive application. Both shells fork a new process and delegate the execution of the user's command to it; moreover, suppose such new processes have the same initial priority (Linux does not know in advance if a program to be executed is batch or interactive). Now if the scheduler selects the CPU-bound process to run first, the other process could wait for a whole time quantum before starting its execution. Therefore, if the quantum duration is long, the system could appear to be unresponsive to the user that launched the interactive application.</p>
<p class="docText1">The choice of the average quantum duration is always a compromise. The rule of thumb adopted by Linux is choose a duration as long as possible, while keeping good system response time.</p>

<br class="calibre7"/>

</div>

{% endraw %}

