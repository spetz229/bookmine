---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-17.html
next: understandlk-CHP-17-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-17-SECT-1"></a>
<h3 class="docSection1Title" id="534871-986">17.1. The Page Frame Reclaiming Algorithm</h3><a name="IDX-CHP-17-4080"></a>
<p class="docText1">One of the fascinating aspects of Linux is that the checks performed before allocating dynamic memory to User Mode processes or to the kernel are somewhat perfunctory.</p>
<p class="docText1">No rigorous check is made, for instance, on the total amount of RAM assigned to the processes created by a single user (the limits mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.5">Process Resource Limits</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a> mostly affect single processes). Similarly, no limit is placed on the size of the many disk caches and memory caches<a name="IDX-CHP-17-4081"></a> 
 used by the kernel.</p>
<p class="docText1">This lack of controls is a design choice that allows the kernel to use the available RAM in the best possible way. When the system load is low, the RAM is filled mostly by the disk caches and the few running processes can benefit from the information stored in them. However, when the system load increases, the RAM is filled mostly by pages of the processes and the caches are shrunken to make room for additional processes.</p>
<p class="docText1">As we saw in previous chapters, both memory and disk caches grab more and more page frames but never release any of them. This is reasonable because cache systems don't know if and when processes will reuse some of the cached data and are therefore unable to identify the portions of cache that should be released. Moreover, thanks to the demand paging<a name="IDX-CHP-17-4082"></a> 
 mechanism described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>, User Mode processes get page frames as long as they proceed with their execution; however, demand paging has no way to force processes to release the page frames whenever they are no longer used.</p>
<p class="docText1">Thus, sooner or later all the free memory will be assigned to processes and caches. The <span class="docEmphasis">page frame reclaiming</span><a name="IDX-CHP-17-4083"></a> 
 algorithm of the Linux kernel refills the lists of free blocks of the buddy system by "stealing" page frames from both User Mode processes and kernel caches.</p>
<p class="docText1">Actually, page frame reclaiming must be performed <span class="docEmphasis">before</span> all the free memory has been used up. Otherwise, the kernel might be easily trapped in a deadly chain of memory requests that leads to a system crash. Essentially, to free a page frame the kernel must write its data to disk; however, to accomplish this operation, the kernel requires another page frame (for instance, to allocate the buffer heads for the I/O data transfer). If no free page frame exists, no page frame can be freed.</p>
<p class="docText1">One of the goals of page frame reclaiming is thus to conserve a minimal pool of free page frames so that the kernel may safely recover from "low on memory" conditions.</p>
<a name="understandlk-CHP-17-SECT-1.1"></a>
<h4 class="docSection2Title">17.1.1. Selecting a Target Page</h4>
<p class="docText1">The objective of the page frame reclaiming algorithm (<span class="docEmphasis">PFRA</span><a name="IDX-CHP-17-4084"></a> 
) is to pick up page frames and make them free. Clearly the page frames selected by the PFRA must be <span class="docEmphasis">non-free</span><a name="IDX-CHP-17-4085"></a> 
, that is, they must not be already included in one of the <tt class="calibre25">free_area</tt> arrays used by the buddy system (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-1.html#understandlk-CHP-8-SECT-1.7">The Buddy System Algorithm</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>).</p>
<p class="docText1">The PFRA handles the page frames in different ways, according to their contents. We can distinguish between <span class="docEmphasis">unreclaimable<a name="IDX-CHP-17-4086"></a> 
 pages</span>, <span class="docEmphasis">swappable<a name="IDX-CHP-17-4087"></a> 
 pages</span>, <span class="docEmphasis">syncable<a name="IDX-CHP-17-4088"></a> 
 pages</span>, and <span class="docEmphasis">discardable<a name="IDX-CHP-17-4089"></a> 
 pages</span>. These types are explained in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-17-TABLE-1">Table 17-1</a>.</p>
<a name="understandlk-CHP-17-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 17-1. The types of pages considered by the PFRA</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type of pages</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Reclaim action</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2">Unreclaimable</p></td><td class="docTableCell"><p class="docText2">Free pages (included in buddy system lists)</p><p class="docText2">Reserved pages (with <tt class="calibre25">PG_reserved</tt> flag set)</p><p class="docText2">Pages dynamically allocated by the kernel</p><p class="docText2">Pages in the Kernel Mode stacks of the processes</p><p class="docText2">Temporarily locked pages (with <tt class="calibre25">PG_locked</tt> flag set)</p><p class="docText2">Memory locked pages (in memory regions<a name="IDX-CHP-17-4090"></a> 
 with <tt class="calibre25">VM_LOCKED</tt> flag set)</p></td><td class="docTableCell"><p class="docText2">(No reclaiming allowed or needed)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Swappable</p></td><td class="docTableCell"><p class="docText2">Anonymous pages in User Mode address spaces<a name="IDX-CHP-17-4091"></a>
</p><p class="docText2">Mapped pages of <span class="docEmphasis">tmpfs</span><a name="IDX-CHP-17-4092"></a> 
 filesystem (e.g., pages of IPC shared<a name="IDX-CHP-17-4093"></a> 
 memory)</p></td><td class="docTableCell"><p class="docText2">Save the page contents in a swap area</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Syncable</p></td><td class="docTableCell"><p class="docText2">Mapped pages in User Mode address spaces</p><p class="docText2">Pages included in the page cache and containing data of disk files</p><p class="docText2">Block device buffer pages</p><p class="docText2">Pages of some disk caches<a name="IDX-CHP-17-4094"></a> 
 (e.g., the inode cache<a name="IDX-CHP-17-4095"></a> 
)</p></td><td class="docTableCell"><p class="docText2">Synchronize the page with its image on disk, if necessary</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">Discardable</p></td><td class="docTableCell"><p class="docText2">Unused pages included in memory caches<a name="IDX-CHP-17-4096"></a> 
 (e.g., slab allocator caches)</p><p class="docText2">Unused pages of the dentry cache<a name="IDX-CHP-17-4097"></a>
</p></td><td class="docTableCell"><p class="docText2">Nothing to be done</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">In the above table, a page is said to be <span class="docEmphasis">mapped</span> if it maps a portion of a file. For instance, all pages in the User Mode address spaces belonging to file memory mappings are mapped, as well as any other page included in the page cache. In almost all cases, mapped pages are syncable: in order to reclaim the page frame, the kernel must check whether the page is dirty and, if necessary, write the page contents in the corresponding disk file.</p>
<p class="docText1">Conversely, a page is said to be <span class="docEmphasis">anonymous</span><a name="IDX-CHP-17-4098"></a> 
 if it belongs to an anonymous memory region of a process (for instance, all pages in the User Mode heap or stack of a process are anonymous). In order to reclaim the page frame, the kernel must save the page contents in a dedicated disk partition or disk file called "swap area" (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17-SECT-4.html#understandlk-CHP-17-SECT-4">Swapping</a>"); therefore, all anonymous pages are swappable.</p>
<p class="docText1">Usually, the pages of special filesystems are not reclaimable. The only exceptions are the pages of the <span class="docEmphasis">tmpfs</span> special filesystem, which can be reclaimed by saving them in a swap area. As we'll see in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19.html#understandlk-CHP-19">Chapter 19</a>, the <span class="docEmphasis">tmpfs</span> special filesystem is used by the IPC shared memory mechanism.</p>
<p class="docText1">When the PFRA must reclaim a page frame belonging to the User Mode address space of a process, it must take into consideration whether the page frame is <span class="docEmphasis">shared</span> or <span class="docEmphasis">non-shared</span><a name="IDX-CHP-17-4099"></a> 
. A shared page frame belongs to multiple User Mode address spaces, while a non-shared page frame belongs to just one. Notice that a non-shared page frame might belong to several lightweight processes referring to the same memory descriptor.</p>
<p class="docText1">Shared page frames are typically created when a process spawns a child; as explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-4.html#understandlk-CHP-9-SECT-4.4">Copy On Write</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>, the page tables of the child are copied from those of the parent, thus parent and child share the same page frames. Another common case occurs when two or more processes access the same file by means of a shared memory mapping (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-2.html#understandlk-CHP-16-SECT-2">Memory Mapping</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>).<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-17-FN1">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-17-FN1">[*]</a></sup> It should be noted, however, that when a single process accesses a file through a shared memory mapping, the corresponding pages are non-shared as far as the PFRA is concerned. Similarly, a page belonging to a private memory mapping may be treated as shared by the PFRA (for instance, because two processes read the same file portion and none of them modified the data in the page).</p></blockquote>
<a name="understandlk-CHP-17-SECT-1.2"></a>
<h4 class="docSection2Title">17.1.2. Design of the PFRA</h4>
<p class="docText1">While it is easy to identify the page candidates for memory reclaimingroughly speaking, any page belonging to a disk or memory cache, or to the User Mode address space of a processselecting the proper target pages is perhaps the most sensitive issue in kernel design.</p>
<p class="docText1">As a matter of fact, the hardest job of a developer working on the virtual memory subsystem consists of finding an algorithm that ensures acceptable performance both for desktop machines (on which memory requests are quite limited but system responsiveness is crucial) and for high-level machines such as large database servers (on which memory requests tend to be huge).</p>
<p class="docText1">Unfortunately, finding a good page frame reclaiming algorithm is a rather empirical job, with very little support from theory. The situation is somewhat similar to evaluating the factors that determine the dynamic priority of a process: the main objective is to tune the parameters in such a way to achieve good system performance, without asking too many questions about why it works well. Often, it's just a matter of "let's try this approach and see what happens." An unpleasant side effect of this empirical design is that the code changes quickly. For that reason, we cannot ensure that the memory reclaiming algorithm we are going to describethe one used in Linux 2.6.11will be exactly the same, by the time you'll read this chapter, as the one adopted by the most up-to-date version of the Linux 2.6 kernel. However, the general ideas and the main heuristic rules described here should continue to hold.</p>
<p class="docText1">Looking too close to the trees' leaves might lead us to miss the whole forest. Therefore, let us present a few general rules adopted by the PFRA. These rules are embedded in the functions that will be described later in this chapter.</p>
<a name="IDX-CHP-17-4100"></a><a name="IDX-CHP-17-4101"></a><a name="IDX-CHP-17-4102"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Free the "harmless" pages first</span></span></p></dt>
<dd class="calibre20"><p class="docList">Pages included in disk and memory caches not referenced by any process should be reclaimed before pages belonging to the User Mode address spaces of the processes; in the former case, in fact, the page frame reclaiming can be done without modifying any Page Table entry. As we will see in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17-SECT-3.html#understandlk-CHP-17-SECT-3.1">The Least Recently Used (LRU) Lists</a>" later in this chapter, this rule is somewhat mitigated by introducing a "swap tendency factor."</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Make all pages of a User Mode process reclaimable</span></span></p></dt>
<dd class="calibre20"><p class="docList">With the exception of locked pages, the PFRA must be able to steal any page of a User Mode process, including the anonymous pages. In this way, processes that have been sleeping for a long period of time will progressively lose all their page frames.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Reclaim a shared page frame by unmapping at once all page table entries that reference it</span></span></p></dt>
<dd class="calibre20"><p class="docList">When the PFRA wants to free a page frame shared by several processes, it clears all page table entries that refer to the shared page frame, and then reclaims the page frame.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Reclaim "unused" pages only</span></span></p></dt><a name="IDX-CHP-17-4100"></a>
<dd class="calibre20"><p class="docList">The PFRA uses a simplified <span class="docEmphasis">Least Recently Used (LRU) replacement algorithm</span> to classify pages as <span class="docEmphasis">in-use</span><a name="IDX-CHP-17-4101"></a> 
 and <span class="docEmphasis">unused</span>.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-17-FN2">[*]</a></sup> If a page has not been accessed for a long time, the probability that it will be accessed in the near future is low and it can be considered "unused;" on the other hand, if a page has been accessed recently, the probability that it will continue to be accessed is high and it must be considered as "in-use." The PFRA reclaims only unused pages. This is just another application of the locality principle<a name="IDX-CHP-17-4102"></a> 
 mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-4.html#understandlk-CHP-2-SECT-4.7">Hardware Cache</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>.</p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-17-FN2">[*]</a></sup> The PFRA could also be considered as a "used-once" algorithm, which has its roots in the 2Q buffer management replacement algorithm proposed by T. Johnson and D. Shasha in 1994.</p></blockquote>
<p class="docList">The main idea behind the LRU algorithm is to associate a counter storing the age of the page with each page in RAMthat is, the interval of time elapsed since the last access to the page. This counter allows the PFRA to reclaim only the oldest page of any process. Some computer platforms provide sophisticated support for LRU algorithms;<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-17-FN3">[<img src="u2020.jpg" border="0" class="calibre10"/>]</a></sup> unfortunately, 80 x 86 processors do not offer such a hardware feature, thus the Linux kernel cannot rely on a page counter that keeps track of the age of every page. To cope with this restriction, Linux takes advantage of the <tt class="calibre25">Accessed</tt> bit included in each Page Table entry, which is automatically set by the hardware when the page is accessed; moreover, the age of a page is represented by the position of the page descriptor in one of two different lists (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17-SECT-3.html#understandlk-CHP-17-SECT-3.1">The Least Recently Used (LRU) Lists</a>" later in this chapter).</p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-17-FN3">[<img src="u2020.jpg" border="0" class="calibre10"/>]</a></sup> For instance, the CPUs of some mainframes automatically update the value of a counter included in each page table entry to specify the age of the corresponding page.</p></blockquote></dd></dl>
<p class="docText1">Therefore, the page frame reclaiming algorithm is a blend of several heuristics:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Careful selection of the order in which caches are examined.</p></li><li class="calibre12"><p class="docText1">Ordering of pages based on aging (least recently used pages should be freed before pages accessed recently).</p></li><li class="calibre12"><p class="docText1">Distinction of pages based on the page state (for example, non-dirty pages are better candidates than dirty pages because they don't have to be written to disk).</p></li></ul>

<br class="calibre7"/>

</div>

{% endraw %}

