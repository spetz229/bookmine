---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-6.html
next: understandlk-CHP-6-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-6-SECT-1"></a>
<h3 class="docSection1Title">6.1. Clock and Timer Circuits</h3><a name="IDX-CHP-6-1630"></a>
<p class="docText1">On the 80x86 architecture, the kernel must explicitly interact with several kinds of clocks<a name="IDX-CHP-6-1631"></a> 
 and timer circuits<a name="IDX-CHP-6-1632"></a> 
. The <span class="docEmphasis">clock circuits</span> are used both to keep track of the current time of day and to make precise time measurements. The <span class="docEmphasis">timer circuits</span> are programmed by the kernel, so that they issue interrupts at a fixed, predefined frequency; such periodic interrupts are crucial for implementing the software timers used by the kernel and the user programs. We'll now briefly describe the clock and hardware circuits that can be found in IBM-compatible PCs.</p>
<a name="understandlk-CHP-6-SECT-1.1"></a>
<h4 class="docSection2Title">6.1.1. Real Time Clock (RTC)</h4><a name="IDX-CHP-6-1633"></a>
<a name="IDX-CHP-6-1634"></a>
<a name="IDX-CHP-6-1635"></a>
<a name="IDX-CHP-6-1636"></a>
<a name="IDX-CHP-6-1637"></a>
<p class="docText1">All PCs include a clock called <span class="docEmphasis">Real Time Clock</span> (<span class="docEmphasis">RTC</span>), which is independent of the CPU and all other chips.</p>
<p class="docText1">The RTC continues to tick even when the PC is switched off, because it is energized by a small battery. The CMOS RAM and RTC are integrated in a single chip (the Motorola 146818 or an equivalent).</p>
<p class="docText1">The RTC is capable of issuing periodic interrupts on IRQ 8 at frequencies ranging between 2 Hz and 8,192 Hz. It can also be programmed to activate the IRQ 8 line when the RTC reaches a specific value, thus working as an alarm clock.</p>
<p class="docText1">Linux uses the RTC only to derive the time and date; however, it allows processes to program the RTC by acting on the <i class="docEmphasis">/dev/rtc</i> device file (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>). The kernel accesses the RTC through the <tt class="calibre25">0x70</tt> and <tt class="calibre25">0x71</tt> I/O ports. The system administrator can read and write the RTC by executing the <i class="docEmphasis">clock</i> Unix system program that acts directly on these two I/O ports.</p>
<a name="understandlk-CHP-6-SECT-1.2"></a>
<h4 class="docSection2Title">6.1.2. Time Stamp Counter (TSC)</h4><a name="IDX-CHP-6-1638"></a>
<p class="docText1">All 80x86 microprocessors include a CLK input pin, which receives the clock signal of an external oscillator. Starting with the Pentium, 80x86 microprocessors sport a counter that is increased at each clock signal. The counter is accessible through the 64-bit <span class="docEmphasis">Time Stamp Counter</span>(<span class="docEmphasis">TSC</span>) register, which can be read by means of the <tt class="calibre25">rdtsc</tt><a name="IDX-CHP-6-1639"></a> 
 assembly language instruction. When using this register, the kernel has to take into consideration the frequency of the clock signal: if, for instance, the clock ticks at 1 GHz, the Time Stamp Counter is increased once every nanosecond.</p>
<p class="docText1">Linux may take advantage of this register to get much more accurate time measurements than those delivered by the Programmable Interval Timer. To do this, Linux must determine the clock signal frequency while initializing the system. In fact, because this frequency is not declared when compiling the kernel, the same kernel image may run on CPUs whose clocks may tick at any frequency.</p>
<p class="docText1">The task of figuring out the actual frequency of a CPU is accomplished during the system's boot. The <tt class="calibre25">calibrate_tsc( )</tt> function computes the frequency by counting the number of clock signals that occur in a time interval of approximately 5 milliseconds. This time constant is produced by properly setting up one of the channels of the Programmable Interval Timer<a name="IDX-CHP-6-1640"></a> 
 (see the next section).<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-FN1">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-6-FN1">[*]</a></sup> To avoid losing significant digits in the integer divisions, <tt class="calibre42">calibrate_tsc( )</tt> returns the duration, in microseconds, of a clock tick multiplied by 232.</p></blockquote>
<a name="understandlk-CHP-6-SECT-1.3"></a>
<h4 class="docSection2Title">6.1.3. Programmable Interval Timer (PIT)</h4><a name="IDX-CHP-6-1641"></a>
<a name="IDX-CHP-6-1642"></a>
<p class="docText1">Besides the Real Time Clock and the Time Stamp Counter, IBM-compatible PCs include another type of time-measuring device called <span class="docEmphasis">Programmable Interval Timer</span>(<span class="docEmphasis">PIT</span>). The role of a PIT is similar to the alarm clock of a microwave oven: it makes the user aware that the cooking time interval has elapsed. Instead of ringing a bell, this device issues a special interrupt called <span class="docEmphasis">timer interrupt</span>, which notifies the kernel that one more time interval has elapsed.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-6-FN2">[<img src="u2020.jpg" border="0" class="calibre10"/>]</a></sup> Another difference from the alarm clock is that the PIT goes on issuing interrupts forever at some fixed frequency established by the kernel. Each IBM-compatible PC includes at least one PIT, which is usually implemented by an 8254 CMOS chip using the <tt class="calibre25">0x40</tt>-<tt class="calibre25">0x43</tt> I/O ports.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-6-FN2">[<img src="u2020.jpg" border="0" class="calibre10"/>]</a></sup> The PIT is also used to drive an audio amplifier connected to the computer's internal speaker.</p></blockquote>
<p class="docText1">As we'll see in detail in the next paragraphs, Linux programs the PIT of IBM-compatible PCs to issue timer interrupts<a name="IDX-CHP-6-1643"></a> 
 on the IRQ 0 at a (roughly) 1000-Hz frequency  that is, once every 1 millisecond. This time interval is called a <span class="docEmphasis">tick</span>, and its length in nanoseconds is stored in the <tt class="calibre25">tick_nsec</tt> variable. On a PC, <tt class="calibre25">tick_nsec</tt> is initialized to 999,848 nanoseconds (yielding a clock signal frequency of about 1000.15 Hz), but its value may be automatically adjusted by the kernel if the computer is synchronized with an external clock (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-6.html#understandlk-CHP-6-SECT-6.2">The adjtimex( ) System Call</a>"). The ticks<a name="IDX-CHP-6-1644"></a> 
 beat time for all activities in the system; in some sense, they are like the ticks sounded by a metronome while a musician is rehearsing.</p>
<p class="docText1">Generally speaking, shorter ticks result in higher resolution timers, which help with smoother multimedia playback and faster response time when performing synchronous I/O multiplexing (<tt class="calibre25">poll( )</tt><a name="IDX-CHP-6-1645"></a> 
 and <tt class="calibre25">select( )</tt><a name="IDX-CHP-6-1646"></a> 
 system calls). This is a trade-off however: shorter ticks require the CPU to spend a larger fraction of its time in Kernel Mode  that is, a smaller fraction of time in User Mode. As a consequence, user programs run slower.</p>
<p class="docText1">The frequency of timer interrupts depends on the hardware architecture. The slower machines have a tick of roughly 10 milliseconds (100 timer interrupts per second), while the faster ones have a tick of roughly 1 millisecond (1000 or 1024 timer interrupts per second).</p>
<p class="docText1">A few macros in the Linux code yield some constants that determine the frequency of timer interrupts. These are discussed in the following list.</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1"><tt class="calibre25">HZ</tt> yields the approximate number of timer interrupts per second  that is, their frequency. This value is set to 1000 for IBM PCs.</p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">CLOCK_TICK_RATE</tt> yields the value 1,193,182, which is the 8254 chip's internal oscillator frequency.</p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">LATCH</tt> yields the ratio between <tt class="calibre25">CLOCK_TICK_RATE</tt> and <tt class="calibre25">HZ</tt>, rounded to the nearest integer. It is used to program the PIT.</p></li></ul>
<p class="docText1">The PIT is initialized by <tt class="calibre25">setup_pit_timer( )</tt> as follows:</p>
<pre class="calibre27">
    spin_lock_irqsave(&amp;i8253_lock, flags);
    outb_p(0x34,0x43);
    udelay(10);
    outb_p(LATCH &amp; 0xff, 0x40);
    udelay(10);
    outb<a name="IDX-CHP-6-1647"></a> 
(LATCH &gt;&gt; 8, 0x40);
    spin_unlock_irqrestore(&amp;i8253_lock, flags);
</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">outb( )</tt> C function is equivalent to the <tt class="calibre25">outb</tt> assembly language instruction: it copies the first operand into the I/O port specified as the second operand. The <tt class="calibre25">outb_p( )</tt> function is similar to <tt class="calibre25">outb( )</tt>, except that it introduces a pause by executing a no-op instruction to keep the hardware from getting confused. The <tt class="calibre25">udelay()</tt> macro introduces a further small delay (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-5.html#understandlk-CHP-6-SECT-5.3">Delay Functions</a>"). The first <tt class="calibre25">outb_ p( )</tt> invocation is a command to the PIT to issue interrupts at a new rate. The next two <tt class="calibre25">outb_ p( )</tt> and <tt class="calibre25">outb( )</tt> invocations supply the new interrupt rate to the device. The 16-bit <tt class="calibre25">LATCH</tt> constant is sent to the 8-bit <tt class="calibre25">0x40</tt> I/O port of the device as two consecutive bytes. As a result, the PIT issues timer interrupts at a (roughly) 1000-Hz frequency (that is, once every 1 ms).</p>
<a name="understandlk-CHP-6-SECT-1.4"></a>
<h4 class="docSection2Title">6.1.4. CPU Local Timer</h4><a name="IDX-CHP-6-1648"></a>
<a name="IDX-CHP-6-1649"></a>
<a name="IDX-CHP-6-1650"></a>
<a name="IDX-CHP-6-1651"></a>
<a name="IDX-CHP-6-1652"></a>
<p class="docText1">The local APIC present in recent 80 x 86 microprocessors (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-2.html#understandlk-CHP-4-SECT-2">Interrupts and Exceptions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>) provides yet another time-measuring device: the <span class="docEmphasis">CPU local timer</span><a name="IDX-CHP-6-1653"></a>
<a name="IDX-CHP-6-1654"></a> 
.</p>
<p class="docText1">The CPU local timer is a device similar to the Programmable Interval Timer just described that can issue one-shot or periodic interrupts. There are, however, a few differences:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The APIC's timer counter is 32 bits long, while the PIT's timer counter is 16 bits long; therefore, the local timer can be programmed to issue interrupts at very low frequencies (the counter stores the number of ticks that must elapse before the interrupt is issued).</p></li><li class="calibre12"><p class="docText1">The local APIC timer sends an interrupt only to its processor, while the PIT raises a global interrupt, which may be handled by any CPU in the system.</p></li><li class="calibre12"><p class="docText1">The APIC's timer is based on the bus clock signal (or the APIC bus signal, in older machines). It can be programmed in such a way to decrease the timer counter every 1, 2, 4, 8, 16, 32, 64, or 128 bus clock signals. Conversely, the PIT, which makes use of its own clock signals, can be programmed in a more flexible way.</p></li></ul>
<a name="understandlk-CHP-6-SECT-1.5"></a>
<h4 class="docSection2Title">6.1.5. High Precision Event Timer (HPET)</h4><a name="IDX-CHP-6-1656"></a>
<a name="IDX-CHP-6-1655"></a>
<p class="docText1">The <span class="docEmphasis">High Precision Event Timer</span> (<span class="docEmphasis">HPET</span>) is a new timer chip developed jointly by Intel and Microsoft. Although HPETs are not yet very common in end-user machines, Linux 2.6 already supports them, so we'll spend a few words describing their characteristics.</p>
<p class="docText1">The HPET provides a number of hardware timers that can be exploited by the kernel. Basically, the chip includes up to eight 32-bit or 64-bit independent <span class="docEmphasis">counters</span><a name="IDX-CHP-6-1657"></a> 
. Each counter is driven by its own clock signal, whose frequency must be at least 10 MHz; therefore, the counter is increased at least once in 100 nanoseconds. Any counter is associated with at most 32 <span class="docEmphasis">timers</span>, each of which is composed by a <span class="docEmphasis">comparator</span> and a <span class="docEmphasis">match register</span>. The comparator is a circuit that checks the value in the counter against the value in the match register, and raises a hardware interrupt if a match is found. Some of the timers can be enabled to generate a periodic interrupt.</p>
<p class="docText1">The HPET chip can be programmed through registers mapped into memory space (much like the I/O APIC). The BIOS establishes the mapping during the bootstrapping phase and reports to the operating system kernel its initial memory address. The HPET registers allow the kernel to read and write the values of the counters and of the match registers<a name="IDX-CHP-6-1658"></a> 
, to program one-shot interrupts, and to enable or disable periodic interrupts on the timers that support them.</p>
<p class="docText1">The next generation of motherboards will likely sport both the HPET and the 8254 PIT; in some future time, however, the HPET is expected to completely replace the PIT.</p>
<a name="understandlk-CHP-6-SECT-1.6"></a>
<h4 class="docSection2Title">6.1.6. ACPI Power Management Timer</h4><a name="IDX-CHP-6-1659"></a>
<p class="docText1">The <span class="docEmphasis">ACPI Power Management Timer</span> (or <span class="docEmphasis">ACPI PMT</span>) is yet another clock device included in almost all ACPI-based motherboards. Its clock signal has a fixed frequency of roughly 3.58 MHz. The device is actually a simple counter increased at each clock tick; to read the current value of the counter, the kernel accesses an I/O port whose address is determined by the BIOS during the initialization phase (see Appendix A).</p>
<p class="docText1">The ACPI Power Management Timer is preferable to the TSC if the operating system or the BIOS may dynamically lower the frequency or voltage of the CPU to save battery power. When this happens, the frequency of the TSC changesthus causing time warps and others unpleasant effectswhile the frequency of the ACPI PMT does not. On the other hand, the high-frequency of the TSC counter is quite handy for measuring very small time intervals.</p>
<p class="docText1">However, if an HPET device is present, it should always be preferred to the other circuits because of its richer architecture. <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-2.html#understandlk-CHP-6-TABLE-2">Table 6-2</a> later in this chapter illustrates how Linux takes advantage of the available timing circuits.</p>
<p class="docText1">Now that we understand what the hardware timers are, we may discuss how the Linux kernel exploits them to conduct all activities of the system.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

