---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-13-SECT-2.html
next: understandlk-CHP-13-SECT-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-13-SECT-3"></a>
<h3 class="docSection1Title" id="534871-948">13.3. Device Files</h3><a name="IDX-CHP-13-3477"></a>
<a name="IDX-CHP-13-3478"></a>
<a name="IDX-CHP-13-3479"></a>
<a name="IDX-CHP-13-3480"></a>
<p class="docText1">As mentioned in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-1.html#understandlk-CHP-1">Chapter 1</a>, Unix-like operating systems are based on the notion of a file, which is just an information container structured as a sequence of bytes. According to this approach, I/O devices are treated as special files called <span class="docEmphasis">device files</span><a name="IDX-CHP-13-3481"></a> 
; thus, the same system calls used to interact with regular files on disk can be used to directly interact with I/O devices. For example, the same <tt class="calibre25">write( )</tt><a name="IDX-CHP-13-3482"></a> 
 system call may be used to write data into a regular file or to send it to a printer by writing to the <i class="docEmphasis">/dev/lp0</i> device file.</p>
<p class="docText1">According to the characteristics of the underlying device drivers, device files can be of two types: <span class="docEmphasis">block</span> or <span class="docEmphasis">character</span>. The difference between the two classes of hardware devices is not so clear-cut. At least we can assume the following:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The data of a block device can be addressed randomly, and the time needed to transfer a data block is small and roughly the same, at least from the point of view of the human user. Typical examples of block devices<a name="IDX-CHP-13-3483"></a> 
 are hard disks, floppy disks<a name="IDX-CHP-13-3484"></a> 
, CD-ROM drives, and DVD players.</p></li><li class="calibre12"><p class="docText1">The data of a character device either cannot be addressed randomly (consider, for instance, a sound card), or they can be addressed randomly, but the time required to access a random datum largely depends on its position inside the device (consider, for instance, a magnetic tape driver).</p></li></ul>
<p class="docText1">Network cards are a notable exception to this schema, because they are hardware devices that are not directly associated with device files.</p>
<p class="docText1">Device files have been in use since the early versions of the Unix operating system. A device file is usually a real file stored in a filesystem. Its inode, however, doesn't need to include pointers to blocks of data on the disk (the file's data) because there are none. Instead, the inode must include an identifier of the hardware device corresponding to the character or block device file.</p>
<p class="docText1">Traditionally, this identifier consists of the type of device file (character or block) and a pair of numbers. The first number, called the <span class="docEmphasis">major number</span>, identifies the device type. Traditionally, all device files that have the same major number and the same type share the same set of file operations, because they are handled by the same device driver. The second number, called the <span class="docEmphasis">minor number</span>, identifies a specific device among a group of devices that share the same major number. For instance, a group of disks managed by the same disk controller have the same major number and different minor numbers<a name="IDX-CHP-13-3485"></a> 
.</p>
<p class="docText1">The <tt class="calibre25">mknod( )</tt><a name="IDX-CHP-13-3486"></a> 
 system call is used to create device files. It receives the name of the device file, its type, and the major and minor numbers as its parameters. Device files are usually included in the <i class="docEmphasis">/dev</i> directory. <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-TABLE-7">Table 13-7</a> illustrates the attributes of some device files. Notice that character and block devices have independent numbering, so block device (3,0) is different from character device (3,0).</p>
<a name="understandlk-CHP-13-TABLE-7"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 13-7. Examples of device files</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Major</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Minor</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/fd0</i></p></td><td class="docTableCell"><p class="docText2">block</p></td><td class="docTableCell"><p class="docText2">2</p></td><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">Floppy disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/hda</i></p></td><td class="docTableCell"><p class="docText2">block</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">First IDE disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/hda2</i></p></td><td class="docTableCell"><p class="docText2">block</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">2</p></td><td class="docTableCell"><p class="docText2">Second primary partition of first IDE disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/hdb</i></p></td><td class="docTableCell"><p class="docText2">block</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">64</p></td><td class="docTableCell"><p class="docText2">Second IDE disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/hdb3</i></p></td><td class="docTableCell"><p class="docText2">block</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">67</p></td><td class="docTableCell"><p class="docText2">Third primary partition of second IDE disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/ttyp0</i></p></td><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">0</p></td><td class="docTableCell"><p class="docText2">Terminal</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/console</i></p></td><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">5</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">Console</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/lp1</i></p></td><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">6</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">Parallel printer</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/ttyS0</i></p></td><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">4</p></td><td class="docTableCell"><p class="docText2">64</p></td><td class="docTableCell"><p class="docText2">First serial port</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/rtc</i></p></td><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">10</p></td><td class="docTableCell"><p class="docText2">135</p></td><td class="docTableCell"><p class="docText2">Real-time clock</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><i class="docEmphasis">/dev/null</i></p></td><td class="docTableCell"><p class="docText2">char</p></td><td class="docTableCell"><p class="docText2">1</p></td><td class="docTableCell"><p class="docText2">3</p></td><td class="docTableCell"><p class="docText2">Null device (black hole)</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Usually, a device file is associated with a hardware device (such as a hard diskfor instance, <i class="docEmphasis">/dev/hda</i>) or with some physical or logical portion of a hardware device (such as a disk partitionfor instance, <i class="docEmphasis">/dev/hda2</i>). In some cases, however, a device file is not associated with any real hardware device, but represents a fictitious logical device. For instance, <i class="docEmphasis">/dev/null</i> is a device file corresponding to a "black hole;" all data written into it is simply discarded, and the file always appears empty.</p>
<p class="docText1">As far as the kernel is concerned, the name of the device file is irrelevant. If you create a device file named <i class="docEmphasis">/tmp/disk</i> of type "block" with the major number 3 and minor number 0, it would be equivalent to the <i class="docEmphasis">/dev/hda</i> device file shown in the table. On the other hand, device filenames may be significant for some application programs. For example, a communication program might assume that the first serial port is associated with the <i class="docEmphasis">/dev/ttyS0</i> device file. But most application programs can be configured to interact with arbitrarily named device files.</p>
<a name="understandlk-CHP-13-SECT-3.1"></a>
<h4 class="docSection2Title">13.3.1. User Mode Handling of Device Files</h4><a name="IDX-CHP-13-3488"></a>
<p class="docText1">In traditional Unix systems (and in earlier versions of Linux), the major and minor numbers of the device files are 8 bits long. Thus, there could be at most 65,536 block device files and 65,536 character device files. You might expect they will suffice, but unfortunately they don't.</p>
<p class="docText1">The real problem is that device files are traditionally allocated once and forever in the <i class="docEmphasis">/dev</i> directory; therefore, each logical device in the system should have an associated device file with a well-defined device number. The official registry of allocated device numbers and <i class="docEmphasis">/dev</i> directory nodes is stored in the <i class="docEmphasis">Documentation/devices.txt</i> file; the macros corresponding to the major numbers of the devices may also be found in the <i class="docEmphasis">include/linux/major.h</i> file.</p>
<p class="docText1">Unfortunately, the number of different hardware devices is so large nowadays that almost all device numbers have already been allocated. The official registry of device numbers works well for the average Linux system; however, it may not be well suited for large-scale systems. Furthermore, high-end systems may use hundreds or thousands of disks of the same type, and an 8-bit minor number is not sufficient. For instance, the registry reserves device numbers for 16 SCSI disks having 15 partitions each; if a high-end system has more than 16 SCSI disks, the standard assignment of major and minor numbers has to be changeda non trivial task that requires modifying the kernel source code and makes the system hard to maintain.</p>
<p class="docText1">In order to solve this kind of problem, the size of the device numbers has been increased in Linux 2.6: the major number is now encoded in 12 bits, while the minor number is encoded in 20 bits. Both numbers are usually kept in a single 32-bit variable of type <tt class="calibre25">dev_t</tt>; the <tt class="calibre25">MAJOR</tt> and <tt class="calibre25">MINOR</tt> macros extract the major and minor numbers, respectively, from a <tt class="calibre25">dev_t</tt> value, while the <tt class="calibre25">MKDEV</tt> macro encodes the two device numbers in a <tt class="calibre25">dev_t</tt> value. For backward compatibility, the kernel handles properly old device files encoded with 16-bit device numbers.</p>
<p class="docText1">The additional available device numbers are not being statically allocated in the official registry, because they should be used only when dealing with unusual demands for device numbers. Actually, today's preferred way to deal with device files is highly dynamic, both in the device number assignment and in the device file creation.</p>
<a name="understandlk-CHP-13-SECT-3.1.1"></a>
<h5 class="docSection3Title">13.3.1.1. Dynamic device number assignment</h5><a name="IDX-CHP-13-3489"></a>
<a name="IDX-CHP-13-3490"></a>
<a name="IDX-CHP-13-3491"></a>
<a name="IDX-CHP-13-3492"></a>
<p class="docText1">Each device driver specifies in the registration phase the range of device numbers that it is going to handle (see the later section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-4.html#understandlk-CHP-13-SECT-4.1">Device Driver Registration</a>"). The driver can, however, require the allocation of an interval of device numbers without specifying the exact values: in this case, the kernel allocates a suitable range of numbers and assigns them to the driver.</p>
<p class="docText1">Therefore, device drivers of new hardware devices no longer require an assignment in the official registry of device numbers; they can simply use whatever numbers are currently available in the system.</p>
<p class="docText1">In this case, however, the device file cannot be created once and forever; it must be created right after the device driver initialization with the proper major and minor numbers. Thus, there must be a standard way to export the device numbers used by each driver to the User Mode applications. As we have seen in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.3">Components of the Device Driver Model</a>," the device driver model provides an elegant solution: the major and minor numbers are stored in the <i class="docEmphasis">dev</i> attributes contained in the subdirectories of <i class="docEmphasis">/sys/class</i>.</p>
<a name="understandlk-CHP-13-SECT-3.1.2"></a>
<h5 class="docSection3Title">13.3.1.2. Dynamic device file creation</h5>
<p class="docText1">The Linux kernel can create the device files dynamically: there is no need to fill the <i class="docEmphasis">/dev</i> directory with the device files of every conceivable hardware device, because the device files can be created "on demand." Thanks to the device driver model, the kernel 2.6 offers a very simple way to do so. A set of User Mode programs, collectively known as the <span class="docEmphasis">udev</span> toolset, must be installed in the system. At the system startup the <i class="docEmphasis">/dev</i> directory is emptied, then a <span class="docEmphasis">udev</span> program scans the subdirectories of <i class="docEmphasis">/sys/class</i> looking for the <i class="docEmphasis">dev</i> files. For each such file, which represents a combination of major and minor number for a logical device supported by the kernel, the program creates a corresponding device file in <i class="docEmphasis">/dev</i>. It also assigns device filenames and creates symbolic links according to a configuration file, in such a way to resemble the traditional naming scheme for Unix device files. Eventually, <i class="docEmphasis">/dev</i> is filled with the device files of all devices supported by the kernel on this system, and nothing else.</p>
<p class="docText1">Often a device file is created after the system has been initialized. This happens either when a module containing a device driver for a still unsupported device is loaded, or when a hot-pluggable devicesuch as a USB peripheralis plugged in the system. The <span class="docEmphasis">udev</span> toolset can automatically create the corresponding device file, because the device driver model supports <span class="docEmphasis">device hotplugging</span><a name="IDX-CHP-13-3493"></a> 
. Whenever a new device is discovered, the kernel spawns a new process that executes the User Mode <i class="docEmphasis">/sbin/hotplug</i> shell script,<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-FN3">[*]</a></sup> passing to it any useful information on the discovered device as environment variables. The User Mode scripts usually reads a configuration file and takes care of any operation required to complete the initialization of the new device. If <span class="docEmphasis">udev</span> is installed, the script also creates the proper device file in the <i class="docEmphasis">/dev</i> directory.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-13-FN3">[*]</a></sup> The pathname of the User Mode program invoked on hot-plugging events can be changed by writing into the <span class="docEmphasis">/proc/sys/kernel/hotplug</span> file.</p></blockquote>
<a name="understandlk-CHP-13-SECT-3.2"></a>
<h4 class="docSection2Title">13.3.2. VFS Handling of Device Files</h4><a name="IDX-CHP-13-3494"></a>
<a name="IDX-CHP-13-3495"></a>
<a name="IDX-CHP-13-3496"></a>
<p class="docText1">Device files live in the system directory tree but are intrinsically different from regular files and directories. When a process accesses a regular file, it is accessing some data blocks in a disk partition through a filesystem; when a process accesses a device file, it is just driving a hardware device. For instance, a process might access a device file to read the room temperature from a digital thermometer connected to the computer. It is the VFS's responsibility to hide the differences between device files and regular files from application programs.</p>
<p class="docText1">To do this, the VFS changes the default file operations of a device file when it is opened; as a result, each system call on the device file is translated to an invocation of a device-related function instead of the corresponding function of the hosting filesystem. The device-related function acts on the hardware device to perform the operation requested by the process.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-FN4">[<img src="u2020.jpg" border="0" class="calibre10"/>]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-13-FN4">[<img src="u2020.jpg" border="0" class="calibre10"/>]</a></sup> Notice that, thanks to the name-resolving mechanism explained in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-5.html#understandlk-CHP-12-SECT-5">Pathname Lookup</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>, symbolic links to device files work just like device files.</p></blockquote>
<p class="docText1">Let's suppose that a process executes an <tt class="calibre25">open( )</tt><a name="IDX-CHP-13-3497"></a> 
 system call on a device file (either of type block or character). The operations performed by the system call have already been described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-6.html#understandlk-CHP-12-SECT-6.1">The open( ) System Call</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>. Essentially, the corresponding service routine resolves the pathname to the device file and sets up the corresponding inode object, dentry object, and file object.</p>
<p class="docText1">The inode object is initialized by reading the corresponding inode on disk through a suitable function of the filesystem (usually <tt class="calibre25">ext2_read_inode( )</tt> or <tt class="calibre25">ext3_read_inode( )</tt>; see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-18.html#understandlk-CHP-18">Chapter 18</a>). When this function determines that the disk inode is relative to a device file, it invokes <tt class="calibre25">init_special_inode( )</tt>, which initializes the <tt class="calibre25">i_rdev</tt> field of the inode object to the major and minor numbers of the device file, and sets the <tt class="calibre25">i_fop</tt> field of the inode object to the address of either the <tt class="calibre25">def_blk_fops</tt> or the <tt class="calibre25">def_chr_fops</tt> file operation table, according to the type of device file. The service routine of the <tt class="calibre25">open( )</tt> system call also invokes the <tt class="calibre25">dentry_open( )</tt> function, which allocates a new file object and sets its <tt class="calibre25">f_op</tt> field to the address stored in <tt class="calibre25">i_fop</tt>that is, to the address of <tt class="calibre25">def_blk_fops</tt> or <tt class="calibre25">def_chr_fops</tt> once again. Thanks to these two tables, every system call issued on a device file will activate a device driver's function rather than a function of the underlying filesystem.</p>

<br class="calibre7"/>

</div>

{% endraw %}

