---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-3.html
next: understandlk-CHP-3-SECT-2.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-3-SECT-1"></a>
<h3 class="docSection1Title" id="534869-967">3.1. Processes, Lightweight Processes, and Threads</h3><a name="IDX-CHP-3-0635"></a>
<a name="IDX-CHP-3-0636"></a>
<a name="IDX-CHP-3-0637"></a>
<a name="IDX-CHP-3-0638"></a>
<a name="IDX-CHP-3-0639"></a>
<p class="docText1">The term "process" is often used with several different meanings. In this book, we stick to the usual OS textbook definition: a <span class="docEmphasis">process</span> is an instance of a program in execution. You might think of it as the collection of data structures that fully describes how far the execution of the program has progressed.</p>
<p class="docText1">Processes are like human beings: they are generated, they have a more or less significant life, they optionally generate one or more child processes, and eventually they die. A small difference is that sex is not really common among processes  each process has just one parent.</p>
<p class="docText1">From the kernel's point of view, the purpose of a process is to act as an entity to which system resources (CPU time, memory, etc.) are allocated.</p>
<p class="docText1">When a process is created, it is almost identical to its parent. It receives a (logical) copy of the parent's address space and executes the same code as the parent, beginning at the next instruction following the process creation system call. Although the parent and child may share the pages containing the program code (text), they have separate copies of the data (stack and heap), so that changes by the child to a memory location are invisible to the parent (and vice versa).</p>
<p class="docText1">While earlier Unix kernels employed this simple model, modern Unix systems do not. They support <span class="docEmphasis">multithreaded applications</span><a name="IDX-CHP-3-0640"></a> 
  user programs having many relatively independent execution flows sharing a large portion of the application data structures. In such systems, a process is composed of several <span class="docEmphasis">user threads</span><a name="IDX-CHP-3-0641"></a> 
 (or simply <span class="docEmphasis">threads</span>), each of which represents an execution flow of the process. Nowadays, most multithreaded applications are written using standard sets of library functions called <span class="docEmphasis">pthread (POSIX thread) libraries</span><a name="IDX-CHP-3-0642"></a> 
.</p>
<p class="docText1">Older versions of the Linux kernel offered no support for multithreaded applications. From the kernel point of view, a multithreaded application was just a normal process. The multiple execution flows of a multithreaded application were created, handled, and scheduled entirely in User Mode, usually by means of a POSIX-compliant <span class="docEmphasis">pthread</span> library.</p>
<p class="docText1">However, such an implementation of multithreaded applications is not very satisfactory. For instance, suppose a chess program uses two threads: one of them controls the graphical chessboard, waiting for the moves of the human player and showing the moves of the computer, while the other thread ponders the next move of the game. While the first thread waits for the human move, the second thread should run continuously, thus exploiting the thinking time of the human player. However, if the chess program is just a single process, the first thread cannot simply issue a blocking system call waiting for a user action; otherwise, the second thread is blocked as well. Instead, the first thread must employ sophisticated nonblocking techniques to ensure that the process remains runnable.</p>
<p class="docText1">Linux uses <span class="docEmphasis">lightweight processes</span><a name="IDX-CHP-3-0643"></a>
<a name="IDX-CHP-3-0644"></a> 
 to offer better support for multithreaded applications. Basically, two lightweight processes may share some resources, like the address space, the open files, and so on. Whenever one of them modifies a shared resource, the other immediately sees the change. Of course, the two processes must synchronize themselves when accessing the shared resource.</p>
<p class="docText1">A straightforward way to implement multithreaded applications is to associate a lightweight process with each thread. In this way, the threads can access the same set of application data structures by simply sharing the same memory address space, the same set of open files, and so on; at the same time, each thread can be scheduled independently by the kernel so that one may sleep while another remains runnable. Examples of POSIX-compliant <span class="docEmphasis">pthread</span> libraries that use Linux's lightweight processes are <span class="docEmphasis">LinuxThreads</span>, <span class="docEmphasis">Native POSIX Thread Library</span> (<span class="docEmphasis">NPTL</span>), and IBM's <span class="docEmphasis">Next Generation Posix Threading Package</span> (<span class="docEmphasis">NGPT</span>).</p>
<p class="docText1">POSIX-compliant multithreaded applications are best handled by kernels that support "thread groups<a name="IDX-CHP-3-0645"></a> 
." In Linux a <span class="docEmphasis">thread group</span> is basically a set of lightweight processes that implement a multithreaded application and act as a whole with regards to some system calls such as <tt class="calibre25">getpid( )</tt><a name="IDX-CHP-3-0646"></a> 
, <tt class="calibre25">kill( )</tt><a name="IDX-CHP-3-0647"></a> 
, and <tt class="calibre25">_exit( )</tt><a name="IDX-CHP-3-0648"></a> 
. We are going to describe them at length later in this chapter.</p>

<br class="calibre7"/>

</div>

{% endraw %}

