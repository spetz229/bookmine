---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-9-SECT-4.html
next: understandlk-CHP-9-SECT-6.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-9-SECT-5"></a>
<h3 class="docSection1Title">9.5. Creating and Deleting a Process Address Space</h3><a name="IDX-CHP-9-2466"></a>
<a name="IDX-CHP-9-2467"></a>
<p class="docText1">Of the six typical cases mentioned earlier in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-1.html#understandlk-CHP-9-SECT-1">The Process's Address Space</a>," in which a process gets new memory regions, the first oneissuing a <tt class="calibre25">fork( )</tt> system callrequires the creation of a whole new address space for the child process. Conversely, when a process terminates, the kernel destroys its address space. In this section, we discuss how these two activities are performed by Linux.</p>
<a name="understandlk-CHP-9-SECT-5.1"></a>
<h4 class="docSection2Title">9.5.1. Creating a Process Address Space</h4><a name="IDX-CHP-9-2468"></a>
<a name="IDX-CHP-9-2469"></a>
<a name="IDX-CHP-9-2470"></a>
<a name="IDX-CHP-9-2471"></a>
<p class="docText1">In the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.1">The clone( ), fork( ), and vfork( ) System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>, we mentioned that the kernel invokes the <tt class="calibre25">copy_mm( )</tt> function while creating<a name="IDX-CHP-9-2472"></a>
<a name="IDX-CHP-9-2473"></a> 
 a new process. This function creates the process address space by setting up all Page Tables and memory descriptors of the new process.</p>
<p class="docText1">Each process usually has its own address space, but lightweight processes can be created by calling <tt class="calibre25">clone( )</tt> with the <tt class="calibre25">CLONE_VM</tt> flag set. These processes share the same address space; that is, they are allowed to address the same set of pages.</p>
<p class="docText1">Following the COW approach described earlier, traditional processes inherit the address space of their parent: pages stay shared as long as they are only read. When one of the processes attempts to write one of them, however, the page is duplicated; after some time, a forked process usually gets its own address space that is different from that of the parent process. Lightweight processes, on the other hand, use the address space of their parent process. Linux implements them simply by not duplicating address space. Lightweight processes can be created considerably faster than normal processes, and the sharing of pages can also be considered a benefit as long as the parent and children coordinate their accesses carefully.</p>
<p class="docText1">If the new process has been created by means of the <tt class="calibre25">clone( )</tt> system call and if the <tt class="calibre25">CLONE_VM</tt> flag of the <tt class="calibre25">flag</tt> parameter is set, <tt class="calibre25">copy_mm( )</tt> gives the clone (<tt class="calibre25">tsk</tt>) the address space of its parent (<tt class="calibre25">current</tt>):</p>
<pre class="calibre27">
    if (clone_flags &amp; CLONE_VM) {
        atomic_inc(&amp;current-&gt;mm-&gt;mm_users);
        spin_unlock_wait(&amp;current-&gt;mm-&gt;page_table_lock);
        tsk-&gt;mm = current-&gt;mm;
        tsk-&gt;active_mm = current-&gt;mm;
        return 0;
    }</pre><br class="calibre7"/>
<p class="docText1">Invoking the <tt class="calibre25">spin_unlock_wait( )</tt> function ensures that, if the page table spin lock of the process is held by some other CPU, the page fault handler does not terminate until that lock is released. In fact, beside protecting the page tables, this spin lock must forbid the creation of new lightweight processes sharing the <tt class="calibre25">current-&gt;mm</tt> descriptor.</p>
<p class="docText1">If the <tt class="calibre25">CLONE_VM</tt> flag is not set, <tt class="calibre25">copy_mm( )</tt> must create a new address space (even though no memory is allocated within that address space until the process requests an address). The function allocates a new memory descriptor, stores its address in the <tt class="calibre25">mm</tt> field of the new process descriptor <tt class="calibre25">tsk</tt>, and copies the contents of <tt class="calibre25">current-&gt;mm</tt> into <tt class="calibre25">tsk-&gt;mm</tt>. It then changes a few fields of the new descriptor:</p>
<pre class="calibre27">
    tsk-&gt;mm = kmem_cache_alloc(mm_cachep, SLAB_KERNEL);
    memcpy(tsk-&gt;mm, current-&gt;mm, sizeof(*tsk-&gt;mm));
    atomic_set(&amp;tsk-&gt;mm-&gt;mm_users, 1);
    atomic_set(&amp;tsk-&gt;mm-&gt;mm_count, 1);
    init_rwsem(&amp;tsk-&gt;mm-&gt;mmap_sem);
    tsk-&gt;mm-&gt;core_waiters = 0;
    tsk-&gt;mm-&gt;page_table_lock = SPIN_LOCK_UNLOCKED;
    tsk-&gt;mm-&gt;ioctx_list_lock = RW_LOCK_UNLOCKED;
    tsk-&gt;mm-&gt;ioctx_list = NULL;
    tsk-&gt;mm-&gt;default_kioctx = INIT_KIOCTX(tsk-&gt;mm-&gt;default_kioctx,
                                          *tsk-&gt;mm);
    tsk-&gt;mm-&gt;free_area_cache = (TASK_SIZE/3+0xfff)&amp;0xfffff000;
    tsk-&gt;mm-&gt;pgd = pgd_alloc(tsk-&gt;mm);
    tsk-&gt;mm-&gt;def_flags = 0;</pre><br class="calibre7"/>
<p class="docText1">Remember that the <tt class="calibre25">pgd_alloc( )</tt> macro allocates a Page Global Directory for the new process.</p>
<p class="docText1">The architecture-dependent <tt class="calibre25">init_new_context( )</tt> function is then invoked: when dealing with 80 x 86 processors, this function checks whether the current process owns a customized Local Descriptor Table; if so, <tt class="calibre25">init_new_context( )</tt> makes a copy of the Local Descriptor Table of <tt class="calibre25">current</tt> and adds it to the address space of <tt class="calibre25">tsk</tt>.</p>
<p class="docText1">Finally, the <tt class="calibre25">dup_mmap( )</tt> function is invoked to duplicate both the memory regions and the Page Tables of the parent process. This function inserts the new memory descriptor <tt class="calibre25">tsk-&gt;mm</tt> in the global list of memory descriptors. Then it scans the list of regions owned by the parent process, starting from the one pointed to by <tt class="calibre25">current-&gt;mm-&gt;mmap</tt>. It duplicates each <tt class="calibre25">vm_area_struct</tt> memory region descriptor encountered and inserts the copy in the list of regions and in the red-black tree owned by the child process.</p>
<p class="docText1">Right after inserting a new memory region descriptor, <tt class="calibre25">dup_mmap( )</tt> invokes <tt class="calibre25">copy_page_range( )</tt> to create, if necessary, the Page Tables needed to map the group of pages included in the memory region and to initialize the new Page Table entries. In particular, each page frame corresponding to a private, writable page (<tt class="calibre25">VM_SHARED</tt> flag off and <tt class="calibre25">VM_MAYWRITE</tt> flag on) is marked as read-only for both the parent and the child, so that it will be handled with the Copy On Write mechanism.</p>
<a name="understandlk-CHP-9-SECT-5.2"></a>
<h4 class="docSection2Title">9.5.2. Deleting a Process Address Space</h4><a name="IDX-CHP-9-2474"></a>
<a name="IDX-CHP-9-2475"></a>
<a name="IDX-CHP-9-2476"></a>
<a name="IDX-CHP-9-2477"></a>
<a name="IDX-CHP-9-2478"></a>
<a name="IDX-CHP-9-2479"></a>
<a name="IDX-CHP-9-2480"></a>
<p class="docText1">When a process terminates, the kernel invokes the <tt class="calibre25">exit_mm( )</tt> function to release the address space owned by that process:</p>
<pre class="calibre27">
    mm_release(tsk, tsk-&gt;mm);
    if (!(mm = tsk-&gt;mm)) /* kernel thread ? */
        return;
    down_read(&amp;mm-&gt;mmap_sem);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">mm_release( )</tt> function essentially wakes up all processes sleeping in the <tt class="calibre25">tsk-&gt;vfork_done</tt> completion (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.10">Completions</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>). Typically, the corresponding wait queue is nonempty only if the exiting process was created by means of the <tt class="calibre25">vfork( )</tt><a name="IDX-CHP-9-2481"></a> 
 system call (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.1">The clone( ), fork( ), and vfork( ) System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>).</p>
<p class="docText1">If the process being terminated is not a kernel thread, the <tt class="calibre25">exit_mm( )</tt> function must release the memory descriptor and all related data structures. First of all, it checks whether the <tt class="calibre25">mm-&gt;core_waiters</tt> flag is set: if it does, then the process is dumping the contents of the memory to a core file. To avoid corruption in the core file, the function makes use of the <tt class="calibre25">mm-&gt;core_done</tt> and <tt class="calibre25">mm-&gt;core_startup_done</tt> completions to serialize the execution of the lightweight processes sharing the same memory descriptor <tt class="calibre25">mm</tt>.</p>
<p class="docText1">Next, the function increases the memory descriptor's main usage counter, resets the <tt class="calibre25">mm</tt> field of the process descriptor, and puts the processor in lazy TLB mode (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-5.html#understandlk-CHP-2-SECT-5.7">Handling the Hardware Cache and the TLB</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>):</p>
<pre class="calibre27">
    atomic_inc(&amp;mm-&gt;mm_count);
    spin_lock(tsk-&gt;alloc_lock);
    tsk-&gt;mm = NULL;
    up_read(&amp;mm-&gt;map_sem);
    enter_lazy_tlb(mm, current);
    spin_unlock(tsk-&gt;alloc_lock);
    mmput(mm);</pre><br class="calibre7"/>
<p class="docText1">Finally, the <tt class="calibre25">mmput( )</tt> function is invoked to release the Local Descriptor Table, the memory region descriptors, and the Page Tables. The memory descriptor itself, however, is not released, because <tt class="calibre25">exit_mm( )</tt> has increased the main usage counter. The descriptor will be released by the <tt class="calibre25">finish_task_switch( )</tt> function when the process being terminated will be effectively evicted from the local CPU (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.4">The schedule( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>).</p>

<br class="calibre7"/>

</div>

{% endraw %}

