---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-3-SECT-4.html
next: understandlk-CHP-4.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-3-SECT-5"></a>
<h3 class="docSection1Title" id="534869-973">3.5. Destroying Processes</h3><a name="IDX-CHP-3-0967"></a>
<a name="IDX-CHP-3-0968"></a>
<a name="IDX-CHP-3-0969"></a>
<a name="IDX-CHP-3-0970"></a>
<p class="docText1">Most processes "die" in the sense that they terminate the execution of the code they were supposed to run. When this occurs, the kernel must be notified so that it can release the resources owned by the process; this includes memory, open files, and any other odds and ends that we will encounter in this book, such as semaphores.</p>
<p class="docText1">The usual way for a process to terminate is to invoke the <tt class="calibre25">exit( )</tt> library function, which releases the resources allocated by the C library, executes each function registered by the programmer, and ends up invoking a system call that evicts the process from the system. The <tt class="calibre25">exit( )</tt><a name="IDX-CHP-3-0971"></a> 
 library function may be inserted by the programmer explicitly. Additionally, the C compiler always inserts an <tt class="calibre25">exit( )</tt> function call right after the last statement of the <tt class="calibre25">main( )</tt> function.</p>
<p class="docText1">Alternatively, the kernel may force a whole thread group to die. This typically occurs when a process in the group has received a signal that it cannot handle or ignore (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>) or when an unrecoverable CPU exception has been raised in Kernel Mode while the kernel was running on behalf of the process (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p>
<a name="understandlk-CHP-3-SECT-5.1"></a>
<h4 class="docSection2Title">3.5.1. Process Termination</h4>
<p class="docText1">In Linux 2.6 there are two system calls that terminate a User Mode application:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The <tt class="calibre25">exit_group( )</tt><a name="IDX-CHP-3-0972"></a> 
 system call, which terminates a full thread group, that is, a whole multithreaded application. The main kernel function that implements this system call is called <tt class="calibre25">do_group_exit( )</tt>. This is the system call that should be invoked by the <tt class="calibre25">exit()</tt> C library function.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">_exit( )</tt><a name="IDX-CHP-3-0973"></a> 
 system call, which terminates a single process, regardless of any other process in the thread group of the victim. The main kernel function that implements this system call is called <tt class="calibre25">do_exit( )</tt>. This is the system call invoked, for instance, by the <tt class="calibre25">pthread_exit( )</tt><a name="IDX-CHP-3-0974"></a> 
 function of the LinuxThreads library.</p></li></ul>
<a name="understandlk-CHP-3-SECT-5.1.1"></a>
<h5 class="docSection3Title">3.5.1.1. The do_group_exit( ) function</h5><a name="IDX-CHP-3-0975"></a>
<a name="IDX-CHP-3-0976"></a>
<a name="IDX-CHP-3-0977"></a>
<a name="IDX-CHP-3-0978"></a>
<a name="IDX-CHP-3-0979"></a>
<a name="IDX-CHP-3-0980"></a>
<a name="IDX-CHP-3-0981"></a>
<a name="IDX-CHP-3-0982"></a>
<a name="IDX-CHP-3-0983"></a>
<p class="docText1">The <tt class="calibre25">do_group_exit( )</tt> function kills all processes belonging to the thread group of <tt class="calibre25">current</tt>. It receives as a parameter the process termination<a name="IDX-CHP-3-0984"></a> 
 code, which is either a value specified in the <tt class="calibre25">exit_group( )</tt> system call (normal termination) or an error code supplied by the kernel (abnormal termination). The function executes the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the <tt class="calibre25">SIGNAL_GROUP_EXIT</tt> flag of the exiting process is not zero, which means that the kernel already started an exit procedure for this thread group. In this case, it considers as exit code the value stored in <tt class="calibre25">current-&gt;signal-&gt;group_exit_code</tt>, and jumps to step 4.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, it sets the <tt class="calibre25">SIGNAL_GROUP_EXIT</tt> flag of the process and stores the termination code in the <tt class="calibre25">current-&gt;signal-&gt;group_exit_code</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">zap_other_threads( )</tt> function to kill the other processes in the thread group of <tt class="calibre25">current</tt>, if any. In order to do this, the function scans the per-PID list in the <tt class="calibre25">PIDTYPE_TGID</tt> hash table corresponding to <tt class="calibre25">current-&gt;tgid</tt>; for each process in the list different from <tt class="calibre25">current</tt>, it sends a <tt class="calibre25">SIGKILL</tt> signal to it (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>). As a result, all such processes will eventually execute the <tt class="calibre25">do_exit( )</tt> function, and thus they will be killed.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">do_exit( )</tt> function passing to it the process termination code. As we'll see below, <tt class="calibre25">do_exit( )</tt> kills the process and never returns.</p></div></li></ol></div>
<a name="understandlk-CHP-3-SECT-5.1.2"></a>
<h5 class="docSection3Title">3.5.1.2. The do_exit( ) function</h5><a name="IDX-CHP-3-0985"></a>
<a name="IDX-CHP-3-0986"></a>
<p class="docText1">All process terminations are handled by the <tt class="calibre25">do_exit( )</tt> function, which removes most references to the terminating process from kernel data structures. The <tt class="calibre25">do_exit( )</tt> function receives as a parameter the process termination code and essentially executes the following actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">PF_EXITING</tt> flag in the <tt class="calibre25">flag</tt> field of the process descriptor to indicate that the process is being eliminated.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Removes, if necessary, the process descriptor from a dynamic timer queue via the <tt class="calibre25">del_timer_sync( )</tt> function (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6.html#understandlk-CHP-6">Chapter 6</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Detaches from the process descriptor the data structures related to paging, semaphores, filesystem, open file descriptors, namespaces, and I/O Permission Bitmap, respectively, with the <tt class="calibre25">exit_mm( )</tt>, <tt class="calibre25">exit_sem( )</tt>, <tt class="calibre25">_ _exit_files( )</tt>, <tt class="calibre25">_ _exit_fs()</tt>, <tt class="calibre25">exit_namespace( )</tt>, and <tt class="calibre25">exit_thread( )</tt> functions. These functions also remove each of these data structures if no other processes are sharing them.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the kernel functions implementing the execution domain and the executable format (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>) of the process being killed are included in kernel modules, the function decreases their usage counters.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">exit_code</tt> field of the process descriptor to the process termination code. This value is either the <tt class="calibre25">_exit( )</tt> or <tt class="calibre25">exit_group( )</tt> system call parameter (normal termination), or an error code supplied by the kernel (abnormal termination).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">exit_notify( )</tt> function to perform the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Updates the parenthood relationships of both the parent process and the child processes. All child processes created by the terminating process become children of another process in the same thread group, if any is running, or otherwise of the <span class="docEmphasis">init</span> process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the <tt class="calibre25">exit_signal</tt> process descriptor field of the process being terminated is different from <tt class="calibre25">-</tt>1, and whether the process is the last member of its thread group (notice that these conditions always hold for any normal process; see step 16 in the description of <tt class="calibre25">copy_process( )</tt> in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-4.html#understandlk-CHP-3-SECT-4.1">The clone( ), fork( ), and vfork( ) System Calls</a>"). In this case, the function sends a signal (usually <tt class="calibre25">SIGCHLD</tt>) to the parent of the process being terminated to notify the parent about a child's death.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the <tt class="calibre25">exit_signal</tt> field is equal to <tt class="calibre25">-</tt>1 or the thread group includes other processes, the function sends a <tt class="calibre25">SIGCHLD</tt> signal to the parent only if the process is being traced (in this case the parent is the debugger, which is thus informed of the death of the lightweight process).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">exit_signal</tt> process descriptor field is equal to <tt class="calibre25">-</tt>1 and the process is not being traced, it sets the <tt class="calibre25">exit_state</tt> field of the process descriptor to <tt class="calibre25">EXIT_DEAD</tt>, and invokes <tt class="calibre25">release_task( )</tt> to reclaim the memory of the remaining process data structures and to decrease the usage counter of the process descriptor (see the following section). The usage counter becomes equal to 1 (see step 3f in the <tt class="calibre25">copy_process( )</tt> function), so that the process descriptor itself is not released right away.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the <tt class="calibre25">exit_signal</tt> process descriptor field is not equal to <tt class="calibre25">-</tt>1 or the process is being traced, it sets the <tt class="calibre25">exit_state</tt> field to <tt class="calibre25">EXIT_ZOMBIE</tt>. We'll see what happens to zombie processes in the following section.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">PF_DEAD</tt> flag in the <tt class="calibre25">flags</tt> field of the process descriptor (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.4">The schedule( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>).</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">schedule( )</tt> function (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>) to select a new process to run. Because a process in an <tt class="calibre25">EXIT_ZOMBIE</tt> state is ignored by the scheduler, the process stops executing right after the <tt class="calibre25">switch_to</tt> macro in <tt class="calibre25">schedule( )</tt> is invoked. As we'll see in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>, the scheduler will check the <tt class="calibre25">PF_DEAD</tt> flag and will decrease the usage counter in the descriptor of the zombie process being replaced to denote the fact that the process is no longer alive.</p></div></li></ol></div>
<a name="understandlk-CHP-3-SECT-5.2"></a>
<h4 class="docSection2Title">3.5.2. Process Removal</h4><a name="IDX-CHP-3-0987"></a>
<a name="IDX-CHP-3-0988"></a>
<a name="IDX-CHP-3-0989"></a>
<a name="IDX-CHP-3-0990"></a>
<a name="IDX-CHP-3-0991"></a>
<a name="IDX-CHP-3-0992"></a>
<a name="IDX-CHP-3-0993"></a>
<a name="IDX-CHP-3-0994"></a>
<a name="IDX-CHP-3-0995"></a>
<a name="IDX-CHP-3-0996"></a>
<a name="IDX-CHP-3-0997"></a>
<a name="IDX-CHP-3-0998"></a>
<a name="IDX-CHP-3-0999"></a>
<a name="IDX-CHP-3-1000"></a>
<a name="IDX-CHP-3-1001"></a>
<p class="docText1">The Unix operating system allows a process to query the kernel to obtain the PID of its parent process or the execution state of any of its children. A process may, for instance, create a child process to perform a specific task and then invoke some <tt class="calibre25">wait( )</tt>-like library function to check whether the child has terminated. If the child has terminated, its termination code will tell the parent process if the task has been carried out successfully.</p>
<p class="docText1">To comply with these design choices, Unix kernels are not allowed to discard data included in a process descriptor field right after the process terminates. They are allowed to do so only after the parent process has issued a <tt class="calibre25">wait( )</tt>-like system call that refers to the terminated process. This is why the <tt class="calibre25">EXIT_ZOMBIE</tt> state has been introduced: although the process is technically dead, its descriptor must be saved until the parent process is notified.</p>
<p class="docText1">What happens if parent processes terminate before their children? In such a case, the system could be flooded with zombie processes whose process descriptors would stay forever in RAM. As mentioned earlier, this problem is solved by forcing all orphan processes to become children of the <span class="docEmphasis">init</span> process. In this way, the <span class="docEmphasis">init</span> process will destroy the zombies while checking for the termination of one of its legitimate children through a <tt class="calibre25">wait( )</tt>-like system call.</p>
<p class="docText1">The <tt class="calibre25">release_task( )</tt> function detaches the last data structures from the descriptor of a zombie process; it is applied on a zombie process in two possible ways: by the <tt class="calibre25">do_exit( )</tt> function if the parent is not interested in receiving signals from the child, or by the <tt class="calibre25">wait4( )</tt><a name="IDX-CHP-3-1002"></a> 
 or <tt class="calibre25">waitpid( )</tt><a name="IDX-CHP-3-1003"></a> 
 system calls after a signal has been sent to the parent. In the latter case, the function also will reclaim the memory used by the process descriptor, while in the former case the memory reclaiming will be done by the scheduler (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>). This function executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Decreases the number of processes belonging to the user owner of the terminated process. This value is stored in the <tt class="calibre25">user_struct</tt> structure mentioned earlier in the chapter (see step 4 of <tt class="calibre25">copy_process( )</tt>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the process is being traced, the function removes it from the debugger's <tt class="calibre25">ptrace_children</tt> list and assigns the process back to its original parent.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">_ _exit_signal()</tt> to cancel any pending signal and to release the <tt class="calibre25">signal_struct</tt> descriptor of the process. If the descriptor is no longer used by other lightweight processes, the function also removes this data structure. Moreover, the function invokes <tt class="calibre25">exit_itimers( )</tt> to detach any POSIX interval timer from the process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">_ _exit_sighand()</tt> to get rid of the signal handlers.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">_ _unhash_process( )</tt>, which in turn:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Decreases by 1 the <tt class="calibre25">nr_threads</tt> variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">detach_pid( )</tt> twice to remove the process descriptor from the <tt class="calibre25">pidhash</tt> hash tables of type <tt class="calibre25">PIDTYPE_PID</tt> and <tt class="calibre25">PIDTYPE_TGID</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the process is a thread group leader, invokes again <tt class="calibre25">detach_pid( )</tt> twice to remove the process descriptor from the <tt class="calibre25">PIDTYPE_PGID</tt> and <tt class="calibre25">PIDTYPE_SID</tt> hash tables.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Uses the <tt class="calibre25">REMOVE_LINKS</tt> macro to unlink the process descriptor from the process list.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the process is not a thread group leader, the leader is a zombie, and the process is the last member of the thread group, the function sends a signal to the parent of the leader to notify it of the death of the process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">sched_exit( )</tt> function to adjust the timeslice of the parent process (this step logically complements step 17 in the description of <tt class="calibre25">copy_process( )</tt>)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">put_task_struct()</tt> to decrease the process descriptor's usage counter; if the counter becomes zero, the function drops any remaining reference to the process:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Decreases the usage counter (<tt class="calibre25">_ _count</tt> field) of the <tt class="calibre25">user_struct</tt> data structure of the user that owns the process (see step 5 of <tt class="calibre25">copy_process( )</tt>), and releases that data structure if the usage counter becomes zero.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the process descriptor and the memory area used to contain the <tt class="calibre25">tHRead_info</tt> descriptor and the Kernel Mode stack.</p></div></li></ol></div></div></li></ol></div>

<br class="calibre7"/>

</div>

{% endraw %}

