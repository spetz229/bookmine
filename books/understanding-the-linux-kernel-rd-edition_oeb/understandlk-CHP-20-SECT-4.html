---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-20-SECT-3.html
next: understandlk-APP-A.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-20-SECT-4"></a>
<h3 class="docSection1Title" id="534871-928">20.4. The exec Functions</h3><a name="IDX-CHP-20-4913"></a>
<a name="IDX-CHP-20-4914"></a>
<a name="IDX-CHP-20-4915"></a>
<a name="IDX-CHP-20-4916"></a>
<a name="IDX-CHP-20-4917"></a>
<a name="IDX-CHP-20-4918"></a>
<a name="IDX-CHP-20-4919"></a>
<a name="IDX-CHP-20-4920"></a>
<a name="IDX-CHP-20-4921"></a>
<a name="IDX-CHP-20-4922"></a>
<a name="IDX-CHP-20-4923"></a>
<a name="IDX-CHP-20-4924"></a>
<a name="IDX-CHP-20-4925"></a>
<a name="IDX-CHP-20-4926"></a>
<a name="IDX-CHP-20-4927"></a>
<a name="IDX-CHP-20-4928"></a>
<a name="IDX-CHP-20-4929"></a>
<a name="IDX-CHP-20-4930"></a>
<a name="IDX-CHP-20-4931"></a>
<a name="IDX-CHP-20-4932"></a>
<a name="IDX-CHP-20-4933"></a>
<a name="IDX-CHP-20-4934"></a>
<a name="IDX-CHP-20-4935"></a>
<a name="IDX-CHP-20-4936"></a>
<a name="IDX-CHP-20-4937"></a>
<a name="IDX-CHP-20-4938"></a>
<a name="IDX-CHP-20-4939"></a>
<a name="IDX-CHP-20-4940"></a>
<a name="IDX-CHP-20-4941"></a>
<a name="IDX-CHP-20-4942"></a>
<a name="IDX-CHP-20-4943"></a>
<a name="IDX-CHP-20-4944"></a>
<a name="IDX-CHP-20-4945"></a>
<a name="IDX-CHP-20-4946"></a>
<a name="IDX-CHP-20-4947"></a>
<a name="IDX-CHP-20-4948"></a>
<a name="IDX-CHP-20-4949"></a>
<p class="docText1">Unix systems provide a family of functions that replace the execution context of a process with a new context described by an executable file. The names of these functions start with the prefix <tt class="calibre25">exec</tt>, followed by one or two letters; therefore, a generic function in the family is usually referred to as an <tt class="calibre25">exec</tt> function.</p>
<p class="docText1">The <tt class="calibre25">exec</tt> functions are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-20-TABLE-7">Table 20-7</a>; they differ in how the parameters are interpreted.</p>
<a name="understandlk-CHP-20-TABLE-7"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 20-7. The exec functions</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Function name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">PATH search</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Command-line arguments</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Environment array</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">execl( )</tt></p></td><td class="docTableCell"><p class="docText2">No</p></td><td class="docTableCell"><p class="docText2">List</p></td><td class="docTableCell"><p class="docText2">No</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">execlp( )</tt></p></td><td class="docTableCell"><p class="docText2">Yes</p></td><td class="docTableCell"><p class="docText2">List</p></td><td class="docTableCell"><p class="docText2">No</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">execle( )</tt></p></td><td class="docTableCell"><p class="docText2">No</p></td><td class="docTableCell"><p class="docText2">List</p></td><td class="docTableCell"><p class="docText2">Yes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">execv( )</tt></p></td><td class="docTableCell"><p class="docText2">No</p></td><td class="docTableCell"><p class="docText2">Array</p></td><td class="docTableCell"><p class="docText2">No</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">execvp( )</tt></p></td><td class="docTableCell"><p class="docText2">Yes</p></td><td class="docTableCell"><p class="docText2">Array</p></td><td class="docTableCell"><p class="docText2">No</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">execve( )</tt></p></td><td class="docTableCell"><p class="docText2">No</p></td><td class="docTableCell"><p class="docText2">Array</p></td><td class="docTableCell"><p class="docText2">Yes</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The first parameter of each function denotes the pathname of the file to be executed. The pathname can be absolute or relative to the process's current directory. Moreover, if the name does not include any / characters, the <tt class="calibre25">execlp( )</tt> and <tt class="calibre25">execvp( )</tt> functions search for the executable file in all directories specified by the <tt class="calibre25">PATH</tt> environment variable.</p>
<p class="docText1">Besides the first parameter, the <tt class="calibre25">execl( )</tt>, <tt class="calibre25">execlp( )</tt>, and <tt class="calibre25">execle( )</tt> functions include a variable number of additional parameters. Each points to a string describing a command-line argument for the new program; as the "<tt class="calibre25">l</tt>" character in the function names suggests, the parameters are organized in a list terminated by a <tt class="calibre25">NULL</tt> value. Usually, the first command-line argument duplicates the executable filename. Conversely, the <tt class="calibre25">execv( )</tt>, <tt class="calibre25">execvp( )</tt>, and <tt class="calibre25">execve( )</tt><a name="IDX-CHP-20-4951"></a> 
 functions specify the command-line arguments with a single parameter; as the <tt class="calibre25">v</tt> character in the function names suggests, the parameter is the address of a vector of pointers to command-line argument strings. The last component of the array must be <tt class="calibre25">NULL</tt>.</p>
<p class="docText1">The <tt class="calibre25">execle( )</tt> and <tt class="calibre25">execve( )</tt> functions receive as their last parameter the address of an array of pointers to environment strings; as usual, the last component of the array must be <tt class="calibre25">NULL</tt>. The other functions may access the environment for the new program from the external <tt class="calibre25">environ</tt> global variable, which is defined in the C library.</p>
<p class="docText1">All <tt class="calibre25">exec</tt> functions, with the exception of <tt class="calibre25">execve( )</tt>, are wrapper routines<a name="IDX-CHP-20-4952"></a> 
 defined in the C library and use <tt class="calibre25">execve( )</tt>, which is the only system call offered by Linux to deal with program execution.</p>
<p class="docText1">The <tt class="calibre25">sys_execve( )</tt> service routine receives the following parameters:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The address of the executable file pathname (in the User Mode address space).</p></li><li class="calibre12"><p class="docText1">The address of a <tt class="calibre25">NULL</tt>-terminated array (in the User Mode address space) of pointers to strings (again in the User Mode address space); each string represents a command-line argument.</p></li><li class="calibre12"><p class="docText1">The address of a <tt class="calibre25">NULL</tt>-terminated array (in the User Mode address space) of pointers to strings (again in the User Mode address space); each string represents an environment variable in the <tt class="calibre25">NAME=value</tt> format.</p></li></ul>
<p class="docText1">The function copies the executable file pathname into a newly allocated page frame. It then invokes the <tt class="calibre25">do_execve( )</tt> function, passing to it the pointers to the page frame, to the pointer's arrays, and to the location of the Kernel Mode stack where the User Mode register contents are saved. In turn, <tt class="calibre25">do_execve( )</tt> performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Dynamically allocates a <tt class="calibre25">linux_binprm</tt> data structure, which will be filled with data concerning the new executable file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">path_lookup( )</tt>, <tt class="calibre25">dentry_open( )</tt>, and <tt class="calibre25">path_release( )</tt> to get the dentry object, the file object, and the inode object associated with the executable file. On failure, it returns the proper error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Verifies that the file is executable by the current process; also, checks that the file is not being written by looking at the <tt class="calibre25">i_writecount</tt> field of the inode; stores <tt class="calibre25">-1</tt> in that field to forbid further write accesses.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">In multiprocessor systems, it invokes the <tt class="calibre25">sched_exec( )</tt> function to determine the least loaded CPU that can execute the new program and to migrate the current process to it (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">init_new_context( )</tt> to check whether the current process was using a custom Local Descriptor Table (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-3.html#understandlk-CHP-2-SECT-3.2">The Linux LDTs</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>); in this case, the function allocates and fills a new LDT to be used by the new program.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">prepare_binprm( )</tt> function to fill the <tt class="calibre25">linux_binprm</tt> data structure. This function, in turn, performs the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Checks again whether the file is executable (at least one execute access right is set); if not, returns an error code. (The previous check in step 3 is not sufficient because a process with the <tt class="calibre25">CAP_DAC_OVERRIDE</tt> capability set always satisfies the check; see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.1">Process Credentials and Capabilities</a>" earlier in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">e_uid</tt> and <tt class="calibre25">e_gid</tt> fields of the <tt class="calibre25">linux_binprm</tt> structure, taking into account the values of the <span class="docEmphasis">setuid</span> and <span class="docEmphasis">setgid</span> flags of the executable file. These fields represent the effective user and group IDs, respectively. Also checks process capabilities (a compatibility hack explained in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.1">Process Credentials and Capabilities</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Fills the <tt class="calibre25">buf</tt> field of the <tt class="calibre25">linux_binprm</tt> structure with the first 128 bytes of the executable file. These bytes include the magic number of the executable format and other information suitable for recognizing the executable file.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the file pathname, command-line arguments, and environment strings into one or more newly allocated page frames. (Eventually, they are assigned to the User Mode address space.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">search_binary_handler( )</tt> function, which scans the <tt class="calibre25">formats</tt> list and tries to apply the <tt class="calibre25">load_binary</tt> method of each element, passing to it the <tt class="calibre25">linux_binprm</tt> data structure. The scan of the <tt class="calibre25">formats</tt> list terminates as soon as a <tt class="calibre25">load_binary</tt> method succeeds in acknowledging the executable format of the file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the executable file format is not present in the <tt class="calibre25">formats</tt> list, it releases all allocated page frames and returns the error code <tt class="calibre25">-ENOEXEC</tt>. Linux cannot recognize the executable file format.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, the function releases the <tt class="calibre25">linux_binprm</tt> data structure and returns the code obtained from the <tt class="calibre25">load_binary</tt> method associated with the executable format of the file.</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">load_binary</tt> method corresponding to an executable file format performs the following operations (we assume that the executable file is stored on a filesystem that allows file memory mapping and that it requires one or more shared libraries):</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks some magic numbers stored in the first 128 bytes of the file to identify the executable format. If the magic numbers don't match, it returns the error code <tt class="calibre25">-ENOEXEC</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Reads the header of the executable file. This header describes the program's segments and the shared libraries requested.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets from the executable file the pathname of the dynamic linker, which is used to locate the shared libraries and map them into memory.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets the dentry object (as well as the inode object and the file object) of the dynamic linker.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the execution permissions of the dynamic linker.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the first 128 bytes of the dynamic linker into a buffer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Performs some consistency checks on the dynamic linker type.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">flush_old_exec( )</tt> function to release almost all resources used by the previous computation; in turn, this function performs the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the table of signal handlers is shared with other processes, it allocates a new table and decrements the usage counter of the old one; moreover, it detaches the process from the old thread group (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>). All of this is done by invoking the <tt class="calibre25">de_thread( )</tt> function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">unshare_files( )</tt> to make a copy of the <tt class="calibre25">files_struct</tt> structure containing the open files of the process, if it is shared with other processes (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.6">Files Associated with a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">exec_mmap( )</tt> function to release the memory descriptor, all memory regions<a name="IDX-CHP-20-4953"></a> 
, and all page frames assigned to the process and to clean up the process's Page Tables.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">comm</tt> field of the process descriptor with the executable file pathname.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">flush_thread( )</tt> function to clear the values of the floating point registers and debug registers<a name="IDX-CHP-20-4954"></a> 
 saved in the TSS segment.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates the table of signal handlers by resetting each signal to its default action. This is done by invoking the <tt class="calibre25">flush_signal_handlers( )</tt> function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">flush_old_files( )</tt> function to close all open files having the corresponding flag in the <tt class="calibre25">files-&gt;close_on_exec</tt> field of the process descriptor set (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12-SECT-2.html#understandlk-CHP-12-SECT-2.6">Files Associated with a Process</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>).<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-20-FN6">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-20-FN6">[*]</a></sup> These flags can be read and modified by means of the <tt class="calibre42">fcntl( )</tt><a name="IDX-CHP-20-4955"></a> 
 system call.</p></blockquote></div></li></ol></div><p class="docList">Now we have reached the point of no return: the function cannot restore the previous computation if something goes wrong.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Clears the <tt class="calibre25">PF_FORKNOEXEC</tt> flag in the process descriptor. This flag, which is set when a process is forked and cleared when it executes a new program, is required for process accounting.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets up the new personality of the processthat is, the <tt class="calibre25">personality</tt> field in the process descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">arch_pick_mmap_layout( )</tt> to select the layout of the memory regions of the process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.4">Program Segments and Process Memory Regions</a>" earlier in this chapter).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">setup_arg_pages( )</tt> function to allocate a new memory region descriptor for the process's User Mode stack and to insert that memory region into the process's address space. <tt class="calibre25">setup_arg_pages( )</tt> also assigns the page frames containing the command-line arguments and the environment variable strings to the new memory region.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">do_mmap( )</tt> function to create a new memory region that maps the text segment (that is, the code) of the executable file. The initial linear address of the memory region depends on the executable format, because the program's executable code is usually not relocatable. Therefore, the function assumes that the text segment is loaded starting from some specific logical address offset (and thus from some specified linear address). ELF programs are loaded starting from linear address <tt class="calibre25">0x08048000</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">do_mmap( )</tt> function to create a new memory region that maps the data segment of the executable file. Again, the initial linear address of the memory region depends on the executable format, because the executable code expects to find its variables at specified offsets (that is, at specified linear addresses). In an ELF program, the data segment is loaded right after the text segment.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Allocates additional memory regions for every other specialized segments of the executable file. Usually, there are none.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes a function that loads the dynamic linker. If the dynamic linker is an ELF executable, the function is named <tt class="calibre25">load_elf_interp( )</tt>. In general, the function performs the operations in steps 12 through 14, but for the dynamic linker instead of the file to be executed. The initial addresses of the memory regions that will include the text and data of the dynamic linker are specified by the dynamic linker itself; however, they are very high (usually above <tt class="calibre25">0x40000000</tt>) to avoid collisions with the memory regions that map the text and data of the file to be executed (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.4">Program Segments and Process Memory Regions</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Stores in the <tt class="calibre25">binfmt</tt> field of the process descriptor the address of the <tt class="calibre25">linux_binfmt</tt> object of the executable format.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Determines the new capabilities of the process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Creates specific dynamic linker tables and stores them on the User Mode stack between the command-line arguments and the array of pointers to environment strings (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-FIG-1">Figure 20-1</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the values of the <tt class="calibre25">start_code</tt>, <tt class="calibre25">end_code</tt>, <tt class="calibre25">start_data</tt>, <tt class="calibre25">end_data</tt>, <tt class="calibre25">start_brk</tt>, <tt class="calibre25">brk</tt>, and <tt class="calibre25">start_stack</tt> fields of the process's memory descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">do_brk( )</tt> function to create a new anonymous memory region mapping the bss segment of the program. (When the process writes into a variable, it triggers demand paging<a name="IDX-CHP-20-4956"></a> 
, and thus the allocation of a page frame.) The size of this memory region was computed when the executable program was linked. The initial linear address of the memory region must be specified, because the program's executable code is usually not relocatable. In an ELF program, the bss segment is loaded right after the data segment.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">start_thread( )</tt> macro to modify the values of the User Mode registers <tt class="calibre25">eip</tt> and <tt class="calibre25">esp</tt> saved on the Kernel Mode stack, so that they point to the entry point of the dynamic linker and to the top of the new User Mode stack, respectively.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the process is being traced, it notifies the debugger about the completion of the <tt class="calibre25">execve( )</tt> system call.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the value 0 (success).</p></div></li></ol></div>
<p class="docText1">When the <tt class="calibre25">execve( )</tt> system call terminates and the calling process resumes its execution in User Mode, the execution context is dramatically changed: the code that invoked the system call no longer exists. In this sense, we could say that <tt class="calibre25">execve( )</tt> never returns on success. Instead, a new program to be executed is mapped in the address space of the process.</p>
<p class="docText1">However, the new program cannot yet be executed, because the dynamic linker must still take care of loading the shared libraries.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-20-FN7">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-20-FN7">[*]</a></sup> Things are much simpler if the executable file is statically linkedthat is, if no shared library is requested. The <tt class="calibre42">load_binary</tt> method simply maps the text, data, bss, and stack segments of the program into the process memory regions, and then sets the User Mode <tt class="calibre42">eip</tt> register to the entry point of the new program.</p></blockquote>
<p class="docText1">Although the dynamic linker runs in User Mode, we briefly sketch out here how it operates. Its first job is to set up a basic execution context for itself, starting from the information stored by the kernel in the User Mode stack between the array of pointers to environment strings and <tt class="calibre25">arg_start</tt>. Then the dynamic linker must examine the program to be executed to identify which shared libraries must be loaded and which functions in each shared library are effectively requested. Next, the interpreter issues several <tt class="calibre25">mmap( )</tt><a name="IDX-CHP-20-4957"></a> 
 system calls to create memory regions mapping the pages that will hold the library functions<a name="IDX-CHP-20-4958"></a> 
 (text and data) actually used by the program. Then the interpreter updates all references to the symbols of the shared library, according to the linear addresses of the library's memory regions. Finally, the dynamic linker terminates its execution by jumping to the main entry point of the program to be executed. From now on, the process will execute the code of the executable file and of the shared libraries.</p>
<p class="docText1">As you may have noticed, executing a program is a complex activity that involves many facets of kernel design, such as process abstraction, memory management, system calls, and filesystems. It is the kind of topic that makes you realize what a marvelous piece of work Linux is!</p>

<br class="calibre7"/>

</div>

{% endraw %}

