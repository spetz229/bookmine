---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-8-SECT-3.html
next: understandlk-CHP-9-SECT-1.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-9"></a>
<div class="calibre23"></div><h2 class="docPrefaceTitle">Chapter 9. Process Address Space</h2>
<p class="docText1">As seen in the previous chapter, a kernel function gets dynamic memory in a fairly straightforward manner by invoking one of a variety of functions: <tt class="calibre25">_ _get_free_pages( )</tt> or <tt class="calibre25">alloc_pages( )</tt> to get pages from the zoned page frame allocator, <tt class="calibre25">kmem_cache_alloc( )</tt> or <tt class="calibre25">kmalloc( )</tt> to use the slab allocator for specialized or general-purpose objects, and <tt class="calibre25">vmalloc( )</tt> or <tt class="calibre25">vmalloc_32( )</tt> to get a noncontiguous memory area. If the request can be satisfied, each of these functions returns a page descriptor address or a linear address identifying the beginning of the allocated dynamic memory area.</p>
<p class="docText1">These simple approaches work for two reasons:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The kernel is the highest-priority component of the operating system. If a kernel function makes a request for dynamic memory, it must have a valid reason to issue that request, and there is no point in trying to defer it.</p></li><li class="calibre12"><p class="docText1">The kernel trusts itself. All kernel functions are assumed to be error-free, so the kernel does not need to insert any protection against programming errors.</p></li></ul>
<p class="docText1">When allocating memory to User Mode processes, the situation is entirely different:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Process requests for dynamic memory are considered non-urgent. When a process's executable file is loaded, for instance, it is unlikely that the process will address all the pages of code in the near future. Similarly, when a process invokes <tt class="calibre25">malloc( )</tt> to get additional dynamic memory, it doesn't mean the process will soon access all the additional memory obtained. Thus, as a general rule, the kernel tries to defer allocating dynamic memory to User Mode processes.</p></li><li class="calibre12"><p class="docText1">Because user programs cannot be trusted, the kernel must be prepared to catch all addressing errors caused by processes in User Mode.</p></li></ul>
<p class="docText1">As this chapter describes, the kernel succeeds in deferring the allocation of dynamic memory to processes by using a new kind of resource. When a User Mode process asks for dynamic memory, it doesn't get additional page frames; instead, it gets the right to use a new range of linear addresses, which become part of its address space. This interval is called a "memory region."</p>
<p class="docText1">In the next section, we discuss how the process views dynamic memory. We then describe the basic components of the process address space in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9-SECT-3.html#understandlk-CHP-9-SECT-3">Memory Regions</a>." Next, we examine in detail the role played by the Page Fault<a name="IDX-CHP-9-2298"></a> 
 exception handler in deferring the allocation of page frames to processes and illustrate how the kernel creates and deletes whole process address spaces. Last, we discuss the APIs and system calls related to address space management.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

