---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-13-SECT-3.html
next: understandlk-CHP-13-SECT-5.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-13-SECT-4"></a>
<h3 class="docSection1Title">13.4. Device Drivers</h3><a name="IDX-CHP-13-3498"></a>
<p class="docText1">A device driver is the set of kernel routines that makes a hardware device respond to the programming interface defined by the canonical set of VFS functions (<i class="docEmphasis">open</i>, <i class="docEmphasis">read</i>, <i class="docEmphasis">lseek</i>, <i class="docEmphasis">ioctl</i>, and so forth) that control a device. The actual implementation of all these functions is delegated to the device driver. Because each device has a different I/O controller, and thus different commands and different state information, most I/O devices have their own drivers.</p>
<p class="docText1">There are many types of device drivers<a name="IDX-CHP-13-3499"></a> 
. They mainly differ in the level of support that they offer to the User Mode applications, as well as in their buffering strategies for the data collected from the hardware devices. Because these choices greatly influence the internal structure of a device driver, we discuss them in the sections "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-SECT-4.5">Direct Memory Access (DMA)</a>" and "Buffering Strategies for Character Devices."</p>
<p class="docText1">A device driver does not consist only of the functions that implement the device file operations. Before using a device driver, several activities must have taken place. We'll examine them in the following sections.</p>
<a name="understandlk-CHP-13-SECT-4.1"></a>
<h4 class="docSection2Title">13.4.1. Device Driver Registration</h4>
<p class="docText1">We know that each system call issued on a device file is translated by the kernel into an invocation of a suitable function of a corresponding device driver. To achieve this, a device driver must <span class="docEmphasis">register</span> itself. In other words, registering<a name="IDX-CHP-13-3500"></a> 
 a device driver means allocating a new <tt class="calibre25">device_driver</tt> descriptor, inserting it in the data structures of the device driver model (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.3">Components of the Device Driver Model</a>"), and linking it to the corresponding device file(s). Accesses to device files whose corresponding drivers have not been previously registered return the error code <tt class="calibre25">-ENODEV</tt>.</p>
<p class="docText1">If a device driver is statically compiled in the kernel, its registration is performed during the kernel initialization phase. Conversely, if a device driver is compiled as a kernel module (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-APP-B.html#understandlk-APP-B">Appendix B</a>), its registration is performed when the module is loaded. In the latter case, the device driver can also unregister itself when the module is unloaded.</p>
<p class="docText1">Let us consider, for instance, a generic PCI device. To properly handle it, its device driver must allocate a descriptor of type <tt class="calibre25">pci_driver</tt>, which is used by the PCI kernel layer to handle the device. After having initialized some fields of this descriptor, the device driver invokes the <tt class="calibre25">pci_register_driver( )</tt> function. Actually, the <tt class="calibre25">pci_driver</tt> descriptor includes an embedded <tt class="calibre25">device_driver</tt> descriptor (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.3">Components of the Device Driver Model</a>"); the <tt class="calibre25">pci_register_function( )</tt> simply initializes the fields of the embedded driver descriptor and invokes <tt class="calibre25">driver_register( )</tt> to insert the driver in the data structures of the device driver model.</p>
<p class="docText1">When a device driver is being registered, the kernel looks for unsupported hardware devices that could be possibly handled by the driver. To do this, it relies on the <tt class="calibre25">match</tt> method of the relevant <tt class="calibre25">bus_type</tt> bus type descriptor, and on the <tt class="calibre25">probe</tt> method of the <tt class="calibre25">device_driver</tt> object. If a hardware device that can be handled by the driver is discovered, the kernel allocates a <tt class="calibre25">device</tt> object and invokes <tt class="calibre25">device_register( )</tt> to insert the device in the device driver model.</p>
<a name="understandlk-CHP-13-SECT-4.2"></a>
<h4 class="docSection2Title">13.4.2. Device Driver Initialization</h4><a name="IDX-CHP-13-3501"></a>
<a name="IDX-CHP-13-3502"></a>
<p class="docText1">Registering a device driver and initializing it are two different things. A device driver is registered as soon as possible, so User Mode applications can use it through the corresponding device files. In contrast, a device driver is initialized at the last possible moment. In fact, initializing a driver means allocating precious resources of the system, which are therefore not available to other drivers.</p>
<p class="docText1">We already have seen an example in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.1">I/O Interrupt Handling</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>: the assignment of IRQs to devices is usually made dynamically, right before using them, because several devices may share the same IRQ line. Other resources that can be allocated at the last possible moment are page frames for DMA transfer buffers and the DMA channel itself (for old non-PCI devices such as the floppy disk driver).</p>
<p class="docText1">To make sure the resources are obtained when needed but are not requested in a redundant manner when they have already been granted, device drivers usually adopt the following schema:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">A usage counter keeps track of the number of processes that are currently accessing the device file. The counter is increased in the <tt class="calibre25">open</tt> method of the device file and decreased in the <tt class="calibre25">release</tt> method.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-13-FN5">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-13-FN5">[*]</a></sup> More precisely, the usage counter keeps track of the number of file objects referring to the device file, because clone processes could share the same file object.</p></blockquote></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">open</tt> method checks the value of the usage counter before the increment. If the counter is zero, the device driver must allocate the resources and enable interrupts and DMA on the hardware device.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">release</tt> method checks the value of the usage counter after the decrement. If the counter is zero, no more processes are using the hardware device. If so, the method disables interrupts and DMA on the I/O controller, and then releases the allocated resources.</p></li></ul>
<a name="understandlk-CHP-13-SECT-4.3"></a>
<h4 class="docSection2Title">13.4.3. Monitoring I/O Operations</h4>
<p class="docText1">The duration of an I/O operation is often unpredictable. It can depend on mechanical considerations (the current position of a disk head with respect to the block to be transferred), on truly random events (when a data packet arrives on the network card), or on human factors (when a user presses a key on the keyboard or when she notices that a paper jam occurred in the printer). In any case, the device driver that started an I/O operation must rely on a monitoring<a name="IDX-CHP-13-3503"></a> 
 technique that signals either the termination of the I/O operation or a time-out.</p>
<p class="docText1">In the case of a terminated operation, the device driver reads the status register of the I/O interface to determine whether the I/O operation was carried out successfully. In the case of a time-out, the driver knows that something went wrong, because the maximum time interval allowed to complete the operation elapsed and nothing happened.</p>
<p class="docText1">The two techniques available to monitor the end of an I/O operation are called the <span class="docEmphasis">polling mode</span><a name="IDX-CHP-13-3504"></a> 
 and the <span class="docEmphasis">interrupt mode</span>.</p>
<a name="understandlk-CHP-13-SECT-4.3.1"></a>
<h5 class="docSection3Title">13.4.3.1. Polling mode</h5>
<p class="docText1">According to this technique, the CPU checks (polls) the device's status register repeatedly until its value signals that the I/O operation has been completed. We have already encountered a technique based on polling in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.4">Spin Locks</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>: when a processor tries to acquire a busy spin lock, it repeatedly polls the variable until its value becomes 0. However, polling applied to I/O operations is usually more elaborate, because the driver must also remember to check for possible time-outs. A simple example of polling looks like the following:</p>
<pre class="calibre27">
    for (;;) {
        if (read_status(device) &amp; DEVICE_END_OPERATION) break;
        if (--count == 0) break;
    }</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">count</tt> variable, which was initialized before entering the loop, is decreased at each iteration, and thus can be used to implement a rough time-out mechanism. Alternatively, a more precise time-out mechanism could be implemented by reading the value of the tick counter <tt class="calibre25">jiffies</tt> at each iteration (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6-SECT-3.html#understandlk-CHP-6-SECT-3">Updating the Time and Date</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6.html#understandlk-CHP-6">Chapter 6</a>) and comparing it with the old value read before starting the wait loop.</p>
<p class="docText1">If the time required to complete the I/O operation is relatively high, say in the order of milliseconds, this schema becomes inefficient because the CPU wastes precious machine cycles while waiting for the I/O operation to complete. In such cases, it is preferable to voluntarily relinquish the CPU after each polling operation by inserting an invocation of the <tt class="calibre25">schedule( )</tt> function inside the loop.</p>
<a name="understandlk-CHP-13-SECT-4.3.2"></a>
<h5 class="docSection3Title">13.4.3.2. Interrupt mode</h5>
<p class="docText1">Interrupt mode can be used only if the I/O controller is capable of signaling, via an IRQ line, the end of an I/O operation.</p>
<p class="docText1">We'll show how interrupt mode<a name="IDX-CHP-13-3505"></a> 
 works on a simple case. Let's suppose we want to implement a driver for a simple input character device. When the user issues a <tt class="calibre25">read( )</tt><a name="IDX-CHP-13-3506"></a> 
 system call on the corresponding device file, an input command is sent to the device's control register. After an unpredictably long time interval, the device puts a single byte of data in its input register. The device driver then returns this byte as the result of the <tt class="calibre25">read( )</tt> system call.</p>
<p class="docText1">This is a typical case in which it is preferable to implement the driver using the interrupt mode. Essentially, the driver includes two functions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">foo_read( )</tt> function that implements the <tt class="calibre25">read</tt> method of the file object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">foo_interrupt( )</tt> function that handles the interrupt.</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">foo_read( )</tt> function is triggered whenever the user reads the device file:</p>
<pre class="calibre27">
    ssize_t foo_read(struct file *filp, char *buf, size_t count,
                     loff_t *ppos)
    {
        foo_dev_t * foo_dev = filp-&gt;private_data;
        if (down_interruptible(&amp;foo_dev-&gt;sem)
            return -ERESTARTSYS;
        foo_dev-&gt;intr = 0;
        outb(DEV_FOO_READ, DEV_FOO_CONTROL_PORT);
        wait_event_interruptible(foo_dev-&gt;wait, (foo_dev-&gt;intr=  =1));
        if (put_user(foo_dev-&gt;data, buf))
            return -EFAULT;
        up(&amp;foo_dev-&gt;sem);
        return 1;
    }</pre><br class="calibre7"/>
<p class="docText1">The device driver relies on a custom descriptor of type <tt class="calibre25">foo_dev_t</tt>; it includes a semaphore <tt class="calibre25">sem</tt> that protects the hardware device from concurrent accesses, a wait queue <tt class="calibre25">wait</tt>, a flag <tt class="calibre25">intr</tt> that is set when the device issues an interrupt, and a single-byte buffer <tt class="calibre25">data</tt> that is written by the interrupt handler and read by the <tt class="calibre25">read</tt> method. In general, all I/O drivers that use interrupts rely on data structures accessed by both the interrupt handler and the <tt class="calibre25">read</tt> and <tt class="calibre25">write</tt> methods. The address of the <tt class="calibre25">foo_dev_t</tt> descriptor is usually stored in the <tt class="calibre25">private_data</tt> field of the device file's file object or in a global variable.</p>
<p class="docText1">The main operations of the <tt class="calibre25">foo_read( )</tt> function are the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">foo_dev-&gt;sem</tt> semaphore, thus ensuring that no other process is accessing the device.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Clears the <tt class="calibre25">intr</tt> flag.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Issues the read command to the I/O device.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes <tt class="calibre25">wait_event_interruptible</tt> to suspend the process until the <tt class="calibre25">intr</tt> flag becomes 1. This macro is described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.4.1">Wait queues</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>.</p></div></li></ol></div>
<p class="docText1">After some time, our device issues an interrupt to signal that the I/O operation is completed and that the data is ready in the proper <tt class="calibre25">DEV_FOO_DATA_PORT</tt> data port. The interrupt handler sets the <tt class="calibre25">intr</tt> flag and wakes the process. When the scheduler decides to reexecute the process, the second part of <tt class="calibre25">foo_read( )</tt> is executed and does the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Copies the character ready in the <tt class="calibre25">foo_dev-&gt;data</tt> variable into the user address space.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Terminates after releasing the <tt class="calibre25">foo_dev-&gt;sem</tt> semaphore.</p></div></li></ol></div>
<p class="docText1">For simplicity, we didn't include any time-out control. In general, time-out control is implemented through static or dynamic timers (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-6.html#understandlk-CHP-6">Chapter 6</a>); the timer must be set to the right time before starting the I/O operation and removed when the operation terminates.</p>
<p class="docText1">Let's now look at the code of the <tt class="calibre25">foo_interrupt( )</tt> function:</p>
<pre class="calibre27">
    irqreturn_t foo_interrupt(int irq, void *dev_id, struct pt_regs *regs)
    {
        foo-&gt;data = inb(DEV_FOO_DATA_PORT);
        foo-&gt;intr = 1;
        wake_up_interruptible(&amp;foo-&gt;wait);
        return 1;
    }</pre><br class="calibre7"/>
<p class="docText1">The interrupt handler reads the character from the input register of the device and stores it in the <tt class="calibre25">data</tt> field of the <tt class="calibre25">foo_dev_t</tt> descriptor of the device driver pointed to by the <tt class="calibre25">foo</tt> global variable. It then sets the <tt class="calibre25">intr</tt> flag and invokes <tt class="calibre25">wake_up_interruptible( )</tt> to wake the process blocked in the <tt class="calibre25">foo-&gt;wait</tt> wait queue.</p>
<p class="docText1">Notice that none of the three parameters are used by our interrupt handler. This is a rather common case.</p>
<a name="understandlk-CHP-13-SECT-4.4"></a>
<h4 class="docSection2Title">13.4.4. Accessing the I/O Shared Memory</h4><a name="IDX-CHP-13-3507"></a>
<a name="IDX-CHP-13-3508"></a>
<a name="IDX-CHP-13-3509"></a>
<p class="docText1">Depending on the device and on the bus type, I/O shared memory in the PC's architecture may be mapped within different physical address ranges. Typically:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">For most devices connected to the ISA bus</span></span></p></dt>
<dd class="calibre20"><p class="docList">The I/O shared memory is usually mapped into the 16-bit physical addresses ranging from <tt class="calibre25">0xa0000</tt> to <tt class="calibre25">0xfffff</tt>; this gives rise to the "hole" between 640 KB and 1 MB mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-5.html#understandlk-CHP-2-SECT-5.3">Physical Memory Layout</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">For devices connected to the PCI bus</span></span></p></dt>
<dd class="calibre20"><p class="docList">The I/O shared memory is mapped into 32-bit physical addresses near the 4 GB boundary. This kind of device is much simpler to handle.</p></dd></dl>
<p class="docText1">A few years ago, Intel introduced the <span class="docEmphasis">Accelerated Graphics Port</span> (<span class="docEmphasis">AGP</span>) standard, which is an enhancement of PCI for high-performance graphic cards. Beside having its own I/O shared memory, this kind of card is capable of directly addressing portions of the motherboard's RAM by means of a special hardware circuit named <span class="docEmphasis">Graphics Address Remapping Table</span> (<span class="docEmphasis">GART</span><a name="IDX-CHP-13-3510"></a> 
). The GART circuitry enables AGP cards to sustain much higher data transfer rates than older PCI cards. From the kernel's point of view, however, it doesn't really matter where the physical memory is located, and GART-mapped memory is handled like the other kinds of I/O shared memory.</p>
<p class="docText1">How does a device driver access an I/O shared memory location? Let's start with the PC's architecture, which is relatively simple to handle, and then extend the discussion to other architectures.</p>
<p class="docText1">Remember that kernel programs act on linear addresses, so the I/O shared memory locations must be expressed as addresses greater than <tt class="calibre25">PAGE_OFFSET</tt>. In the following discussion, we assume that <tt class="calibre25">PAGE_OFFSET</tt> is equal to <tt class="calibre25">0xc0000000</tt>that is, that the kernel linear addresses are in the fourth gigabyte.</p>
<p class="docText1">Device drivers must translate I/O physical addresses of I/O shared memory locations into linear addresses in kernel space. In the PC architecture, this can be achieved simply by ORing the 32-bit physical address with the <tt class="calibre25">0xc0000000</tt> constant. For instance, suppose the kernel needs to store the value in the I/O location at physical address <tt class="calibre25">0x000b0fe4</tt> in <tt class="calibre25">t1</tt> and the value in the I/O location at physical address <tt class="calibre25">0xfc000000</tt> in <tt class="calibre25">t2</tt>. One might think that the following statements could do the job:</p>
<pre class="calibre27">
    t1 = *((unsigned char *)(0xc00b0fe4));
    t2 = *((unsigned char *)(0xfc000000));</pre><br class="calibre7"/>
<p class="docText1">During the initialization phase, the kernel maps the available RAM's physical addresses into the initial portion of the fourth gigabyte of the linear address space. Therefore, the Paging Unit maps the <tt class="calibre25">0xc00b0fe4</tt> linear address appearing in the first statement back to the original I/O physical address <tt class="calibre25">0x000b0fe4</tt>, which falls inside the "ISA hole" between 640 KB and 1 MB (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-5.html#understandlk-CHP-2-SECT-5">Paging in Linux</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>). This works fine.</p>
<p class="docText1">There is a problem, however, for the second statement, because the I/O physical address is greater than the last physical address of the system RAM. Therefore, the <tt class="calibre25">0xfc000000</tt> linear address does not correspond to the <tt class="calibre25">0xfc000000</tt> physical address. In such cases, the kernel Page Tables must be modified to include a linear address that maps the I/O physical address. This can be done by invoking the <tt class="calibre25">ioremap( )</tt> or <tt class="calibre25">ioremap_nocache( )</tt> functions. The first function, which is similar to <tt class="calibre25">vmalloc( )</tt>, invokes <tt class="calibre25">get_vm_area( )</tt> to create a new <tt class="calibre25">vm_struct</tt> descriptor (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-3.html#understandlk-CHP-8-SECT-3.2">Descriptors of Noncontiguous Memory Areas</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>) for a linear address interval that has the size of the required I/O shared memory area. The functions then update the corresponding Page Table entries of the canonical kernel Page Tables appropriately. The <tt class="calibre25">ioremap_nocache( )</tt> function differs from <tt class="calibre25">ioremap( )</tt> in that it also disables the hardware cache when referencing the remapped linear addresses properly.</p>
<p class="docText1">The correct form for the second statement might therefore look like:</p>
<pre class="calibre27">
    io_mem = ioremap(0xfb000000, 0x200000);
    t2 = *((unsigned char *)(io_mem + 0x100000));</pre><br class="calibre7"/>
<p class="docText1">The first statement creates a new 2 MB linear address interval, which maps physical addresses starting from <tt class="calibre25">0xfb000000</tt>; the second one reads the memory location that has the <tt class="calibre25">0xfc000000</tt> address. To remove the mapping later, the device driver must use the <tt class="calibre25">iounmap( )</tt> function.</p>
<p class="docText1">On some architectures other than the PC, I/O shared memory cannot be accessed by simply dereferencing the linear address pointing to the physical memory location. Therefore, Linux defines the following architecture-dependent functions, which should be used when accessing I/O shared memory:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">readb( )</span></span>, <span class="docPubcolor"><span class="docMonofont">readw( )</span></span>, <span class="docPubcolor"><span class="docMonofont">readl( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Reads 1, 2, or 4 bytes, respectively, from an I/O shared memory location</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">writeb( )</span></span>, <span class="docPubcolor"><span class="docMonofont">writew( )</span></span>, <span class="docPubcolor"><span class="docMonofont">writel( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Writes 1, 2, or 4 bytes, respectively, into an I/O shared memory location</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">memcpy_fromio( )</span></span>, <span class="docPubcolor"><span class="docMonofont">memcpy_toio( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Copies a block of data from an I/O shared memory location to dynamic memory and vice versa</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">memset_io( )</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Fills an I/O shared memory area with a fixed value</p></dd></dl>
<p class="docText1">The recommended way to access the <tt class="calibre25">0xfc000000</tt> I/O location is thus:</p>
<pre class="calibre27">
    io_mem = ioremap(0xfb000000, 0x200000);
    t2 = readb(io_mem + 0x100000);</pre><br class="calibre7"/>
<p class="docText1">Thanks to these functions, all dependencies on platform-specific ways of accessing the I/O shared memory can be hidden.</p>
<a name="understandlk-CHP-13-SECT-4.5"></a>
<h4 class="docSection2Title">13.4.5. Direct Memory Access (DMA)</h4><a name="IDX-CHP-13-3511"></a>
<a name="IDX-CHP-13-3512"></a>
<a name="IDX-CHP-13-3513"></a>
<a name="IDX-CHP-13-3514"></a>
<a name="IDX-CHP-13-3515"></a>
<a name="IDX-CHP-13-3516"></a>
<a name="IDX-CHP-13-3517"></a>
<a name="IDX-CHP-13-3518"></a>
<a name="IDX-CHP-13-3519"></a>
<a name="IDX-CHP-13-3520"></a>
<a name="IDX-CHP-13-3521"></a>
<a name="IDX-CHP-13-3522"></a>
<p class="docText1">In the original PC architecture, the CPU is the only <span class="docEmphasis">bus master</span> of the system, that is, the only hardware device that drives the address/data bus in order to fetch and store values in the RAM's locations. With more modern bus architectures such as PCI, each peripheral can act as bus master, if provided with the proper circuitry. Thus, nowadays all PCs include auxiliary <span class="docEmphasis">DMA</span><a name="IDX-CHP-13-3523"></a> 
 circuits<a name="IDX-CHP-13-3524"></a> 
, which can transfer data between the RAM and an I/O device. Once activated by the CPU, the DMA is able to continue the data transfer on its own; when the data transfer is completed, the DMA issues an interrupt request. The conflicts that occur when CPUs and DMA circuits need to access the same memory location at the same time are resolved by a hardware circuit called a <span class="docEmphasis">memory arbiter</span> (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-2.html#understandlk-CHP-5-SECT-2.2">Atomic Operations</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>).</p>
<p class="docText1">The DMA is mostly used by disk drivers and other devices that transfer a large number of bytes at once. Because setup time for the DMA is relatively high, it is more efficient to directly use the CPU for the data transfer when the number of bytes is small.</p>
<p class="docText1">The first DMA circuits for the old ISA buses were complex, hard to program, and limited to the lower 16 MB of physical memory. More recent DMA circuits for the PCI and SCSI buses rely on dedicated hardware circuits in the buses and make life easier for device driver developers.</p>
<a name="understandlk-CHP-13-SECT-4.5.1"></a>
<h5 class="docSection3Title">13.4.5.1. Synchronous and asynchronous DMA</h5><a name="IDX-CHP-13-3525"></a>
<a name="IDX-CHP-13-3526"></a>
<a name="IDX-CHP-13-3527"></a>
<a name="IDX-CHP-13-3528"></a>
<p class="docText1">A device driver can use the DMA in two different ways called <span class="docEmphasis">synchronous DMA</span> and <span class="docEmphasis">asynchronous DMA</span>. In the first case, the data transfers are triggered by processes; in the second case the data transfers are triggered by hardware devices.</p>
<p class="docText1">An example of synchronous DMA is a sound card that is playing a sound track. A User Mode application writes the sound data (called <span class="docEmphasis">samples</span>) on a device file associated with the <span class="docEmphasis">digital signal processor</span> (<span class="docEmphasis">DSP</span>) of the sound card. The device driver of the sound card accumulates these samples in a kernel buffer. At the same time, the device driver instructs the sound card to copy the samples from the kernel buffer to the DSP with a well-defined timing. When the sound card finishes the data transfer, it raises an interrupt, and the device driver checks whether the kernel buffer still contains samples yet to be played; if so, the driver activates another DMA data transfer.</p>
<p class="docText1">An example of asynchronous DMA is a network card that is receiving a frame (data packet) from a LAN. The peripheral stores the frame in its I/O shared memory, then raises an interrupt. The device driver of the network card acknowledges the interrupt, then instructs the peripheral to copy the frame from the I/O shared memory into a kernel buffer. When the data transfer completes, the network card raises another interrupt, and the device driver notifies the upper kernel layer about the new frame.</p>
<a name="understandlk-CHP-13-SECT-4.5.2"></a>
<h5 class="docSection3Title">13.4.5.2. Helper functions for DMA transfers</h5>
<p class="docText1">When designing a driver for a device that makes use of DMA, the developer should write code that is both architecture-independent and, as far as DMA is concerned, bus-independent. This goal is now feasible thanks to the rich set of DMA helper functions provided by the kernel. These helper functions hide the differences in the DMA mechanisms of the various hardware architectures.</p>
<p class="docText1">There are two subsets of DMA helper functions: an older subset provides architecture-independent functions for PCI devices; a more recent subset ensures both bus and architecture independence. We'll now examine some of these functions while pointing out some hardware peculiarities of DMAs.</p>
<a name="understandlk-CHP-13-SECT-4.5.3"></a>
<h5 class="docSection3Title">13.4.5.3. Bus addresses</h5><a name="IDX-CHP-13-3529"></a>
<p class="docText1">Every DMA transfer involves (at least) one memory buffer, which contains the data to be read or written by the hardware device. In general, before activating the transfer, the device driver must ensure that the DMA circuit can directly access the RAM locations.</p>
<p class="docText1">Until now we have distinguished three kinds of memory addresses: logical and linear addresses, which are used internally by the CPU, and physical addresses, which are the memory addresses used by the CPU to physically drive the data bus. However, there is a fourth kind of memory address: the so-called <span class="docEmphasis">bus address</span>. It corresponds to the memory addresses used by all hardware devices except the CPU to drive the data bus.</p>
<p class="docText1">Why should the kernel be concerned at all about bus addresses<a name="IDX-CHP-13-3530"></a> 
? Well, in a DMA operation, the data transfer takes place without CPU intervention; the data bus is driven directly by the I/O device and the DMA circuit. Therefore, when the kernel sets up a DMA operation, it must write the bus address of the memory buffer involved in the proper I/O ports of the DMA or I/O device.</p>
<p class="docText1">In the 80 x 86 architecture, bus addresses coincide with physical addresses. However, other architectures such as Sun's SPARC and Hewlett-Packard's Alpha include a hardware circuit called the <span class="docEmphasis">I/O Memory Management Unit (IO-MMU)</span>, analog to the paging unit of the microprocessor, which maps physical addresses into bus addresses. All I/O drivers that make use of DMAs must set up properly the IO-MMU before starting the data transfer.</p>
<p class="docText1">Different buses have different bus address sizes. For instance, bus addresses for ISA are 24-bits long, thus in the 80 x 86 architecture DMA transfers can be done only on the lower 16 MB of physical memorythat's why the memory for the buffer used by such DMA has to be allocated in the <tt class="calibre25">ZONE_DMA</tt> memory zone with the <tt class="calibre25">GFP_DMA</tt> flag. The original PCI standard defines bus addresses of 32 bits; however, some PCI hardware devices have been originally designed for the ISA bus, thus they still cannot access RAM locations above physical address <tt class="calibre25">0x00ffffff</tt>. The recent PCI-X standard uses 64-bit bus addresses and allows DMA circuits to address directly the high memory.</p>
<p class="docText1">In Linux, the <tt class="calibre25">dma_addr_t</tt> type represents a generic bus address. In the 80 x 86 architecture <tt class="calibre25">dma_addr_t</tt> corresponds to a 32-bit integer, unless the kernel supports PAE (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-4.html#understandlk-CHP-2-SECT-4.5">The Physical Address Extension (PAE) Paging Mechanism</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>), in which case <tt class="calibre25">dma_addr_t</tt> corresponds to a 64-bit integer.</p>
<p class="docText1">The <tt class="calibre25">pci_set_dma_mask( )</tt> and <tt class="calibre25">dma_set_mask( )</tt> helper functions check whether the bus accepts a given size for the bus addresses (mask) and, if so, notify the bus layer that the given peripheral will use that size for its bus addresses.</p>
<a name="understandlk-CHP-13-SECT-4.5.4"></a>
<h5 class="docSection3Title">13.4.5.4. Cache coherency</h5><a name="IDX-CHP-13-3531"></a>
<a name="IDX-CHP-13-3532"></a>
<a name="IDX-CHP-13-3533"></a>
<a name="IDX-CHP-13-3534"></a>
<a name="IDX-CHP-13-3535"></a>
<a name="IDX-CHP-13-3536"></a>
<a name="IDX-CHP-13-3537"></a>
<a name="IDX-CHP-13-3538"></a>
<p class="docText1">The system architecture does not necessarily offer a coherency protocol between the hardware cache and the DMA circuits at the hardware level, so the DMA helper functions must take into consideration the hardware cache when implementing DMA mapping operations. To see why, suppose that the device driver fills the memory buffer with some data, then immediately instructs the hardware device to read that data with a DMA transfer. If the DMA accesses the physical RAM locations but the corresponding hardware cache lines have not yet been written to RAM, then the hardware device fetches the old values of the memory buffer.</p>
<p class="docText1">Device driver developers may handle DMA buffers in two different ways by making use of two different classes of helper functions. Using Linux terminology, the developer chooses between two different <span class="docEmphasis">DMA mapping types</span><a name="IDX-CHP-13-3539"></a> 
:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Coherent DMA mapping</span></span></p></dt>
<dd class="calibre20"><p class="docList">When using this mapping, the kernel ensures that there will be no cache coherency problems between the memory and the hardware device; this means that every write operation performed by the CPU on a RAM location is immediately visible to the hardware device, and vice versa. This type of mapping is also called "synchronous" or "consistent."</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Streaming DMA mapping</span></span></p></dt>
<dd class="calibre20"><p class="docList">When using this mapping, the device driver must take care of cache coherency problems by using the proper synchronization helper functions. This type of mapping is also called "asynchronous" or "non-coherent."</p></dd></dl>
<p class="docText1">In the 80 x 86 architecture there are never cache coherency problems when using the DMA, because the hardware devices themselves take care of "snooping" the accesses to the hardware caches. Therefore, a driver for a hardware device designed specifically for the 80 x 86 architecture may choose either one of the two DMA mapping types: they are essentially equivalent. On the other hand, in many architecturessuch as MIPS, SPARC, and some models of PowerPChardware devices do not always snoop in the hardware caches, so cache coherency problems arise. In general, choosing the proper DMA mapping type for an architecture-independent driver is not trivial.</p>
<p class="docText1">As a general rule, if the buffer is accessed in unpredictable ways by the CPU and the DMA processor, coherent DMA mapping is mandatory (for instance, buffers for SCSI adapters' command data structures). In other cases, streaming DMA mapping is preferable, because in some architectures handling the coherent DMA mapping is cumbersome and may lead to lower system performance.</p>
<a name="understandlk-CHP-13-SECT-4.5.5"></a>
<h5 class="docSection3Title">13.4.5.5. Helper functions for coherent DMA mappings</h5><a name="IDX-CHP-13-3540"></a>
<a name="IDX-CHP-13-3541"></a>
<a name="IDX-CHP-13-3542"></a>
<a name="IDX-CHP-13-3543"></a>
<a name="IDX-CHP-13-3544"></a>
<a name="IDX-CHP-13-3545"></a>
<a name="IDX-CHP-13-3546"></a>
<a name="IDX-CHP-13-3547"></a>
<a name="IDX-CHP-13-3548"></a>
<a name="IDX-CHP-13-3549"></a>
<a name="IDX-CHP-13-3550"></a>
<a name="IDX-CHP-13-3551"></a>
<a name="IDX-CHP-13-3552"></a>
<a name="IDX-CHP-13-3553"></a>
<p class="docText1">Usually, the device driver allocates the memory buffer and establishes the coherent DMA mapping in the initialization phase; it releases the mapping and the buffer when it is unloaded. To allocate a memory buffer and to establish a coherent DMA mapping, the kernel provides the architecture-dependent <tt class="calibre25">pci_alloc_consistent( )</tt> and <tt class="calibre25">dma_alloc_coherent( )</tt> functions. They both return the linear address and the bus address of the new buffer. In the 80 x 86 architecture, they return the linear address and the physical address of the new buffer. To release the mapping and the buffer, the kernel provides the <tt class="calibre25">pci_free_consistent( )</tt> and the <tt class="calibre25">dma_free_coherent( )</tt> functions.</p>
<a name="understandlk-CHP-13-SECT-4.5.6"></a>
<h5 class="docSection3Title">13.4.5.6. Helper functions for streaming DMA mappings</h5>
<p class="docText1">Memory buffers for streaming DMA mappings are usually mapped just before the transfer and unmapped thereafter. It is also possible to keep the same mapping among several DMA transfers, but in this case the device driver developer must be aware of the hardware cache lying between the memory and the peripheral.</p>
<p class="docText1">To set up a streaming DMA transfer, the driver must first dynamically allocate the memory buffer by means of the zoned page frame allocator (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-1.html#understandlk-CHP-8-SECT-1.5">The Zoned Page Frame Allocator</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>) or the generic memory allocator (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-2.html#understandlk-CHP-8-SECT-2.14">General Purpose Objects</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>). Then, the drivers must establish the streaming DMA mapping by invoking either the <tt class="calibre25">pci_map_single( )</tt> or the <tt class="calibre25">dma_map_single( )</tt> function, which receives as its parameter the linear address of the buffer and returns its bus address. To release the mapping, the driver invokes the corresponding <tt class="calibre25">pci_unmap_single( )</tt> or <tt class="calibre25">dma_unmap_single( )</tt> functions.</p>
<p class="docText1">To avoid cache coherency problems, right before starting a DMA transfer from the RAM to the device, the driver should invoke <tt class="calibre25">pci_dma_sync_single_for_device( )</tt> or <tt class="calibre25">dma_sync_single_for_device( )</tt>, which flush, if necessary, the cache lines corresponding to the DMA buffer. Similarly, a device driver should not access a memory buffer right after the end of a DMA transfer from the device to the RAM: instead, before reading the buffer, the driver should invoke <tt class="calibre25">pci_dma_sync_single_for_cpu( )</tt> or <tt class="calibre25">dma_sync_single_for_cpu( )</tt>, which invalidate, if necessary, the corresponding hardware cache lines. In the 80 x 86 architecture, these functions do almost nothing, because the coherency between hardware caches and DMAs is maintained by the hardware.</p>
<p class="docText1">Even buffers in high memory (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-1.html#understandlk-CHP-8-SECT-1.6">Kernel Mappings of High-Memory Page Frames</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>) can be used for DMA transfers; the developer uses <tt class="calibre25">pci_map_page( )</tt>or <tt class="calibre25">dma_map_page( )</tt>passing to it the descriptor address of the page including the buffer and the offset of the buffer inside the page. Correspondingly, to release the mapping of the high memory buffer, the developer uses <tt class="calibre25">pci_unmap_page( )</tt> or <tt class="calibre25">dma_unmap_page( )</tt>.</p>
<a name="understandlk-CHP-13-SECT-4.6"></a>
<h4 class="docSection2Title">13.4.6. Levels of Kernel Support</h4><a name="IDX-CHP-13-3554"></a>
<a name="IDX-CHP-13-3555"></a>
<a name="IDX-CHP-13-3556"></a>
<p class="docText1">The Linux kernel does not fully support all possible existing I/O devices. Generally speaking, in<a name="IDX-CHP-13-3557"></a> 
 fact, there are three possible kinds of support for a hardware device:</p>
<a name="IDX-CHP-13-3558"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">No support at all</span></span></p></dt>
<dd class="calibre20"><p class="docList">The application program interacts directly with the device's I/O ports by issuing suitable <tt class="calibre25">in</tt> and <tt class="calibre25">out</tt><a name="IDX-CHP-13-3558"></a> 
 assembly language instructions.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Minimal support</span></span></p></dt>
<dd class="calibre20"><p class="docList">The kernel does not recognize the hardware device, but does recognize its I/O interface. User programs are able to treat the interface as a sequential device capable of reading and/or writing sequences of characters.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Extended support</span></span></p></dt>
<dd class="calibre20"><p class="docList">The kernel recognizes the hardware device and handles the I/O interface itself. In fact, there might not even be a device file for the device.</p></dd></dl>
<p class="docText1">The most common example of the first approach, which does not rely on any kernel device driver, is how the X Window System<a name="IDX-CHP-13-3559"></a> 
 traditionally handles the graphic display. This is quite efficient, although it constrains the X server from using the hardware interrupts issued by the I/O device. This approach also requires some additional effort to allow the X server to access the required I/O ports. As mentioned in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-3.html#understandlk-CHP-3-SECT-3.2">Task State Segment</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3.html#understandlk-CHP-3">Chapter 3</a>, the <tt class="calibre25">iopl( )</tt><a name="IDX-CHP-13-3560"></a> 
 and <tt class="calibre25">ioperm( )</tt><a name="IDX-CHP-13-3561"></a> 
 system calls grant a process the privilege to access I/O ports. They can be invoked only by programs having root privileges. But such programs can be made available to users by setting the <span class="docEmphasis">setuid</span> flag of the executable file (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20-SECT-1.html#understandlk-CHP-20-SECT-1.1">Process Credentials and Capabilities</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>).</p>
<p class="docText1">Recent Linux versions support several widely used graphic cards. The <i class="docEmphasis">/dev/fb</i> device file provides an abstraction for the frame buffer of the graphic card and allows application software to access it without needing to know anything about the I/O ports of the graphics interface. Furthermore, the kernel supports the Direct Rendering Infrastructure (DRI) that allows application software to exploit the hardware of accelerated 3D graphics cards. In any case, the traditional do-it-yourself X Window System server is still widely adopted.</p>
<p class="docText1">The minimal support approach is used to handle external hardware devices connected to a general-purpose I/O interface. The kernel takes care of the I/O interface by offering a device file (and thus a device driver); the application program handles the external hardware device by reading and writing the device file.</p>
<p class="docText1">Minimal support is preferable to extended support because it keeps the kernel size small. However, among the general-purpose I/O interfaces commonly found on a PC, only the serial port and the parallel port can be handled with this approach. Thus, a serial mouse is directly controlled by an application program, such as the X server, and a serial modem always requires a communication program, such as Minicom, Seyon, or a Point-to-Point Protocol (PPP) daemon.</p>
<p class="docText1">Minimal support has a limited range of applications, because it cannot be used when the external device must interact heavily with internal kernel data structures. For example, consider a removable hard disk that is connected to a general-purpose I/O interface. An application program cannot interact with all kernel data structures and functions needed to recognize the disk and to mount its filesystem, so extended support is mandatory in this case.</p>
<p class="docText1">In general, every hardware device directly connected to the I/O bus, such as the internal hard disk, is handled according to the extended support approach: the kernel must provide a device driver for each such device. External devices attached to the Universal Serial Bus (USB), the PCMCIA port found in many laptops, or the SCSI interfacein short, every general-purpose I/O interface except the serial and the parallel portsalso require extended support.</p>
<p class="docText1">It is worth noting that the standard file-related system calls such as <tt class="calibre25">open( )</tt><a name="IDX-CHP-13-3562"></a> 
, <tt class="calibre25">read( )</tt><a name="IDX-CHP-13-3563"></a> 
, and <tt class="calibre25">write( )</tt><a name="IDX-CHP-13-3564"></a> 
 do not always give the application full control of the underlying hardware device. In fact, the lowest-common-denominator approach of the VFS does not include room for special commands that some devices need or let an application check whether the device is in a specific internal state.</p>
<p class="docText1">The <tt class="calibre25">ioctl( )</tt><a name="IDX-CHP-13-3565"></a> 
 system call was introduced to satisfy such needs. Besides the file descriptor of the device file and a second 32-bit parameter specifying the request, the system call can accept an arbitrary number of additional parameters. For example, specific <tt class="calibre25">ioctl( )</tt> requests exist to get the CD-ROM sound volume or to eject the CD-ROM media. Application programs may provide the user interface of a CD player using these kinds of <tt class="calibre25">ioctl( )</tt> requests.</p>

<br class="calibre7"/>

</div>

{% endraw %}

