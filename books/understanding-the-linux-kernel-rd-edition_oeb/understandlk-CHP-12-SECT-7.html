---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-12-SECT-6.html
next: understandlk-CHP-13.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-12-SECT-7"></a>
<h3 class="docSection1Title">12.7. File Locking</h3>
<p class="docText1">When a file can be accessed by more than one process, a synchronization problem occurs. What happens if two processes try to write in the same file location? Or again, what happens if a process reads from a file location while another process is writing into it?</p>
<p class="docText1">In traditional Unix systems, concurrent accesses to the same file location produce unpredictable results. However, Unix systems provide a mechanism that allows the processes to <span class="docEmphasis">lock</span> a file region so that concurrent accesses may be easily avoided.</p>
<p class="docText1">The POSIX standard requires a file-locking mechanism based on the <tt class="calibre25">fcntl( )</tt><a name="IDX-CHP-12-3304"></a> 
 system call. It is possible to lock an arbitrary region of a file (even a single byte) or to lock the whole file (including data appended in the future). Because a process can choose to lock only a part of a file, it can also hold multiple locks on different parts of the file.</p>
<p class="docText1">This kind of lock does not keep out another process that is ignorant of locking. Like a semaphore used to protect a critical region in code, the lock is considered "advisory" because it doesn't work unless other processes cooperate in checking the existence of a lock before accessing the file. Therefore, POSIX's locks are known as <span class="docEmphasis">advisory locks</span><a name="IDX-CHP-12-3305"></a> 
.</p>
<p class="docText1">Traditional BSD<a name="IDX-CHP-12-3306"></a> 
 variants implement advisory locking through the <tt class="calibre25">flock( )</tt><a name="IDX-CHP-12-3307"></a> 
 system call. This call does not allow a process to lock a file region, only the whole file. Traditional System V<a name="IDX-CHP-12-3308"></a> 
 variants provide the <tt class="calibre25">lockf( )</tt><a name="IDX-CHP-12-3309"></a> 
 library function, which is simply an interface to <tt class="calibre25">fcntl( )</tt>.</p>
<p class="docText1">More importantly, System V Release 3 introduced <span class="docEmphasis">mandatory locking</span>: the kernel checks that every invocation of the <tt class="calibre25">open( )</tt><a name="IDX-CHP-12-3310"></a> 
, <tt class="calibre25">read( )</tt><a name="IDX-CHP-12-3311"></a> 
, and <tt class="calibre25">write( )</tt><a name="IDX-CHP-12-3312"></a> 
 system calls does not violate a mandatory lock on the file being accessed. Therefore, mandatory locks<a name="IDX-CHP-12-3313"></a> 
 are enforced even between noncooperative processes.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN9">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-12-FN9">[*]</a></sup> Oddly enough, a process may still unlink (delete) a file even if some other process owns a mandatory lock on it! This perplexing situation is possible because when a process deletes a file hard link, it does not modify its contents, but only the contents of its parent directory.</p></blockquote>
<p class="docText1">Whether processes use advisory or mandatory locks, they can use both shared <span class="docEmphasis">read locks</span><a name="IDX-CHP-12-3314"></a> 
 and exclusive <span class="docEmphasis">write locks</span><a name="IDX-CHP-12-3315"></a> 
. Several processes may have read locks on some file region, but only one process can have a write lock on it at the same time. Moreover, it is not possible to get a write lock when another process owns a read lock for the same file region, and vice versa.</p>
<a name="understandlk-CHP-12-SECT-7.1"></a>
<h4 class="docSection2Title">12.7.1. Linux File Locking</h4><a name="IDX-CHP-12-3316"></a>
<a name="IDX-CHP-12-3317"></a>
<a name="IDX-CHP-12-3318"></a>
<a name="IDX-CHP-12-3319"></a>
<a name="IDX-CHP-12-3320"></a>
<a name="IDX-CHP-12-3321"></a>
<a name="IDX-CHP-12-3322"></a>
<p class="docText1">Linux supports all types of file locking: advisory and mandatory locks, plus the <tt class="calibre25">fcntl( )</tt> and <tt class="calibre25">flock( )</tt> system calls (<tt class="calibre25">lockf( )</tt> is implemented as a standard library function).</p>
<p class="docText1">The expected behavior of the <tt class="calibre25">flock( )</tt> system call in every Unix-like operating system is to produce advisory locks only, without regard for the <tt class="calibre25">MS_MANDLOCK</tt> mount flag. In Linux, however, a special kind of <tt class="calibre25">flock( )</tt>'s mandatory lock is used to support some proprietary network filesystems<a name="IDX-CHP-12-3323"></a> 
. It is the so-called <span class="docEmphasis">share-mode mandatory lock</span>; when set, no other process may open a file that would conflict with the access mode of the lock. Use of this feature for native Unix applications is discouraged, because the resulting source code will be nonportable.</p>
<p class="docText1">Another kind of <tt class="calibre25">fcntl( )</tt>-based mandatory lock called <span class="docEmphasis">lease</span> has been introduced in Linux. When a process tries to open a file protected by a lease, it is blocked as usual. However, the process that owns the lock receives a signal. Once informed, it should first update the file so that its content is consistent, and then release the lock. If the owner does not do this in a well-defined time interval (tunable by writing a number of seconds into <i class="docEmphasis">/proc<a name="IDX-CHP-12-3324"></a> 
/sys/fs/lease-break-time</i>, usually 45 seconds), the lease is automatically removed by the kernel and the blocked process is allowed to continue.</p>
<p class="docText1">A process can get or release an advisory file lock on a file in two possible ways:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">By issuing the <tt class="calibre25">flock( )</tt> system call. The two parameters of the system call are the <tt class="calibre25">fd</tt> file descriptor, and a command to specify the lock operation. The lock applies to the whole file.</p></li><li class="calibre12"><p class="docText1">By using the <tt class="calibre25">fcntl( )</tt> system call. The three parameters of the system call are the <tt class="calibre25">fd</tt> file descriptor, a command to specify the lock operation, and a pointer to a <tt class="calibre25">flock</tt> structure (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-20">Table 12-20</a>). A couple of fields in this structure allow the process to specify the portion of the file to be locked. Processes can thus hold several locks on different portions of the same file.</p></li></ul>
<p class="docText1">Both the <tt class="calibre25">fcntl( )</tt> and the <tt class="calibre25">flock( )</tt> system call may be used on the same file at the same time, but a file locked through <tt class="calibre25">fcntl( )</tt> does not appear locked to <tt class="calibre25">flock( )</tt>, and vice versa. This has been done on purpose in order to avoid the deadlocks occurring when an application using a type of lock relies on a library that uses the other type.</p>
<p class="docText1">Handling mandatory file locks is a bit more complex. Here are the steps to follow:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Mount the filesystem where mandatory locking is required using the <tt class="calibre25">-o mand</tt> option in the <i class="docEmphasis">mount</i> command, which sets the <tt class="calibre25">MS_MANDLOCK</tt> flag in the <tt class="calibre25">mount( )</tt><a name="IDX-CHP-12-3325"></a> 
 system call. The default is to disable mandatory locking.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Mark the files as candidates for mandatory locking by setting their set-group bit (SGID) and clearing the group-execute permission bit. Because the set-group bit makes no sense when the group-execute bit is off, the kernel interprets that combination as a hint to use mandatory locks instead of advisory ones.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Uses the <tt class="calibre25">fcntl( )</tt> system call (see below) to get or release a file lock.</p></div></li></ol></div>
<p class="docText1">Handling leases is much simpler than handling mandatory locks: it is sufficient to invoke a <tt class="calibre25">fcntl( )</tt> system call with a <tt class="calibre25">F_SETLEASE</tt> or <tt class="calibre25">F_GETLEASE</tt> command. Another <tt class="calibre25">fcntl( )</tt> invocation with the <tt class="calibre25">F_SETSIG</tt> command may be used to change the type of signal to be sent to the lease process holder.</p>
<p class="docText1">Besides the checks in the <tt class="calibre25">read( )</tt><a name="IDX-CHP-12-3326"></a> 
 and <tt class="calibre25">write( )</tt><a name="IDX-CHP-12-3327"></a> 
 system calls, the kernel takes into consideration the existence of mandatory locks when servicing all system calls that could modify the contents of a file. For instance, an <tt class="calibre25">open( )</tt><a name="IDX-CHP-12-3328"></a> 
 system call with the <tt class="calibre25">O_TRUNC</tt> flag set fails if any mandatory lock exists for the file.</p>
<p class="docText1">The following section describes the main data structure used by the kernel to handle file locks issued by means of the <tt class="calibre25">flock( )</tt> system call (<tt class="calibre25">FL_FLOCK</tt> locks) and of the <tt class="calibre25">fcntl( )</tt> system call (<tt class="calibre25">FL_POSIX</tt> locks).</p>
<a name="understandlk-CHP-12-SECT-7.2"></a>
<h4 class="docSection2Title">12.7.2. File-Locking Data Structures</h4><a name="IDX-CHP-12-3329"></a>
<a name="IDX-CHP-12-3330"></a>
<a name="IDX-CHP-12-3331"></a>
<a name="IDX-CHP-12-3332"></a>
<p class="docText1">All type of Linux locks are represented by the same <tt class="calibre25">file_lock</tt> data structure whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-19">Table 12-19</a>.</p>
<a name="understandlk-CHP-12-TABLE-19"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-19. The fields of the file_lock data structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct file_lock *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_next</tt></p></td><td class="docTableCell"><p class="docText2">Next element in list of locks associated with the inode</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_link</tt></p></td><td class="docTableCell"><p class="docText2">Pointers for active or blocked list</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct list_head</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_block</tt></p></td><td class="docTableCell"><p class="docText2">Pointers for the lock's waiters list</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct files_struct *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_owner</tt></p></td><td class="docTableCell"><p class="docText2">Owner's <tt class="calibre25">files_struct</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_pid</tt></p></td><td class="docTableCell"><p class="docText2">PID of the process owner</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">wait_queue_head_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_wait</tt></p></td><td class="docTableCell"><p class="docText2">Wait queue of blocked processes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct file *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_file</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to file object</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned char</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_flags</tt></p></td><td class="docTableCell"><p class="docText2">Lock flags</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned char</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_type</tt></p></td><td class="docTableCell"><p class="docText2">Lock type</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">loff_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_start</tt></p></td><td class="docTableCell"><p class="docText2">Starting offset of locked region</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">loff_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_end</tt></p></td><td class="docTableCell"><p class="docText2">Ending offset of locked region</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct fasync_struct *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_fasync</tt></p></td><td class="docTableCell"><p class="docText2">Used for lease break notifications</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned long</p></td><td class="docTableCell"><p class="docText2">fl_break_time</p></td><td class="docTableCell"><p class="docText2">Remaining time before end of lease</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct file_lock_operations *</p></td><td class="docTableCell"><p class="docText2">fl_ops</p></td><td class="docTableCell"><p class="docText2">Pointer to file lock operations</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct lock_manager_operations *</p></td><td class="docTableCell"><p class="docText2">fl_mops</p></td><td class="docTableCell"><p class="docText2">Pointer to lock manager operations</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">union</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fl_u</tt></p></td><td class="docTableCell"><p class="docText2">Filesystem-specific information</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">All <tt class="calibre25">lock_file</tt> structures that refer to the same file on disk are collected in a singly linked list, whose first element is pointed to by the <tt class="calibre25">i_flock</tt> field of the inode object. The <tt class="calibre25">fl_next</tt> field of the <tt class="calibre25">lock_file</tt> structure specifies the next element in the list.</p>
<p class="docText1">When a process issues a blocking system call to require an exclusive lock while there are shared locks on the same file, the lock request cannot be satisfied immediately and the process must be suspended. The process is thus inserted into a wait queue pointed to by the <tt class="calibre25">fl_wait</tt> field of the blocked lock's <tt class="calibre25">file_lock</tt> structure. Two lists are used to distinguish lock requests that have been satisfied (<span class="docEmphasis">active locks</span><a name="IDX-CHP-12-3333"></a> 
) from those that cannot be satisfied right away (<span class="docEmphasis">blocked locks</span><a name="IDX-CHP-12-3334"></a> 
).</p>
<p class="docText1">All active locks are linked together in the "global file lock list" whose head element is stored in the <tt class="calibre25">file_lock_list</tt> variable. Similarly, all blocked locks are linked together in the "blocked list" whose head element is stored in the <tt class="calibre25">blocked_list</tt> variable. The <tt class="calibre25">fl_link</tt> field is used to insert a <tt class="calibre25">lock_file</tt> structure in either one of these two lists.</p>
<p class="docText1">Last but not least, the kernel must keep track of all blocked locks (the "waiters") associated with a given active lock (the "blocker"): this is the purpose of a list that links together all waiters with respect to a given blocker. The <tt class="calibre25">fl_block</tt> field of the blocker is the dummy head of the list, while the <tt class="calibre25">fl_block</tt> fields of the waiters store the pointers to the adjacent elements in the list.</p>
<a name="understandlk-CHP-12-SECT-7.3"></a>
<h4 class="docSection2Title">12.7.3. FL_FLOCK Locks</h4><a name="IDX-CHP-12-3335"></a>
<a name="IDX-CHP-12-3336"></a>
<a name="IDX-CHP-12-3337"></a>
<a name="IDX-CHP-12-3338"></a>
<a name="IDX-CHP-12-3339"></a>
<a name="IDX-CHP-12-3340"></a>
<a name="IDX-CHP-12-3341"></a>
<a name="IDX-CHP-12-3342"></a>
<a name="IDX-CHP-12-3343"></a>
<a name="IDX-CHP-12-3344"></a>
<a name="IDX-CHP-12-3345"></a>
<p class="docText1">An <tt class="calibre25">FL_FLOCK</tt> lock is always associated with a file object and is thus owned by the process that opened the file (or by all clone processes sharing the same opened file). When a lock is requested and granted, the kernel replaces every other lock that the process is holding on the same file object with the new lock. This happens only when a process wants to change an already owned read lock into a write one, or vice versa. Moreover, when a file object is being freed by the <tt class="calibre25">fput( )</tt> function, all <tt class="calibre25">FL_FLOCK</tt> locks that refer to the file object are destroyed. However, there could be other <tt class="calibre25">FL_FLOCK</tt> read locks set by other processes for the same file (inode), and they still remain active.</p>
<p class="docText1">The <tt class="calibre25">flock( )</tt> system call allows a process to apply or remove an advisory lock on an open file. It acts on two parameters: the <tt class="calibre25">fd</tt> file descriptor of the file to be acted upon and a <tt class="calibre25">cmd</tt> parameter that specifies the lock operation. A <tt class="calibre25">cmd</tt> parameter of <tt class="calibre25">LOCK_SH</tt> requires a shared lock for reading, <tt class="calibre25">LOCK_EX</tt> requires an exclusive lock for writing, and <tt class="calibre25">LOCK_UN</tt> releases the lock.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN10">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-12-FN10">[*]</a></sup> Actually, the <tt class="calibre42">flock( )</tt> system call can also establish share-mode mandatory locks by specifying the command <tt class="calibre42">LOCK_MAND</tt>. However, we'll not further discuss this case.</p></blockquote>
<p class="docText1">Usually this system call blocks the current process if the request cannot be immediately satisfied, for instance if the process requires an exclusive lock while some other process has already acquired the same lock. However, if the <tt class="calibre25">LOCK_NB</tt> flag is passed together with the <tt class="calibre25">LOCK_SH</tt> or <tt class="calibre25">LOCK_EX</tt> operation, the system call does not block; in other words, if the lock cannot be immediately obtained, the system call returns an error code.</p>
<p class="docText1">When the <tt class="calibre25">sys_flock( )</tt> service routine is invoked, it performs the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether <tt class="calibre25">fd</tt> is a valid file descriptor; if not, returns an error code. Gets the address <tt class="calibre25">filp</tt> of the corresponding file object.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks that the process has read and/or write permission on the open file; if not, returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets a new <tt class="calibre25">file_lock</tt> object <tt class="calibre25">lock</tt> and initializes it in the appropriate way: the <tt class="calibre25">fl_type</tt> field is set according to the value of the parameter <tt class="calibre25">cmd</tt>, the <tt class="calibre25">fl_file</tt> field is set to the address <tt class="calibre25">filp</tt> of the file object, the <tt class="calibre25">fl_flags</tt> field is set to <tt class="calibre25">FL_FLOCK</tt>, the <tt class="calibre25">fl_pid</tt> field is set to <tt class="calibre25">current-&gt;tgid</tt>, and the <tt class="calibre25">fl_end</tt> field is set to <tt class="calibre25">-1</tt> to denote the fact that locking refers to the whole file (and not to a portion of it).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">cmd</tt> parameter does not include the <tt class="calibre25">LOCK_NB</tt> bit, it adds to the <tt class="calibre25">fl_flags</tt> field the <tt class="calibre25">FL_SLEEP</tt> flag.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the file has a <tt class="calibre25">flock</tt> file operation, the routine invokes it, passing as its parameters the file object pointer <tt class="calibre25">filp</tt>, a flag (<tt class="calibre25">F_SETLKW</tt> or <tt class="calibre25">F_SETLK</tt> depending on the value of the <tt class="calibre25">LOCK_NB</tt> bit), and the address of the new <tt class="calibre25">file_lock</tt> object <tt class="calibre25">lock</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the <tt class="calibre25">flock</tt> file operation is not defined (the common case), invokes <tt class="calibre25">flock_lock_file_wait( )</tt> to try to perform the required lock operation. Two parameters are passed: <tt class="calibre25">filp</tt>, a file object pointer, and <tt class="calibre25">lock</tt>, the address of the new <tt class="calibre25">file_lock</tt> object created in step 3.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">file_lock</tt> descriptor has not been inserted in the active or blocked lists in the previous step, the routine releases it.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns 0 in case of success.</p></div></li></ol></div>
<p class="docText1">The <tt class="calibre25">flock_lock_file_wait( )</tt> function executes a cycle consisting of the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">flock_lock_file( )</tt> passing as parameters the file object pointer <tt class="calibre25">filp</tt> and the address of the new <tt class="calibre25">file_lock</tt> object <tt class="calibre25">lock</tt>. This function performs, in turn, the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Searches the list that <tt class="calibre25">filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock</tt> points to. If an <tt class="calibre25">FL_FLOCK</tt> lock for the same file object is found, checks its type (<tt class="calibre25">LOCK_SH</tt> or <tt class="calibre25">LOCK_EX</tt>): if it is equal to the type of the new lock, returns 0 (nothing has to be done). Otherwise, the function removes the old element from the list of locks on the inode and the global file lock list, wakes up all processes sleeping in the wait queues of the locks in the <tt class="calibre25">fl_block</tt> list, and frees the <tt class="calibre25">file_lock</tt> structure.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the process is performing an unlock (<tt class="calibre25">LOCK_UN</tt>), nothing else needs to be done: the lock was nonexisting or it has already been released, thus returns 0.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If an <tt class="calibre25">FL_FLOCK</tt> lock for the same file object has been foundthus the process is changing an already owned read lock into a write one (or vice versa)gives some other higher-priority process, in particular every process previously blocked on the old file lock, a chance to run by invoking <tt class="calibre25">cond_resched( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Searches the list of locks on the inode again to verify that no existing <tt class="calibre25">FL_FLOCK</tt> lock conflicts with the requested one. There must be no <tt class="calibre25">FL_FLOCK</tt> write lock in the list, and moreover, there must be no <tt class="calibre25">FL_FLOCK</tt> lock at all if the process is requesting a write lock.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If no conflicting lock exists, it inserts the new <tt class="calibre25">file_lock</tt> structure into the inode's lock list and into the global file lock list, then returns 0 (success).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">A conflicting lock has been found: if the <tt class="calibre25">FL_SLEEP</tt> flag in the <tt class="calibre25">fl_flags</tt> field is set, it inserts the new lock (the waiter lock) in the circular list of the blocker lock and in the global blocked list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the error code <tt class="calibre25">-EAGAIN</tt>.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the return code of <tt class="calibre25">flock_lock_file( )</tt>:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the return code is 0 (no conflicting looks), it returns 0 (success).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">There are incompatibilities. If the <tt class="calibre25">FL_SLEEP</tt> flag in the <tt class="calibre25">fl_flags</tt> field is cleared, it releases the <tt class="calibre25">lock file_lock</tt> descriptor and returns <tt class="calibre25">-EAGAIN</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, there are incompatibilities but the process can sleep: invokes <tt class="calibre25">wait_event_interruptible( )</tt> to insert the current process in the <tt class="calibre25">lock-&gt;fl_wait</tt> wait queue and to suspend it. When the process is awakened (right after the blocker lock has been released), it jumps to step 1 to retry the operation.</p></div></li></ol></div></div></li></ol></div>
<a name="understandlk-CHP-12-SECT-7.4"></a>
<h4 class="docSection2Title">12.7.4. FL_POSIX Locks</h4><a name="IDX-CHP-12-3346"></a>
<a name="IDX-CHP-12-3347"></a>
<a name="IDX-CHP-12-3348"></a>
<a name="IDX-CHP-12-3349"></a>
<a name="IDX-CHP-12-3350"></a>
<a name="IDX-CHP-12-3351"></a>
<a name="IDX-CHP-12-3352"></a>
<a name="IDX-CHP-12-3353"></a>
<a name="IDX-CHP-12-3354"></a>
<a name="IDX-CHP-12-3355"></a>
<a name="IDX-CHP-12-3356"></a>
<a name="IDX-CHP-12-3357"></a>
<a name="IDX-CHP-12-3358"></a>
<a name="IDX-CHP-12-3359"></a>
<a name="IDX-CHP-12-3360"></a>
<a name="IDX-CHP-12-3361"></a>
<p class="docText1">An <tt class="calibre25">FL_POSIX</tt> lock is always associated with a process <span class="docEmphasis">and</span> with an inode; the lock is automatically released either when the process dies or when a file descriptor is closed (even if the process opened the same file twice or duplicated a file descriptor). Moreover, <tt class="calibre25">FL_POSIX</tt> locks are never inherited by a child across a <tt class="calibre25">fork( )</tt>.</p>
<p class="docText1">When used to lock files, the <tt class="calibre25">fcntl( )</tt> system call acts on three parameters: the <tt class="calibre25">fd</tt> file descriptor of the file to be acted upon, a <tt class="calibre25">cmd</tt> parameter that specifies the lock operation, and an <tt class="calibre25">fl</tt> pointer to a <tt class="calibre25">flock</tt> data structure<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-FN11">[*]</a></sup> stored in the User Mode process address space; its fields are described in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-12-TABLE-20">Table 12-20</a>.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-12-FN11">[*]</a></sup> Linux also defines a <tt class="calibre42">flock64</tt> structure, which uses 64-bit long integers for the <tt class="calibre42">offset</tt> and <tt class="calibre42">length</tt> fields. In the following, we focus on the <tt class="calibre42">flock</tt> data structure, but the description is valid for <tt class="calibre42">flock64</tt> too.</p></blockquote>
<a name="understandlk-CHP-12-TABLE-20"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 12-20. The fields of the flock data structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">short</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">l_type</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">F_RDLOCK</tt> (requests a shared lock), <tt class="calibre25">F_WRLOCK</tt> (requests an exclusive lock), <tt class="calibre25">F_UNLOCK</tt> (releases the lock)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">short</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">l_whence</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">SEEK_SET</tt> (from beginning of file), <tt class="calibre25">SEEK_CURRENT</tt> (from current file pointer), <tt class="calibre25">SEEK_END</tt> (from end of file)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">off_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">l_start</tt></p></td><td class="docTableCell"><p class="docText2">Initial offset of the locked region relative to the value of <tt class="calibre25">l_whence</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">off_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">l_len</tt></p></td><td class="docTableCell"><p class="docText2">Length of locked region (0 means that the region includes all potential writes past the current end of the file)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">pid_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">l_pid</tt></p></td><td class="docTableCell"><p class="docText2">PID of the owner</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">sys_fcntl( )</tt> service routine behaves differently, depending on the value of the flag set in the <tt class="calibre25">cmd</tt> parameter:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">F_GETLK</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Determines whether the lock described by the <tt class="calibre25">flock</tt> structure conflicts with some <tt class="calibre25">FL_POSIX</tt> lock already obtained by another process. In this case, the <tt class="calibre25">flock</tt> structure is overwritten with the information about the existing lock.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">F_SETLK</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Sets the lock described by the <tt class="calibre25">flock</tt> structure. If the lock cannot be acquired, the system call returns an error code.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">F_SETLKW</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Sets the lock described by the <tt class="calibre25">flock</tt> structure. If the lock cannot be acquired, the system call blocks; that is, the calling process is put to sleep until the lock is available.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">F_GETLK64</span></span>, <span class="docPubcolor"><span class="docMonofont">F_SETLK64</span></span>, <span class="docPubcolor"><span class="docMonofont">F_SETLKW64</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Identical to the previous ones, but the <tt class="calibre25">flock64</tt> data structure is used rather than <tt class="calibre25">flock</tt>.</p></dd></dl>
<p class="docText1">The <tt class="calibre25">sys_fcntl( )</tt> service routine gets first a file object corresponding to the <tt class="calibre25">fd</tt> parameter and invokes then <tt class="calibre25">fcntl_getlk( )</tt> or <tt class="calibre25">fcntl_setlk( )</tt>, depending on the command passed as its parameter (<tt class="calibre25">F_GETBLK</tt> for the former function, <tt class="calibre25">F_SETLK</tt> or <tt class="calibre25">F_SETLKW</tt> for the latter one). We'll consider the second case only.</p>
<p class="docText1">The <tt class="calibre25">fcntl_setlk( )</tt> function acts on three parameters: a <tt class="calibre25">filp</tt> pointer to the file object, a <tt class="calibre25">cmd</tt> command (<tt class="calibre25">F_SETLK</tt> or <tt class="calibre25">F_SETLKW</tt>), and a pointer to a <tt class="calibre25">flock</tt> data structure. The steps performed are the following:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Reads the structure pointed to by the <tt class="calibre25">fl</tt> parameter in a local variable of type <tt class="calibre25">flock</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the lock should be a mandatory one and the file has a shared memory mapping (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-2.html#understandlk-CHP-16-SECT-2">Memory Mapping</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>). In this case, the function refuses to create the lock and returns the <tt class="calibre25">-EAGAIN</tt> error code, because the file is already being accessed by another process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes a new <tt class="calibre25">file_lock</tt> structure according to the contents of the user's <tt class="calibre25">flock</tt> structure and to the file size stored in the file's inode.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the command is <tt class="calibre25">F_SETLKW</tt>, the function sets the <tt class="calibre25">FL_SLEEP</tt> flag in the <tt class="calibre25">fl_flags</tt> field of the <tt class="calibre25">file_lock</tt> structure.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">l_type</tt> field in the <tt class="calibre25">flock</tt> structure is equal to <tt class="calibre25">F_RDLCK</tt>, it checks whether the process is allowed to read from the file; similarly, if <tt class="calibre25">l_type</tt> is equal to <tt class="calibre25">F_WRLCK</tt>, checks whether the process is allowed to write into the file. If not, it returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">lock</tt> method of the file operations, if defined. Usually for disk-based filesystems<a name="IDX-CHP-12-3362"></a> 
, this method is not defined.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">_ _posix_lock_file( )</tt> passing as parameters the address of the file's inode object and the address of the <tt class="calibre25">file_lock</tt> object. This function performs, in turn, the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">posix_locks_conflict( )</tt> for each <tt class="calibre25">FL_POSIX</tt> lock in the inode's lock list. The function checks whether the lock conflicts with the requested one. Essentially, there must be no <tt class="calibre25">FL_POSIX</tt> write lock for the same region in the inode list, and there may be no <tt class="calibre25">FL_POSIX</tt> lock at all for the same region if the process is requesting a write lock. However, locks owned by the same process never conflict; this allows a process to change the characteristics of a lock it already owns.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If a conflicting lock is found, the function checks whether <tt class="calibre25">fcntl( )</tt> was invoked with the <tt class="calibre25">F_SETLKW</tt> command. If so, the current process must be suspended: invokes <tt class="calibre25">posix_locks_deadlock( )</tt> to check that no deadlock condition is being created among processes waiting for <tt class="calibre25">FL_POSIX</tt> locks, then inserts the new lock (waiter lock) both in the blocker list of the conflicting lock (blocker lock) and in the blocked list, and finally returns an error code. Otherwise, if <tt class="calibre25">fcntl( )</tt> was invoked with the <tt class="calibre25">F_SETLK</tt> command, returns an error code.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">As soon as the inode's lock list includes no conflicting lock, the function checks all the <tt class="calibre25">FL_POSIX</tt> locks of the current process that overlap the file region that the current process wants to lock, and combines and splits adjacent areas as required. For example, if the process requested a write lock for a file region that falls inside a read-locked wider region, the previous read lock is split into two parts covering the nonoverlapping areas, while the central region is protected by the new write lock. In case of overlaps, newer locks always replace older ones.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Inserts the new <tt class="calibre25">file_lock</tt> structure in the global file lock list and in the inode list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the value 0 (success).</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the return code of <tt class="calibre25">_ _posix_lock_file( )</tt>:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">If the return code is 0 (no conflicting locks), it returns 0 (success).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">There are incompatibilities. If the <tt class="calibre25">FL_SLEEP</tt> flag in the <tt class="calibre25">fl_flags</tt> field is cleared, it releases the new <tt class="calibre25">file_lock</tt> descriptor and returns <tt class="calibre25">-EAGAIN</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if there are incompatibilities but the process can sleep, it invokes <tt class="calibre25">wait_event_interruptible( )</tt> to insert the current process in the <tt class="calibre25">lock-&gt;fl_wait</tt> wait queue and to suspend it. When the process is awakened (right after the blocker lock has been released), it jumps to step 7 to retry the operation.</p></div></li></ol></div></div></li></ol></div>

<br class="calibre7"/>

</div>

{% endraw %}

