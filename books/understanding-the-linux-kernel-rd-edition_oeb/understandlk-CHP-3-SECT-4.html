---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-3-SECT-3.html
next: understandlk-CHP-3-SECT-5.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-3-SECT-4"></a>
<h3 class="docSection1Title" id="534869-973">3.4. Creating Processes</h3>
<p class="docText1">Unix operating systems rely heavily on process creation to satisfy user requests. For example, the shell creates a new process that executes another copy of the shell whenever the user enters a command.</p>
<p class="docText1">Traditional Unix systems treat all processes in the same way: resources owned by the parent process are duplicated in the child process. This approach makes process creation very slow and inefficient, because it requires copying the entire address space of the parent process. The child process rarely needs to read or modify all the resources inherited from the parent; in many cases, it issues an immediate <tt class="calibre25">execve( )</tt> and wipes out the address space that was so carefully copied.</p>
<p class="docText1">Modern Unix kernels solve this problem by introducing three different mechanisms:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The Copy On Write technique allows both the parent and the child to read the same physical pages. Whenever either one tries to write on a physical page, the kernel copies its contents into a new physical page that is assigned to the writing process. The implementation of this technique in Linux is fully explained in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>.</p></li><li class="calibre12"><p class="docText1">Lightweight processes allow both the parent and the child to share many per-process kernel data structures, such as the paging tables (and therefore the entire User Mode address space), the open file tables, and the signal dispositions.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">vfork( )</tt> system call creates a process that shares the memory address space of its parent. To prevent the parent from overwriting data needed by the child, the parent's execution is blocked until the child exits or executes a new program. We'll learn more about the <tt class="calibre25">vfork( )</tt> system call in the following section.</p></li></ul>
<a name="understandlk-CHP-3-SECT-4.1"></a>
<h4 class="docSection2Title">3.4.1. The clone( ), fork( ), and vfork( ) System Calls</h4><a name="IDX-CHP-3-0883"></a>
<a name="IDX-CHP-3-0884"></a>
<a name="IDX-CHP-3-0885"></a>
<a name="IDX-CHP-3-0886"></a>
<a name="IDX-CHP-3-0887"></a>
<a name="IDX-CHP-3-0888"></a>
<a name="IDX-CHP-3-0889"></a>
<a name="IDX-CHP-3-0890"></a>
<a name="IDX-CHP-3-0891"></a>
<a name="IDX-CHP-3-0892"></a>
<a name="IDX-CHP-3-0893"></a>
<a name="IDX-CHP-3-0894"></a>
<a name="IDX-CHP-3-0895"></a>
<a name="IDX-CHP-3-0896"></a>
<a name="IDX-CHP-3-0897"></a>
<a name="IDX-CHP-3-0898"></a>
<a name="IDX-CHP-3-0899"></a>
<a name="IDX-CHP-3-0900"></a>
<a name="IDX-CHP-3-0901"></a>
<a name="IDX-CHP-3-0902"></a>
<a name="IDX-CHP-3-0903"></a>
<a name="IDX-CHP-3-0904"></a>
<a name="IDX-CHP-3-0905"></a>
<a name="IDX-CHP-3-0906"></a>
<a name="IDX-CHP-3-0907"></a>
<p class="docText1">Lightweight processes are created in Linux by using a function named <tt class="calibre25">clone( )</tt>, which uses the following parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">fn</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Specifies a function to be executed by the new process; when the function returns, the child terminates. The function returns an integer, which represents the exit code for the child process.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">arg</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Points to data passed to the <tt class="calibre25">fn( )</tt> function.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">flags</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Miscellaneous information. The low byte specifies the signal number to be sent to the parent process when the child terminates; the <tt class="calibre25">SIGCHLD</tt> signal is generally selected. The remaining three bytes encode a group of clone flags, which are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-3-TABLE-8">Table 3-8</a>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">child_stack</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Specifies the User Mode stack pointer to be assigned to the <tt class="calibre25">esp</tt> register of the child process. The invoking process (the parent) should always allocate a new stack for the child.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">tls</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Specifies the address of a data structure that defines a Thread Local Storage segment for the new lightweight process (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-3.html#understandlk-CHP-2-SECT-3.1">The Linux GDT</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>). Meaningful only if the <tt class="calibre25">CLONE_SETTLS</tt> flag is set.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ptid</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Specifies the address of a User Mode variable of the parent process that will hold the PID of the new lightweight process. Meaningful only if the <tt class="calibre25">CLONE_PARENT_SETTID</tt> flag is set.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ctid</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Specifies the address of a User Mode variable of the new lightweight process that will hold the PID of such process. Meaningful only if the <tt class="calibre25">CLONE_CHILD_SETTID</tt> flag is set.</p></dd></dl>
<a name="understandlk-CHP-3-TABLE-8"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 3-8. Clone flags</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Flag name</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_VM</tt></p></td><td class="docTableCell"><p class="docText2">Shares the memory descriptor and all Page Tables (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-9.html#understandlk-CHP-9">Chapter 9</a>).</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_FS</tt></p></td><td class="docTableCell"><p class="docText2">Shares the table that identifies the root directory and the current working directory, as well as the value of the bitmask used to mask the initial file permissions of a new file (the so-called file umask<a name="IDX-CHP-3-0908"></a> 
).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_FILES</tt></p></td><td class="docTableCell"><p class="docText2">Shares the table that identifies the open files (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>).</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_SIGHAND</tt></p></td><td class="docTableCell"><p class="docText2">Shares the tables that identify the signal handlers and the blocked and pending signals (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>). If this flag is true, the <tt class="calibre25">CLONE_VM</tt> flag must also be set.</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_PTRACE</tt></p></td><td class="docTableCell"><p class="docText2">If traced, the parent wants the child to be traced too. Furthermore, the debugger may want to trace the child on its own; in this case, the kernel forces the flag to 1.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_VFORK</tt></p></td><td class="docTableCell"><p class="docText2">Set when the system call issued is a <tt class="calibre25">vfork( )</tt> (see later in this section).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_PARENT</tt></p></td><td class="docTableCell"><p class="docText2">Sets the parent of the child (<tt class="calibre25">parent</tt> and <tt class="calibre25">real_parent</tt> fields in the process descriptor) to the parent of the calling process.</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_THREAD</tt></p></td><td class="docTableCell"><p class="docText2">Inserts the child into the same thread group of the parent, and forces the child to share the signal descriptor of the parent. The child's <tt class="calibre25">tgid</tt> and <tt class="calibre25">group_leader</tt> fields are set accordingly. If this flag is true, the <tt class="calibre25">CLONE_SIGHAND</tt> flag must also be set.</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_NEWNS</tt></p></td><td class="docTableCell"><p class="docText2">Set if the clone needs its own namespace, that is, its own view of the mounted filesystems (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-12.html#understandlk-CHP-12">Chapter 12</a>); it is not possible to specify both <tt class="calibre25">CLONE_NEWNS</tt> and <tt class="calibre25">CLONE_FS</tt>.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_SYSVSEM</tt></p></td><td class="docTableCell"><p class="docText2">Shares the System V IPC undoable semaphore operations (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19-SECT-3.html#understandlk-CHP-19-SECT-3.3">IPC Semaphores</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19.html#understandlk-CHP-19">Chapter 19</a>).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_SETTLS</tt></p></td><td class="docTableCell"><p class="docText2">Creates a new Thread Local Storage (TLS) segment for the lightweight process; the segment is described in the structure pointed to by the <tt class="calibre25">tls</tt> parameter.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_PARENT_SETTID</tt></p></td><td class="docTableCell"><p class="docText2">Writes the PID of the child into the User Mode variable of the parent pointed to by the <tt class="calibre25">ptid</tt> parameter.</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_CHILD_CLEARTID</tt></p></td><td class="docTableCell"><p class="docText2">When set, the kernel sets up a mechanism to be triggered when the child process will exit or when it will start executing a new program. In these cases, the kernel will clear the User Mode variable pointed to by the <tt class="calibre25">ctid</tt> parameter and will awaken any process waiting for this event.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_DETACHED</tt></p></td><td class="docTableCell"><p class="docText2">A legacy flag ignored by the kernel.</p></td></tr><tr class="calibre2"><td class="docTableCell" valign="top"><p class="docText2"><tt class="calibre25">CLONE_UNTRACED</tt></p></td><td class="docTableCell"><p class="docText2">Set by the kernel to override the value of the <tt class="calibre25">CLONE_PTRACE</tt> flag (used for disabling tracing of kernel threads<a name="IDX-CHP-3-0909"></a> 
; see the section "<a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-3-SECT-4.2">Kernel Threads</a>" later in this chapter).</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_CHILD_SETTID</tt></p></td><td class="docTableCell"><p class="docText2">Writes the PID of the child into the User Mode variable of the child pointed to by the <tt class="calibre25">ctid</tt> parameter.</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">CLONE_STOPPED</tt></p></td><td class="docTableCell"><p class="docText2">Forces the child to start in the <tt class="calibre25">TASK_STOPPED</tt> state.</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1"><tt class="calibre25">clone( )</tt> is actually a wrapper function defined in the C library (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10-SECT-1.html#understandlk-CHP-10-SECT-1">POSIX APIs and System Calls</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>), which sets up the stack of the new lightweight process and invokes a <tt class="calibre25">clone( )</tt> system call hidden to the programmer. The <tt class="calibre25">sys_clone( )</tt> service routine that implements the <tt class="calibre25">clone( )</tt> system call does not have the <tt class="calibre25">fn</tt> and <tt class="calibre25">arg</tt> parameters. In fact, the wrapper function saves the pointer <tt class="calibre25">fn</tt> into the child's stack position corresponding to the return address of the wrapper function itself; the pointer <tt class="calibre25">arg</tt> is saved on the child's stack right below <tt class="calibre25">fn</tt>. When the wrapper function terminates, the CPU fetches the return address from the stack and executes the <tt class="calibre25">fn(arg)</tt> function.</p>
<p class="docText1">The traditional <tt class="calibre25">fork( )</tt> system call is implemented by Linux as a <tt class="calibre25">clone( )</tt> system call whose <tt class="calibre25">flags</tt> parameter specifies both a <tt class="calibre25">SIGCHLD</tt> signal and all the clone flags cleared, and whose <tt class="calibre25">child_stack</tt> parameter is the current parent stack pointer. Therefore, the parent and child temporarily share the same User Mode stack. But thanks to the Copy On Write mechanism, they usually get separate copies of the User Mode stack as soon as one tries to change the stack.</p>
<p class="docText1">The <tt class="calibre25">vfork( )</tt> system call, introduced in the previous section, is implemented by Linux as a <tt class="calibre25">clone( )</tt> system call whose <tt class="calibre25">flags</tt> parameter specifies both a <tt class="calibre25">SIGCHLD</tt> signal and the flags <tt class="calibre25">CLONE_VM</tt> and <tt class="calibre25">CLONE_VFORK</tt>, and whose <tt class="calibre25">child_stack</tt> parameter is equal to the current parent stack pointer.</p>
<a name="understandlk-CHP-3-SECT-4.1.1"></a>
<h5 class="docSection3Title">3.4.1.1. The do_fork( ) function</h5><a name="IDX-CHP-3-0910"></a>
<a name="IDX-CHP-3-0911"></a>
<a name="IDX-CHP-3-0912"></a>
<a name="IDX-CHP-3-0913"></a>
<a name="IDX-CHP-3-0914"></a>
<p class="docText1">The <tt class="calibre25">do_fork( )</tt> function, which handles the <tt class="calibre25">clone( )</tt>, <tt class="calibre25">fork( )</tt>, and <tt class="calibre25">vfork( )</tt> system calls, acts on the following parameters:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">clone_flags</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Same as the <tt class="calibre25">flags</tt> parameter of <tt class="calibre25">clone( )</tt></p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">stack_start</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Same as the <tt class="calibre25">child_stack</tt> parameter of <tt class="calibre25">clone( )</tt></p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">regs</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Pointer to the values of the general purpose registers saved into the Kernel Mode stack when switching from User Mode to Kernel Mode (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-6.html#understandlk-CHP-4-SECT-6.1.6">The do_IRQ( ) function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">stack_size</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Unused (always set to 0)</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">parent_tidptr, child_tidptr</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Same as the corresponding <tt class="calibre25">ptid</tt> and <tt class="calibre25">ctid</tt> parameters of <tt class="calibre25">clone()</tt></p></dd></dl>
<p class="docText1"><tt class="calibre25">do_fork( )</tt> makes use of an auxiliary function called <tt class="calibre25">copy_process( )</tt> to set up the process descriptor and any other kernel data structure required for child's execution. Here are the main steps performed by <tt class="calibre25">do_fork( )</tt>:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Allocates a new PID for the child by looking in the <tt class="calibre25">pidmap_array</tt> bitmap (see the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the <tt class="calibre25">ptrace</tt> field of the parent (<tt class="calibre25">current-&gt;ptrace</tt>): if it is not zero, the parent process is being traced by another process, thus <tt class="calibre25">do_fork( )</tt> checks whether the debugger wants to trace the child on its own (independently of the value of the <tt class="calibre25">CLONE_PTRACE</tt> flag specified by the parent); in this case, if the child is not a kernel thread (<tt class="calibre25">CLONE_UNTRACED</tt> flag cleared), the function sets the <tt class="calibre25">CLONE_PTRACE</tt> flag.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">copy_process()</tt> to make a copy of the process descriptor. If all needed resources are available, this function returns the address of the <tt class="calibre25">task_struct</tt> descriptor just created. This is the workhorse of the forking procedure, and we will describe it right after <tt class="calibre25">do_fork( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If either the <tt class="calibre25">CLONE_STOPPED</tt> flag is set or the child process must be traced, that is, the <tt class="calibre25">PT_PTRACED</tt> flag is set in <tt class="calibre25">p-&gt;ptrace</tt>, it sets the state of the child to <tt class="calibre25">TASK_STOPPED</tt> and adds a pending <tt class="calibre25">SIGSTOP</tt> signal to it (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11-SECT-1.html#understandlk-CHP-11-SECT-1">The Role of Signals</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-11.html#understandlk-CHP-11">Chapter 11</a>). The state of the child will remain <tt class="calibre25">TASK_STOPPED</tt> until another process (presumably the tracing process or the parent) will revert its state to <tt class="calibre25">TASK_RUNNING</tt>, usually by means of a <tt class="calibre25">SIGCONT</tt> signal.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">CLONE_STOPPED</tt> flag is not set, it invokes the <tt class="calibre25">wake_up_new_task( )</tt> function, which performs the following operations:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Adjusts the scheduling parameters of both the parent and the child (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-2.html#understandlk-CHP-7-SECT-2">The Scheduling Algorithm</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the child will run on the same CPU as the parent,<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-3-FN8">[*]</a></sup> and parent and child do not share the same set of page tables (<tt class="calibre25">CLONE_VM</tt> flag cleared), it then forces the child to run before the parent by inserting it into the parent's runqueue right before the parent. This simple step yields better performance if the child flushes its address space and executes a new program right after the forking. If we let the parent run first, the Copy On Write mechanism would give rise to a series of unnecessary page duplications.</p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-3-FN8">[*]</a></sup> The parent process might be moved on to another CPU while the kernel forks the new process.</p></blockquote></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the child will not be run on the same CPU as the parent, or if parent and child share the same set of page tables (<tt class="calibre25">CLONE_VM</tt> flag set), it inserts the child in the last position of the parent's runqueue.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">CLONE_STOPPED</tt> flag is set, it puts the child in the <tt class="calibre25">TASK_STOPPED</tt> state.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the parent process is being traced, it stores the PID of the child in the <tt class="calibre25">ptrace_message</tt> field of <tt class="calibre25">current</tt> and invokes <tt class="calibre25">ptrace_notify( )</tt>, which essentially stops the current process and sends a <tt class="calibre25">SIGCHLD</tt> signal to its parent. The "grandparent" of the child is the debugger that is tracing the parent; the <tt class="calibre25">SIGCHLD</tt> signal notifies the debugger that <tt class="calibre25">current</tt> has forked a child, whose PID can be retrieved by looking into the <tt class="calibre25">current-&gt;ptrace_message</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">CLONE_VFORK</tt> flag is specified, it inserts the parent process in a wait queue and suspends it until the child releases its memory address space (that is, until the child either terminates or executes a new program).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Terminates by returning the PID of the child.</p></div></li></ol></div>
<a name="understandlk-CHP-3-SECT-4.1.2"></a>
<h5 class="docSection3Title">3.4.1.2. The copy_process( ) function</h5><a name="IDX-CHP-3-0915"></a>
<a name="IDX-CHP-3-0916"></a>
<a name="IDX-CHP-3-0917"></a>
<a name="IDX-CHP-3-0918"></a>
<a name="IDX-CHP-3-0919"></a>
<a name="IDX-CHP-3-0920"></a>
<a name="IDX-CHP-3-0921"></a>
<a name="IDX-CHP-3-0922"></a>
<a name="IDX-CHP-3-0923"></a>
<a name="IDX-CHP-3-0924"></a>
<a name="IDX-CHP-3-0925"></a>
<a name="IDX-CHP-3-0926"></a>
<a name="IDX-CHP-3-0927"></a>
<a name="IDX-CHP-3-0928"></a>
<a name="IDX-CHP-3-0929"></a>
<a name="IDX-CHP-3-0930"></a>
<a name="IDX-CHP-3-0931"></a>
<a name="IDX-CHP-3-0932"></a>
<a name="IDX-CHP-3-0933"></a>
<a name="IDX-CHP-3-0934"></a>
<a name="IDX-CHP-3-0935"></a>
<a name="IDX-CHP-3-0936"></a>
<p class="docText1">The <tt class="calibre25">copy_process( )</tt> function sets up the process descriptor and any other kernel data structure required for a child's execution. Its parameters are the same as <tt class="calibre25">do_fork( )</tt>, plus the PID of the child. Here is a description of its most significant steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the flags passed in the <tt class="calibre25">clone_flags</tt> parameter are compatible. In particular, it returns an error code in the following cases:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Both the flags <tt class="calibre25">CLONE_NEWNS</tt> and <tt class="calibre25">CLONE_FS</tt> are set.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">CLONE_THREAD</tt> flag is set, but the <tt class="calibre25">CLONE_SIGHAND</tt> flag is cleared (lightweight processes in the same thread group must share signals).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">CLONE_SIGHAND</tt> flag is set, but the <tt class="calibre25">CLONE_VM</tt> flag is cleared (lightweight processes sharing the signal handlers must also share the memory descriptor).</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Performs any additional security checks by invoking <tt class="calibre25">security_task_create( )</tt> and, later, <tt class="calibre25">security_task_alloc( )</tt>. The Linux kernel 2.6 offers hooks for security extensions that enforce a security model stronger than the one adopted by traditional Unix. See <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a> for details.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">dup_task_struct( )</tt> to get the process descriptor for the child. This function performs the following actions:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Invokes _ _<tt class="calibre25">unlazy_fpu( )</tt> on the current process to save, if necessary, the contents of the FPU, MMX, and SSE/SSE2 registers in the <tt class="calibre25">thread_info</tt> structure of the parent. Later, <tt class="calibre25">dup_task_struct( )</tt> will copy these values in the <tt class="calibre25">thread_info</tt> structure of the child.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">alloc_task_struct( )</tt> macro to get a process descriptor (<tt class="calibre25">task_struct</tt> structure) for the new process, and stores its address in the <tt class="calibre25">tsk</tt> local variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">alloc_thread_info</tt> macro to get a free memory area to store the <tt class="calibre25">thread_info</tt> structure and the Kernel Mode stack of the new process, and saves its address in the <tt class="calibre25">ti</tt> local variable. As explained in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-2.html#understandlk-CHP-3-SECT-2.2">Identifying a Process</a>," the size of this memory area is either 8 KB or 4 KB.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the contents of the <tt class="calibre25">current</tt>'s process descriptor into the <tt class="calibre25">task_struct</tt> structure pointed to by <tt class="calibre25">tsk</tt>, then sets <tt class="calibre25">tsk-&gt;thread_info</tt> to <tt class="calibre25">ti</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Copies the contents of the <tt class="calibre25">current</tt>'s <tt class="calibre25">thread_info</tt> descriptor into the structure pointed to by <tt class="calibre25">ti</tt>, then sets <tt class="calibre25">ti-&gt;task</tt> to <tt class="calibre25">tsk</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the usage counter of the new process descriptor (<tt class="calibre25">tsk-&gt;usage</tt>) to 2 to specify that the process descriptor is in use and that the corresponding process is alive (its state is not <tt class="calibre25">EXIT_ZOMBIE</tt> or <tt class="calibre25">EXIT_DEAD</tt>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns the process descriptor pointer of the new process (<tt class="calibre25">tsk</tt>).</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks whether the value stored in <tt class="calibre25">current-&gt;signal-&gt;rlim[RLIMIT_NPROC]</tt>.<tt class="calibre25">rlim_cur</tt> is smaller than or equal to the current number of processes owned by the user. If so, an error code is returned, unless the process has root privileges. The function gets the current number of processes owned by the user from a per-user data structure named <tt class="calibre25">user_struct</tt>. This data structure can be found through a pointer in the <tt class="calibre25">user</tt> field of the process descriptor.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases the usage counter of the <tt class="calibre25">user_struct</tt> structure (<tt class="calibre25">tsk-&gt;user-&gt;_ _count</tt> field) and the counter of the processes owned by the user (<tt class="calibre25">tsk-&gt;user-&gt;processes</tt>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks that the number of processes in the system (stored in the <tt class="calibre25">nr_threads</tt> variable) does not exceed the value of the <tt class="calibre25">max_threads</tt> variable. The default value of this variable depends on the amount of RAM in the system. The general rule is that the space taken by all <tt class="calibre25">tHRead_info</tt> descriptors and Kernel Mode stacks cannot exceed 1/8 of the physical memory. However, the system administrator may change this value by writing in the <i class="docEmphasis">/proc/sys/kernel/threads-max</i> file.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the kernel functions implementing the execution domain and the executable format (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>) of the new process are included in kernel modules, it increases their usage counters (see Appendix B).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets a few crucial fields related to the process state:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the big kernel lock<a name="IDX-CHP-3-0937"></a> 
 counter <tt class="calibre25">tsk-&gt;lock_depth</tt> to <tt class="calibre25">-</tt>1 (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-4.html#understandlk-CHP-5-SECT-4.2">The Big Kernel Lock</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">tsk-&gt;did_exec</tt> field to 0: it counts the number of <tt class="calibre25">execve( )</tt><a name="IDX-CHP-3-0938"></a> 
 system calls issued by the process.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Updates some of the flags included in the <tt class="calibre25">tsk-&gt;flags</tt> field that have been copied from the parent process: first clears the <tt class="calibre25">PF_SUPERPRIV</tt> flag, which indicates whether the process has used any of its superuser privileges, then sets the <tt class="calibre25">PF_FORKNOEXEC</tt> flag, which indicates that the child has not yet issued an <tt class="calibre25">execve( )</tt> system call.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Stores the PID of the new process in the <tt class="calibre25">tsk-&gt;pid</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the <tt class="calibre25">CLONE_PARENT_SETTID</tt> flag in the <tt class="calibre25">clone_flags</tt> parameter is set, it copies the child's PID into the User Mode variable addressed by the <tt class="calibre25">parent_tidptr</tt> parameter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">list_head</tt> data structures and the spin locks included in the child's process descriptor, and sets up several other fields related to pending signals, timers, and time statistics.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">copy_semundo( )</tt>, <tt class="calibre25">copy_files( )</tt>, <tt class="calibre25">copy_fs( )</tt>, <tt class="calibre25">copy_sighand( )</tt>, <tt class="calibre25">copy_signal( )</tt>, <tt class="calibre25">copy_mm( )</tt>, and <tt class="calibre25">copy_namespace( )</tt> to create new data structures and copy into them the values of the corresponding parent process data structures, unless specified differently by the <tt class="calibre25">clone_flags</tt> parameter.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">copy_thread( )</tt> to initialize the Kernel Mode stack of the child process with the values contained in the CPU registers when the <tt class="calibre25">clone( )</tt> system call was issued (these values have been saved in the Kernel Mode stack of the parent, as described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>). However, the function forces the value 0 into the field corresponding to the <tt class="calibre25">eax</tt> register (this is the child's return value of the <tt class="calibre25">fork()</tt> or <tt class="calibre25">clone( )</tt> system call). The <tt class="calibre25">tHRead.esp</tt> field in the descriptor of the child process is initialized with the base address of the child's Kernel Mode stack, and the address of an assembly language function (<tt class="calibre25">ret_from_fork( )</tt>) is stored in the <tt class="calibre25">thread.eip</tt> field. If the parent process makes use of an I/O Permission Bitmap, the child gets a copy of such bitmap. Finally, if the <tt class="calibre25">CLONE_SETTLS</tt> flag is set, the child gets the TLS segment specified by the User Mode data structure pointed to by the <tt class="calibre25">tls</tt> parameter of the <tt class="calibre25">clone( )</tt> system call.<sup class="docFootnote"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-3-FN9">[*]</a></sup></p><blockquote class="calibre22"><p class="docFootnote2"><sup class="calibre24"><a name="understandlk-CHP-3-FN9">[*]</a></sup> A careful reader might wonder how <tt class="calibre42">copy_thread( )</tt> gets the value of the <tt class="calibre42">tls</tt> parameter of <tt class="calibre42">clone( )</tt>, because <tt class="calibre42">tls</tt> is not passed to <tt class="calibre42">do_fork( )</tt> and nested functions. As we'll see in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>, the parameters of the system calls are usually passed to the kernel by copying their values into some CPU register; thus, these values are saved in the Kernel Mode stack together with the other registers. The <tt class="calibre42">copy_thread( )</tt> function just looks at the address saved in the Kernel Mode stack location corresponding to the value of <tt class="calibre42">esi</tt>.</p></blockquote></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If either <tt class="calibre25">CLONE_CHILD_SETTID</tt> or <tt class="calibre25">CLONE_CHILD_CLEARTID</tt> is set in the <tt class="calibre25">clone_flags</tt> parameter, it copies the value of the <tt class="calibre25">child_tidptr</tt> parameter in the <tt class="calibre25">tsk-&gt;set_chid_tid</tt> or <tt class="calibre25">tsk-&gt;clear_child_tid</tt> field, respectively. These flags specify that the value of the variable pointed to by <tt class="calibre25">child_tidptr</tt> in the User Mode address space of the child has to be changed, although the actual write operations will be done later.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Turns off the <tt class="calibre25">TIF_SYSCALL_TRACE</tt> flag in the <tt class="calibre25">tHRead_info</tt> structure of the child, so that the <tt class="calibre25">ret_from_fork( )</tt> function will not notify the debugging process about the system call termination (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10-SECT-3.html#understandlk-CHP-10-SECT-3">Entering and Exiting a System Call</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-10.html#understandlk-CHP-10">Chapter 10</a>). (The system call tracing of the child is not disabled, because it is controlled by the <tt class="calibre25">PTRACE_SYSCALL</tt> flag in <tt class="calibre25">tsk-&gt;ptrace</tt>.)</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the <tt class="calibre25">tsk-&gt;exit_signal</tt> field with the signal number encoded in the low bits of the <tt class="calibre25">clone_flags</tt> parameter, unless the <tt class="calibre25">CLONE_THREAD</tt> flag is set, in which case initializes the field to <tt class="calibre25">-</tt>1. As we'll see in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-5.html#understandlk-CHP-3-SECT-5.1">Process Termination</a>" later in this chapter, only the death of the last member of a thread group (usually, the thread group leader) causes a signal notifying the parent of the thread group leader.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">sched_fork( )</tt> to complete the initialization of the scheduler data structure of the new process. The function also sets the state of the new process to <tt class="calibre25">TASK_RUNNING</tt> and sets the <tt class="calibre25">preempt_count</tt> field of the <tt class="calibre25">tHRead_info</tt> structure to 1, thus disabling kernel preemption (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5-SECT-1.html#understandlk-CHP-5-SECT-1.1">Kernel Preemption</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-5.html#understandlk-CHP-5">Chapter 5</a>). Moreover, in order to keep process scheduling fair, the function shares the remaining timeslice of the parent between the parent and the child (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.1">The scheduler_tick( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">cpu</tt> field in the <tt class="calibre25">thread_info</tt> structure of the new process to the number of the local CPU returned by <tt class="calibre25">smp_processor_id( )</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes the fields that specify the parenthood relationships. In particular, if <tt class="calibre25">CLONE_PARENT</tt> or <tt class="calibre25">CLONE_THREAD</tt> are set, it initializes <tt class="calibre25">tsk-&gt;real_parent</tt> and <tt class="calibre25">tsk-&gt;parent</tt> to the value in <tt class="calibre25">current-&gt;real_parent</tt>; the parent of the child thus appears as the parent of the current process. Otherwise, it sets the same fields to <tt class="calibre25">current</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the child does not need to be traced (<tt class="calibre25">CLONE_PTRACE</tt> flag not set), it sets the <tt class="calibre25">tsk-&gt;ptrace</tt> field to 0. This field stores a few flags used when a process is being traced by another process. In such a way, even if the current process is being traced, the child will not.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Executes the <tt class="calibre25">SET_LINKS</tt> macro to insert the new process descriptor in the process list.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the child must be traced (<tt class="calibre25">PT_PTRACED</tt> flag in the <tt class="calibre25">tsk-&gt;ptrace</tt> field set), it sets <tt class="calibre25">tsk-&gt;parent</tt> to <tt class="calibre25">current-&gt;parent</tt> and inserts the child into the trace list of the debugger.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">attach_pid( )</tt> to insert the PID of the new process descriptor in the <tt class="calibre25">pidhash[PIDTYPE_PID]</tt> hash table.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the child is a thread group leader (flag <tt class="calibre25">CLONE_THREAD</tt> cleared):</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes <tt class="calibre25">tsk-&gt;tgid</tt> to <tt class="calibre25">tsk-&gt;pid</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes <tt class="calibre25">tsk-&gt;group_leader</tt> to <tt class="calibre25">tsk</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes three times <tt class="calibre25">attach_pid( )</tt> to insert the child in the PID hash tables of type <tt class="calibre25">PIDTYPE_TGID</tt>, <tt class="calibre25">PIDTYPE_PGID</tt>, and <tt class="calibre25">PIDTYPE_SID</tt>.</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Otherwise, if the child belongs to the thread group of its parent (<tt class="calibre25">CLONE_THREAD</tt> flag set):</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Initializes <tt class="calibre25">tsk-&gt;tgid</tt> to <tt class="calibre25">tsk-&gt;current-&gt;tgid</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Initializes <tt class="calibre25">tsk-&gt;group_leader</tt> to the value in <tt class="calibre25">current-&gt;group_leader</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">attach_pid( )</tt> to insert the child in the <tt class="calibre25">PIDTYPE_TGID</tt> hash table (more specifically, in the per-PID list of the <tt class="calibre25">current-&gt;group_leader</tt> process).</p></div></li></ol></div></div></li><li class="calibre12"><div class="calibre45"><p class="docList">A new process has now been added to the set of processes: increases the value of the <tt class="calibre25">nr_threads</tt> variable.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Increases the <tt class="calibre25">total_forks</tt> variable to keep track of the number of forked processes.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Terminates by returning the child's process descriptor pointer (<tt class="calibre25">tsk</tt>).</p></div></li></ol></div>
<p class="docText1">Let's go back to what happens after <tt class="calibre25">do_fork()</tt> terminates. Now we have a complete child process in the runnable state. But it isn't actually running. It is up to the scheduler to decide when to give the CPU to this child. At some future process switch, the schedule bestows this favor on the child process by loading a few CPU registers with the values of the <tt class="calibre25">thread</tt> field of the child's process descriptor. In particular, <tt class="calibre25">esp</tt> is loaded with <tt class="calibre25">thread.esp</tt> (that is, with the address of child's Kernel Mode stack), and <tt class="calibre25">eip</tt> is loaded with the address of <tt class="calibre25">ret_from_fork( )</tt>. This assembly language function invokes the <tt class="calibre25">schedule_tail( )</tt> function (which in turn invokes the <tt class="calibre25">finish_task_switch( )</tt> function to complete the process switch; see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7-SECT-4.html#understandlk-CHP-7-SECT-4.4">The schedule( ) Function</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-7.html#understandlk-CHP-7">Chapter 7</a>), reloads all other registers with the values stored in the stack, and forces the CPU back to User Mode. The new process then starts its execution right at the end of the <tt class="calibre25">fork( )</tt>, <tt class="calibre25">vfork( )</tt>, or <tt class="calibre25">clone( )</tt> system call. The value returned by the system call is contained in <tt class="calibre25">eax</tt>: the value is 0 for the child and equal to the PID for the child's parent. To understand how this is done, look back at what <tt class="calibre25">copy_thread()</tt> does on the <tt class="calibre25">eax</tt> register of the child's process (step 13 of <tt class="calibre25">copy_process()</tt>).</p>
<p class="docText1">The child process executes the same code as the parent, except that the fork returns a 0 (see step 13 of <tt class="calibre25">copy_process( )</tt>). The developer of the application can exploit this fact, in a manner familiar to Unix programmers, by inserting a conditional statement in the program based on the PID value that forces the child to behave differently from the parent process.</p>
<a name="understandlk-CHP-3-SECT-4.2"></a>
<h4 class="docSection2Title">3.4.2. Kernel Threads</h4><a name="IDX-CHP-3-0939"></a>
<p class="docText1">Traditional Unix systems delegate some critical tasks to intermittently running processes, including flushing disk caches, swapping out unused pages, servicing network connections, and so on. Indeed, it is not efficient to perform these tasks in strict linear fashion; both their functions and the end user processes get better response if they are scheduled in the background. Because some of the system processes run only in Kernel Mode, modern operating systems delegate their functions to <span class="docEmphasis">kernel threads</span><a name="IDX-CHP-3-0940"></a> 
, which are not encumbered with the unnecessary User Mode context. In Linux, kernel threads differ from regular processes in the following ways:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Kernel threads run only in Kernel Mode, while regular processes run alternatively in Kernel Mode and in User Mode.</p></li><li class="calibre12"><p class="docText1">Because kernel threads run only in Kernel Mode, they use only linear addresses greater than <tt class="calibre25">PAGE_OFFSET</tt>. Regular processes, on the other hand, use all four gigabytes of linear addresses, in either User Mode or Kernel Mode.</p></li></ul>
<a name="understandlk-CHP-3-SECT-4.2.1"></a>
<h5 class="docSection3Title">3.4.2.1. Creating a kernel thread</h5>
<p class="docText1">The <tt class="calibre25">kernel_thread( )</tt> function creates a new kernel thread. It receives as parameters the address of the kernel function to be executed (<tt class="calibre25">fn</tt>), the argument to be passed to that function (<tt class="calibre25">arg</tt>), and a set of clone flags (<tt class="calibre25">flags</tt>). The function essentially invokes <tt class="calibre25">do_fork( )</tt> as follows:</p>
<pre class="calibre27">
    do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, pregs, 0, NULL, NULL);</pre><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">CLONE_VM</tt> flag avoids the duplication of the page tables of the calling process: this duplication would be a waste of time and memory, because the new kernel thread will not access the User Mode address space anyway. The <tt class="calibre25">CLONE_UNTRACED</tt> flag ensures that no process will be able to trace the new kernel thread, even if the calling process is being traced.</p>
<p class="docText1">The <tt class="calibre25">pregs</tt> parameter passed to <tt class="calibre25">do_fork( )</tt> corresponds to the address in the Kernel Mode stack where the <tt class="calibre25">copy_thread( )</tt> function will find the initial values of the CPU registers for the new thread. The <tt class="calibre25">kernel_thread( )</tt> function builds up this stack area so that:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The <tt class="calibre25">ebx</tt> and <tt class="calibre25">edx</tt> registers will be set by <tt class="calibre25">copy_thread()</tt> to the values of the parameters <tt class="calibre25">fn</tt> and <tt class="calibre25">arg</tt>, respectively.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">eip</tt> register will be set to the address of the following assembly language fragment:</p><pre class="calibre27">
    movl %edx,%eax
    pushl %edx
    call *%ebx
    pushl %eax
    call do_exit</pre><br class="calibre7"/>
</li></ul>
<p class="docText1">Therefore, the new kernel thread starts by executing the <tt class="calibre25">fn(arg)</tt> function. If this function terminates, the kernel thread executes the <tt class="calibre25">_exit( )</tt><a name="IDX-CHP-3-0941"></a> 
 system call passing to it the return value of <tt class="calibre25">fn( )</tt> (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-3-SECT-5.html#understandlk-CHP-3-SECT-5">Destroying Processes</a>" later in this chapter).</p>
<a name="understandlk-CHP-3-SECT-4.2.2"></a>
<h5 class="docSection3Title">3.4.2.2. Process 0</h5><a name="IDX-CHP-3-0942"></a>
<a name="IDX-CHP-3-0943"></a>
<a name="IDX-CHP-3-0944"></a>
<a name="IDX-CHP-3-0945"></a>
<a name="IDX-CHP-3-0946"></a>
<a name="IDX-CHP-3-0947"></a>
<a name="IDX-CHP-3-0948"></a>
<a name="IDX-CHP-3-0949"></a>
<a name="IDX-CHP-3-0950"></a>
<a name="IDX-CHP-3-0951"></a>
<a name="IDX-CHP-3-0952"></a>
<a name="IDX-CHP-3-0953"></a>
<a name="IDX-CHP-3-0954"></a>
<p class="docText1">The ancestor of all processes, called <span class="docEmphasis">process 0</span>, the <span class="docEmphasis">idle process</span>, or, for historical reasons, the <span class="docEmphasis">swapper process</span>, is a kernel thread created from scratch during the initialization phase of Linux (see Appendix A). This ancestor process uses the following statically allocated data structures (data structures for all other processes are dynamically allocated):</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">A process descriptor stored in the <tt class="calibre25">init_task</tt> variable, which is initialized by the <tt class="calibre25">INIT_TASK</tt> macro.</p></li><li class="calibre12"><p class="docText1">A <tt class="calibre25">thread_info</tt> descriptor and a Kernel Mode stack stored in the <tt class="calibre25">init_thread_union</tt> variable and initialized by the <tt class="calibre25">INIT_THREAD_INFO</tt> macro.</p></li><li class="calibre12"><p class="docText1">The following tables, which the process descriptor points to:</p><ul class="calibre61"><li class="calibre12"><p class="docText1"><tt class="calibre25">init_mm</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">init_fs</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">init_files</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">init_signals</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">init_sighand</tt></p></li></ul><p class="docText1">The tables are initialized, respectively, by the following macros:</p><ul class="calibre61"><li class="calibre12"><p class="docText1"><tt class="calibre25">INIT_MM</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">INIT_FS</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">INIT_FILES</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">INIT_SIGNALS</tt></p></li><li class="calibre12"><p class="docText1"><tt class="calibre25">INIT_SIGHAND</tt></p></li></ul></li><li class="calibre12"><p class="docText1">The master kernel Page Global Directory stored in <tt class="calibre25">swapper_pg_dir</tt> (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2-SECT-5.html#understandlk-CHP-2-SECT-5.5">Kernel Page Tables</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-2.html#understandlk-CHP-2">Chapter 2</a>).</p></li></ul>
<p class="docText1">The <tt class="calibre25">start_kernel( )</tt> function initializes all the data structures needed by the kernel, enables interrupts, and creates another kernel thread, named <span class="docEmphasis">process 1</span> (more commonly referred to as the <span class="docEmphasis">init process</span><a name="IDX-CHP-3-0955"></a> 
):</p>
<pre class="calibre27">
    kernel_thread(init, NULL, CLONE_FS|CLONE_SIGHAND);</pre><br class="calibre7"/>
<p class="docText1">The newly created kernel thread has PID 1 and shares all per-process kernel data structures with process 0. When selected by the scheduler, the <span class="docEmphasis">init</span> process starts executing the <tt class="calibre25">init( )</tt> function.</p>
<p class="docText1">After having created the <span class="docEmphasis">init</span> process, process 0 executes the <tt class="calibre25">cpu_idle( )</tt> function, which essentially consists of repeatedly executing the <tt class="calibre25">hlt</tt><a name="IDX-CHP-3-0956"></a> 
 assembly language instruction with the interrupts enabled (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>). Process 0 is selected by the scheduler only when there are no other processes in the <tt class="calibre25">TASK_RUNNING</tt> state.</p>
<p class="docText1">In multiprocessor systems there is a process 0 for each CPU. Right after the power-on, the BIOS of the computer starts a single CPU while disabling the others. The swapper process running on CPU 0 initializes the kernel data structures, then enables the other CPUs and creates the additional <span class="docEmphasis">swapper</span> processes by means of the <tt class="calibre25">copy_process( )</tt> function passing to it the value 0 as the new PID. Moreover, the kernel sets the <tt class="calibre25">cpu</tt> field of the <tt class="calibre25">tHRead_info</tt> descriptor of each forked process to the proper CPU index.</p>
<a name="understandlk-CHP-3-SECT-4.2.3"></a>
<h5 class="docSection3Title">3.4.2.3. Process 1</h5><a name="IDX-CHP-3-0957"></a>
<a name="IDX-CHP-3-0958"></a>
<a name="IDX-CHP-3-0959"></a>
<p class="docText1">The kernel thread created by process 0 executes the <tt class="calibre25">init( )</tt> function, which in turn completes the initialization of the kernel. Then <tt class="calibre25">init( )</tt> invokes the <tt class="calibre25">execve( )</tt><a name="IDX-CHP-3-0960"></a> 
 system call to load the executable program <span class="docEmphasis">init</span>. As a result, the <span class="docEmphasis">init</span> kernel thread becomes a regular process having its own per-process kernel data structure (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-20.html#understandlk-CHP-20">Chapter 20</a>). The <span class="docEmphasis">init</span> process stays alive until the system is shut down, because it creates and monitors the activity of all processes that implement the outer layers of the operating system.</p>
<a name="understandlk-CHP-3-SECT-4.2.4"></a>
<h5 class="docSection3Title">3.4.2.4. Other kernel threads</h5>
<p class="docText1">Linux uses many other kernel threads. Some of them are created in the initialization phase and run until shutdown; others are created "on demand," when the kernel must execute a task that is better performed in its own execution context.</p>
<p class="docText1">A few examples of kernel threads (besides process 0 and process 1) are:</p>
<a name="IDX-CHP-3-0961"></a><a name="IDX-CHP-3-0962"></a><a name="IDX-CHP-3-0963"></a><a name="IDX-CHP-3-0964"></a><a name="IDX-CHP-3-0965"></a><a name="IDX-CHP-3-0966"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">keventd (also called events)</span></span></p></dt><a name="IDX-CHP-3-0961"></a>
<dd class="calibre20"><p class="docList">Executes the functions in the <tt class="calibre25">keventd_wq</tt> workqueue (see <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>).</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">kapmd</span></span></p></dt><a name="IDX-CHP-3-0962"></a>
<dd class="calibre20"><p class="docList">Handles the events related to the Advanced Power Management (APM).</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">kswapd</span></span></p></dt><a name="IDX-CHP-3-0963"></a>
<dd class="calibre20"><p class="docList">Reclaims memory, as described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17-SECT-3.html#understandlk-CHP-17-SECT-3.4">Periodic Reclaiming</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-17.html#understandlk-CHP-17">Chapter 17</a>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">pdflush</span></span></p></dt><a name="IDX-CHP-3-0964"></a>
<dd class="calibre20"><p class="docList">Flushes "dirty" buffers to disk to reclaim memory, as described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-3.html#understandlk-CHP-15-SECT-3.1">The pdflush Kernel Threads</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">kblockd</span></span></p></dt><a name="IDX-CHP-3-0965"></a>
<dd class="calibre20"><p class="docList">Executes the functions in the <tt class="calibre25">kblockd_workqueue</tt> workqueue. Essentially, it periodically activates the block device drivers, as described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-3.html#understandlk-CHP-14-SECT-3.3">Activating the Block Device Driver</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14.html#understandlk-CHP-14">Chapter 14</a>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">ksoftirqd</span></span></p></dt><a name="IDX-CHP-3-0966"></a>
<dd class="calibre20"><p class="docList">Runs the tasklets (see section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4-SECT-7.html#understandlk-CHP-4-SECT-7">Softirqs and Tasklets</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-4.html#understandlk-CHP-4">Chapter 4</a>); there is one of these kernel threads for each CPU in the system.</p></dd></dl>

<br class="calibre7"/>

</div>

{% endraw %}

