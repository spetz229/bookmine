---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-14-SECT-1.html
next: understandlk-CHP-14-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-14-SECT-2"></a>
<h3 class="docSection1Title" id="534871-926">14.2. The Generic Block Layer</h3><a name="IDX-CHP-14-3606"></a>
<a name="IDX-CHP-14-3607"></a>
<p class="docText1">The generic block layer is a kernel component that handles the requests for all block devices in the system. Thanks to its functions, the kernel may easily:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">Put data buffers in high memorythe page frame(s) will be mapped in the kernel linear address space only when the CPU must access the data, and will be unmapped right after.</p></li><li class="calibre12"><p class="docText1">Implementwith some additional efforta "zero-copy" schema, where disk data is directly put in the User Mode address space without being copied to kernel memory first; essentially, the buffer used by the kernel for the I/O transfer lies in a page frame mapped in the User Mode linear address space of a process.</p></li><li class="calibre12"><p class="docText1">Manage logical volumessuch as those used by LVM (the Logical Volume Manager) and RAID (Redundant Array of Inexpensive Disks): several disk partitions, even on different block devices, can be seen as a single partition.</p></li><li class="calibre12"><p class="docText1">Exploit the advanced features of the most recent disk controllers, such as large onboard disk caches<a name="IDX-CHP-14-3608"></a> 
, enhanced DMA capabilities, onboard scheduling of the I/O transfer requests, and so on.</p></li></ul>
<a name="understandlk-CHP-14-SECT-2.1"></a>
<h4 class="docSection2Title">14.2.1. The Bio Structure</h4><a name="IDX-CHP-14-3609"></a>
<a name="IDX-CHP-14-3610"></a>
<a name="IDX-CHP-14-3611"></a>
<p class="docText1">The core data structure of the generic block layer is a descriptor of an ongoing I/O block device operation called <span class="docEmphasis">bio</span>. Each bio essentially includes an identifier for a disk storage areathe initial sector number and the number of sectors included in the storage areaand one or more segments describing the memory areas involved in the I/O operation. A bio is implemented by the <tt class="calibre25">bio</tt> data structure, whose fields are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-14-TABLE-1">Table 14-1</a>.</p>
<a name="understandlk-CHP-14-TABLE-1"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 14-1. The fields of the bio structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sector_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_sector</tt></p></td><td class="docTableCell"><p class="docText2">First sector on disk of block I/O operation</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct bio *</p></td><td class="docTableCell"><p class="docText2">bi_next</p></td><td class="docTableCell"><p class="docText2">Link to the next bio in the request queue</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">block_device *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_bdev</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to block device descriptor</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_flags</tt></p></td><td class="docTableCell"><p class="docText2">Bio status flags</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_rw</tt></p></td><td class="docTableCell"><p class="docText2">I/O operation flags</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned short</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_vcnt</tt></p></td><td class="docTableCell"><p class="docText2">Number of segments in the bio's <tt class="calibre25">bio_vec</tt> array</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned short</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_idx</tt></p></td><td class="docTableCell"><p class="docText2">Current index in the bio's <tt class="calibre25">bio_vec</tt> array of segments</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned short</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_phys_segments</tt></p></td><td class="docTableCell"><p class="docText2">Number of physical segments of the bio after merging</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned short</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_hw_segments</tt></p></td><td class="docTableCell"><p class="docText2">Number of hardware segments after merging</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_size</tt></p></td><td class="docTableCell"><p class="docText2">Bytes (yet) to be transferred</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned int</p></td><td class="docTableCell"><p class="docText2">bi_hw_front_size</p></td><td class="docTableCell"><p class="docText2">Used by the hardware segment merge algorithm</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">unsigned int</p></td><td class="docTableCell"><p class="docText2">bi_hw_back_size</p></td><td class="docTableCell"><p class="docText2">Used by the hardware segment merge algorithm</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bi_max_vecs</tt></p></td><td class="docTableCell"><p class="docText2">Maximum allowed number of segments in the bio's <tt class="calibre25">bio_vec</tt> array</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">struct bio_vec *</p></td><td class="docTableCell"><p class="docText2">bi_io_vec</p></td><td class="docTableCell"><p class="docText2">Pointer to the bio's <tt class="calibre25">bio_vec</tt> array of segments</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">bio_end_io_t *</p></td><td class="docTableCell"><p class="docText2">bi_end_io</p></td><td class="docTableCell"><p class="docText2">Method invoked at the end of bio's I/O operation</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">atomic_t</p></td><td class="docTableCell"><p class="docText2">bi_cnt</p></td><td class="docTableCell"><p class="docText2">Reference counter for the <tt class="calibre25">bio</tt></p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">void *</p></td><td class="docTableCell"><p class="docText2">bi_private</p></td><td class="docTableCell"><p class="docText2">Pointer used by the generic block layer and the I/O completion method of the block device driver</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2">bio_destructor_t *</p></td><td class="docTableCell"><p class="docText2">bi_destructor</p></td><td class="docTableCell"><p class="docText2">Destructor method (usually <tt class="calibre25">bio_destructor()</tt>) invoked when the bio is being freed</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Each segment in a bio is represented by a <tt class="calibre25">bio_vec</tt> data structure, whose fields are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-14-TABLE-2">Table 14-2</a>. The <tt class="calibre25">bi_io_vec</tt> field of the bio points to the first element of an array of <tt class="calibre25">bio_vec</tt> data structures, while the <tt class="calibre25">bi_vcnt</tt> field stores the current number of elements in the array.</p>
<a name="understandlk-CHP-14-TABLE-2"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 14-2. The fields of the bio_vec structure</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct page *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bv_page</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the page descriptor of the segment's page frame</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bv_len</tt></p></td><td class="docTableCell"><p class="docText2">Length of the segment in bytes</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">bv_offset</tt></p></td><td class="docTableCell"><p class="docText2">Offset of the segment's data in the page frame</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The contents of a <tt class="calibre25">bio</tt> descriptor keep changing during the block I/O operation. For instance, if the block device driver cannot perform the whole data transfer with one scatter-gather DMA operation, the <tt class="calibre25">bi_idx</tt> field is updated to keep track of the first segment in the bio that is yet to be transferred. To iterate over the segments of a biostarting from the current segment at index <tt class="calibre25">bi_idx</tt>a device driver can execute the <tt class="calibre25">bio_for_each_segment</tt> macro.</p>
<p class="docText1">When the generic block layer starts a new I/O operation, it allocates a new bio structure by invoking the <tt class="calibre25">bio_alloc( )</tt> function. Usually, bios are allocated through the slab allocator, but the kernel also keeps a small memory pool of bios to be used when memory is scarce (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8-SECT-2.html#understandlk-CHP-8-SECT-2.15">Memory Pools</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-8.html#understandlk-CHP-8">Chapter 8</a>). The kernel also keeps a memory pool for the <tt class="calibre25">bio_vec</tt> structuresafter all, it would not make sense to allocate a bio without being able to allocate the segment descriptors to be included in the bio. Correspondingly, the <tt class="calibre25">bio_put( )</tt> function decrements the reference counter (<tt class="calibre25">bi_cnt</tt>) of a bio and, if the counter becomes zero, it releases the bio structure and the related <tt class="calibre25">bio_vec</tt> structures.</p>
<a name="understandlk-CHP-14-SECT-2.2"></a>
<h4 class="docSection2Title">14.2.2. Representing Disks and Disk Partitions</h4><a name="IDX-CHP-14-3612"></a>
<a name="IDX-CHP-14-3613"></a>
<a name="IDX-CHP-14-3614"></a>
<a name="IDX-CHP-14-3615"></a>
<a name="IDX-CHP-14-3616"></a>
<a name="IDX-CHP-14-3617"></a>
<a name="IDX-CHP-14-3618"></a>
<a name="IDX-CHP-14-3619"></a>
<p class="docText1">A <span class="docEmphasis">disk</span> is a logical block device that is handled by the generic block layer. Usually a disk corresponds to a hardware block device such as a hard disk, a floppy disk, or a CD-ROM disk. However, a disk can be a virtual device built upon several physical disk partitions, or a storage area living in some dedicated pages of RAM. In any case, the upper kernel components operate on all disks<a name="IDX-CHP-14-3620"></a> 
 in the same way thanks to the services offered by the generic block layer.</p>
<p class="docText1">A disk is represented by the <tt class="calibre25">gendisk</tt> object, whose fields are shown in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-14-TABLE-3">Table 14-3</a>.</p>
<a name="understandlk-CHP-14-TABLE-3"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 14-3. The fields of the gendisk object</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">major</tt></p></td><td class="docTableCell"><p class="docText2">Major number of the disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">first_minor</tt></p></td><td class="docTableCell"><p class="docText2">First minor number associated with the disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">minors</tt></p></td><td class="docTableCell"><p class="docText2">Range of minor numbers associated with the disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">char [32]</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">disk_name</tt></p></td><td class="docTableCell"><p class="docText2">Conventional name of the disk (usually, the canonical name of the corresponding device file)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct hd_struct **</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">part</tt></p></td><td class="docTableCell"><p class="docText2">Array of partition descriptors for the disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct</tt></p><p class="docText2"><tt class="calibre25">block_device_operations *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">fops</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to a table of block device methods</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct request_queue *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">queue</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the request queue of the disk (see "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-3.html#understandlk-CHP-14-SECT-3.1">Request Queue Descriptors</a>" later in this chapter)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">void *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">private_data</tt></p></td><td class="docTableCell"><p class="docText2">Private data of the block device driver</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sector_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">capacity</tt></p></td><td class="docTableCell"><p class="docText2">Size of the storage area of the disk (in number of sectors)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">flags</tt></p></td><td class="docTableCell"><p class="docText2">Flags describing the kind of disk (see below)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">char [64]</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">devfs_name</tt></p></td><td class="docTableCell"><p class="docText2">Device filename in the (nowadays deprecated) <span class="docEmphasis">devfs</span><a name="IDX-CHP-14-3621"></a> 
 special filesystem</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">number</tt></p></td><td class="docTableCell"><p class="docText2">No longer used</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct device *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">driverfs_dev</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to the <tt class="calibre25">device</tt> object of the disk's hardware device (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.3">Components of the Device Driver Model</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct kobject</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">kobj</tt></p></td><td class="docTableCell"><p class="docText2">Embedded kobject (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.2">Kobjects</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct timer_rand_state *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">random</tt></p></td><td class="docTableCell"><p class="docText2">Pointer to a data structure that records the timing of the disk's interrupts; used by the kernel built-in random number generator</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">policy</tt></p></td><td class="docTableCell"><p class="docText2">Set to 1 if the disk is read-only (write operations forbidden), 0 otherwise</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">atomic_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">sync_io</tt></p></td><td class="docTableCell"><p class="docText2">Counter of sectors written to disk, used only for RAID</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">stamp</tt></p></td><td class="docTableCell"><p class="docText2">Timestamp used to determine disk queue usage statistics</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned long</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">stamp_idle</tt></p></td><td class="docTableCell"><p class="docText2">Same as above</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">in_flight</tt></p></td><td class="docTableCell"><p class="docText2">Number of ongoing I/O operations</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct disk_stats *</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">dkstats</tt></p></td><td class="docTableCell"><p class="docText2">Statistics about per-CPU disk usage</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">The <tt class="calibre25">flags</tt> field stores information about the disk. The most important flag is <tt class="calibre25">GENHD_FL_UP</tt>: if it is set, the disk is initialized and working. Another relevant flag is <tt class="calibre25">GENHD_FL_REMOVABLE</tt>, which is set if the disk is a removable support, such as a floppy disk or a CD-ROM.</p>
<p class="docText1">The <tt class="calibre25">fops</tt> field of the <tt class="calibre25">gendisk</tt> object points to a <tt class="calibre25">block_device_operations</tt> table, which stores a few custom methods for crucial operations of the block device (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-14-TABLE-4">Table 14-4</a>).</p>
<a name="understandlk-CHP-14-TABLE-4"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 14-4. The methods of the block devices</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Method</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Triggers</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">open</tt></p></td><td class="docTableCell"><p class="docText2">Opening the block device file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">release</tt></p></td><td class="docTableCell"><p class="docText2">Closing the last reference to a block device file</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">ioctl</tt></p></td><td class="docTableCell"><p class="docText2">Issuing an <tt class="calibre25">ioctl( )</tt><a name="IDX-CHP-14-3622"></a> 
 system call on the block device file (uses the big kernel lock<a name="IDX-CHP-14-3623"></a> 
)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">compat_ioctl</tt></p></td><td class="docTableCell"><p class="docText2">Issuing an <tt class="calibre25">ioctl( )</tt> system call on the block device file (does not use the big kernel lock)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">media_changed</tt></p></td><td class="docTableCell"><p class="docText2">Checking whether the removable media has been changed (e.g., floppy disk)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">revalidate_disk</tt></p></td><td class="docTableCell"><p class="docText2">Checking whether the block device holds valid data</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">Hard disks are commonly split into logical <span class="docEmphasis">partitions</span><a name="IDX-CHP-14-3624"></a> 
. Each block device file may represent either a whole disk or a partition inside the disk. For instance, a master EIDE disk might be represented by a device file <i class="docEmphasis">/dev/hda</i> having major number 3 and minor number 0; the first two partitions inside the disk might be represented by device files <i class="docEmphasis">/dev/hda1</i> and <i class="docEmphasis">/dev/hda2</i> having major number 3 and minor numbers 1 and 2, respectively. In general, the partitions inside a disk are characterized by consecutive minor numbers.</p>
<p class="docText1">If a disk is split in partitions, their layout is kept in an array of <tt class="calibre25">hd_struct</tt> structures whose address is stored in the <tt class="calibre25">part</tt> field of the <tt class="calibre25">gendisk</tt> object. The array is indexed by the relative index of the partition inside the disk. The fields of the <tt class="calibre25">hd_struct</tt> descriptor are listed in <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-14-TABLE-5">Table 14-5</a>.</p>
<a name="understandlk-CHP-14-TABLE-5"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="100%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle">Table 14-5. The fields of the hd_struct descriptor</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Type</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Field</span></p></th><th class="thead" scope="col"><p class="docText1"><span class="calibre5">Description</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sector_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">start_sect</tt></p></td><td class="docTableCell"><p class="docText2">Starting sector of the partition inside the disk</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">sector_t</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">nr_sects</tt></p></td><td class="docTableCell"><p class="docText2">Length of the partition (number of sectors)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">struct kobject</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">kobj</tt></p></td><td class="docTableCell"><p class="docText2">Embedded kobject (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-2.html#understandlk-CHP-13-SECT-2.2">Kobjects</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>)</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">reads</tt></p></td><td class="docTableCell"><p class="docText2">Number of read operations issued on the partition</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">read_sectors</tt></p></td><td class="docTableCell"><p class="docText2">Number of sectors read from the partition</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">writes</tt></p></td><td class="docTableCell"><p class="docText2">Number of write operations issued on the partition</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">unsigned int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">write_sectors</tt></p></td><td class="docTableCell"><p class="docText2">Number of sectors written into the partition</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">policy</tt></p></td><td class="docTableCell"><p class="docText2">Set to 1 if the partition is read-only, 0 otherwise</p></td></tr><tr class="calibre2"><td class="docTableCell"><p class="docText2"><tt class="calibre25">int</tt></p></td><td class="docTableCell"><p class="docText2"><tt class="calibre25">partno</tt></p></td><td class="docTableCell"><p class="docText2">The relative index of the partition inside the disk</p></td></tr></table></p><br class="calibre7"/>
<p class="docText1">When the kernel discovers a new disk in the system (in the boot phase, or when a removable media is inserted in a drive, or when an external disk is attached at run-time), it invokes the <tt class="calibre25">alloc_disk( )</tt> function, which allocates and initializes a new <tt class="calibre25">gendisk</tt> object and, if the new disk is split in several partitions, a suitable array of <tt class="calibre25">hd_struct</tt> descriptors. Then, it invokes the <tt class="calibre25">add_disk( )</tt> function to insert the new <tt class="calibre25">gendisk</tt> descriptor into the data structures of the generic block layer (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-4.html#understandlk-CHP-14-SECT-4.2">Device Driver Registration and Initialization</a>" later in this chapter).</p>
<a name="understandlk-CHP-14-SECT-2.3"></a>
<h4 class="docSection2Title">14.2.3. Submitting a Request</h4><a name="IDX-CHP-14-3625"></a>
<a name="IDX-CHP-14-3626"></a>
<a name="IDX-CHP-14-3627"></a>
<a name="IDX-CHP-14-3628"></a>
<a name="IDX-CHP-14-3629"></a>
<a name="IDX-CHP-14-3630"></a>
<a name="IDX-CHP-14-3631"></a>
<a name="IDX-CHP-14-3632"></a>
<p class="docText1">Let us describe the common sequence of steps executed by the kernel when submitting an I/O operation request to the generic block layer. We'll assume that the requested chunks of data are adjacent on disk and that the kernel has already determined their physical location.</p>
<p class="docText1">The first step consists in executing the <tt class="calibre25">bio_alloc( )</tt> function to allocate a new bio descriptor. Then, the kernel initializes the bio descriptor by setting a few fields:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">The <tt class="calibre25">bi_sector</tt> field is set to the initial sector number of the data (if the block device is split in several partitions, the sector number is relative to the start of the partition).</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">bi_size</tt> field is set to the number of sectors covering the data.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">bi_bdev</tt> field is set to the address of the block device descriptor (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-4.html#understandlk-CHP-14-SECT-4.1">Block Devices</a>" later in this chapter).</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">bi_io_vec</tt> field is set to the initial address of an array of <tt class="calibre25">bio_vec</tt> data structures, each of which describes a segment (memory buffer) involved in the I/O operation; moreover, the <tt class="calibre25">bi_vcnt</tt> field is set to the total number of segments in the bio.</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">bi_rw</tt> field is set with the flags of the requested operation. The most important flag specifies the data transfer direction: <tt class="calibre25">READ</tt> (0) or <tt class="calibre25">WRITE</tt> (1).</p></li><li class="calibre12"><p class="docText1">The <tt class="calibre25">bi_end_io</tt> field is set to the address of a completion procedure that is executed whenever the I/O operation on the bio is completed.</p></li></ul>
<p class="docText1">Once the <tt class="calibre25">bio</tt> descriptor has been properly initialized, the kernel invokes the <tt class="calibre25">generic_make_request( )</tt> function, which is the main entry point of the generic block layer. The function essentially executes the following steps:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Checks that <tt class="calibre25">bio-&gt;bi_sector</tt> does not exceed the number of sectors of the block device. If it does, the function sets the <tt class="calibre25">BIO_EOF</tt> flag of <tt class="calibre25">bio-&gt;bi_flags</tt>, prints a kernel error message, invokes the <tt class="calibre25">bio_endio()</tt> function, and terminates. <tt class="calibre25">bio_endio( )</tt> updates the <tt class="calibre25">bi_size</tt> and <tt class="calibre25">bi_sector</tt> fields of the bio descriptor, and it invokes the <tt class="calibre25">bi_end_io</tt> bio's method. The implementation of the latter function essentially depends on the kernel component that has triggered the I/O data transfer; we will see some examples of <tt class="calibre25">bi_end_io</tt> methods in the following chapters.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Gets the request queue <tt class="calibre25">q</tt> associated with the block device (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-3.html#understandlk-CHP-14-SECT-3.1">Request Queue Descriptors</a>" later in this chapter); its address can be found in the <tt class="calibre25">bd_disk</tt> field of the block device descriptor, which in turn is pointed to by the <tt class="calibre25">bio-&gt;bi_bdev</tt> field.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">block_wait_queue_running( )</tt> to check whether the I/O scheduler currently in use is being dynamically replaced; in this case, the function puts the process to sleep until the new I/O scheduler is started (see the next section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-3.html#understandlk-CHP-14-SECT-3">The I/O Scheduler</a>").</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes <tt class="calibre25">blk_partition_remap( )</tt> to check whether the block device refers to a disk partition (<tt class="calibre25">bio-&gt;bi_bdev</tt> not equal to <tt class="calibre25">bio-&gt;bi_dev-&gt;bd_contains</tt>; see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-4.html#understandlk-CHP-14-SECT-4.1">Block Devices</a>" later in this chapter). In this case, the function gets the <tt class="calibre25">hd_struct</tt> descriptor of the partition from the <tt class="calibre25">bio-&gt;bi_bdev</tt> field to perform the following substeps:</p><div class="calibre44"><ol class="docList4" type="a"><li class="calibre12"><div class="calibre45"><p class="docList">Updates the <tt class="calibre25">read_sectors</tt> and <tt class="calibre25">reads</tt> fields, or the <tt class="calibre25">write_sectors</tt> and <tt class="calibre25">writes</tt> fields, of the <tt class="calibre25">hd_struct</tt> descriptor, according to the direction of data transfer.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Adjusts the <tt class="calibre25">bio-&gt;bi_sector</tt> field so as to transform the sector number relative to the start of the partition to a sector number relative to the whole disk.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Sets the <tt class="calibre25">bio-&gt;bi_bdev</tt> field to the block device descriptor of the whole disk (<tt class="calibre25">bio-&gt;bd_contains</tt>).</p></div></li></ol></div><p class="docList">From now on, the generic block layer, the I/O scheduler, and the device driver forget about disk partitioning, and work directly with the whole disk.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Invokes the <tt class="calibre25">q-&gt;make_request_fn</tt> method to insert the <tt class="calibre25">bio</tt> request in the request queue <tt class="calibre25">q</tt>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Returns.</p></div></li></ol></div>
<p class="docText1">We will discuss a typical implementation of the <tt class="calibre25">make_request_fn</tt> method in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14-SECT-3.html#understandlk-CHP-14-SECT-3.5">Issuing a Request to the I/O Scheduler</a>" later in this chapter.</p>

<br class="calibre7"/>

</div>

{% endraw %}

