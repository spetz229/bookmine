---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-18-SECT-6.html
next: understandlk-CHP-19.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-18-SECT-7"></a>
<h3 class="docSection1Title">18.7. The Ext3 Filesystem</h3><a name="IDX-CHP-18-4456"></a>
<a name="IDX-CHP-18-4457"></a>
<a name="IDX-CHP-18-4458"></a>
<a name="IDX-CHP-18-4459"></a>
<p class="docText1">In this section we'll briefly describe the enhanced filesystem that has evolved from Ext2, named <span class="docEmphasis">Ext3</span>. The new filesystem has been designed with two simple concepts in mind:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">To be a journaling filesystem (see the next section)</p></li><li class="calibre12"><p class="docText1">To be, as much as possible, compatible with the old Ext2 filesystem</p></li></ul>
<p class="docText1">Ext3 achieves both the goals very well. In particular, it is largely based on Ext2, so its data structures on disk are essentially identical to those of an Ext2 filesystem. As a matter of fact, if an Ext3 filesystem has been cleanly unmounted, it can be remounted as an Ext2 filesystem; conversely, creating a journal of an Ext2 filesystem and remounting it as an Ext3 filesystem is a simple, fast operation.</p>
<p class="docText1">Thanks to the compatibility between Ext3 and Ext2, most descriptions in the previous sections of this chapter apply to Ext3 as well. Therefore, in this section, we focus on the new feature offered by Ext3  "the journal."</p>
<a name="understandlk-CHP-18-SECT-7.1"></a>
<h4 class="docSection2Title">18.7.1. Journaling Filesystems</h4><a name="IDX-CHP-18-4460"></a>
<a name="IDX-CHP-18-4461"></a>
<a name="IDX-CHP-18-4462"></a>
<a name="IDX-CHP-18-4463"></a>
<a name="IDX-CHP-18-4464"></a>
<a name="IDX-CHP-18-4465"></a>
<p class="docText1">As disks became larger, one design choice of traditional Unix filesystems (such as Ext2) turns out to be inappropriate. As we know from <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-14.html#understandlk-CHP-14">Chapter 14</a>, updates to filesystem blocks might be kept in dynamic memory for long period of time before being flushed to disk. A dramatic event such as a power-down failure or a system crash might thus leave the filesystem in an inconsistent state. To overcome this problem, each traditional Unix filesystem is checked before being mounted; if it has not been properly unmounted, then a specific program executes an exhaustive, time-consuming check and fixes all the filesystem's data structures on disk.</p>
<p class="docText1">For instance, the Ext2 filesystem status is stored in the <tt class="calibre25">s_mount_state</tt> field of the superblock on disk. The <i class="docEmphasis">e2fsck</i> utility program is invoked by the boot script to check the value stored in this field; if it is not equal to <tt class="calibre25">EXT2_VALID_FS</tt>, the filesystem was not properly unmounted, and therefore <i class="docEmphasis">e2fsck</i> starts checking all disk data structures of the filesystem.</p>
<p class="docText1">Clearly, the time spent checking the consistency of a filesystem depends mainly on the number of files and directories to be examined; therefore, it also depends on the disk size. Nowadays, with filesystems reaching hundreds of gigabytes, a single consistency check may take hours. The involved downtime is unacceptable for every production environment or high-availability server.</p>
<p class="docText1">The goal of a <span class="docEmphasis">journaling filesystem</span> is to avoid running time-consuming consistency checks on the whole filesystem by looking instead in a special disk area that contains the most recent disk write operations named <span class="docEmphasis">journal</span>. Remounting a journaling filesystem after a system failure is a matter of a few seconds.</p>
<a name="understandlk-CHP-18-SECT-7.2"></a>
<h4 class="docSection2Title">18.7.2. The Ext3 Journaling Filesystem</h4><a name="IDX-CHP-18-4466"></a>
<a name="IDX-CHP-18-4467"></a>
<a name="IDX-CHP-18-4468"></a>
<p class="docText1">The idea behind Ext3 journaling is to perform each high-level change to the filesystem in two steps. First, a copy of the blocks to be written is stored in the journal; then, when the I/O data transfer to the journal is completed (in short, data is <span class="docEmphasis">committed to the journal</span>), the blocks are written in the filesystem. When the I/O data transfer to the filesystem terminates (data is <span class="docEmphasis">committed to the filesystem</span>), the copies of the blocks in the journal are discarded.</p>
<p class="docText1">While recovering after a system failure, the <i class="docEmphasis">e2fsck</i> program distinguishes the following two cases:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphBoldItalic">The system failure occurred before a commit to the journal</span></span></p></dt>
<dd class="calibre20"><p class="docList">Either the copies of the blocks relative to the high-level change are missing from the journal or they are incomplete; in both cases, <i class="docEmphasis">e2fsck</i> ignores them.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphBoldItalic">The system failure occurred after a commit to the journal</span></span></p></dt>
<dd class="calibre20"><p class="docList">The copies of the blocks are valid, and <i class="docEmphasis">e2fsck</i> writes them into the filesystem.</p></dd></dl>
<p class="docText1">In the first case, the high-level change to the filesystem is lost, but the filesystem state is still consistent. In the second case, <i class="docEmphasis">e2fsck</i> applies the whole high-level change, thus fixing every inconsistency due to unfinished I/O data transfers into the filesystem.</p>
<p class="docText1">Don't expect too much from a journaling filesystem; it ensures consistency only at the system call level. For instance, a system failure that occurs while you are copying a large file by issuing several <tt class="calibre25">write( )</tt><a name="IDX-CHP-18-4469"></a> 
 system calls will interrupt the copy operation, thus the duplicated file will be shorter than the original one.</p>
<p class="docText1">Furthermore, journaling filesystems do not usually copy all blocks into the journal. In fact, each filesystem consists of two kinds of blocks: those containing the so-called <span class="docEmphasis">metadata</span><a name="IDX-CHP-18-4470"></a>
<a name="IDX-CHP-18-4471"></a>
<a name="IDX-CHP-18-4472"></a> 
 and those containing regular data. In the case of Ext2 and Ext3, there are six kinds of metadata: superblocks, group block descriptors, inodes, blocks used for indirect addressing (indirection blocks), data bitmap blocks, and inode bitmap blocks. Other filesystems may use different metadata.</p>
<p class="docText1">Several journaling filesystems, such as SGI's XFS<a name="IDX-CHP-18-4473"></a>
<a name="IDX-CHP-18-4474"></a> 
 and IBM's JFS<a name="IDX-CHP-18-4475"></a>
<a name="IDX-CHP-18-4476"></a> 
, limit themselves to logging the operations affecting metadata. In fact, metadata's log records are sufficient to restore the consistency of the on-disk filesystem data structures. However, since operations on blocks of file data are not logged, nothing prevents a system failure from corrupting the contents of the files.</p>
<p class="docText1">The Ext3 filesystem, however, can be configured to log the operations affecting both the filesystem metadata and the data blocks of the files. Because logging every kind of write operation leads to a significant performance penalty, Ext3 lets the system administrator decide what has to be logged; in particular, it offers three different journaling modes<a name="IDX-CHP-18-4477"></a> 
:</p>
<dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Journal</span></span></p></dt>
<dd class="calibre20"><p class="docList">All filesystem data and metadata changes are logged into the journal. This mode minimizes the chance of losing the updates made to each file, but it requires many additional disk accesses. For example, when a new file is created, all its data blocks must be duplicated as log records. This is the safest and slowest Ext3 journaling mode.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Ordered</span></span></p></dt>
<dd class="calibre20"><p class="docList">Only changes to filesystem metadata are logged into the journal. However, the Ext3 filesystem groups metadata and relative data blocks so that data blocks are written to disk <span class="docEmphasis">before</span> the metadata. This way, the chance to have data corruption inside the files is reduced; for instance, each write access that enlarges a file is guaranteed to be fully protected by the journal. This is the default Ext3 journaling mode.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Writeback</span></span></p></dt>
<dd class="calibre20"><p class="docList">Only changes to filesystem metadata are logged; this is the method found on the other journaling filesystems and is the fastest mode.</p></dd></dl>
<p class="docText1">The journaling mode of the Ext3 filesystem is specified by an option of the <i class="docEmphasis">mount</i> system command. For instance, to mount an Ext3 filesystem stored in the <i class="docEmphasis">/dev/sda2</i> partition on the <i class="docEmphasis">/jdisk</i> mount point with the "writeback" mode, the system administrator can type the command:</p>
<pre class="calibre27">
# mount -t ext3 -o data=writeback /dev/sda2 /jdisk</pre><br class="calibre7"/>
<a name="understandlk-CHP-18-SECT-7.3"></a>
<h4 class="docSection2Title">18.7.3. The Journaling Block Device Layer</h4><a name="IDX-CHP-18-4478"></a>
<a name="IDX-CHP-18-4479"></a>
<a name="IDX-CHP-18-4480"></a>
<a name="IDX-CHP-18-4481"></a>
<p class="docText1">The Ext3 journal is usually stored in a hidden file named <i class="docEmphasis">.journal</i> located in the root directory of the filesystem.</p>
<p class="docText1">The Ext3 filesystem does not handle the journal on its own; rather, it uses a general kernel layer named <span class="docEmphasis">Journaling Block Device</span>, or <span class="docEmphasis">JBD</span>. Right now, only Ext3 uses the JBD layer, but other filesystems might use it in the future.</p>
<p class="docText1">The JBD layer is a rather complex piece of software. The Ext3 filesystem invokes the JBD routines to ensure that its subsequent operations don't corrupt the disk data structures in case of system failure. However, JBD typically uses the same disk to log the changes performed by the Ext3 filesystem, and it is therefore vulnerable to system failures as much as Ext3. In other words, JBD must also protect itself from system failures that could corrupt the journal.</p>
<p class="docText1">Therefore, the interaction between Ext3 and JBD is essentially based on three fundamental units:</p>
<a name="IDX-CHP-18-4482"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Log record</span></span></p></dt>
<dd class="calibre20"><p class="docList">Describes a single update of a disk block of the journaling filesystem.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Atomic operation handle</span></span></p></dt>
<dd class="calibre20"><p class="docList">Includes log records<a name="IDX-CHP-18-4482"></a> 
 relative to a single high-level change of the filesystem; typically, each system call modifying the filesystem gives rise to a single atomic operation handle.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Transaction</span></span></p></dt>
<dd class="calibre20"><p class="docList">Includes several atomic operation handles whose log records are marked valid for <i class="docEmphasis">e2fsck</i> at the same time.</p></dd></dl>
<a name="understandlk-CHP-18-SECT-7.3.1"></a>
<h5 class="docSection3Title">18.7.3.1. Log records</h5>
<p class="docText1">A <span class="docEmphasis">log record</span> is essentially the description of a low-level operation that is going to be issued by the filesystem. In some journaling filesystems, the log record consists of exactly the span of bytes modified by the operation, together with the starting position of the bytes inside the filesystem. The JBD layer, however, uses log records consisting of the whole buffer modified by the low-level operation. This approach may waste a lot of journal space (for instance, when the low-level operation just changes the value of a bit in a bitmap), but it is also much faster because the JBD layer can work directly with buffers and their buffer heads.</p>
<p class="docText1">Log records are thus represented inside the journal as normal blocks of data (or metadata). Each such block, however, is associated with a small tag of type <tt class="calibre25">journal_block_tag_t</tt>, which stores the logical block number of the block inside the filesystem and a few status flags.</p>
<p class="docText1">Later, whenever a buffer is being considered by the JBD, either because it belongs to a log record or because it is a data block that should be flushed to disk before the corresponding metadata block (in the "ordered" journaling mode), the kernel attaches a <tt class="calibre25">journal_head</tt> data structure to the buffer head. In this case, the <tt class="calibre25">b_private</tt> field of the buffer head stores the address of the <tt class="calibre25">journal_head</tt> data structure and the <tt class="calibre25">BH_JBD</tt> flag is set (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15-SECT-2.html#understandlk-CHP-15-SECT-2.1">Block Buffers and Buffer Heads</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>).</p>
<a name="understandlk-CHP-18-SECT-7.3.2"></a>
<h5 class="docSection3Title">18.7.3.2. Atomic operation handles</h5><a name="IDX-CHP-18-4483"></a>
<a name="IDX-CHP-18-4484"></a>
<a name="IDX-CHP-18-4485"></a>
<a name="IDX-CHP-18-4486"></a>
<a name="IDX-CHP-18-4487"></a>
<a name="IDX-CHP-18-4488"></a>
<p class="docText1">Every system call modifying the filesystem is usually split into a series of low-level operations that manipulate disk data structures.</p>
<p class="docText1">For instance, suppose that Ext3 must satisfy a user request to append a block of data to a regular file. The filesystem layer must determine the last block of the file, locate a free block in the filesystem, update the data block bitmap inside the proper block group, store the logical number of the new block either in the file's inode or in an indirect addressing block, write the contents of the new block, and finally, update several fields of the inode. As you see, the append operation translates into many lower-level operations on the data and metadata blocks of the filesystem.</p>
<p class="docText1">Now, just imagine what could happen if a system failure occurred in the middle of an append operation, when some of the lower-level manipulations have already been executed while others have not. Of course, the scenario could be even worse, with high-level operations affecting two or more files (for example, moving a file from one directory to another).</p>
<p class="docText1">To prevent data corruption, the Ext3 filesystem must ensure that each system call is handled in an atomic way. An <span class="docEmphasis">atomic operation handle</span> is a set of low-level operations on the disk data structures that correspond to a single high-level operation. When recovering from a system failure, the filesystem ensures that either the whole high-level operation is applied or none of its low-level operations is.</p>
<p class="docText1">Each atomic operation handle is represented by a descriptor of type <tt class="calibre25">handle_t</tt>. To start an atomic operation, the Ext3 filesystem invokes the <tt class="calibre25">journal_start( )</tt> JBD function, which allocates, if necessary, a new atomic operation handle and inserts it into the current transactions (see the next section). Because every low-level operation on the disk might suspend the process, the address of the active handle is stored in the <tt class="calibre25">journal_info</tt> field of the process descriptor. To notify that an atomic operation is completed, the Ext3 filesystem invokes the <tt class="calibre25">journal_stop( )</tt> function.</p>
<a name="understandlk-CHP-18-SECT-7.3.3"></a>
<h5 class="docSection3Title">18.7.3.3. Transactions</h5><a name="IDX-CHP-18-4489"></a>
<a name="IDX-CHP-18-4490"></a>
<a name="IDX-CHP-18-4491"></a>
<a name="IDX-CHP-18-4492"></a>
<a name="IDX-CHP-18-4493"></a>
<a name="IDX-CHP-18-4494"></a>
<p class="docText1">For reasons of efficiency, the JBD layer manages the journal by grouping the log records that belong to several atomic operation handles into a single <span class="docEmphasis">transaction</span>. Furthermore, all log records relative to a handle must be included in the same transaction.</p>
<p class="docText1">All log records of a transaction are stored in consecutive blocks of the journal. The JBD layer handles each transaction as a whole. For instance, it reclaims the blocks used by a transaction only after all data included in its log records is committed to the filesystem.</p>
<p class="docText1">As soon as it is created, a transaction may accept log records of new handles. The transaction stops accepting new handles when either of the following occurs:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">A fixed amount of time has elapsed, typically 5 seconds.</p></li><li class="calibre12"><p class="docText1">There are no free blocks in the journal left for a new handle.</p></li></ul>
<p class="docText1">A transaction is represented by a descriptor of type <tt class="calibre25">TRansaction_t</tt>. The most important field is <tt class="calibre25">t_state</tt>, which describes the current status of the transaction.</p>
<p class="docText1">Essentially, a transaction can be:</p>
<a name="IDX-CHP-18-4495"></a><dl class="docText1"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Complete</span></span></p></dt>
<dd class="calibre20"><p class="docList">All log records included in the transaction have been physically written onto the journal. When recovering from a system failure, <i class="docEmphasis">e2fsck</i> considers every complete transaction of the journal and writes the corresponding blocks into the filesystem. In this case, the <tt class="calibre25">t_state</tt> field stores the value <tt class="calibre25">T_FINISHED</tt>.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docEmphasis">Incomplete</span></span></p></dt>
<dd class="calibre20"><p class="docList">At least one log record included in the transaction has not yet been physically written to the journal, or new log records are still being added to the transaction. In case of system failure, the image of the transaction stored in the journal is likely not up-to-date. Therefore, when recovering from a system failure, <i class="docEmphasis">e2fsck</i> does not trust the incomplete transactions<a name="IDX-CHP-18-4495"></a> 
 in the journal and skips them. In this case, the <tt class="calibre25">t_state</tt> field stores one of the following values:</p>
<dl class="docList5"><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">T_RUNNING</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Still accepting new atomic operation handles.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">T_LOCKED</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">Not accepting new atomic operation handles, but some of them are still unfinished.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">T_FLUSH</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">All atomic operation handles have finished, but some log records are still being written to the journal.</p></dd><dt class="calibre7"><br class="calibre7"/><p class="calibre14"><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">T_COMMIT</span></span></span></p></dt>
<dd class="calibre20"><p class="docList">All log records of the atomic operation handles have been written to disk, but the transaction has yet to be marked as completed on the journal.</p></dd></dl></dd></dl>
<p class="docText1">At any time the journal may include several transactions, but only one of them is in the <tt class="calibre25">T_RUNNING</tt> state  it is the <span class="docEmphasis">active transaction</span> that is accepting the new atomic operation handle requests issued by the Ext3 filesystem.</p>
<p class="docText1">Several transactions in the journal might be incomplete, because the buffers containing the relative log records have not yet been written to the journal.</p>
<p class="docText1">If a transaction is complete, all its log records have been written to the journal but some of the corresponding buffers have yet to be written onto the filesystem. A complete transaction is deleted from the journal when the JBD layer verifies that all buffers described by the log records have been successfully written onto the Ext3 filesystem.</p>
<a name="understandlk-CHP-18-SECT-7.4"></a>
<h4 class="docSection2Title">18.7.4. How Journaling Works</h4><a name="IDX-CHP-18-4496"></a>
<a name="IDX-CHP-18-4497"></a>
<a name="IDX-CHP-18-4498"></a>
<a name="IDX-CHP-18-4499"></a>
<a name="IDX-CHP-18-4500"></a>
<a name="IDX-CHP-18-4501"></a>
<a name="IDX-CHP-18-4502"></a>
<a name="IDX-CHP-18-4503"></a>
<a name="IDX-CHP-18-4504"></a>
<a name="IDX-CHP-18-4505"></a>
<a name="IDX-CHP-18-4506"></a>
<a name="IDX-CHP-18-4507"></a>
<a name="IDX-CHP-18-4508"></a>
<a name="IDX-CHP-18-4509"></a>
<a name="IDX-CHP-18-4510"></a>
<a name="IDX-CHP-18-4511"></a>
<a name="IDX-CHP-18-4512"></a>
<a name="IDX-CHP-18-4513"></a>
<a name="IDX-CHP-18-4514"></a>
<a name="IDX-CHP-18-4515"></a>
<p class="docText1">Let's try to explain how journaling works with an example: the Ext3 filesystem layer receives a request to write some data blocks of a regular file.</p>
<p class="docText1">As you might easily guess, we are not going to describe in detail every single operation of the Ext3 filesystem layer and of the JBD layer. There would be far too many issues to be covered! However, we describe the essential actions:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">The service routine of the <tt class="calibre25">write( )</tt><a name="IDX-CHP-18-4516"></a> 
 system call triggers the <tt class="calibre25">write</tt> method of the file object associated with the Ext3 regular file. For Ext3, this method is implemented by the <tt class="calibre25">generic_file_write( )</tt> function, already described in the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16-SECT-1.html#understandlk-CHP-16-SECT-1.3">Writing to a File</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">generic_file_write( )</tt> function invokes the <tt class="calibre25">prepare_write</tt> method of the <tt class="calibre25">address_space</tt> object several times, once for every page of data involved by the write operation. For Ext3, this method is implemented by the <tt class="calibre25">ext3_prepare_write( )</tt> function.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">ext3_prepare_write( )</tt> function starts a new atomic operation by invoking the <tt class="calibre25">journal_start( )</tt> JBD function. The handle is added to the active transaction. Actually, the atomic operation handle is created only when executing the first invocation of the <tt class="calibre25">journal_start( )</tt> function. Following invocations verify that the <tt class="calibre25">journal_info</tt> field of the process descriptor is already set and use the referenced handle.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">ext3_prepare_write( )</tt> function invokes the <tt class="calibre25">block_prepare_write( )</tt> function already described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-16.html#understandlk-CHP-16">Chapter 16</a>, passing to it the address of the <tt class="calibre25">ext3_get_block( )</tt> function. Remember that <tt class="calibre25">block_prepare_write( )</tt> takes care of preparing the buffers and the buffer heads of the file's page.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">When the kernel must determine the logical number of a block of the Ext3 filesystem, it executes the <tt class="calibre25">ext3_get_block( )</tt> function. This function is actually similar to <tt class="calibre25">ext2_get_block( )</tt>, which is described in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-18-SECT-6.html#understandlk-CHP-18-SECT-6.5">Allocating a Data Block</a>." A crucial difference, however, is that the Ext3 filesystem invokes functions of the JBD layer to ensure that the low-level operations are logged:</p><ul class="calibre61"><li class="calibre12"><p class="docList"><span class="docEmphasis">Before</span> issuing a low-level write operation on a metadata<a name="IDX-CHP-18-4517"></a> 
 block of the filesystem, the function invokes <tt class="calibre25">journal_get_write_access( )</tt>. Basically, this latter function adds the metadata buffer to a list of the active transaction. However, it must also check whether the metadata is included in an older incomplete transaction of the journal; in this case, it duplicates the buffer to make sure that the older transactions are committed with the old content.</p></li><li class="calibre12"><p class="docList"><span class="docEmphasis">After</span> updating the buffer containing the metadata block, the Ext3 filesystem invokes <tt class="calibre25">journal_dirty_metadata( )</tt> to move the metadata buffer to the proper dirty list of the active transaction and to log the operation in the journal.</p></li></ul><p class="docList">Notice that metadata buffers handled by the JBD layer are not usually included in the dirty lists of buffers of the inode, so they are not written to disk by the normal disk cache flushing mechanisms described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the Ext3 filesystem has been mounted in "journal" mode, the <tt class="calibre25">ext3_prepare_write( )</tt> function also invokes <tt class="calibre25">journal_get_write_access( )</tt> on every buffer touched by the write operation.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Control returns to the <tt class="calibre25">generic_file_write( )</tt> function, which updates the page with the data stored in the User Mode address space and then invokes the <tt class="calibre25">commit_write</tt> method of the <tt class="calibre25">address_space</tt> object. For Ext3, the function that implements this method depends on how the Ext3 filesystem has been mounted:</p><ul class="calibre61"><li class="calibre12"><p class="docList">If the Ext3 filesystem has been mounted in "journal" mode, the <tt class="calibre25">commit_write</tt> method is implemented by the <tt class="calibre25">ext3_journalled_commit_write( )</tt> function, which invokes <tt class="calibre25">journal_dirty_metadata( )</tt> on every buffer of data (not metadata) in the page. This way, the buffer is included in the proper dirty list of the active transaction and not in the dirty list of the owner inode; moreover, the corresponding log records are written to the journal. Finally, <tt class="calibre25">ext3_journalled_commit_write( )</tt> invokes <tt class="calibre25">journal_stop( )</tt> to notify the JBD layer that the atomic operation handle is closed.</p></li><li class="calibre12"><p class="docList">If the Ext3 filesystem has been mounted in "ordered" mode, the <tt class="calibre25">commit_write</tt> method is implemented by the <tt class="calibre25">ext3_ordered_commit_write( )</tt> function, which invokes the <tt class="calibre25">journal_dirty_data( )</tt> function on every buffer of data in the page to insert the buffer in a proper list of the active transactions. The JBD layer ensures that all buffers in this list are written to disk before the metadata buffers of the transaction. No log record is written onto the journal. Next, <tt class="calibre25">ext3_ordered_commit_write( )</tt> executes the normal <tt class="calibre25">generic_commit_write( )</tt> function described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>, which inserts the data buffers in the list of the dirty buffers of the owner inode. Finally, <tt class="calibre25">ext3_ordered_commit_write( )</tt> invokes <tt class="calibre25">journal_stop( )</tt> to notify the JBD layer that the atomic operation handle is closed.</p></li><li class="calibre12"><p class="docList">If the Ext3 filesystem has been mounted in "writeback" mode, the <tt class="calibre25">commit_write</tt> method is implemented by the <tt class="calibre25">ext3_writeback_commit_write( )</tt> function, which executes the normal <tt class="calibre25">generic_commit_write( )</tt> function described in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-15.html#understandlk-CHP-15">Chapter 15</a>, which inserts the data buffers in the list of the dirty buffers of the owner inode. Then, <tt class="calibre25">ext3_writeback_commit_write( )</tt> invokes <tt class="calibre25">journal_stop( )</tt> to notify the JBD layer that the atomic operation handle is closed.</p></li></ul></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The service routine of the <tt class="calibre25">write( )</tt> system call terminates here. However, the JBD layer has not finished its work. Eventually, our transaction becomes complete when all its log records have been physically written to the journal. Then <tt class="calibre25">journal_commit_transaction( )</tt> is executed.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the Ext3 filesystem has been mounted in "ordered" mode, the <tt class="calibre25">journal_commit_transaction( )</tt> function activates the I/O data transfers for all data buffers included in the list of the transaction and waits until all data transfers terminate.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">The <tt class="calibre25">journal_commit_transaction( )</tt> function activates the I/O data transfers for all metadata buffers included in the transaction (and also for all data buffers, if Ext3 was mounted in "journal" mode).</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Periodically, the kernel activates a checkpoint activity for every complete transaction in the journal. The checkpoint basically involves verifying whether the I/O data transfers triggered by <tt class="calibre25">journal_commit_transaction( )</tt> have successfully terminated. If so, the transaction can be deleted from the journal.</p></div></li></ol></div>
<p class="docText1">Of course, the log records in the journal never play an active role until a system failure occurs. Only during system reboot does the <i class="docEmphasis">e2fsck</i> utility program scan the journal stored in the filesystem and reschedule all write operations described by the log records of the complete transactions.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

