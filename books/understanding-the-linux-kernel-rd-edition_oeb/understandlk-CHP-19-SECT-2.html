---
layout: page
title: "Understanding the Linux Kernel, 3rd Edition"
prev: understandlk-CHP-19-SECT-1.html
next: understandlk-CHP-19-SECT-3.html
book_path: books/understanding-the-linux-kernel-rd-edition_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="understandlk-CHP-19-SECT-2"></a>
<h3 class="docSection1Title">19.2. FIFOs</h3>
<p class="docText1">Although pipes are a simple, flexible, and efficient communication mechanism, they have one main drawbacknamely, that there is no way to open an already existing pipe. This makes it impossible for two arbitrary processes to share the same pipe, unless the pipe was created by a common ancestor process.</p>
<p class="docText1">This drawback is substantial for many application programs. Consider, for instance, a database engine server, which continuously polls client processes wishing to issue some queries and which sends the results of the database lookups back to them. Each interaction between the server and a given client might be handled by a pipe. However, client processes are usually created on demand by a command shell when a user explicitly queries the database; server and client processes thus cannot easily share a pipe.</p>
<p class="docText1">To address such limitations, Unix systems introduce a special file type called a <span class="docEmphasis">named pipe</span> or <span class="docEmphasis">FIFO</span> (which stands for "first in, first out;" the first byte written into the special file is also the first byte that is read). Each FIFO is much like a pipe: rather than owning disk blocks in the filesystems, an opened FIFO is associated with a kernel buffer that temporarily stores the data exchanged by two or more processes.</p>
<p class="docText1">Thanks to the disk inode, however, a FIFO can be accessed by every process, because the FIFO filename is included in the system's directory tree. Thus, in our example, the communication between server and clients may be easily established by using FIFOs<a name="IDX-CHP-19-4577"></a> 
 instead of pipes. The server creates, at startup, a FIFO used by client programs to make their requests. Each client program creates, before establishing the connection, another FIFO to which the server program can write the answer to the query and includes the FIFO's name in the initial request to the server.</p>
<p class="docText1">In Linux 2.6, FIFOs and pipes are almost identical and use the same <tt class="calibre25">pipe_inode_info</tt> structures. As a matter of fact, the <tt class="calibre25">read</tt> and <tt class="calibre25">write</tt> file operation methods of a FIFO are implemented by the same <tt class="calibre25">pipe_read( )</tt> and <tt class="calibre25">pipe_write( )</tt> functions described in the earlier sections "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19-SECT-1.html#understandlk-CHP-19-SECT-1.4">Reading from a Pipe</a>" and "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19-SECT-1.html#understandlk-CHP-19-SECT-1.5">Writing into a Pipe</a>." Actually, there are only two significant differences:</p>
<ul class="calibre11"><li class="calibre12"><p class="docText1">FIFO inodes appear on the system directory tree rather than on the <span class="docEmphasis">pipefs</span><a name="IDX-CHP-19-4578"></a> 
 special filesystem.</p></li><li class="calibre12"><p class="docText1">FIFOs are a bidirectional communication channel; that is, it is possible to open a FIFO in read/write mode.</p></li></ul>
<p class="docText1">To complete our description, therefore, we just have to explain how FIFOs are created and opened.</p>
<a name="understandlk-CHP-19-SECT-2.1"></a>
<h4 class="docSection2Title">19.2.1. Creating and Opening a FIFO</h4><a name="IDX-CHP-19-4579"></a>
<a name="IDX-CHP-19-4580"></a>
<a name="IDX-CHP-19-4581"></a>
<a name="IDX-CHP-19-4582"></a>
<a name="IDX-CHP-19-4583"></a>
<a name="IDX-CHP-19-4584"></a>
<a name="IDX-CHP-19-4585"></a>
<a name="IDX-CHP-19-4586"></a>
<a name="IDX-CHP-19-4587"></a>
<a name="IDX-CHP-19-4588"></a>
<a name="IDX-CHP-19-4589"></a>
<a name="IDX-CHP-19-4590"></a>
<a name="IDX-CHP-19-4591"></a>
<p class="docText1">A process creates a FIFO by issuing a <tt class="calibre25">mknod( )<sup class="docFootnote3"><a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-FN4">[*]</a></sup></tt> system call (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-3.html#understandlk-CHP-13-SECT-3">Device Files</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>), passing to it as parameters the pathname of the new FIFO and the value <tt class="calibre25">S_IFIFO</tt> (<tt class="calibre25">0x10000</tt>) logically ORed with the permission bit mask of the new file. POSIX introduces a function named <tt class="calibre25">mkfifo( )</tt> specifically to create a FIFO. This call is implemented in Linux, as in System V<a name="IDX-CHP-19-4592"></a> 
 Release 4, as a C library function that invokes <tt class="calibre25">mknod( )</tt>.</p><blockquote class="calibre22"><p class="docFootnote1"><sup class="calibre24"><a name="understandlk-CHP-19-FN4">[*]</a></sup> In fact, <tt class="calibre42">mknod( )</tt> can be used to create nearly every kind of file, such as block and character device files, FIFOs, and even regular files (it cannot create directories or sockets, though).</p></blockquote>
<p class="docText1">Once created, a FIFO can be accessed through the usual <tt class="calibre25">open( )</tt>, <tt class="calibre25">read( )</tt>, <tt class="calibre25">write( )</tt>, and <tt class="calibre25">close( )</tt> system calls, but the VFS handles it in a special way, because the FIFO inode and file operations are customized and do not depend on the filesystems in which the FIFO is stored.</p>
<p class="docText1">The POSIX standard specifies the behavior of the <tt class="calibre25">open( )</tt> system call on FIFOs; the behavior depends essentially on the requested access type, the kind of I/O operation (blocking or nonblocking), and the presence of other processes accessing the FIFO.</p>
<p class="docText1">A process may open a FIFO for reading, for writing, or for reading and writing. The file operations associated with the corresponding file object are set to special methods for these three cases.</p>
<p class="docText1">When a process opens a FIFO, the VFS performs the same operations as it does for device files (see the section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13-SECT-3.html#understandlk-CHP-13-SECT-3.2">VFS Handling of Device Files</a>" in <a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-13.html#understandlk-CHP-13">Chapter 13</a>). The inode object associated with the opened FIFO is initialized by a filesystem-dependent <tt class="calibre25">read_inode</tt> superblock method; this method always checks whether the inode on disk represents a special file, and invokes, if necessary, the <tt class="calibre25">init_special_inode( )</tt> function. It turn, this function sets the <tt class="calibre25">i_fop</tt> field of the inode object to the address of the <tt class="calibre25">def_fifo_fops</tt> table. Later, the kernel sets the file operation table of the file object to <tt class="calibre25">def_fifo_fops</tt>, and executes its <tt class="calibre25">open</tt> method, which is implemented by <tt class="calibre25">fifo_open( )</tt>.</p>
<p class="docText1">The <tt class="calibre25">fifo_open( )</tt> function initializes the data structures specific to the FIFO; in particular, it performs the following operations:</p>
<div class="calibre44"><ol class="docList1" type="1"><li class="calibre12"><div class="calibre45"><p class="docList">Acquires the <tt class="calibre25">i_sem</tt> inode semaphore.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Checks the <tt class="calibre25">i_pipe</tt> field of the inode object; if it is <tt class="calibre25">NULL</tt>, it allocates and it initializes a new <tt class="calibre25">pipe_inode_info</tt> structure, as in steps 1b-1e in the earlier section "<a class="pcalibre5 docLink pcalibre1" href="understandlk-CHP-19-SECT-1.html#understandlk-CHP-19-SECT-1.3">Creating and Destroying a Pipe</a>."</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Depending on the access mode specified as the parameter of the <tt class="calibre25">open( )</tt><a name="IDX-CHP-19-4593"></a> 
 system call, it initializes the <tt class="calibre25">f_op</tt> field of the file object with the address of the proper file operation table (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-5">Table 19-5</a>).</p><a name="understandlk-CHP-19-TABLE-5"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="90%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle1">Table 19-5. FIFO's file operations</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docList"><span class="calibre5">Access type</span></p></th><th class="thead" scope="col"><p class="docList"><span class="calibre5">File operations</span></p></th><th class="thead" scope="col"><p class="docList"><span class="calibre5">Read method</span></p></th><th class="thead" scope="col"><p class="docList"><span class="calibre5">Write method</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Read-only</p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">read_fifo_fops</tt></p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">pipe_read( )</tt></p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">bad_pipe_w( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Write-only</p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">write_fifo_fops</tt></p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">bad_pipe_r( )</tt></p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">pipe_write( )</tt></p></td></tr><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Read/write</p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">rdwr_fifo_fops</tt></p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">pipe_read( )</tt></p></td><td class="docTableCell2"><p class="docText2"><tt class="calibre25">pipe_write( )</tt></p></td></tr></table></p><br class="calibre7"/></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the access mode is either read-only or read/write, it adds one to the <tt class="calibre25">readers</tt> and <tt class="calibre25">r_counter</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> structure. Moreover, if the access mode is read-only and there is no other reading process, it wakes up any writing process sleeping in the wait queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If the access mode is either write-only or read/write, it adds one to the <tt class="calibre25">writers</tt> and <tt class="calibre25">w_counter</tt> fields of the <tt class="calibre25">pipe_inode_info</tt> structure. Moreover, if the access mode is write-only and there is no other writing process, it wakes up any reading process sleeping in the wait queue.</p></div></li><li class="calibre12"><div class="calibre45"><p class="docList">If there are no readers or no writers, it decides whether the function should block or terminate returning an error code (see <a class="pcalibre5 docLink pcalibre1" href="#understandlk-CHP-19-TABLE-6">Table 19-6</a>).</p><a name="understandlk-CHP-19-TABLE-6"></a><p class="calibre14"><table cellspacing="0" frame="hsides" rules="all" cellpadding="4" width="90%" class="calibre15"><caption class="calibre33"><h5 class="docFigureTitle1">Table 19-6. Behavior of the fifo_open( ) function</h5></caption><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre34"><th class="thead" scope="col"><p class="docList"><span class="calibre5">Access type</span></p></th><th class="thead" scope="col"><p class="docList"><span class="calibre5">Blocking</span></p></th><th class="thead" scope="col"><p class="docList"><span class="calibre5">Nonblocking</span></p></th></tr></thead><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Read-only, with writers</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td></tr><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Read-only, no writer</p></td><td class="docTableCell2"><p class="docText2">Wait for a writer</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td></tr><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Write-only, with readers</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td></tr><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Write-only, no reader</p></td><td class="docTableCell2"><p class="docText2">Wait for a reader</p></td><td class="docTableCell2"><p class="docText2">Return <tt class="calibre25">-ENXIO</tt></p></td></tr><tr class="calibre2"><td class="docTableCell2"><p class="docText2">Read/write</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td><td class="docTableCell2"><p class="docText2">Successfully return</p></td></tr></table></p><br class="calibre7"/></div></li><li class="calibre12"><div class="calibre45"><p class="docList">Releases the inode semaphore, and terminates, returning 0 (success).</p></div></li></ol></div>
<p class="docText1">The FIFO's three specialized file operation tables differ mainly in the implementation of the <tt class="calibre25">read</tt> and <tt class="calibre25">write</tt> methods. If the access type allows read operations, the <tt class="calibre25">read</tt> method is implemented by the <tt class="calibre25">pipe_read( )</tt> function. Otherwise, it is implemented by <tt class="calibre25">bad_pipe_r( )</tt>, which only returns an error code. Similarly, if the access type allows write operations, the <tt class="calibre25">write</tt> method is implemented by the <tt class="calibre25">pipe_write( )</tt> function; otherwise, it is implemented by <tt class="calibre25">bad_pipe_w( )</tt>, which also returns an error code.</p>
<a href="31071535.html"><img src="pixel.jpg" alt="" border="0" class="calibre19"/></a>
<br class="calibre7"/>

</div>

{% endraw %}

