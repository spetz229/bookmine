---
layout: page
title: "Java Concurrency in Practice"
prev: ch08lev1sec3.html
next: ch08lev1sec5.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch08lev1sec4" class="calibre18" id="ch08lev1sec4"></a>
<h3 id="title-IDA2E0VX" class="docSection1Title">8.4. Extending ThreadPoolExecutor</h3>
<p class="docText1"><tt class="calibre25">ThreadPoolExecutor</tt> was designed for extension, providing several "hooks" for subclasses to override<tt class="calibre25">beforeExecute</tt>, <tt class="calibre25">afterExecute</tt>, and <tt class="calibre25">terminate</tt>that can be used to extend the behavior of <tt class="calibre25">ThreadPoolExecutor</tt>.</p>
<p class="docText1">The <tt class="calibre25">beforeExecute</tt> and <tt class="calibre25">afterExecute</tt> hooks are called in the thread that executes the task, and can be used for adding logging, timing, monitoring, or statistics gathering. The <tt class="calibre25">afterExecute</tt> hook is called whether the task completes by returning normally from <tt class="calibre25">run</tt> or by throwing an <tt class="calibre25">Exception</tt>. (If the task completes with an <tt class="calibre25">Error</tt>, <tt class="calibre25">afterExecute</tt> is not called.) If <tt class="calibre25">beforeExecute</tt> throws a <tt class="calibre25">RuntimeException</tt>, the task is not executed and <tt class="calibre25">afterExecute</tt> is not called.</p>
<p class="docText1">The <tt class="calibre25">terminated</tt> hook is called when the thread pool completes the shutdown process, after all tasks have finished and all worker threads have shut down. It can be used to release resources allocated by the <tt class="calibre25">Executor</tt> during its lifecycle, perform notification or logging, or finalize statistics gathering.</p>
<a name="ch08lev2sec8" class="calibre18" id="ch08lev2sec8"></a>
<h4 id="title-IDAPG0VX" class="docSection2Title">8.4.1. Example: Adding Statistics to a Thread Pool</h4>
<p class="docText1"><tt class="calibre25">TimingThreadPool</tt> in <a class="calibre2" href="#ch08list09">Listing 8.9</a> shows a custom thread pool that uses <tt class="calibre25">before-Execute</tt>, <tt class="calibre25">afterExecute</tt>, and <tt class="calibre25">terminated</tt> to add logging and statistics gathering. To measure a task's runtime, <tt class="calibre25">beforeExecute</tt> must record the start time and store it somewhere <tt class="calibre25">afterExecute</tt> can find it. Because execution hooks are called in the thread that executes the task, a value placed in a <tt class="calibre25">ThreadLocal</tt> by <tt class="calibre25">beforeExecute</tt> can be retrieved by <tt class="calibre25">afterExecute</tt>. <tt class="calibre25">TimingThreadPool</tt> uses a pair of <tt class="calibre25">AtomicLong</tt>s to keep track of the total number of tasks processed and the total processing time, and uses the <tt class="calibre25">terminated</tt> hook to print a log message showing the average task time.</p>
<p class="docText1"></p><a name="ch08list09" class="calibre18" id="ch08list09"></a><h5 id="title-IDA2H0VX" class="docExampleTitle">Listing 8.9. Thread Pool Extended with Logging and Timing.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class TimingThreadPool extends ThreadPoolExecutor {
    private final ThreadLocal&lt;Long&gt; startTime
            = new ThreadLocal&lt;Long&gt;();
    private final Logger log = Logger.getLogger("TimingThreadPool");
    private final AtomicLong numTasks = new AtomicLong();
    private final AtomicLong totalTime = new AtomicLong();

    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        log.fine(String.format("Thread %s: start %s", t, r));
        startTime.set(System.nanoTime());
    }

    protected void afterExecute(Runnable r, Throwable t) {
        try {
            long endTime = System.nanoTime();
            long taskTime = endTime - startTime.get();
            numTasks.incrementAndGet();
            totalTime.addAndGet(taskTime);
            log.fine(String.format("Thread %s: end %s, time=%dns",
                    t, r, taskTime));
        } finally {
            super.afterExecute(r, t);
        }
    }

    protected void terminated() {
        try {
            log.info(String.format("Terminated: avg time=%dns",
                    totalTime.get() / numTasks.get()));
        } finally {
            super.terminated();
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3">Â </p>

</div>

{% endraw %}

