---
layout: page
title: "Java Concurrency in Practice"
prev: ch05lev1sec1.html
next: ch05lev1sec3.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch05lev1sec2" class="calibre18" id="ch05lev1sec2"></a>
<h3 id="title-IDALN1MZ" class="docSection1Title">5.2. Concurrent Collections</h3>
<p class="docText1">Java 5.0 improves on the synchronized collections by providing several <span class="docEmphasis">concurrent</span> collection classes. Synchronized collections achieve their thread safety by serializing all access to the collection's state. The cost of this approach is poor concurrency; when multiple threads contend for the collection-wide lock, throughput suffers.</p>
<p class="docText1">The concurrent collections, on the other hand, are designed for concurrent access from multiple threads. Java 5.0 adds <tt class="calibre25">ConcurrentHashMap</tt>, a replacement for synchronized hash-based <tt class="calibre25">Map</tt> implementations, and <tt class="calibre25">CopyOnWriteArrayList</tt>, a replacement for synchronized <tt class="calibre25">List</tt> implementations for cases where traversal is the dominant operation. The new <tt class="calibre25">ConcurrentMap</tt> interface adds support for common compound actions such as put-if-absent, replace, and conditional remove.</p>
<a name="ch05sb02" class="calibre18" id="ch05sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Replacing synchronized collections with concurrent collections can offer dramatic scalability improvements with little risk.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">Java 5.0 also adds two new collection types, <tt class="calibre25">Queue</tt> and <tt class="calibre25">BlockingQueue</tt>. A <tt class="calibre25">Queue</tt> is intended to hold a set of elements temporarily while they await processing. Several implementations are provided, including <tt class="calibre25">ConcurrentLinkedQueue</tt>, a <a name="iddle1461" class="calibre18" id="iddle1461"></a><a name="iddle1490" class="calibre18" id="iddle1490"></a><a name="iddle1491" class="calibre18" id="iddle1491"></a><a name="iddle1493" class="calibre18" id="iddle1493"></a><a name="iddle1494" class="calibre18" id="iddle1494"></a><a name="iddle1558" class="calibre18" id="iddle1558"></a><a name="iddle1937" class="calibre18" id="iddle1937"></a><a name="iddle2879" class="calibre18" id="iddle2879"></a><a name="iddle2880" class="calibre18" id="iddle2880"></a><a name="iddle2887" class="calibre18" id="iddle2887"></a><a name="iddle2990" class="calibre18" id="iddle2990"></a><a name="iddle3005" class="calibre18" id="iddle3005"></a><a name="iddle3044" class="calibre18" id="iddle3044"></a><a name="iddle3045" class="calibre18" id="iddle3045"></a><a name="iddle3046" class="calibre18" id="iddle3046"></a><a name="iddle3047" class="calibre18" id="iddle3047"></a><a name="iddle3048" class="calibre18" id="iddle3048"></a><a name="iddle3075" class="calibre18" id="iddle3075"></a><a name="iddle3116" class="calibre18" id="iddle3116"></a><a name="iddle3117" class="calibre18" id="iddle3117"></a><a name="iddle3144" class="calibre18" id="iddle3144"></a><a name="iddle3153" class="calibre18" id="iddle3153"></a><a name="iddle3552" class="calibre18" id="iddle3552"></a><a name="iddle3665" class="calibre18" id="iddle3665"></a><a name="iddle4062" class="calibre18" id="iddle4062"></a><a name="iddle4134" class="calibre18" id="iddle4134"></a><a name="iddle4218" class="calibre18" id="iddle4218"></a><a name="iddle4219" class="calibre18" id="iddle4219"></a><a name="iddle4220" class="calibre18" id="iddle4220"></a><a name="iddle4221" class="calibre18" id="iddle4221"></a><a name="iddle4331" class="calibre18" id="iddle4331"></a><a name="iddle4332" class="calibre18" id="iddle4332"></a><a name="iddle4333" class="calibre18" id="iddle4333"></a><a name="iddle4334" class="calibre18" id="iddle4334"></a><a name="iddle4474" class="calibre18" id="iddle4474"></a><a name="iddle4475" class="calibre18" id="iddle4475"></a><a name="iddle4502" class="calibre18" id="iddle4502"></a><a name="iddle4969" class="calibre18" id="iddle4969"></a><a name="iddle4970" class="calibre18" id="iddle4970"></a><a name="iddle4971" class="calibre18" id="iddle4971"></a><a name="iddle4972" class="calibre18" id="iddle4972"></a><a name="iddle5152" class="calibre18" id="iddle5152"></a>traditional FIFO queue, and <tt class="calibre25">PriorityQueue</tt>, a (non concurrent) priority ordered queue. <tt class="calibre25">Queue</tt> operations do not block; if the queue is empty, the retrieval operation returns <tt class="calibre25">null</tt>. While you can simulate the behavior of a <tt class="calibre25">Queue</tt> with a <tt class="calibre25">List</tt>in fact, <tt class="calibre25">LinkedList</tt> also implements <tt class="calibre25">Queue</tt>the <tt class="calibre25">Queue</tt> classes were added because eliminating the random-access requirements of <tt class="calibre25">List</tt> admits more efficient concurrent implementations.</p>
<p class="docText1"><tt class="calibre25">BlockingQueue</tt> extends <tt class="calibre25">Queue</tt> to add blocking insertion and retrieval operations. If the queue is empty, a retrieval blocks until an element is available, and if the queue is full (for bounded queues) an insertion blocks until there is space available. Blocking queues are extremely useful in producer-consumer designs, and are covered in greater detail in <a class="calibre2" href="ch05lev1sec3.html#ch05lev1sec3">Section 5.3</a>.</p>
<p class="docText1">Just as <tt class="calibre25">ConcurrentHashMap</tt> is a concurrent replacement for a synchronized hash-based <tt class="calibre25">Map</tt>, Java 6 adds <tt class="calibre25">ConcurrentSkipListMap</tt> and <tt class="calibre25">ConcurrentSkipListSet</tt>, which are concurrent replacements for a synchronized <tt class="calibre25">SortedMap</tt> or <tt class="calibre25">SortedSet</tt> (such as <tt class="calibre25">treeMap</tt> or <tt class="calibre25">TReeSet</tt> wrapped with <tt class="calibre25">synchronizedMap</tt>).</p>
<a name="ch05lev2sec4" class="calibre18" id="ch05lev2sec4"></a>
<h4 id="title-IDADB2MZ" class="docSection2Title">5.2.1. ConcurrentHashMap</h4>
<p class="docText1">The synchronized collections classes hold a lock for the duration of each operation. Some operations, such as <tt class="calibre25">HashMap.get</tt> or <tt class="calibre25">List.contains</tt>, may involve more work than is initially obvious: traversing a hash bucket or list to find a specific object entails calling <tt class="calibre25">equals</tt> (which itself may involve a fair amount of computation) on a number of candidate objects. In a hash-based collection, if <tt class="calibre25">hashCode</tt> does not spread out hash values well, elements may be unevenly distributed among buckets; in the degenerate case, a poor hash function will turn a hash table into a linked list. Traversing a long list and calling <tt class="calibre25">equals</tt> on some or all of the elements can take a long time, and during that time no other thread can access the collection.</p>
<p class="docText1"><tt class="calibre25">ConcurrentHashMap</tt> is a hash-based <tt class="calibre25">Map</tt> like <tt class="calibre25">HashMap</tt>, but it uses an entirely different locking strategy that offers better concurrency and scalability. Instead of synchronizing every method on a common lock, restricting access to a single thread at a time, it uses a finer-grained locking mechanism called <span class="docEmphasis">lock striping</span> (see <a class="calibre2" href="ch11lev1sec4.html#ch11lev2sec10">Section 11.4.3</a>) to allow a greater degree of shared access. Arbitrarily many reading threads can access the map concurrently, readers can access the map concurrently with writers, and a limited number of writers can modify the map concurrently. The result is far higher throughput under concurrent access, with little performance penalty for single-threaded access.</p>
<p class="docText1"><tt class="calibre25">ConcurrentHashMap</tt>, along with the other concurrent collections, further improve on the synchronized collection classes by providing iterators that do not throw <tt class="calibre25">ConcurrentModificationException</tt>, thus eliminating the need to lock the collection during iteration. The iterators returned by <tt class="calibre25">ConcurrentHashMap</tt> are <span class="docEmphasis">weakly consistent</span> instead of fail-fast. A weakly consistent iterator can tolerate concurrent modification, traverses elements as they existed when the iterator was constructed, and may (but is not guaranteed to) reflect modifications to the collection after the construction of the iterator.</p>
<p class="docText1">As with all improvements, there are still a few tradeoffs. The semantics of methods that operate on the entire <tt class="calibre25">Map</tt>, such as <tt class="calibre25">size</tt> and <tt class="calibre25">isEmpty</tt>, have been <a name="iddle1020" class="calibre18" id="iddle1020"></a><a name="iddle1021" class="calibre18" id="iddle1021"></a><a name="iddle1163" class="calibre18" id="iddle1163"></a><a name="iddle1665" class="calibre18" id="iddle1665"></a><a name="iddle1671" class="calibre18" id="iddle1671"></a><a name="iddle1724" class="calibre18" id="iddle1724"></a><a name="iddle1725" class="calibre18" id="iddle1725"></a><a name="iddle2995" class="calibre18" id="iddle2995"></a><a name="iddle3008" class="calibre18" id="iddle3008"></a><a name="iddle3097" class="calibre18" id="iddle3097"></a><a name="iddle3181" class="calibre18" id="iddle3181"></a><a name="iddle3845" class="calibre18" id="iddle3845"></a><a name="iddle3846" class="calibre18" id="iddle3846"></a><a name="iddle3858" class="calibre18" id="iddle3858"></a><a name="iddle3859" class="calibre18" id="iddle3859"></a><a name="iddle4214" class="calibre18" id="iddle4214"></a><a name="iddle4215" class="calibre18" id="iddle4215"></a><a name="iddle4276" class="calibre18" id="iddle4276"></a><a name="iddle4277" class="calibre18" id="iddle4277"></a><a name="iddle4928" class="calibre18" id="iddle4928"></a>slightly weakened to reflect the concurrent nature of the collection. Since the result of <tt class="calibre25">size</tt> could be out of date by the time it is computed, it is really only an estimate, so <tt class="calibre25">size</tt> is allowed to return an approximation instead of an exact count. While at first this may seem disturbing, in reality methods like <tt class="calibre25">size</tt> and <tt class="calibre25">isEmpty</tt> are far less useful in concurrent environments because these quantities are moving targets. So the requirements for these operations were weakened to enable performance optimizations for the most important operations, primarily <tt class="calibre25">get</tt>, <tt class="calibre25">put</tt>, <tt class="calibre25">containsKey</tt>, and <tt class="calibre25">remove</tt>.</p>
<p class="docText1">The one feature offered by the synchronized <tt class="calibre25">Map</tt> implementations but not by <tt class="calibre25">ConcurrentHashMap</tt> is the ability to lock the map for exclusive access. With <tt class="calibre25">Hashtable</tt> and <tt class="calibre25">synchronizedMap</tt>, acquiring the <tt class="calibre25">Map</tt> lock prevents any other thread from accessing it. This might be necessary in unusual cases such as adding several mappings atomically, or iterating the <tt class="calibre25">Map</tt> several times and needing to see the same elements in the same order. On the whole, though, this is a reasonable tradeoff: concurrent collections should be expected to change their contents continuously.</p>
<p class="docText1">Because it has so many advantages and so few disadvantages compared to <tt class="calibre25">Hashtable</tt> or <tt class="calibre25">synchronizedMap</tt>, replacing synchronized <tt class="calibre25">Map</tt> implementations with <tt class="calibre25">ConcurrentHashMap</tt> in most cases results only in better scalability. Only if your application needs to lock the map for exclusive access <sup class="docFootnote"><a class="calibre2" href="#ch05fn03">[3]</a></sup> is <tt class="calibre25">ConcurrentHashMap</tt> not an appropriate drop-in replacement.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch05fn03" class="calibre18" id="ch05fn03">[3]</a></sup> Or if you are relying on the synchronization side effects of the synchronized <tt class="calibre35">Map</tt> implementations.</p></blockquote>
<a name="ch05lev2sec5" class="calibre18" id="ch05lev2sec5"></a>
<h4 id="title-IDA5T2MZ" class="docSection2Title">5.2.2. Additional Atomic Map Operations</h4>
<p class="docText1">Since a <tt class="calibre25">ConcurrentHashMap</tt> cannot be locked for exclusive access, we cannot use client-side locking to create new atomic operations such as put-if-absent, as we did for <tt class="calibre25">Vector</tt> in <a class="calibre2" href="ch04lev1sec4.html#ch04lev2sec11">Section 4.4.1</a>. Instead, a number of common compound operations such as put-if-absent, remove-if-equal, and replace-if-equal are implemented as atomic operations and specified by the <tt class="calibre25">ConcurrentMap</tt> interface, shown in <a class="calibre2" href="#ch05list07">Listing 5.7</a>. If you find yourself adding such functionality to an existing synchronized <tt class="calibre25">Map</tt> implementation, it is probably a sign that you should consider using a <tt class="calibre25">ConcurrentMap</tt> instead.</p>
<a name="ch05lev2sec6" class="calibre18" id="ch05lev2sec6"></a>
<h4 id="title-IDADV2MZ" class="docSection2Title">5.2.3. CopyOnWriteArrayList</h4>
<p class="docText1"><tt class="calibre25">CopyOnWriteArrayList</tt> is a concurrent replacement for a synchronized <tt class="calibre25">List</tt> that offers better concurrency in some common situations and eliminates the need to lock or copy the collection during iteration. (Similarly, <tt class="calibre25">CopyOnWriteArraySet</tt> is a concurrent replacement for a synchronized <tt class="calibre25">Set</tt>.)</p>
<p class="docText1">The copy-on-write collections derive their thread safety from the fact that as long as an effectively immutable object is properly published, no further synchronization is required when accessing it. They implement mutability by creating and republishing a new copy of the collection every time it is modified. Iterators for the copy-on-write collections retain a reference to the backing array that was current at the start of iteration, and since this will never change, they need to <a name="iddle1221" class="calibre18" id="iddle1221"></a><a name="iddle1226" class="calibre18" id="iddle1226"></a><a name="iddle1439" class="calibre18" id="iddle1439"></a><a name="iddle1488" class="calibre18" id="iddle1488"></a><a name="iddle1579" class="calibre18" id="iddle1579"></a><a name="iddle1580" class="calibre18" id="iddle1580"></a><a name="iddle1844" class="calibre18" id="iddle1844"></a><a name="iddle1845" class="calibre18" id="iddle1845"></a><a name="iddle1846" class="calibre18" id="iddle1846"></a><a name="iddle1869" class="calibre18" id="iddle1869"></a><a name="iddle1870" class="calibre18" id="iddle1870"></a><a name="iddle1938" class="calibre18" id="iddle1938"></a><a name="iddle2006" class="calibre18" id="iddle2006"></a><a name="iddle2007" class="calibre18" id="iddle2007"></a><a name="iddle2070" class="calibre18" id="iddle2070"></a><a name="iddle2071" class="calibre18" id="iddle2071"></a><a name="iddle3242" class="calibre18" id="iddle3242"></a><a name="iddle3243" class="calibre18" id="iddle3243"></a><a name="iddle3326" class="calibre18" id="iddle3326"></a><a name="iddle3327" class="calibre18" id="iddle3327"></a><a name="iddle3681" class="calibre18" id="iddle3681"></a><a name="iddle3750" class="calibre18" id="iddle3750"></a><a name="iddle3754" class="calibre18" id="iddle3754"></a><a name="iddle4993" class="calibre18" id="iddle4993"></a><a name="iddle4994" class="calibre18" id="iddle4994"></a>synchronize only briefly to ensure visibility of the array contents. As a result, multiple threads can iterate the collection without interference from one another or from threads wanting to modify the collection. The iterators returned by the copy-on-write collections do not throw <tt class="calibre25">ConcurrentModificationException</tt> and return the elements exactly as they were at the time the iterator was created, regardless of subsequent modifications.</p>
<a name="ch05list07" class="calibre18" id="ch05list07"></a><h5 id="title-IDAW42MZ" class="docExampleTitle">Listing 5.7. <tt class="calibre33">ConcurrentMap</tt> Interface.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public interface ConcurrentMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
    <span class="docEmphasis">// Insert into map only if no value is mapped from K</span>
    V putIfAbsent(K key, V value);

    <span class="docEmphasis">// Remove only if K is mapped to V</span>
    boolean remove(K key, V value);

    <span class="docEmphasis">// Replace value only if K is mapped to oldValue</span>
    boolean replace(K key, V oldValue, V newValue);

    <span class="docEmphasis">// Replace value only if K is mapped to some value</span>
    V replace(K key, V newValue);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Obviously, there is some cost to copying the backing array every time the collection is modified, especially if the collection is large; the copy-on-write collections are reasonable to use only when iteration is far more common than modification. This criterion exactly describes many event-notification systems: delivering a notification requires iterating the list of registered listeners and calling each one of them, and in most cases registering or unregistering an event listener is far less common than receiving an event notification. (See [CPJ 2.4.4] for more information on copy-on-write.)</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

