---
layout: page
title: "Java Concurrency in Practice"
prev: ch12lev1sec3.html
next: ch12lev1sec5.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch12lev1sec4" class="calibre18" id="ch12lev1sec4"></a>
<h3 id="647011-837" class="docSection1Title">12.4. Complementary Testing Approaches</h3>
<p class="docText1">While we'd like to believe that an effective testing program should "find all the bugs", this is an unrealistic goal. NASA devotes more of its engineering resources to testing (it is estimated they employ 20 testers for each developer) than any commercial entity could afford toand the code produced is still not free of defects. In complex programs, no amount of testing can find all coding errors.</p>
<p class="docText1">The goal of testing is not so much to <span class="docEmphasis">find errors</span> as it is to <span class="docEmphasis">increase confidence</span> that the code works as expected. Since it is unrealistic to assume you can find all the bugs, the goal of a quality assurance (QA) plan should be to achieve the greatest possible confidence given the testing resources available. More things can go wrong in a concurrent program than in a sequential one, and therefore more testing is required to achieve the same level of confidence. So far we've focused primarily on techniques for constructing effective unit and performance tests. Testing is critically important for building confidence that concurrent classes behave correctly, but should be only one of the QA metholologies you employ.</p>
<p class="docText1"><a name="iddle1273" class="calibre18" id="iddle1273"></a><a name="iddle1274" class="calibre18" id="iddle1274"></a><a name="iddle1275" class="calibre18" id="iddle1275"></a><a name="iddle1276" class="calibre18" id="iddle1276"></a><a name="iddle1277" class="calibre18" id="iddle1277"></a><a name="iddle1369" class="calibre18" id="iddle1369"></a><a name="iddle1370" class="calibre18" id="iddle1370"></a><a name="iddle2363" class="calibre18" id="iddle2363"></a><a name="iddle3840" class="calibre18" id="iddle3840"></a><a name="iddle4441" class="calibre18" id="iddle4441"></a><a name="iddle4556" class="calibre18" id="iddle4556"></a><a name="iddle4557" class="calibre18" id="iddle4557"></a><a name="iddle4953" class="calibre18" id="iddle4953"></a>Different QA methodologies are more effective at finding some types of defects and less effective at finding others. By employing complementary testing methodologies such as code review and static analysis, you can achieve greater confidence than you could with any single approach.</p>
<a name="ch12lev2sec15" class="calibre18" id="ch12lev2sec15"></a>
<h4 id="title-IDA1RPZW" class="docSection2Title">12.4.1. Code Review</h4>
<p class="docText1">As effective and important as unit and stress tests are for finding concurrency bugs, they are no substitute for rigorous code review by multiple people. (On the other hand, code review is no substitute for testing either.) You can and should design tests to maximize their chances of discovering safety errors, and you should run them frequently, but you should not neglect to have concurrent code reviewed carefully by someone besides its author. Even concurrency experts make mistakes; taking the time to have someone else review the code is almost always worthwhile. Expert concurrent programmers are better at finding subtle races than are most test programs. (Also, platform issues such as JVM implementation details or processor memory models can prevent bugs from showing up on particular hardware or software configurations.) Code review also has other benefits; not only can it find errors, but it often improves the quality of comments describing the implementation details, thus reducing future maintenence cost and risk.</p>
<a name="ch12lev2sec16" class="calibre18" id="ch12lev2sec16"></a>
<h4 id="title-IDAHSPZW" class="docSection2Title">12.4.2. Static Analysis Tools</h4>
<p class="docText1">As of this writing, <span class="docEmphasis">static analysis tools</span> are rapidly emerging as an effective complement to formal testing and code review. Static code analysis is the process of analyzing code without executing it, and code auditing tools can analyze classes to look for instances of common <span class="docEmphasis">bug patterns</span>. Static analysis tools such as the open-source FindBugs<sup class="docFootnote"><a class="calibre2" href="#ch12fn09">[9]</a></sup> contain <span class="docEmphasis">bug-pattern detectors</span> for many common coding errors, many of which can easily be missed by testing or code review.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch12fn09" class="calibre18" id="ch12fn09">[9]</a></sup> <tt class="calibre35"><a class="calibre2" target="_blank" href="http://findbugs.sourceforge.net">http://findbugs.sourceforge.net</a></tt></p></blockquote>
<p class="docText1">Static analysis tools produce a list of warnings that must be examined by hand to determine whether they represent actual errors. Historically, tools like <tt class="calibre25">lint</tt> produced so many false warnings as to scare developers away, but tools like FindBugs have been tuned to produce many fewer false alarms. Static analysis tools are still somewhat primitive (especially in their integration with development tools and lifecycle), but they are already effective enough to be a valuable addition to the testing process.</p>
<p class="docText1">As of this writing, FindBugs includes detectors for the following concurrencyrelated bug patterns, and more are being added all the time:</p>
<p class="docText1"><span class="docEmphStrong">Inconsistent synchronization.</span> Many objects follow the synchronization policy of guarding all variables with the object's intrinsic lock. If a field is accessed frequently but not always with the <tt class="calibre25">this</tt> lock held, this may indicate that the synchronization policy is not being consistently followed.</p>
<p class="docText1">Analysis tools must guess at the synchronization policy because Java classes do not have formal concurrency specifications. In the future, if annotations <a name="iddle1572" class="calibre18" id="iddle1572"></a><a name="iddle1573" class="calibre18" id="iddle1573"></a><a name="iddle1970" class="calibre18" id="iddle1970"></a><a name="iddle3088" class="calibre18" id="iddle3088"></a><a name="iddle3089" class="calibre18" id="iddle3089"></a><a name="iddle3159" class="calibre18" id="iddle3159"></a><a name="iddle3160" class="calibre18" id="iddle3160"></a><a name="iddle3324" class="calibre18" id="iddle3324"></a><a name="iddle3325" class="calibre18" id="iddle3325"></a><a name="iddle5136" class="calibre18" id="iddle5136"></a>such as <tt class="calibre25">@GuardedBy</tt> are standardized, auditing tools could interpret annotations rather than having to guess at the relationship between variables and locks, thus improving the quality of analysis.</p>
<p class="docText1"><span class="docEmphStrong">Invoking <tt class="calibre25">THRead.run</tt>.</span> <tt class="calibre25">THRead</tt> implements <tt class="calibre25">Runnable</tt> and therefore has a <tt class="calibre25">run</tt> method. However, it is almost always a mistake to call <tt class="calibre25">Thread.run</tt> directly; usually the programmer meant to call <tt class="calibre25">THRead.start</tt>.</p>
<p class="docText1"><span class="docEmphStrong">Unreleased lock.</span> Unlike intrinsic locks, explicit locks (see <a class="calibre2" href="ch13.html#ch13">Chapter 13</a>) are not automatically released when control exits the scope in which they were acquired. The standard idiom is to release the lock from a <tt class="calibre25">finally</tt> block; otherwise the lock can remain unreleased in the event of an <tt class="calibre25">Exception</tt>.</p>
<p class="docText1"><span class="docEmphStrong">Empty <tt class="calibre25">synchronized</tt> block.</span> While empty <tt class="calibre25">synchronized</tt> blocks do have semantics under the Java Memory Model, they are frequently used incorrectly, and there are usually better solutions to whatever problem the developer was trying to solve.</p>
<p class="docText1"><span class="docEmphStrong">Double-checked locking.</span> Double-checked locking is a broken idiom for reducing synchronization overhead in lazy initialization (see <a class="calibre2" href="ch16lev1sec2.html#ch16lev2sec8">Section 16.2.4</a>) that involves reading a shared mutable field without appropriate synchronization.</p>
<p class="docText1"><span class="docEmphStrong">Starting a thread from a constructor.</span> Starting a thread from a constructor introduces the risk of subclassing problems, and can allow the <tt class="calibre25">this</tt> reference to escape the constructor.</p>
<p class="docText1"><span class="docEmphStrong">Notification errors.</span> The <tt class="calibre25">notify</tt> and <tt class="calibre25">notifyAll</tt> methods indicate that an object's state may have changed in a way that would unblock threads that are waiting on the associated condition queue. These methods should be called only when the state associated with the condition queue has changed. A <tt class="calibre25">synchronized</tt> block that calls <tt class="calibre25">notify</tt> or <tt class="calibre25">notifyAll</tt> but does not modify any state is likely to be an error. (See <a class="calibre2" href="ch14.html#ch14">Chapter 14</a>.)</p>
<p class="docText1"><span class="docEmphStrong">Condition wait errors.</span> When waiting on a condition queue, <tt class="calibre25">Object.wait</tt> or <tt class="calibre25">Condition. await</tt> should be called in a loop, with the appropriate lock held, after testing some state predicate (see <a class="calibre2" href="ch14.html#ch14">Chapter 14</a>). Calling <tt class="calibre25">Object.wait</tt> or <tt class="calibre25">Condition.await</tt> without the lock held, not in a loop, or without testing some state predicate is almost certainly an error.</p>
<p class="docText1"><span class="docEmphStrong">Misuse of <tt class="calibre25">Lock</tt> and <tt class="calibre25">Condition</tt>.</span> Using a <tt class="calibre25">Lock</tt> as the lock argument for a <tt class="calibre25">synchronized</tt> block is likely to be a typo, as is calling <tt class="calibre25">Condition.wait</tt> instead of <tt class="calibre25">await</tt> (though the latter would likely be caught in testing, since it would throw an <tt class="calibre25">IllegalMonitorStateException</tt> the first time it was called).</p>
<p class="docText1"><span class="docEmphStrong">Sleeping or waiting while holding a lock.</span> Calling <tt class="calibre25">Thread.sleep</tt> with a lock held can prevent other threads from making progress for a long time and is therefore a potentially serious liveness hazard. Calling <tt class="calibre25">Object.wait</tt> or <tt class="calibre25">Condition.await</tt> with two locks held poses a similar hazard.</p>
<p class="docText1"><span class="docEmphStrong">Spin loops.</span> <a name="iddle1103" class="calibre18" id="iddle1103"></a><a name="iddle3254" class="calibre18" id="iddle3254"></a><a name="iddle3255" class="calibre18" id="iddle3255"></a><a name="iddle3695" class="calibre18" id="iddle3695"></a><a name="iddle4344" class="calibre18" id="iddle4344"></a><a name="iddle4847" class="calibre18" id="iddle4847"></a><a name="iddle4848" class="calibre18" id="iddle4848"></a><a name="iddle4947" class="calibre18" id="iddle4947"></a><a name="iddle4948" class="calibre18" id="iddle4948"></a><a name="iddle4952" class="calibre18" id="iddle4952"></a><a name="iddle5143" class="calibre18" id="iddle5143"></a>Code that does nothing but spin (busy wait) checking a field for an expected value can waste CPU time and, if the field is not volatile, is not guaranteed to terminate. Latches or condition waits are often a better technique when waiting for a state transition to occur.</p>
<a name="ch12lev2sec17" class="calibre18" id="ch12lev2sec17"></a>
<h4 id="title-IDANAGBX" class="docSection2Title">12.4.3. Aspect-oriented Testing Techniques</h4>
<p class="docText1">As of this writing, aspect-oriented programming (AOP) techniques have only limited applicability to concurrency, because most popular AOP tools do not yet support pointcuts at synchronization points. However, AOP can be applied to assert invariants or some aspects of compliance with synchronization policies. For example, (<a class="calibre2" href="bib01.html#biblio01_020">Laddad, 2003</a>) provides an example of using an aspect to wrap all calls to non-thread-safe Swing methods with the assertion that the call is occurring in the event thread. As it requires no code changes, this technique is easy to apply and can disclose subtle publication and thread-confinement errors.</p>
<a name="ch12lev2sec18" class="calibre18" id="ch12lev2sec18"></a>
<h4 id="title-IDABBGBX" class="docSection2Title">12.4.4. Profilers and Monitoring Tools</h4>
<p class="docText1">Most commercial profiling tools have some support for threads. They vary in feature set and effectiveness, but can often provide insight into what your program is doing (although profiling tools are usually intrusive and can substantially affect program timing and behavior). Most offer a display showing a timeline for each thread with different colors for the various thread states (runnable, blocked waiting for a lock, blocked waiting for I/O, etc.). Such a display can show how effectively your program is utilizing the available CPU resources, and if it is doing badly, where to look for the cause. (Many profilers also claim features for identifying which locks are causing contention, but in practice these features are often a blunter instrument than is desired for analyzing a program's locking behavior.)</p>
<p class="docText1">The built-in JMX agent also offers some limited features for monitoring thread behavior. The <tt class="calibre25">ThreadInfo</tt> class includes the thread's current state and, if the thread is blocked, the lock or condition queue on which it is blocked. If the "thread contention monitoring" feature is enabled (it is disabled by default because of its performance impact), <tt class="calibre25">ThreadInfo</tt> also includes the number of times that the thread has blocked waiting for a lock or notification, and the cumulative amount of time it has spent waiting.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

