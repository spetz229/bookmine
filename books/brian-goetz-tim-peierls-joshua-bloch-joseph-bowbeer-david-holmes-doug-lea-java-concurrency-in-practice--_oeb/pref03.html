---
layout: page
title: "Java Concurrency in Practice"
prev: pref02.html
next: ch01.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="pref03" class="calibre18" id="pref03"></a><h2 id="title-IDAFLAGV" class="docPrefaceTitle">Preface</h2><p class="docText1">At this writing, multicore processors are just now becoming inexpensive enough for midrange desktop systems. Not coincidentally, many development teams are noticing more and more threading-related bug reports in their projects. In a recent post on the NetBeans developer site, one of the core maintainers observed that a single class had been patched over 14 times to fix threading-related problems. Dion Almaer, former editor of TheServerSide, recently blogged (after a painful debugging session that ultimately revealed a threading bug) that most Java programs are so rife with concurrency bugs that they work only "by accident".</p><p class="docText1">Indeed, developing, testing and debugging multithreaded programs can be extremely difficult because concurrency bugs do not manifest themselves predictably. And when they do surface, it is often at the worst possible timein production, under heavy load.</p><p class="docText1">One of the challenges of developing concurrent programs in Java is the mismatch between the concurrency features offered by the platform and how developers need to think about concurrency in their programs. The language provides low-level <span class="docEmphasis">mechanisms</span> such as synchronization and condition waits, but these mechanisms must be used consistently to implement application-level protocols or <span class="docEmphasis">policies</span>. Without such policies, it is all too easy to create programs that compile and appear to work but are nevertheless broken. Many otherwise excellent books on concurrency fall short of their goal by focusing excessively on low-level mechanisms and APIs rather than design-level policies and patterns.</p><p class="docText1">Java 5.0 is a huge step forward for the development of concurrent applications in Java, providing new higher-level components and additional low-level mechanisms that make it easier for novices and experts alike to build concurrent applications. The authors are the primary members of the JCP Expert Group that created these facilities; in addition to describing their behavior and features, we present the underlying design patterns and anticipated usage scenarios that motivated their inclusion in the platform libraries.</p><p class="docText1">Our goal is to give readers a set of design rules and mental models that make it easierand more funto build correct, performant concurrent classes and applications in Java.</p><p class="docText1">We hope you enjoy <span class="docEmphasis">Java Concurrency in Practice</span>.</p><p class="docText1">Brian Goetz<br class="calibre11"/>Williston, VT<br class="calibre11"/><span class="docEmphasis">March 2006</span></p><a name="pref03lev1sec1" class="calibre18" id="pref03lev1sec1"></a>
<h3 id="title-IDAFMAGV" class="docSection1Title">How to Use this Book</h3>
<p class="docText1">To address the abstraction mismatch between Java's low-level mechanisms and the necessary design-level policies, we present a <span class="docEmphasis">simplified</span> set of rules for writing concurrent programs. Experts may look at these rules and say "Hmm, that's not entirely true: class <span class="docEmphasis">C</span> is thread-safe even though it violates rule <span class="docEmphasis">R</span>." While it is possible to write correct programs that break our rules, doing so requires a deep understanding of the low-level details of the Java Memory Model, and we want developers to be able to write correct concurrent programs <span class="docEmphasis">without</span> having to master these details. Consistently following our simplified rules will produce correct and maintainable concurrent programs.</p>
<p class="docText1">We assume the reader already has some familiarity with the basic mechanisms for concurrency in Java. <span class="docEmphasis">Java Concurrency in Practice</span> is not an introduction to concurrencyfor that, see the threading chapter of any decent introductory volume, such as <span class="docEmphasis">The Java Programming Language</span> (<a class="calibre2" href="bib01.html#biblio01_001">Arnold et al., 2005</a>). Nor is it an encyclopedic reference for All Things Concurrencyfor that, see <span class="docEmphasis">Concurrent Programming in Java</span> (<a class="calibre2" href="bib01.html#biblio01_021">Lea, 2000</a>). Rather, it offers practical design rules to assist developers in the difficult process of creating safe and performant concurrent classes. Where appropriate, we cross-reference relevant sections of <span class="docEmphasis">The Java Programming Language</span>, <span class="docEmphasis">Concurrent Programming in Java</span>, <span class="docEmphasis">The Java Language Specification</span> (<a class="calibre2" href="bib01.html#biblio01_001">Gosling et al., 2005</a>), and <span class="docEmphasis">Effective Java</span> (<a class="calibre2" href="bib01.html#biblio01_003">Bloch, 2001</a>) using the conventions [JPL n.m], [CPJ n.m], [JLS n.m], and [EJ Item n].</p>
<p class="docText1">After the introduction (<a class="calibre2" href="ch01.html#ch01">Chapter 1</a>), the book is divided into four parts:</p>
<p class="docText1"><span class="docEmphStrong">Fundamentals.</span> <a class="calibre2" href="part01.html#part01">Part I</a> (<a class="calibre2" href="ch02_split_000.html#ch02">Chapters 2</a>-<a class="calibre2" href="ch05.html#ch05">5</a>) focuses on the basic concepts of concurrency and thread safety, and how to compose thread-safe classes out of the concurrent building blocks provided by the class library. A "cheat sheet" summarizing the most important of the rules presented in <a class="calibre2" href="part01.html#part01">Part I</a> appears on page 110.</p>
<p class="docText1"><a class="calibre2" href="ch02_split_000.html#ch02">Chapters 2</a> (Thread Safety) and <a class="calibre2" href="ch03.html#ch03">3</a> (Sharing Objects) form the foundation for the book. Nearly all of the rules on avoiding concurrency hazards, constructing thread-safe classes, and verifying thread safety are here. Readers who prefer "practice" to "theory" may be tempted to skip ahead to <a class="calibre2" href="part02.html#part02">Part II</a>, but make sure to come back and read <a class="calibre2" href="ch02_split_000.html#ch02">Chapters 2</a> and <a class="calibre2" href="ch03.html#ch03">3</a> before writing any concurrent code!</p>
<p class="docText1"><a class="calibre2" href="ch04.html#ch04">Chapter 4</a> (Composing Objects) covers techniques for composing thread-safe classes into larger thread-safe classes. <a class="calibre2" href="ch05.html#ch05">Chapter 5</a> (Building Blocks) covers the concurrent building blocksthread-safe collections and synchronizersprovided by the platform libraries.</p>
<p class="docText1"><span class="docEmphStrong">Structuring Concurrent Applications.</span> <a class="calibre2" href="part02.html#part02">Part II</a> (<a class="calibre2" href="ch06.html#ch06">Chapters 6</a>-<a class="calibre2" href="ch09.html#ch09">9</a>) describes how to exploit threads to improve the throughput or responsiveness of concurrent applications. <a class="calibre2" href="ch06.html#ch06">Chapter 6</a> (Task Execution) covers identifying parallelizable tasks and executing them within the task-execution framework. <a class="calibre2" href="ch07.html#ch07">Chapter 7</a> (Cancellation and Shutdown) deals with techniques for convincing tasks and threads to terminate before they would normally do so; how programs deal with cancellation and shutdown is often one of the factors that separates truly robust concurrent applications from those that merely work. <a class="calibre2" href="ch08.html#ch08">Chapter 8</a> (Applying Thread Pools) addresses some of the more advanced features of the task-execution framework.</p>
<p class="docText1"><a class="calibre2" href="ch09.html#ch09">Chapter 9</a> (GUI Applications) focuses on techniques for improving responsiveness in single-threaded subsystems.</p>
<p class="docText1"><span class="docEmphStrong">Liveness, Performance, and Testing.</span> <a class="calibre2" href="part03.html#part03">Part III</a> (<a class="calibre2" href="ch10.html#ch10">Chapters 10</a>-<a class="calibre2" href="ch12.html#ch12">12</a>) concerns itself with ensuring that concurrent programs actually do what you want them to do and do so with acceptable performance. <a class="calibre2" href="ch10.html#ch10">Chapter 10</a> (Avoiding Liveness Hazards) describes how to avoid liveness failures that can prevent programs from making forward progress. <a class="calibre2" href="ch11.html#ch11">Chapter 11</a> (Performance and Scalability) covers techniques for improving the performance and scalability of concurrent code. <a class="calibre2" href="ch12.html#ch12">Chapter 12</a> (Testing Concurrent Programs) covers techniques for testing concurrent code for both correctness and performance.</p>
<p class="docText1"><span class="docEmphStrong">Advanced Topics.</span> <a class="calibre2" href="part04.html#part04">Part IV</a> (<a class="calibre2" href="ch13.html#ch13">Chapters 13</a>-<a class="calibre2" href="ch16.html#ch16">16</a>) covers topics that are likely to be of interest only to experienced developers: explicit locks, atomic variables, nonblocking algorithms, and developing custom synchronizers.</p>
<a name="pref03lev1sec2" class="calibre18" id="pref03lev1sec2"></a>
<h3 id="title-IDAVVAGV" class="docSection1Title">Code Examples</h3>
<p class="docText1">While many of the general concepts in this book are applicable to versions of Java prior to Java 5.0 and even to non-Java environments, most of the code examples (and all the statements about the Java Memory Model) assume Java 5.0 or later. Some of the code examples may use library features added in Java 6.</p>
<p class="docText1">The code examples have been compressed to reduce their size and to highlight the relevant portions. The full versions of the code examples, as well as supplementary examples and errata, are available from the book's website, <tt class="calibre25"><a class="calibre2" target="_blank" href="http://www.javaconcurrencyinpractice.com">http://www.javaconcurrencyinpractice.com</a></tt>.</p>
<p class="docText1">The code examples are of three sorts: "good" examples, "not so good" examples, and "bad" examples. Good examples illustrate techniques that should be emulated. Bad examples illustrate techniques that should definitely <span class="docEmphasis">not</span> be emulated, and are identified with a "Mr. Yuk" icon<sup class="docFootnote"><a class="calibre2" href="#pref03fn01">[1]</a></sup> to make it clear that this is "toxic" code (see <a class="calibre2" href="#pref03list01">Listing 1</a>). Not-so-good examples illustrate techniques that are not <span class="docEmphasis">necessarily</span> wrong but are fragile, risky, or perform poorly, and are decorated with a "Mr. Could BeHappier" icon as in <a class="calibre2" href="#pref03list02">Listing 2</a>.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="pref03fn01" class="calibre18" id="pref03fn01">[1]</a></sup> Mr. Yuk is a registered trademark of the Children's Hospital of Pittsburgh and appears by permission.</p></blockquote>
<a name="pref03list01" class="calibre18" id="pref03list01"></a><h5 id="title-IDACXAGV" class="docExampleTitle">Listing 1. Bad Way to Sort a List. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" src="face.jpg" class="calibre29"/>
<pre class="calibre30">public &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    // <span class="docEmphasis">Never returns the wrong answer!</span>
    System.exit(0);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Some readers may question the role of the "bad" examples in this book; after all, a book should show how to do things right, not wrong. The bad examples have two purposes. They illustrate common pitfalls, but more importantly they demonstrate how to analyze a program for thread safetyand the best way to do that is to see the ways in which thread safety is compromised.</p>
<p class="docText1"></p><a name="pref03list02" class="calibre18" id="pref03list02"></a><h5 id="title-IDAHYAGV" class="docExampleTitle">Listing 2. Less than Optimal Way to Sort a List.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" src="face1.jpg" class="calibre31"/>
<pre class="calibre30">public &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    for (int i=0; i&lt;1000000; i++)
        doNothing();
    Collections.sort(list);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="pref03lev1sec3" class="calibre18" id="pref03lev1sec3"></a>
<h3 id="title-IDACZAGV" class="docSection1Title">Acknowledgments</h3>
<p class="docText1">This book grew out of the development process for the <tt class="calibre25">java.util.concurrent</tt> package that was created by the Java Community Process JSR 166 for inclusion in Java 5.0. Many others contributed to JSR 166; in particular we thank Martin Buchholz for doing all the work related to getting the code into the JDK, and all the readers of the <tt class="calibre25">concurrency-interest</tt> mailing list who offered their suggestions and feedback on the draft APIs.</p>
<p class="docText1">This book has been tremendously improved by the suggestions and assistance of a small army of reviewers, advisors, cheerleaders, and armchair critics. We would like to thank Dion Almaer, Tracy Bialik, Cindy Bloch, Martin Buchholz, Paul Christmann, Cliff Click, Stuart Halloway, David Hovemeyer, Jason Hunter, Michael Hunter, Jeremy Hylton, Heinz Kabutz, Robert Kuhar, Ramnivas Laddad, Jared Levy, Nicole Lewis, Victor Luchangco, Jeremy Manson, Paul Martin, Berna Massingill, Michael Maurer, Ted Neward, Kirk Pepperdine, Bill Pugh, Sam Pullara, Russ Rufer, Bill Scherer, Jeffrey Siegal, Bruce Tate, Gil Tene, Paul Tyma, and members of the Silicon Valley Patterns Group who, through many interesting technical conversations, offered guidance and made suggestions that helped make this book better.</p>
<p class="docText1">We are especially grateful to Cliff Biffle, Barry Hayes, Dawid Kurzyniec, Angelika Langer, Doron Rajwan, and Bill Venners, who reviewed the entire manuscript in excruciating detail, found bugs in the code examples, and suggested numerous improvements.</p>
<p class="docText1">We thank Katrina Avery for a great copy-editing job and Rosemary Simpson for producing the index under unreasonable time pressure. We thank Ami Dewar for doing the illustrations.</p>
<p class="docText1">Thanks to the whole team at Addison-Wesley who helped make this book a reality. Ann Sellers got the project launched and Greg Doench shepherded it to a smooth completion; Elizabeth Ryan guided it through the production process.</p>
<p class="docText1">We would also like to thank the thousands of software engineers who contributed indirectly by creating the software used to create this book, including TEX, LATEX, Adobe Acrobat, <tt class="calibre25">pic</tt>, <tt class="calibre25">grap</tt>, Adobe Illustrator, Perl, Apache Ant, IntelliJ IDEA, GNU emacs, Subversion, TortoiseSVN, and of course, the Java platform and class libraries.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

