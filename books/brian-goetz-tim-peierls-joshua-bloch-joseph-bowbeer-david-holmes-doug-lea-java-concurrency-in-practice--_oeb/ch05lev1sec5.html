---
layout: page
title: "Java Concurrency in Practice"
prev: ch05lev1sec4.html
next: ch05lev1sec6.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch05lev1sec5" class="calibre18" id="ch05lev1sec5"></a>
<h3 id="title-IDA25IJU" class="docSection1Title">5.5. Synchronizers</h3>
<p class="docText1"><a name="iddle1440" class="calibre18" id="iddle1440"></a><a name="iddle1582" class="calibre18" id="iddle1582"></a><a name="iddle1624" class="calibre18" id="iddle1624"></a><a name="iddle1625" class="calibre18" id="iddle1625"></a><a name="iddle1629" class="calibre18" id="iddle1629"></a><a name="iddle1653" class="calibre18" id="iddle1653"></a><a name="iddle1654" class="calibre18" id="iddle1654"></a><a name="iddle1728" class="calibre18" id="iddle1728"></a><a name="iddle1903" class="calibre18" id="iddle1903"></a><a name="iddle1904" class="calibre18" id="iddle1904"></a><a name="iddle2026" class="calibre18" id="iddle2026"></a><a name="iddle2194" class="calibre18" id="iddle2194"></a><a name="iddle2446" class="calibre18" id="iddle2446"></a><a name="iddle2932" class="calibre18" id="iddle2932"></a><a name="iddle2933" class="calibre18" id="iddle2933"></a><a name="iddle2934" class="calibre18" id="iddle2934"></a><a name="iddle2935" class="calibre18" id="iddle2935"></a><a name="iddle2936" class="calibre18" id="iddle2936"></a><a name="iddle3683" class="calibre18" id="iddle3683"></a><a name="iddle3684" class="calibre18" id="iddle3684"></a><a name="iddle4398" class="calibre18" id="iddle4398"></a><a name="iddle4585" class="calibre18" id="iddle4585"></a><a name="iddle4586" class="calibre18" id="iddle4586"></a><a name="iddle4587" class="calibre18" id="iddle4587"></a><a name="iddle4588" class="calibre18" id="iddle4588"></a><a name="iddle4589" class="calibre18" id="iddle4589"></a><a name="iddle4590" class="calibre18" id="iddle4590"></a>Blocking queues are unique among the collections classes: not only do they act as containers for objects, but they can also coordinate the control flow of producer and consumer threads because <tt class="calibre25">take</tt> and <tt class="calibre25">put</tt> block until the queue enters the desired state (not empty or not full).</p>
<p class="docText1">A <span class="docEmphasis">synchronizer</span> is any object that coordinates the control flow of threads based on its state. Blocking queues can act as synchronizers; other types of synchronizers include semaphores, barriers, and latches. There are a number of synchronizer classes in the platform library; if these do not meet your needs, you can also create your own using the mechanisms described in <a class="calibre2" href="ch14.html#ch14">Chapter 14</a>.</p>
<p class="docText1">All synchronizers share certain structural properties: they encapsulate state that determines whether threads arriving at the synchronizer should be allowed to pass or forced to wait, provide methods to manipulate that state, and provide methods to wait efficiently for the synchronizer to enter the desired state.</p>
<a name="ch05lev2sec10" class="calibre18" id="ch05lev2sec10"></a>
<h4 id="title-IDA1TJJU" class="docSection2Title">5.5.1. Latches</h4>
<p class="docText1">A <span class="docEmphasis">latch</span> is a synchronizer that can delay the progress of threads until it reaches its <span class="docEmphasis">terminal</span> state [CPJ 3.4.2]. A latch acts as a gate: until the latch reaches the terminal state the gate is closed and no thread can pass, and in the terminal state the gate opens, allowing all threads to pass. Once the latch reaches the terminal state, it cannot change state again, so it remains open forever. Latches can be used to ensure that certain activities do not proceed until other one-time activities complete, such as:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1">Ensuring that a computation does not proceed until resources it needs have been initialized. A simple binary (two-state) latch could be used to indicate "Resource <span class="docEmphasis">R</span> has been initialized", and any activity that requires <span class="docEmphasis">R</span> would wait first on this latch.</p></li><li class="calibre16"><p class="docText1"><a name="iddle1700" class="calibre18" id="iddle1700"></a><a name="iddle2197" class="calibre18" id="iddle2197"></a><a name="iddle1136" class="calibre18" id="iddle1136"></a><a name="iddle1291" class="calibre18" id="iddle1291"></a><a name="iddle1300" class="calibre18" id="iddle1300"></a><a name="iddle1397" class="calibre18" id="iddle1397"></a><a name="iddle1441" class="calibre18" id="iddle1441"></a><a name="iddle1607" class="calibre18" id="iddle1607"></a><a name="iddle1697" class="calibre18" id="iddle1697"></a><a name="iddle2225" class="calibre18" id="iddle2225"></a><a name="iddle2423" class="calibre18" id="iddle2423"></a><a name="iddle2430" class="calibre18" id="iddle2430"></a><a name="iddle2432" class="calibre18" id="iddle2432"></a><a name="iddle2940" class="calibre18" id="iddle2940"></a><a name="iddle3982" class="calibre18" id="iddle3982"></a><a name="iddle4019" class="calibre18" id="iddle4019"></a><a name="iddle4424" class="calibre18" id="iddle4424"></a><a name="iddle4425" class="calibre18" id="iddle4425"></a><a name="iddle4604" class="calibre18" id="iddle4604"></a><a name="iddle4605" class="calibre18" id="iddle4605"></a><a name="iddle4654" class="calibre18" id="iddle4654"></a><a name="iddle4655" class="calibre18" id="iddle4655"></a><a name="iddle5144" class="calibre18" id="iddle5144"></a><a name="iddle5145" class="calibre18" id="iddle5145"></a>Ensuring that a service does not start until other services on which it depends have started. Each service would have an associated binary latch; starting service <span class="docEmphasis">S</span> would involve first waiting on the latches for other services on which <span class="docEmphasis">S</span> depends, and then releasing the <span class="docEmphasis">S</span> latch after startup completes so any services that depend on <span class="docEmphasis">S</span> can then proceed.</p></li><li class="calibre16"><p class="docText1">Waiting until all the parties involved in an activity, for instance the players in a multi-player game, are ready to proceed. In this case, the latch reaches the terminal state after all the players are ready.</p></li></ul>
<p class="docText1"><tt class="calibre25">CountDownLatch</tt> is a flexible latch implementation that can be used in any of these situations; it allows one or more threads to wait for a set of events to occur. The latch state consists of a counter initialized to a positive number, representing the number of events to wait for. The <tt class="calibre25">countDown</tt> method decrements the counter, indicating that an event has occurred, and the <tt class="calibre25">await</tt> methods wait for the counter to reach zero, which happens when all the events have occurred. If the counter is nonzero on entry, <tt class="calibre25">await</tt> blocks until the counter reaches zero, the waiting thread is interrupted, or the wait times out.</p>
<p class="docText1"><tt class="calibre25">TestHarness</tt> in <a class="calibre2" href="#ch05list11">Listing 5.11</a> illustrates two common uses for latches. <tt class="calibre25">TestHarness</tt> creates a number of threads that run a given task concurrently. It uses two latches, a "starting gate" and an "ending gate". The starting gate is initialized with a count of one; the ending gate is initialized with a count equal to the number of worker threads. The first thing each worker thread does is wait on the starting gate; this ensures that none of them starts working until they all are ready to start. The last thing each does is count down on the ending gate; this allows the master thread to wait efficiently until the last of the worker threads has finished, so it can calculate the elapsed time.</p>
<p class="docText1">Why did we bother with the latches in <tt class="calibre25">TestHarness</tt> instead of just starting the threads immediately after they are created? Presumably, we wanted to measure how long it takes to run a task <span class="docEmphasis">n</span> times <span class="docEmphasis">concurrently</span>. If we simply created and started the threads, the threads started earlier would have a "head start" on the later threads, and the degree of contention would vary over time as the number of active threads increased or decreased. Using a starting gate allows the master thread to release all the worker threads at once, and the ending gate allows the master thread to wait for the <span class="docEmphasis">last</span> thread to finish rather than waiting sequentially for each thread to finish.</p>
<a name="ch05lev2sec11" class="calibre18" id="ch05lev2sec11"></a>
<h4 id="title-IDAAHSIU" class="docSection2Title">5.5.2. FutureTask</h4>
<p class="docText1"><tt class="calibre25">FutureTask</tt> also acts like a latch. (<tt class="calibre25">FutureTask</tt> implements <tt class="calibre25">Future</tt>, which describes an abstract result-bearing computation [CPJ 4.3.3].) A computation represented by a <tt class="calibre25">FutureTask</tt> is implemented with a <tt class="calibre25">Callable</tt>, the result-bearing equivalent of <tt class="calibre25">Runnable</tt>, and can be in one of three states: waiting to run, running, or completed. Completion subsumes all the ways a computation can complete, including normal completion, cancellation, and exception. Once a <tt class="calibre25">FutureTask</tt> enters the completed state, it stays in that state forever.</p>
<p class="docText1">The behavior of <tt class="calibre25">Future.get</tt> depends on the state of the task. If it is completed, <tt class="calibre25">get</tt> returns the result immediately, and otherwise blocks until the task transitions <a name="iddle2039" class="calibre18" id="iddle2039"></a><a name="iddle2040" class="calibre18" id="iddle2040"></a><a name="iddle2156" class="calibre18" id="iddle2156"></a><a name="iddle2226" class="calibre18" id="iddle2226"></a><a name="iddle2261" class="calibre18" id="iddle2261"></a><a name="iddle2436" class="calibre18" id="iddle2436"></a>to the completed state and then returns the result or throws an exception. <tt class="calibre25">FutureTask</tt> conveys the result from the thread executing the computation to the thread(s) retrieving the result; the specification of <tt class="calibre25">FutureTask</tt> guarantees that this transfer constitutes a safe publication of the result.</p>
<a name="ch05list11" class="calibre18" id="ch05list11"></a><h5 id="title-IDAOSKIU" class="docExampleTitle">Listing 5.11. Using <tt class="calibre33">CountDownLatch</tt> for Starting and Stopping Threads in Timing Tests.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i &lt; nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><tt class="calibre25">FutureTask</tt> is used by the <tt class="calibre25">Executor</tt> framework to represent asynchronous tasks, and can also be used to represent any potentially lengthy computation that can be started before the results are needed. <tt class="calibre25">Preloader</tt> in <a class="calibre2" href="#ch05list12">Listing 5.12</a> uses <tt class="calibre25">FutureTask</tt> to perform an expensive computation whose results are needed later; by starting the computation early, you reduce the time you would have to wait later when you actually need the results.</p>
<a name="ch05list12" class="calibre18" id="ch05list12"></a><h5 id="title-IDARTKIU" class="docExampleTitle">Listing 5.12. Using <tt class="calibre33">FutureTask</tt> to Preload Data that is Needed Later.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class Preloader {
    private final FutureTask&lt;ProductInfo&gt; future =
        new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException)
                throw (DataLoadException) cause;
            else
                throw launderThrowable(cause);
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><tt class="calibre25">Preloader</tt> creates a <tt class="calibre25">FutureTask</tt> that describes the task of loading product information from a database and a thread in which the computation will be performed. It provides a <tt class="calibre25">start</tt> method to start the thread, since it is inadvisable to start a thread from a constructor or static initializer. When the program later needs the <tt class="calibre25">ProductInfo</tt>, it can call <tt class="calibre25">get</tt>, which returns the loaded data if it is ready, or waits for the load to complete if not.</p>
<p class="docText1">Tasks described by <tt class="calibre25">Callable</tt> can throw checked and unchecked exceptions, and any code can throw an <tt class="calibre25">Error</tt>. Whatever the task code may throw, it is <a name="iddle1319" class="calibre18" id="iddle1319"></a><a name="iddle1320" class="calibre18" id="iddle1320"></a><a name="iddle1442" class="calibre18" id="iddle1442"></a><a name="iddle1701" class="calibre18" id="iddle1701"></a><a name="iddle2252" class="calibre18" id="iddle2252"></a><a name="iddle2253" class="calibre18" id="iddle2253"></a><a name="iddle2701" class="calibre18" id="iddle2701"></a><a name="iddle2702" class="calibre18" id="iddle2702"></a><a name="iddle3551" class="calibre18" id="iddle3551"></a><a name="iddle3612" class="calibre18" id="iddle3612"></a><a name="iddle3613" class="calibre18" id="iddle3613"></a><a name="iddle3841" class="calibre18" id="iddle3841"></a><a name="iddle3842" class="calibre18" id="iddle3842"></a><a name="iddle3936" class="calibre18" id="iddle3936"></a><a name="iddle3937" class="calibre18" id="iddle3937"></a><a name="iddle4025" class="calibre18" id="iddle4025"></a><a name="iddle4136" class="calibre18" id="iddle4136"></a><a name="iddle4145" class="calibre18" id="iddle4145"></a><a name="iddle4146" class="calibre18" id="iddle4146"></a><a name="iddle4150" class="calibre18" id="iddle4150"></a><a name="iddle4880" class="calibre18" id="iddle4880"></a><a name="iddle4881" class="calibre18" id="iddle4881"></a>wrapped in an <tt class="calibre25">ExecutionException</tt> and rethrown from <tt class="calibre25">Future.get</tt>. This complicates code that calls <tt class="calibre25">get</tt>, not only because it must deal with the possibility of <tt class="calibre25">ExecutionException</tt> (and the unchecked <tt class="calibre25">CancellationException</tt>), but also because the cause of the <tt class="calibre25">ExecutionException</tt> is returned as a <tt class="calibre25">THRowable</tt>, which is inconvenient to deal with.</p>
<p class="docText1">When <tt class="calibre25">get</tt> throws an <tt class="calibre25">ExecutionException</tt> in <tt class="calibre25">Preloader</tt>, the cause will fall into one of three categories: a checked exception thrown by the <tt class="calibre25">Callable</tt>, a <tt class="calibre25">RuntimeException</tt>, or an <tt class="calibre25">Error</tt>. We must handle each of these cases separately, but we will use the <tt class="calibre25">launderThrowable</tt> utility method in <a class="calibre2" href="#ch05list13">Listing 5.13</a> to encapsulate some of the messier exception-handling logic. Before calling <tt class="calibre25">launderThrowable</tt>, <tt class="calibre25">Preloader</tt> tests for the known checked exceptions and rethrows them. That leaves only unchecked exceptions, which <tt class="calibre25">Preloader</tt> handles by calling <tt class="calibre25">launderThrowable</tt> and throwing the result. If the <tt class="calibre25">Throwable</tt> passed to <tt class="calibre25">launderThrowable</tt> is an <tt class="calibre25">Error</tt>, <tt class="calibre25">launderThrowable</tt> rethrows it directly; if it is not a <tt class="calibre25">RuntimeException</tt>, it throws an <tt class="calibre25">IllegalStateException</tt> to indicate a logic error. That leaves only <tt class="calibre25">RuntimeException</tt>, which <tt class="calibre25">launderThrowable</tt> returns to its caller, and which the caller generally rethrows.</p>
<a name="ch05list13" class="calibre18" id="ch05list13"></a><h5 id="title-IDAD4KIU" class="docExampleTitle">Listing 5.13. Coercing an Unchecked <tt class="calibre33">Throwable</tt> to a <tt class="calibre33">RuntimeException</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30"><span class="docEmphasis">/** If the Throwable is an Error, throw it; if it is a</span>
<span class="docEmphasis">*  RuntimeException return it, otherwise throw IllegalStateException</span>
<span class="docEmphasis">*/</span>
public static RuntimeException launderThrowable(Throwable t) {
    if (t instanceof RuntimeException)
        return (RuntimeException) t;
    else if (t instanceof Error)
        throw (Error) t;
    else
        throw new IllegalStateException("Not unchecked", t);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch05lev2sec12" class="calibre18" id="ch05lev2sec12"></a>
<h4 id="title-IDA24KIU" class="docSection2Title">5.5.3. Semaphores</h4>
<p class="docText1"><span class="docEmphasis">Counting semaphores</span> are used to control the number of activities that can access a certain resource or perform a given action at the same time [CPJ 3.4.1]. Counting semaphores can be used to implement resource pools or to impose a bound on a collection.</p>
<p class="docText1">A <tt class="calibre25">Semaphore</tt> manages a set of virtual <span class="docEmphasis">permits</span>; the initial number of permits is passed to the <tt class="calibre25">Semaphore</tt> constructor. Activities can acquire permits (as long as some remain) and release permits when they are done with them. If no permit is available, <tt class="calibre25">acquire</tt> blocks until one is (or until interrupted or the operation times out). The <tt class="calibre25">release</tt> method returns a permit to the semaphore. <sup class="docFootnote"><a class="calibre2" href="#ch05fn04">[4]</a></sup> A degenerate case <a name="iddle1039" class="calibre18" id="iddle1039"></a><a name="iddle1060" class="calibre18" id="iddle1060"></a><a name="iddle1061" class="calibre18" id="iddle1061"></a><a name="iddle1189" class="calibre18" id="iddle1189"></a><a name="iddle1190" class="calibre18" id="iddle1190"></a><a name="iddle1191" class="calibre18" id="iddle1191"></a><a name="iddle1192" class="calibre18" id="iddle1192"></a><a name="iddle1194" class="calibre18" id="iddle1194"></a><a name="iddle1197" class="calibre18" id="iddle1197"></a><a name="iddle1204" class="calibre18" id="iddle1204"></a><a name="iddle1205" class="calibre18" id="iddle1205"></a><a name="iddle1209" class="calibre18" id="iddle1209"></a><a name="iddle1210" class="calibre18" id="iddle1210"></a><a name="iddle1242" class="calibre18" id="iddle1242"></a><a name="iddle1243" class="calibre18" id="iddle1243"></a><a name="iddle1259" class="calibre18" id="iddle1259"></a><a name="iddle1260" class="calibre18" id="iddle1260"></a><a name="iddle1374" class="calibre18" id="iddle1374"></a><a name="iddle1375" class="calibre18" id="iddle1375"></a><a name="iddle1443" class="calibre18" id="iddle1443"></a><a name="iddle1741" class="calibre18" id="iddle1741"></a><a name="iddle2067" class="calibre18" id="iddle2067"></a><a name="iddle2443" class="calibre18" id="iddle2443"></a><a name="iddle2444" class="calibre18" id="iddle2444"></a><a name="iddle2445" class="calibre18" id="iddle2445"></a><a name="iddle2882" class="calibre18" id="iddle2882"></a><a name="iddle2883" class="calibre18" id="iddle2883"></a><a name="iddle2937" class="calibre18" id="iddle2937"></a><a name="iddle3284" class="calibre18" id="iddle3284"></a><a name="iddle3357" class="calibre18" id="iddle3357"></a><a name="iddle3452" class="calibre18" id="iddle3452"></a><a name="iddle3453" class="calibre18" id="iddle3453"></a><a name="iddle3555" class="calibre18" id="iddle3555"></a><a name="iddle3556" class="calibre18" id="iddle3556"></a><a name="iddle3609" class="calibre18" id="iddle3609"></a><a name="iddle4123" class="calibre18" id="iddle4123"></a><a name="iddle4148" class="calibre18" id="iddle4148"></a><a name="iddle4149" class="calibre18" id="iddle4149"></a><a name="iddle4574" class="calibre18" id="iddle4574"></a><a name="iddle4575" class="calibre18" id="iddle4575"></a><a name="iddle4576" class="calibre18" id="iddle4576"></a><a name="iddle4577" class="calibre18" id="iddle4577"></a><a name="iddle4578" class="calibre18" id="iddle4578"></a><a name="iddle4890" class="calibre18" id="iddle4890"></a>of a counting semaphore is a binary semaphore, a <tt class="calibre25">Semaphore</tt> with an initial count of one. A binary semaphore can be used as a <span class="docEmphasis">mutex</span> with nonreentrant locking semantics; whoever holds the sole permit holds the mutex.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch05fn04" class="calibre18" id="ch05fn04">[4]</a></sup> The implementation has no actual permit objects, and <tt class="calibre35">Semaphore</tt> does not associate dispensed permits with threads, so a permit acquired in one thread can be released from another thread. You can think of <tt class="calibre35">acquire</tt> as consuming a permit and <tt class="calibre35">release</tt> as creating one; a <tt class="calibre35">Semaphore</tt> is not limited to the number of permits it was created with.</p></blockquote>
<p class="docText1">Semaphores are useful for implementing resource pools such as database connection pools. While it is easy to construct a fixed-sized pool that fails if you request a resource from an empty pool, what you really want is to <span class="docEmphasis">block</span> if the pool is empty and unblock when it becomes nonempty again. If you initialize a <tt class="calibre25">Semaphore</tt> to the pool size, <tt class="calibre25">acquire</tt> a permit before trying to fetch a resource from the pool, and <tt class="calibre25">release</tt> the permit after putting a resource back in the pool, <tt class="calibre25">acquire</tt> blocks until the pool becomes nonempty. This technique is used in the bounded buffer class in <a class="calibre2" href="ch12.html#ch12">Chapter 12</a>. (An easier way to construct a blocking object pool would be to use a <tt class="calibre25">BlockingQueue</tt> to hold the pooled resources.)</p>
<p class="docText1">Similarly, you can use a <tt class="calibre25">Semaphore</tt> to turn any collection into a blocking bounded collection, as illustrated by <tt class="calibre25">BoundedHashSet</tt> in <a class="calibre2" href="#ch05list14">Listing 5.14</a>. The semaphore is initialized to the desired maximum size of the collection. The <tt class="calibre25">add</tt> operation acquires a permit before adding the item into the underlying collection. If the underlying <tt class="calibre25">add</tt> operation does not actually add anything, it releases the permit immediately. Similarly, a successful <tt class="calibre25">remove</tt> operation releases a permit, enabling more elements to be added. The underlying <tt class="calibre25">Set</tt> implementation knows nothing about the bound; this is handled by <tt class="calibre25">BoundedHashSet</tt>.</p>
<a name="ch05lev2sec13" class="calibre18" id="ch05lev2sec13"></a>
<h4 id="title-IDACLJIU" class="docSection2Title">5.5.4. Barriers</h4>
<p class="docText1">We have seen how latches can facilitate starting a group of related activities or waiting for a group of related activities to complete. Latches are single-use objects; once a latch enters the terminal state, it cannot be reset.</p>
<p class="docText1"><span class="docEmphasis">Barriers</span> are similar to latches in that they block a group of threads until some event has occurred [CPJ 4.4.3]. The key difference is that with a barrier, all the threads must come together at a barrier point <span class="docEmphasis">at the same time</span> in order to proceed. Latches are for waiting for <span class="docEmphasis">events</span>; barriers are for waiting for <span class="docEmphasis">other threads</span>. A barrier implements the protocol some families use to rendezvous during a day at the mall: "Everyone meet at McDonald's at 6:00; once you get there, stay there until everyone shows up, and then we'll figure out what we're doing next."</p>
<p class="docText1"><tt class="calibre25">CyclicBarrier</tt> allows a fixed number of parties to rendezvous repeatedly at a <span class="docEmphasis">barrier point</span> and is useful in parallel iterative algorithms that break down a problem into a fixed number of independent subproblems. Threads call <tt class="calibre25">await</tt> when they reach the barrier point, and <tt class="calibre25">await</tt> blocks until <span class="docEmphasis">all</span> the threads have reached the barrier point. If all threads meet at the barrier point, the barrier has been successfully passed, in which case all threads are released and the barrier is reset so it can be used again. If a call to <tt class="calibre25">await</tt> times out or a thread blocked in <tt class="calibre25">await</tt> is interrupted, then the barrier is considered <span class="docEmphasis">broken</span> and all outstanding calls to <tt class="calibre25">await</tt> terminate with <tt class="calibre25">BrokenBarrierException</tt>. If the barrier is successfully passed, <tt class="calibre25">await</tt> returns a unique arrival index for each thread, which can be used to "elect" a leader that takes some special action in the next iteration. <tt class="calibre25">CyclicBar</tt> <a name="iddle2091" class="calibre18" id="iddle2091"></a><a name="iddle4138" class="calibre18" id="iddle4138"></a><a name="iddle4213" class="calibre18" id="iddle4213"></a><a name="iddle1128" class="calibre18" id="iddle1128"></a><a name="iddle1129" class="calibre18" id="iddle1129"></a><a name="iddle1288" class="calibre18" id="iddle1288"></a><a name="iddle1289" class="calibre18" id="iddle1289"></a><a name="iddle1328" class="calibre18" id="iddle1328"></a><a name="iddle1329" class="calibre18" id="iddle1329"></a><a name="iddle1444" class="calibre18" id="iddle1444"></a><a name="iddle1994" class="calibre18" id="iddle1994"></a><a name="iddle2239" class="calibre18" id="iddle2239"></a><a name="iddle2961" class="calibre18" id="iddle2961"></a><a name="iddle2962" class="calibre18" id="iddle2962"></a><a name="iddle3465" class="calibre18" id="iddle3465"></a><a name="iddle3466" class="calibre18" id="iddle3466"></a><a name="iddle3979" class="calibre18" id="iddle3979"></a><a name="iddle3980" class="calibre18" id="iddle3980"></a><a name="iddle4080" class="calibre18" id="iddle4080"></a><a name="iddle4081" class="calibre18" id="iddle4081"></a><a name="iddle4288" class="calibre18" id="iddle4288"></a><a name="iddle4289" class="calibre18" id="iddle4289"></a><a name="iddle4478" class="calibre18" id="iddle4478"></a><a name="iddle4479" class="calibre18" id="iddle4479"></a><a name="iddle4661" class="calibre18" id="iddle4661"></a><a name="iddle4662" class="calibre18" id="iddle4662"></a><tt class="calibre25">rier</tt> also lets you pass a <span class="docEmphasis">barrier action</span> to the constructor; this is a <tt class="calibre25">Runnable</tt> that is executed (in one of the subtask threads) when the barrier is successfully passed but before the blocked threads are released.</p>
<a name="ch05list14" class="calibre18" id="ch05list14"></a><h5 id="title-IDAI3JIU" class="docExampleTitle">Listing 5.14. Using <tt class="calibre33">Semaphore</tt> to Bound a Collection.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class BoundedHashSet&lt;T&gt; {
    private final Set&lt;T&gt; set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        }
        finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Barriers are often used in simulations, where the work to calculate one step can be done in parallel but all the work associated with a given step must complete before advancing to the next step. For example, in <span class="docEmphasis">n</span>-body particle simulations, each step calculates an update to the position of each particle based on the locations and other attributes of the other particles. Waiting on a barrier between each update ensures that all updates for step <span class="docEmphasis">k</span> have completed before moving on to step <span class="docEmphasis">k</span> + 1.</p>
<p class="docText1"><tt class="calibre25">CellularAutomata</tt> in <a class="calibre2" href="ch05lev1sec6.html#ch05list15">Listing 5.15</a> demonstrates using a barrier to compute a cellular automata simulation, such as Conway's Life game (<a class="calibre2" href="bib01.html#biblio01_012">Gardner, 1970</a>). When parallelizing a simulation, it is generally impractical to assign a separate thread to each element (in the case of Life, a cell); this would require too many threads, and the overhead of coordinating them would dwarf the computation. Instead, it makes sense to <span class="docEmphasis">partition</span> the problem into a number of subparts, let each thread solve a subpart, and then merge the results. <tt class="calibre25">CellularAutomata</tt> partitions the board into <span class="docEmphasis">N</span><sub class="calibre40"><span class="docEmphasis">cpu</span></sub> parts, where <span class="docEmphasis">N</span><sub class="calibre40"><span class="docEmphasis">cpu</span></sub> is the number of CPUs available, and assigns each part to a thread. <sup class="docFootnote"><a class="calibre2" href="#ch05fn05">[5]</a></sup> At each step, the worker threads calculate new values for all the cells in their part of the board. When all worker threads have reached the barrier, the barrier action commits the new values to the data model. After the barrier action runs, the worker threads are released to compute the next step of the calculation, which includes consulting an <tt class="calibre25">isDone</tt> method to determine whether further iterations are required.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch05fn05" class="calibre18" id="ch05fn05">[5]</a></sup> For computational problems like this that do no I/O and access no shared data, <span class="docEmphasis">Ncpu</span> or <span class="docEmphasis">Ncpu</span> + 1 threads yield optimal throughput; more threads do not help, and may in fact degrade performance as the threads compete for CPU and memory resources.</p></blockquote>
<p class="docText1">Another form of barrier is <tt class="calibre25">Exchanger</tt>, a two-party barrier in which the parties exchange data at the barrier point [CPJ 3.4.3]. Exchangers are useful when the parties perform asymmetric activities, for example when one thread fills a buffer with data and the other thread consumes the data from the buffer; these threads could use an <tt class="calibre25">Exchanger</tt> to meet and exchange a full buffer for an empty one. When two threads exchange objects via an <tt class="calibre25">Exchanger</tt>, the exchange constitutes a safe publication of both objects to the other party.</p>
<p class="docText1">The timing of the exchange depends on the responsiveness requirements of the application. The simplest approach is that the filling task exchanges when the buffer is full, and the emptying task exchanges when the buffer is empty; this minimizes the number of exchanges but can delay processing of some data if the arrival rate of new data is unpredictable. Another approach would be that the filler exchanges when the buffer is full, but also when the buffer is partially filled and a certain amount of time has elapsed.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

