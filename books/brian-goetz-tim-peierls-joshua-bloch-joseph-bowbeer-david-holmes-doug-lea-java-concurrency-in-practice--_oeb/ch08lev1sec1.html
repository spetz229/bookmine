---
layout: page
title: "Java Concurrency in Practice"
prev: ch08.html
next: ch08lev1sec2.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch08lev1sec1" class="calibre18" id="ch08lev1sec1"></a>
<h3 id="title-IDA4SVLL" class="docSection1Title">8.1. Implicit Couplings Between Tasks and Execution Policies</h3>
<p class="docText1">We claimed earlier that the <tt class="calibre25">Executor</tt> framework decouples task submission from task execution. Like many attempts at decoupling complex processes, this was a bit of an overstatement. While the <tt class="calibre25">Executor</tt> framework offers substantial flexibility in specifying and modifying execution policies, not all tasks are compatible with all execution policies. Types of tasks that require specific execution policies include:</p>
<p class="docText1"><span class="docEmphStrong">Dependent tasks.</span> The most well behaved tasks are <span class="docEmphasis">independent</span>: those that do not depend on the timing, results, or side effects of other tasks. When executing independent tasks in a thread pool, you can freely vary the pool size and configuration without affecting anything but performance. On the other hand, when you submit tasks that depend on other tasks to a thread pool, you implicitly create constraints on the execution policy that must be carefully managed to avoid liveness problems (see <a class="calibre2" href="#ch08lev2sec1">Section 8.1.1</a>).</p>
<p class="docText1"><span class="docEmphStrong">Tasks that exploit thread confinement.</span> Single-threaded executors make stronger promises about concurrency than do arbitrary thread pools. They guarantee that tasks are not executed concurrently, which allows you to relax the thread safety of task code. Objects can be confined to the task thread, thus enabling tasks designed to run in that thread to access those objects without synchronization, even if those resources are not thread-safe. This forms an implicit coupling between the task and the execution policythe tasks require <a name="iddle1818" class="calibre18" id="iddle1818"></a><a name="iddle1883" class="calibre18" id="iddle1883"></a><a name="iddle1963" class="calibre18" id="iddle1963"></a><a name="iddle1964" class="calibre18" id="iddle1964"></a><a name="iddle2493" class="calibre18" id="iddle2493"></a><a name="iddle2494" class="calibre18" id="iddle2494"></a><a name="iddle2526" class="calibre18" id="iddle2526"></a><a name="iddle3942" class="calibre18" id="iddle3942"></a><a name="iddle3943" class="calibre18" id="iddle3943"></a><a name="iddle4375" class="calibre18" id="iddle4375"></a><a name="iddle4608" class="calibre18" id="iddle4608"></a><a name="iddle4617" class="calibre18" id="iddle4617"></a><a name="iddle4648" class="calibre18" id="iddle4648"></a><a name="iddle4649" class="calibre18" id="iddle4649"></a><a name="iddle4824" class="calibre18" id="iddle4824"></a><a name="iddle4850" class="calibre18" id="iddle4850"></a><a name="iddle4922" class="calibre18" id="iddle4922"></a><a name="iddle4923" class="calibre18" id="iddle4923"></a>their executor to be single-threaded.<sup class="docFootnote"><a class="calibre2" href="#ch08fn01">[1]</a></sup> In this case, if you changed the <tt class="calibre25">Executor</tt> from a single-threaded one to a thread pool, thread safety could be lost.<blockquote class="calibre19"><p class="docFootnote2"><sup class="calibre27"><a name="ch08fn01" class="calibre18" id="ch08fn01">[1]</a></sup> The requirement is not quite this strong; it would be enough to ensure only that tasks not execute concurrently and provide enough synchronization so that the memory effects of one task are guaranteed to be visible to the next taskwhich is precisely the guarantee offered by <tt class="calibre35">newSingle-ThreadExecutor</tt>.</p></blockquote></p>
<p class="docText1"><span class="docEmphStrong">Response-time-sensitive tasks.</span> GUI applications are sensitive to response time: users are annoyed at long delays between a button click and the corresponding visual feedback. Submitting a long-running task to a single-threaded executor, or submitting several long-running tasks to a thread pool with a small number of threads, may impair the responsiveness of the service managed by that <tt class="calibre25">Executor</tt>.</p>
<p class="docText1"><span class="docEmphStrong">Tasks that use <tt class="calibre25">ThreadLocal</tt>.</span> <tt class="calibre25">ThreadLocal</tt> allows each thread to have its own private "version" of a variable. However, executors are free to reuse threads as they see fit. The standard <tt class="calibre25">Executor</tt> implementations may reap idle threads when demand is low and add new ones when demand is high, and also replace a worker thread with a fresh one if an unchecked exception is thrown from a task. <tt class="calibre25">ThreadLocal</tt> makes sense to use in pool threads only if the thread-local value has a lifetime that is bounded by that of a task; <tt class="calibre25">Thread-Local</tt> should not be used in pool threads to communicate values between tasks.</p>
<p class="docText1">Thread pools work best when tasks are <span class="docEmphasis">homogeneous</span> and <span class="docEmphasis">independent</span>. Mixing long-running and short-running tasks risks "clogging" the pool unless it is very large; submitting tasks that depend on other tasks risks deadlock unless the pool is unbounded. Fortunately, requests in typical network-based server applicationsweb servers, mail servers, file serversusually meet these guidelines.</p>
<a name="ch08sb01" class="calibre18" id="ch08sb01"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Some tasks have characteristics that require or preclude a specific execution policy. Tasks that depend on other tasks require that the thread pool be large enough that tasks are never queued or rejected; tasks that exploit thread confinement require sequential execution. Document these requirements so that future maintainers do not undermine safety or liveness by substituting an incompatible execution policy.</p>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch08lev2sec1" class="calibre18" id="ch08lev2sec1"></a>
<h4 id="title-IDAG2VLL" class="docSection2Title">8.1.1. Thread Starvation Deadlock</h4>
<p class="docText1">If tasks that depend on other tasks execute in a thread pool, they can deadlock. In a single-threaded executor, a task that submits another task to the same executor and waits for its result will always deadlock. The second task sits on the work queue until the first task completes, but the first will not complete because it is <a name="iddle1475" class="calibre18" id="iddle1475"></a><a name="iddle1817" class="calibre18" id="iddle1817"></a><a name="iddle2200" class="calibre18" id="iddle2200"></a><a name="iddle2263" class="calibre18" id="iddle2263"></a><a name="iddle2264" class="calibre18" id="iddle2264"></a><a name="iddle2517" class="calibre18" id="iddle2517"></a><a name="iddle4374" class="calibre18" id="iddle4374"></a><a name="iddle4823" class="calibre18" id="iddle4823"></a>waiting for the result of the second task. The same thing can happen in larger thread pools if all threads are executing tasks that are blocked waiting for other tasks still on the work queue. This is called <span class="docEmphasis">thread starvation deadlock</span>, and can occur whenever a pool task initiates an unbounded blocking wait for some resource or condition that can succeed only through the action of another pool task, such as waiting for the return value or side effect of another task, unless you can guarantee that the pool is large enough.</p>
<p class="docText1"><tt class="calibre25">THReadDeadlock</tt> in <a class="calibre2" href="#ch08list01">Listing 8.1</a> illustrates thread starvation deadlock. <tt class="calibre25">Render-PageTask</tt> submits two additional tasks to the <tt class="calibre25">Executor</tt> to fetch the page header and footer, renders the page body, waits for the results of the header and footer tasks, and then combines the header, body, and footer into the finished page. With a single-threaded executor, <tt class="calibre25">THReadDeadlock</tt> will always deadlock. Similarly, tasks coordinating amongst themselves with a barrier could also cause thread starvation deadlock if the pool is not big enough.</p>
<a name="ch08sb02" class="calibre18" id="ch08sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Whenever you submit to an <tt class="calibre25">Executor</tt> tasks that are not independent, be aware of the possibility of thread starvation deadlock, and document any pool sizing or configuration constraints in the code or configuration file where the <tt class="calibre25">Executor</tt> is configured.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">In addition to any explicit bounds on the size of a thread pool, there may also be implicit limits because of constraints on other resources. If your application uses a JDBC connection pool with ten connections and each task needs a database connection, it is as if your thread pool only has ten threads because tasks in excess of ten will block waiting for a connection.</p>
<a name="ch08list01" class="calibre18" id="ch08list01"></a><h5 id="title-IDA0A4TK" class="docExampleTitle">Listing 8.1. Task that Deadlocks in a Single-threaded <tt class="calibre33">Executor</tt>. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" src="face.jpg" class="calibre29"/>
<pre class="calibre30">public class ThreadDeadlock {
    ExecutorService exec = Executors.newSingleThreadExecutor();

    public class RenderPageTask implements Callable&lt;String&gt; {
        public String call() throws Exception {
            Future&lt;String&gt; header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            // <span class="docEmphasis">Will deadlock -- task waiting for result of subtask</span>
            return <span class="docEmphStrong">header.get()</span> + page + <span class="docEmphStrong">footer.get();</span>
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch08lev2sec2" class="calibre18" id="ch08lev2sec2"></a>
<h4 id="title-IDAEC4TK" class="docSection2Title">8.1.2. Long-running Tasks</h4>
<p class="docText1"><a name="iddle1220" class="calibre18" id="iddle1220"></a><a name="iddle1234" class="calibre18" id="iddle1234"></a><a name="iddle1235" class="calibre18" id="iddle1235"></a><a name="iddle1431" class="calibre18" id="iddle1431"></a><a name="iddle1932" class="calibre18" id="iddle1932"></a><a name="iddle1933" class="calibre18" id="iddle1933"></a><a name="iddle2676" class="calibre18" id="iddle2676"></a><a name="iddle2677" class="calibre18" id="iddle2677"></a><a name="iddle2763" class="calibre18" id="iddle2763"></a><a name="iddle3540" class="calibre18" id="iddle3540"></a><a name="iddle3541" class="calibre18" id="iddle3541"></a><a name="iddle3631" class="calibre18" id="iddle3631"></a><a name="iddle3897" class="calibre18" id="iddle3897"></a><a name="iddle3924" class="calibre18" id="iddle3924"></a><a name="iddle3955" class="calibre18" id="iddle3955"></a><a name="iddle3956" class="calibre18" id="iddle3956"></a><a name="iddle4319" class="calibre18" id="iddle4319"></a><a name="iddle4637" class="calibre18" id="iddle4637"></a><a name="iddle4638" class="calibre18" id="iddle4638"></a><a name="iddle4803" class="calibre18" id="iddle4803"></a><a name="iddle4910" class="calibre18" id="iddle4910"></a><a name="iddle4911" class="calibre18" id="iddle4911"></a><a name="iddle4991" class="calibre18" id="iddle4991"></a><a name="iddle4992" class="calibre18" id="iddle4992"></a><a name="iddle5129" class="calibre18" id="iddle5129"></a><a name="iddle5130" class="calibre18" id="iddle5130"></a><a name="iddle5131" class="calibre18" id="iddle5131"></a>Thread pools can have responsiveness problems if tasks can block for extended periods of time, even if deadlock is not a possibility. A thread pool can become clogged with long-running tasks, increasing the service time even for short tasks. If the pool size is too small relative to the expected steady-state number of longrunning tasks, eventually all the pool threads will be running long-running tasks and responsiveness will suffer.</p>
<p class="docText1">One technique that can mitigate the ill effects of long-running tasks is for tasks to use timed resource waits instead of unbounded waits. Most blocking methods in the plaform libraries come in both untimed and timed versions, such as <tt class="calibre25">Thread.join</tt>, <tt class="calibre25">BlockingQueue.put</tt>, <tt class="calibre25">CountDownLatch.await</tt>, and <tt class="calibre25">Selector.select</tt>. If the wait times out, you can mark the task as failed and abort it or requeue it for execution later. This guarantees that each task eventually makes progress towards either successful or failed completion, freeing up threads for tasks that might complete more quickly. If a thread pool is frequently full of blocked tasks, this may also be a sign that the pool is too small.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

