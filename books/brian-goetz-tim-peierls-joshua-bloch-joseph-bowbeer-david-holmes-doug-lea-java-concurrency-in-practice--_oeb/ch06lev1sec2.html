---
layout: page
title: "Java Concurrency in Practice"
prev: ch06lev1sec1.html
next: ch06lev1sec3.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch06lev1sec2" class="calibre18" id="ch06lev1sec2"></a>
<h3 id="631532-878" class="docSection1Title">6.2. The Executor Framework</h3>
<p class="docText1"><a name="iddle1134" class="calibre18" id="iddle1134"></a><a name="iddle1135" class="calibre18" id="iddle1135"></a><a name="iddle1849" class="calibre18" id="iddle1849"></a><a name="iddle1850" class="calibre18" id="iddle1850"></a><a name="iddle1922" class="calibre18" id="iddle1922"></a><a name="iddle1923" class="calibre18" id="iddle1923"></a><a name="iddle1924" class="calibre18" id="iddle1924"></a><a name="iddle2254" class="calibre18" id="iddle2254"></a><a name="iddle2255" class="calibre18" id="iddle2255"></a><a name="iddle2761" class="calibre18" id="iddle2761"></a><a name="iddle2762" class="calibre18" id="iddle2762"></a><a name="iddle2976" class="calibre18" id="iddle2976"></a><a name="iddle2977" class="calibre18" id="iddle2977"></a><a name="iddle3598" class="calibre18" id="iddle3598"></a><a name="iddle3623" class="calibre18" id="iddle3623"></a><a name="iddle3685" class="calibre18" id="iddle3685"></a><a name="iddle3921" class="calibre18" id="iddle3921"></a><a name="iddle3928" class="calibre18" id="iddle3928"></a><a name="iddle4797" class="calibre18" id="iddle4797"></a>Tasks are logical units of work, and threads are a mechanism by which tasks can run asynchronously. We've examined two policies for executing tasks using threadsexecute tasks sequentially in a single thread, and execute each task in its own thread. Both have serious limitations: the sequential approach suffers from poor responsiveness and throughput, and the thread-per-task approach suffers from poor resource management.</p>
<p class="docText1">In <a class="calibre2" href="ch05.html#ch05">Chapter 5</a>, we saw how to use <span class="docEmphasis">bounded queues</span> to prevent an overloaded application from running out of memory. <span class="docEmphasis">Thread pools</span> offer the same benefit for thread management, and <tt class="calibre25">java.util.concurrent</tt> provides a flexible thread pool implementation as part of the <tt class="calibre25">Executor</tt> framework. The primary abstraction for task execution in the Java class libraries is <span class="docEmphasis">not</span> <tt class="calibre25">Thread</tt>, but <tt class="calibre25">Executor</tt>, shown in <a class="calibre2" href="#ch06list03">Listing 6.3</a>.</p>
<a name="ch06list03" class="calibre18" id="ch06list03"></a><h5 id="title-IDABOD5H" class="docExampleTitle">Listing 6.3. <tt class="calibre33">Executor</tt> Interface.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public interface Executor {
    void execute(Runnable command);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><tt class="calibre25">Executor</tt> may be a simple interface, but it forms the basis for a flexible and powerful framework for asynchronous task execution that supports a wide variety of task execution policies. It provides a standard means of decoupling <span class="docEmphasis">task submission</span> from <span class="docEmphasis">task execution</span>, describing tasks with <tt class="calibre25">Runnable</tt>. The <tt class="calibre25">Executor</tt> implementations also provide lifecycle support and hooks for adding statistics gathering, application management, and monitoring.</p>
<p class="docText1"><tt class="calibre25">Executor</tt> is based on the producer-consumer pattern, where activities that submit tasks are the producers (producing units of work to be done) and the threads that execute tasks are the consumers (consuming those units of work). <span class="docEmphasis">Using an <tt class="calibre25">Executor</tt> is usually the easiest path to implementing a producer-consumer design in your application.</span></p>
<a name="ch06lev2sec4" class="calibre18" id="ch06lev2sec4"></a>
<h4 id="title-IDAFPD5H" class="docSection2Title">6.2.1. Example: Web Server Using Executor</h4>
<p class="docText1">Building a web server with an <tt class="calibre25">Executor</tt> is easy. <tt class="calibre25">TaskExecutionWebServer</tt> in <a class="calibre2" href="#ch06list04">Listing 6.4</a> replaces the hard-coded thread creation with an <tt class="calibre25">Executor</tt>. In this case, we use one of the standard <tt class="calibre25">Executor</tt> implementations, a fixed-size thread pool with 100 threads.</p>
<p class="docText1">In <tt class="calibre25">TaskExecutionWebServer</tt>, submission of the request-handling task is decoupled from its execution using an <tt class="calibre25">Executor</tt>, and its behavior can be changed merely by substituting a different <tt class="calibre25">Executor</tt> implementation. Changing <tt class="calibre25">Executor</tt> implementations or configuration is far less invasive than changing the way tasks are submitted; <tt class="calibre25">Executor</tt> configuration is generally a one-time event and can easily be exposed for deployment-time configuration, whereas task submission code tends to be strewn throughout the program and harder to expose.</p>
<p class="docText1"></p><a name="ch06list04" class="calibre18" id="ch06list04"></a><h5 id="title-IDATQD5H" class="docExampleTitle">Listing 6.4. Web Server Using a Thread Pool.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">class TaskExecutionWebServer {
    private static final int NTHREADS = 100;
    <span class="docEmphStrong">private static final Executor exec</span>
<span class="docEmphStrong">= Executors.newFixedThreadPool(NTHREADS);</span>

    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            <span class="docEmphStrong">exec.execute(task);</span>
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle2193" class="calibre18" id="iddle2193"></a><a name="iddle2202" class="calibre18" id="iddle2202"></a><a name="iddle2250" class="calibre18" id="iddle2250"></a><a name="iddle3582" class="calibre18" id="iddle3582"></a><a name="iddle4620" class="calibre18" id="iddle4620"></a>We can easily modify <tt class="calibre25">TaskExecutionWebServer</tt> to behave like <tt class="calibre25">ThreadPer-TaskWebServer</tt> by substituting an <tt class="calibre25">Executor</tt> that creates a new thread for each request. Writing such an <tt class="calibre25">Executor</tt> is trivial, as shown in <tt class="calibre25">ThreadPerTaskExecutor</tt> in <a class="calibre2" href="#ch06list05">Listing 6.5</a>.</p>
<a name="ch06list05" class="calibre18" id="ch06list05"></a><h5 id="title-IDA3TD5H" class="docExampleTitle">Listing 6.5. <tt class="calibre33">Executor</tt> that Starts a New Thread for Each Task.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class ThreadPerTaskExecutor implements Executor {
    public void execute(Runnable r) {
        <span class="docEmphStrong">new Thread(r).start();</span>
    };
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Similarly, it is also easy to write an <tt class="calibre25">Executor</tt> that would make <tt class="calibre25">TaskExecutionWebServer</tt> behave like the single-threaded version, executing each task synchronously before returning from <tt class="calibre25">execute</tt>, as shown in <tt class="calibre25">WithinThreadExecutor</tt> in <a class="calibre2" href="#ch06list06">Listing 6.6</a>.</p>
<a name="ch06lev2sec5" class="calibre18" id="ch06lev2sec5"></a>
<h4 id="title-IDADVD5H" class="docSection2Title">6.2.2. Execution Policies</h4>
<p class="docText1">The value of decoupling submission from execution is that it lets you easily specify, and subsequently change without great difficulty, the <span class="docEmphasis">execution policy</span> for a given class of tasks. An execution policy specifies the "what, where, when, and how" of task execution, including:</p>
<p class="docText1"></p><a name="ch06list06" class="calibre18" id="ch06list06"></a><h5 id="title-IDAVVD5H" class="docExampleTitle">Listing 6.6. <tt class="calibre33">Executor</tt> that Executes Tasks Synchronously in the Calling Thread.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class WithinThreadExecutor implements Executor {
    public void execute(Runnable r) {
        r.run();
    };
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<ul class="calibre15"><li class="calibre16"><p class="docText1"><a name="iddle1597" class="calibre18" id="iddle1597"></a><a name="iddle1598" class="calibre18" id="iddle1598"></a><a name="iddle2219" class="calibre18" id="iddle2219"></a><a name="iddle2375" class="calibre18" id="iddle2375"></a><a name="iddle2460" class="calibre18" id="iddle2460"></a><a name="iddle2524" class="calibre18" id="iddle2524"></a><a name="iddle2525" class="calibre18" id="iddle2525"></a><a name="iddle3486" class="calibre18" id="iddle3486"></a><a name="iddle3619" class="calibre18" id="iddle3619"></a><a name="iddle3625" class="calibre18" id="iddle3625"></a><a name="iddle3746" class="calibre18" id="iddle3746"></a><a name="iddle3747" class="calibre18" id="iddle3747"></a><a name="iddle3775" class="calibre18" id="iddle3775"></a><a name="iddle3895" class="calibre18" id="iddle3895"></a><a name="iddle3920" class="calibre18" id="iddle3920"></a><a name="iddle4792" class="calibre18" id="iddle4792"></a><a name="iddle4794" class="calibre18" id="iddle4794"></a><a name="iddle5159" class="calibre18" id="iddle5159"></a>In what thread will tasks be executed?</p></li><li class="calibre16"><p class="docText1">In what order should tasks be executed (FIFO, LIFO, priority order)?</p></li><li class="calibre16"><p class="docText1">How many tasks may execute concurrently?</p></li><li class="calibre16"><p class="docText1">How many tasks may be queued pending execution?</p></li><li class="calibre16"><p class="docText1">If a task has to be rejected because the system is overloaded, which task should be selected as the victim, and how should the application be notified?</p></li><li class="calibre16"><p class="docText1">What actions should be taken before or after executing a task?</p></li></ul>
<p class="docText1">Execution policies are a resource management tool, and the optimal policy depends on the available computing resources and your quality-of-service requirements. By limiting the number of concurrent tasks, you can ensure that the application does not fail due to resource exhaustion or suffer performance problems due to contention for scarce resources.<sup class="docFootnote"><a class="calibre2" href="#ch06fn03">[3]</a></sup> Separating the specification of execution policy from task submission makes it practical to select an execution policy at deployment time that is matched to the available hardware.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch06fn03" class="calibre18" id="ch06fn03">[3]</a></sup> This is analogous to one of the roles of a transaction monitor in an enterprise application: it can throttle the rate at which transactions are allowed to proceed so as not to exhaust or overstress limited resources.</p></blockquote>
<a name="ch06sb01" class="calibre18" id="ch06sb01"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Whenever you see code of the form:</p>
<div class="docText2"><pre class="calibre36">new Thread(runnable).start()
</pre></div><br class="calibre11"/>
<p class="docText1">and you think you might at some point want a more flexible execution policy, seriously consider replacing it with the use of an <tt class="calibre25">Executor</tt>.</p>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch06lev2sec6" class="calibre18" id="ch06lev2sec6"></a>
<h4 id="title-IDAM4D5H" class="docSection2Title">6.2.3. Thread Pools</h4>
<p class="docText1">A thread pool, as its name suggests, manages a homogeneous pool of worker threads. A thread pool is tightly bound to a <span class="docEmphasis">work queue</span> holding tasks waiting to be executed. Worker threads have a simple life: request the next task from the work queue, execute it, and go back to waiting for another task.</p>
<p class="docText1"><a name="iddle1733" class="calibre18" id="iddle1733"></a><a name="iddle2267" class="calibre18" id="iddle2267"></a><a name="iddle2268" class="calibre18" id="iddle2268"></a><a name="iddle2269" class="calibre18" id="iddle2269"></a><a name="iddle2297" class="calibre18" id="iddle2297"></a><a name="iddle3572" class="calibre18" id="iddle3572"></a><a name="iddle3573" class="calibre18" id="iddle3573"></a><a name="iddle3628" class="calibre18" id="iddle3628"></a><a name="iddle4009" class="calibre18" id="iddle4009"></a><a name="iddle4799" class="calibre18" id="iddle4799"></a>Executing tasks in pool threads has a number of advantages over the thread-per-task approach. Reusing an existing thread instead of creating a new one amortizes thread creation and teardown costs over multiple requests. As an added bonus, since the worker thread often already exists at the time the request arrives, the latency associated with thread creation does not delay task execution, thus improving responsiveness. By properly tuning the size of the thread pool, you can have enough threads to keep the processors busy while not having so many that your application runs out of memory or thrashes due to competition among threads for resources.</p>
<p class="docText1">The class library provides a flexible thread pool implementation along with some useful predefined configurations. You can create a thread pool by calling one of the static factory methods in <tt class="calibre25">Executors</tt>:</p>
<p class="docText1"><span class="docEmphStrong">newFixedThreadPool.</span> A fixed-size thread pool creates threads as tasks are submitted, up to the maximum pool size, and then attempts to keep the pool size constant (adding new threads if a thread dies due to an unexpected <tt class="calibre25">Exception</tt>).</p>
<p class="docText1"><span class="docEmphStrong">newCachedThreadPool.</span> A cached thread pool has more flexibility to reap idle threads when the current size of the pool exceeds the demand for processing, and to add new threads when demand increases, but places no bounds on the size of the pool.</p>
<p class="docText1"><span class="docEmphStrong">newSingleThreadExecutor.</span> A single-threaded executor creates a single worker thread to process tasks, replacing it if it dies unexpectedly. Tasks are guaranteed to be processed sequentially according to the order imposed by the task queue (FIFO, LIFO, priority order).<sup class="docFootnote"><a class="calibre2" href="#ch06fn04">[4]</a></sup><blockquote class="calibre19"><p class="docFootnote2"><sup class="calibre27"><a name="ch06fn04" class="calibre18" id="ch06fn04">[4]</a></sup> Single-threaded executors also provide sufficient internal synchronization to guarantee that any memory writes made by tasks are visible to subsequent tasks; this means that objects can be safely confined to the "task thread" even though that thread may be replaced with another from time to time.</p></blockquote></p>
<p class="docText1"><span class="docEmphStrong">newScheduledThreadPool.</span> A fixed-size thread pool that supports delayed and periodic task execution, similar to <tt class="calibre25">Timer</tt>. (See <a class="calibre2" href="#ch06lev2sec8">Section 6.2.5</a>.)</p>
<p class="docText1">The <tt class="calibre25">newFixedThreadPool</tt> and <tt class="calibre25">newCachedThreadPool</tt> factories return instances of the general-purpose <tt class="calibre25">ThreadPoolExecutor</tt>, which can also be used directly to construct more specialized executors. We discuss thread pool configuration options in depth in <a class="calibre2" href="ch08.html#ch08">Chapter 8</a>.</p>
<p class="docText1">The web server in <tt class="calibre25">TaskExecutionWebServer</tt> uses an <tt class="calibre25">Executor</tt> with a bounded pool of worker threads. Submitting a task with <tt class="calibre25">execute</tt> adds the task to the work queue, and the worker threads repeatedly dequeue tasks from the work queue and execute them.</p>
<p class="docText1">Switching from a thread-per-task policy to a pool-based policy has a big effect on application stability: the web server will no longer fail under heavy load.<sup class="docFootnote"><a class="calibre2" href="#ch06fn05">[5]</a></sup> <a name="iddle2274" class="calibre18" id="iddle2274"></a><a name="iddle2275" class="calibre18" id="iddle2275"></a><a name="iddle2456" class="calibre18" id="iddle2456"></a><a name="iddle2457" class="calibre18" id="iddle2457"></a><a name="iddle2458" class="calibre18" id="iddle2458"></a><a name="iddle2758" class="calibre18" id="iddle2758"></a><a name="iddle2759" class="calibre18" id="iddle2759"></a><a name="iddle2973" class="calibre18" id="iddle2973"></a><a name="iddle2974" class="calibre18" id="iddle2974"></a><a name="iddle3599" class="calibre18" id="iddle3599"></a><a name="iddle3825" class="calibre18" id="iddle3825"></a><a name="iddle3826" class="calibre18" id="iddle3826"></a><a name="iddle3929" class="calibre18" id="iddle3929"></a><a name="iddle4017" class="calibre18" id="iddle4017"></a><a name="iddle4018" class="calibre18" id="iddle4018"></a><a name="iddle4252" class="calibre18" id="iddle4252"></a><a name="iddle4267" class="calibre18" id="iddle4267"></a><a name="iddle4269" class="calibre18" id="iddle4269"></a><a name="iddle4400" class="calibre18" id="iddle4400"></a><a name="iddle4401" class="calibre18" id="iddle4401"></a><a name="iddle4635" class="calibre18" id="iddle4635"></a><a name="iddle4641" class="calibre18" id="iddle4641"></a><a name="iddle4672" class="calibre18" id="iddle4672"></a><a name="iddle4673" class="calibre18" id="iddle4673"></a>It also degrades more gracefully, since it does not create thousands of threads that compete for limited CPU and memory resources. And using an <tt class="calibre25">Executor</tt> opens the door to all sorts of additional opportunities for tuning, management, monitoring, logging, error reporting, and other possibilities that would have been far more difficult to add without a task execution framework.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch06fn05" class="calibre18" id="ch06fn05">[5]</a></sup> While the server may not fail due to the creation of too many threads, if the task arrival rate exceeds the task service rate for long enough it is still possible (just harder) to run out of memory because of the growing queue of <tt class="calibre35">Runnable</tt>s awaiting execution. This can be addressed within the <tt class="calibre35">Executor</tt> framework by using a bounded work queuesee <a class="calibre2" href="ch08lev1sec3.html#ch08lev2sec4">Section 8.3.2</a>.</p></blockquote>
<a name="ch06lev2sec7" class="calibre18" id="ch06lev2sec7"></a>
<h4 id="title-IDASVKRF" class="docSection2Title">6.2.4. Executor Lifecycle</h4>
<p class="docText1">We've seen how to create an <tt class="calibre25">Executor</tt> but not how to shut one down. An <tt class="calibre25">Executor</tt> implementation is likely to create threads for processing tasks. But the JVM can't exit until all the (nondaemon) threads have terminated, so failing to shut down an <tt class="calibre25">Executor</tt> could prevent the JVM from exiting.</p>
<p class="docText1">Because an <tt class="calibre25">Executor</tt> processes tasks asynchronously, at any given time the state of previously submitted tasks is not immediately obvious. Some may have completed, some may be currently running, and others may be queued awaiting execution. In shutting down an application, there is a spectrum from graceful shutdown (finish what you've started but don't accept any new work) to abrupt shutdown (turn off the power to the machine room), and various points in between. Since <tt class="calibre25">Executor</tt>s provide a service to applications, they should be able to be shut down as well, both gracefully and abruptly, and feed back information to the application about the status of tasks that were affected by the shutdown.</p>
<p class="docText1">To address the issue of execution service lifecycle, the <tt class="calibre25">ExecutorService</tt> interface extends <tt class="calibre25">Executor</tt>, adding a number of methods for lifecycle management (as well as some convenience methods for task submission). The lifecycle management methods of <tt class="calibre25">ExecutorService</tt> are shown in <a class="calibre2" href="#ch06list07">Listing 6.7</a>.</p>
<a name="ch06list07" class="calibre18" id="ch06list07"></a><h5 id="title-IDA2WKRF" class="docExampleTitle">Listing 6.7. Lifecycle Methods in <tt class="calibre33">ExecutorService</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public interface ExecutorService extends Executor {
    void shutdown();
    List&lt;Runnable&gt; shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    //  ... <span class="docEmphasis">additional convenience methods for task submission</span>
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">The lifecycle implied by <tt class="calibre25">ExecutorService</tt> has three states<span class="docEmphasis">running</span>, <span class="docEmphasis">shutting down</span>, and <span class="docEmphasis">terminated</span>. <tt class="calibre25">ExecutorService</tt>s are initially created in the <span class="docEmphasis">running</span> state. The <tt class="calibre25">shutdown</tt> method initiates a graceful shutdown: no new tasks are accepted but previously submitted tasks are allowed to completeincluding those that have not yet begun execution. The <tt class="calibre25">shutdownNow</tt> method initiates an abrupt shutdown: it attempts to cancel outstanding tasks and does not start any tasks that are queued but not begun.</p>
<p class="docText1">Tasks submitted to an <tt class="calibre25">ExecutorService</tt> after it has been shut down are handled by the <span class="docEmphasis">rejected execution handler</span> (see <a class="calibre2" href="ch08lev1sec3.html#ch08lev2sec5">Section 8.3.3</a>), which might silently discard <a name="iddle2128" class="calibre18" id="iddle2128"></a><a name="iddle3830" class="calibre18" id="iddle3830"></a><a name="iddle4265" class="calibre18" id="iddle4265"></a><a name="iddle4266" class="calibre18" id="iddle4266"></a>the task or might cause <tt class="calibre25">execute</tt> to throw the unchecked <tt class="calibre25">RejectedExecutionException</tt>. Once all tasks have completed, the <tt class="calibre25">ExecutorService</tt> TRansitions to the <span class="docEmphasis">terminated</span> state. You can wait for an <tt class="calibre25">ExecutorService</tt> to reach the terminated state with <tt class="calibre25">awaitTermination</tt>, or poll for whether it has yet terminated with <tt class="calibre25">isTerminated</tt>. It is common to follow <tt class="calibre25">shutdown</tt> immediately by <tt class="calibre25">awaitTermination</tt>, creating the effect of synchronously shutting down the <tt class="calibre25">ExecutorService</tt>.(<tt class="calibre25">Executor</tt> shutdown and task cancellation are covered in more detail in <a class="calibre2" href="ch07.html#ch07">Chapter 7</a>.)</p>
<p class="docText1"><tt class="calibre25">LifecycleWebServer</tt> in <a class="calibre2" href="#ch06list08">Listing 6.8</a> extends our web server with lifecycle support. It can be shut down in two ways: programmatically by calling <tt class="calibre25">stop</tt>, and through a client request by sending the web server a specially formatted HTTP request.</p>
<a name="ch06list08" class="calibre18" id="ch06list08"></a><h5 id="title-IDANDLRF" class="docExampleTitle">Listing 6.8. Web Server with Shutdown Support.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">class LifecycleWebServer {
    private final ExecutorService exec = ...;

    public void start() throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (!exec.isShutdown()) {
            try {
                final Socket conn = socket.accept();
                exec.execute(new Runnable() {
                    public void run() { handleRequest(conn); }
                });
            } catch (RejectedExecutionException e) {
                if (!exec.isShutdown())
                    log("task submission rejected", e);
            }
        }
    }

    public void stop() { exec.shutdown(); }

    void handleRequest(Socket connection) {
        Request req = readRequest(connection);
        if (isShutdownRequest(req))
            stop();
        else
            dispatchRequest(req);
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch06lev2sec8" class="calibre18" id="ch06lev2sec8"></a>
<h4 id="title-IDAAELRF" class="docSection2Title">6.2.5. Delayed and Periodic Tasks</h4>
<p class="docText1"><a name="iddle1089" class="calibre18" id="iddle1089"></a><a name="iddle1256" class="calibre18" id="iddle1256"></a><a name="iddle1852" class="calibre18" id="iddle1852"></a><a name="iddle1853" class="calibre18" id="iddle1853"></a><a name="iddle1854" class="calibre18" id="iddle1854"></a><a name="iddle1913" class="calibre18" id="iddle1913"></a><a name="iddle1914" class="calibre18" id="iddle1914"></a><a name="iddle2234" class="calibre18" id="iddle2234"></a><a name="iddle2248" class="calibre18" id="iddle2248"></a><a name="iddle2563" class="calibre18" id="iddle2563"></a><a name="iddle2954" class="calibre18" id="iddle2954"></a><a name="iddle3450" class="calibre18" id="iddle3450"></a><a name="iddle3581" class="calibre18" id="iddle3581"></a><a name="iddle4090" class="calibre18" id="iddle4090"></a><a name="iddle4091" class="calibre18" id="iddle4091"></a><a name="iddle4296" class="calibre18" id="iddle4296"></a><a name="iddle4607" class="calibre18" id="iddle4607"></a><a name="iddle4659" class="calibre18" id="iddle4659"></a><a name="iddle4660" class="calibre18" id="iddle4660"></a><a name="iddle4784" class="calibre18" id="iddle4784"></a><a name="iddle4886" class="calibre18" id="iddle4886"></a><a name="iddle4887" class="calibre18" id="iddle4887"></a><a name="iddle4916" class="calibre18" id="iddle4916"></a><a name="iddle4917" class="calibre18" id="iddle4917"></a><a name="iddle4920" class="calibre18" id="iddle4920"></a><a name="iddle4921" class="calibre18" id="iddle4921"></a><a name="iddle4932" class="calibre18" id="iddle4932"></a><a name="iddle4933" class="calibre18" id="iddle4933"></a>The <tt class="calibre25">Timer</tt> facility manages the execution of deferred ("run this task in 100 ms") and periodic ("run this task every 10 ms") tasks. However, <tt class="calibre25">Timer</tt> has some drawbacks, and <tt class="calibre25">ScheduledThreadPoolExecutor</tt> should be thought of as its replacement.<sup class="docFootnote"><a class="calibre2" href="#ch06fn06">[6]</a></sup> You can construct a <tt class="calibre25">ScheduledThreadPoolExecutor</tt> through its constructor or through the <tt class="calibre25">newScheduledThreadPool</tt> factory.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch06fn06" class="calibre18" id="ch06fn06">[6]</a></sup> <tt class="calibre35">Timer</tt> does have support for scheduling based on absolute, not relative time, so that tasks can be sensitive to changes in the system clock; <tt class="calibre35">ScheduledThreadPoolExecutor</tt> supports only relative time.</p></blockquote>
<p class="docText1">A <tt class="calibre25">Timer</tt> creates only a single thread for executing timer tasks. If a timer task takes too long to run, the timing accuracy of other <tt class="calibre25">TimerTask</tt>s can suffer. If a recurring <tt class="calibre25">TimerTask</tt> is scheduled to run every 10 ms and another <tt class="calibre25">Timer-Task</tt> takes 40 ms to run, the recurring task either (depending on whether it was scheduled at fixed rate or fixed delay) gets called four times in rapid succession after the long-running task completes, or "misses" four invocations completely. Scheduled thread pools address this limitation by letting you provide multiple threads for executing deferred and periodic tasks.</p>
<p class="docText1">Another problem with <tt class="calibre25">Timer</tt> is that it behaves poorly if a <tt class="calibre25">TimerTask</tt> throws an unchecked exception. The <tt class="calibre25">Timer</tt> thread doesn't catch the exception, so an unchecked exception thrown from a <tt class="calibre25">TimerTask</tt> terminates the timer thread. <tt class="calibre25">Timer</tt> also doesn't resurrect the thread in this situation; instead, it erroneously assumes the entire <tt class="calibre25">Timer</tt> was cancelled. In this case, <tt class="calibre25">TimerTask</tt>s that are already scheduled but not yet executed are never run, and new tasks cannot be scheduled. (This problem, called "thread leakage" is described in <a class="calibre2" href="ch07lev1sec3.html#ch07lev1sec3">Section 7.3</a>, along with techniques for avoiding it.)</p>
<p class="docText1"><tt class="calibre25">OutOfTime</tt> in <a class="calibre2" href="ch06lev1sec3.html#ch06list09">Listing 6.9</a> illustrates how a <tt class="calibre25">Timer</tt> can become confused in this manner and, as confusion loves company, how the <tt class="calibre25">Timer</tt> shares its confusion with the next hapless caller that tries to submit a <tt class="calibre25">TimerTask</tt>. You might expect the program to run for six seconds and exit, but what actually happens is that it terminates after one second with an <tt class="calibre25">IllegalStateException</tt> whose message text is "Timer already cancelled". <tt class="calibre25">ScheduledThreadPoolExecutor</tt> deals properly with ill-behaved tasks; there is little reason to use <tt class="calibre25">Timer</tt> in Java 5.0 or later.</p>
<p class="docText1">If you need to build your own scheduling service, you may still be able to take advantage of the library by using a <tt class="calibre25">DelayQueue</tt>, a <tt class="calibre25">BlockingQueue</tt> implementation that provides the scheduling functionality of <tt class="calibre25">ScheduledThreadPoolExecutor</tt>. A <tt class="calibre25">DelayQueue</tt> manages a collection of <tt class="calibre25">Delayed</tt> objects. A <tt class="calibre25">Delayed</tt> has a delay time associated with it: <tt class="calibre25">DelayQueue</tt> lets you <tt class="calibre25">take</tt> an element only if its delay has expired. Objects are returned from a <tt class="calibre25">DelayQueue</tt> ordered by the time associated with their delay.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

