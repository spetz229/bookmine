---
layout: page
title: "Java Concurrency in Practice"
prev: ch07lev1sec2.html
next: ch07lev1sec4.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch07lev1sec3" class="calibre18" id="ch07lev1sec3"></a>
<h3 id="title-IDADFA1T" class="docSection1Title">7.3. Handling Abnormal Thread Termination</h3>
<p class="docText1">It is obvious when a single-threaded console application terminates due to an uncaught exceptionthe program stops running and produces a stack trace that is very different from typical program output. Failure of a thread in a concurrent application is not always so obvious. The stack trace may be printed on the console, but no one may be watching the console. Also, when a thread fails, the application may appear to continue to work, so its failure could go unnoticed. Fortunately, there are means of both detecting and preventing threads from "leaking" from an application.</p>
<p class="docText1">The leading cause of premature thread death is <tt class="calibre25">RuntimeException</tt>. Because these exceptions indicate a programming error or other unrecoverable problem, they are generally not caught. Instead they propagate all the way up the stack, at which point the default behavior is to print a stack trace on the console and let the thread terminate.</p>
<p class="docText1">The consequences of abnormal thread death range from benign to disastrous, depending on the thread's role in the application. Losing a thread from a thread pool can have performance consequences, but an application that runs well with a 50-thread pool will probably run fine with a 49-thread pool too. But losing the event dispatch thread in a GUI application would be quite noticeablethe application would stop processing events and the GUI would freeze. <tt class="calibre25">OutOfTime</tt> on <a class="calibre2" href="ch06lev1sec3.html#ch06list09">124</a> showed a serious consequence of thread leakage: the service represented by the <tt class="calibre25">Timer</tt> is permanently out of commission.</p>
<p class="docText1">Just about any code can throw a <tt class="calibre25">RuntimeException</tt>. Whenever you call another method, you are taking a leap of faith that it will return normally or throw one of the checked exceptions its signature declares. The less familiar you are with the code being called, the more skeptical you should be about its behavior.</p>
<p class="docText1">Task-processing threads such as the worker threads in a thread pool or the Swing event dispatch thread spend their whole life calling unknown code through an abstraction barrier like <tt class="calibre25">Runnable</tt>, and these threads should be very skeptical that the code they call will be well behaved. It would be very bad if a service like the Swing event thread failed just because some poorly written event handler threw a <tt class="calibre25">NullPointerException</tt>. Accordingly, these facilities should call tasks within a <tt class="calibre25">try-catch</tt> block that catches unchecked exceptions, or within a <tt class="calibre25">try-finally</tt> block to ensure that if the thread exits abnormally the framework is informed of this and can take corrective action. This is one of the few times when you might want to consider catching <tt class="calibre25">RuntimeException</tt>when you are calling unknown, untrusted code through an abstraction such as <tt class="calibre25">Runnable</tt>.<sup class="docFootnote"><a class="calibre2" href="#ch07fn07">[7]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch07fn07" class="calibre18" id="ch07fn07">[7]</a></sup> There is some controversy over the safety of this technique; when a thread throws an unchecked <a name="iddle2235" class="calibre18" id="iddle2235"></a><a name="iddle2315" class="calibre18" id="iddle2315"></a><a name="iddle2316" class="calibre18" id="iddle2316"></a><a name="iddle2929" class="calibre18" id="iddle2929"></a><a name="iddle2955" class="calibre18" id="iddle2955"></a><a name="iddle4529" class="calibre18" id="iddle4529"></a><a name="iddle4773" class="calibre18" id="iddle4773"></a><a name="iddle4774" class="calibre18" id="iddle4774"></a><a name="iddle4785" class="calibre18" id="iddle4785"></a><a name="iddle4853" class="calibre18" id="iddle4853"></a><a name="iddle4854" class="calibre18" id="iddle4854"></a><a name="iddle4999" class="calibre18" id="iddle4999"></a><a name="iddle5002" class="calibre18" id="iddle5002"></a>exception, the entire application may possibly be compromised. But the alternativeshutting down the entire applicationis usually not practical.</p></blockquote>
<p class="docText1"><a class="calibre2" href="#ch07list23">Listing 7.23</a> illustrates a way to structure a worker thread within a thread pool. If a task throws an unchecked exception, it allows the thread to die, but not before notifying the framework that the thread has died. The framework may then replace the worker thread with a new thread, or may choose not to because the thread pool is being shut down or there are already enough worker threads to meet current demand. <tt class="calibre25">ThreadPoolExecutor</tt> and Swing use this technique to ensure that a poorly behaved task doesn't prevent subsequent tasks from executing. If you are writing a worker thread class that executes submitted tasks, or calling untrusted external code (such as dynamically loaded plugins), use one of these approaches to prevent a poorly written task or plugin from taking down the thread that happens to call it.</p>
<a name="ch07list23" class="calibre18" id="ch07list23"></a><h5 id="title-IDABMOLH" class="docExampleTitle">Listing 7.23. Typical Thread-pool Worker Thread Structure.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public void run() {
    Throwable thrown = null;
    try {
        while (!isInterrupted())
            runTask(getTaskFromWorkQueue());
    } catch (Throwable e) {
        thrown = e;
    } finally {
        threadExited(this, thrown);
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07lev2sec13" class="calibre18" id="ch07lev2sec13"></a>
<h4 id="title-IDATBA1T" class="docSection2Title">7.3.1. Uncaught Exception Handlers</h4>
<p class="docText1">The previous section offered a proactive approach to the problem of unchecked exceptions. The Thread API also provides the <tt class="calibre25">UncaughtExceptionHandler</tt> facility, which lets you detect when a thread dies due to an uncaught exception. The two approaches are complementary: taken together, they provide defense-indepth against thread leakage.</p>
<p class="docText1">When a thread exits due to an uncaught exception, the JVM reports this event to an application-provided <tt class="calibre25">UncaughtExceptionHandler</tt> (see <a class="calibre2" href="#ch07list24">Listing 7.24</a>); if no handler exists, the default behavior is to print the stack trace to <tt class="calibre25">System.err</tt>.<sup class="docFootnote"><a class="calibre2" href="#ch07fn08">[8]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch07fn08" class="calibre18" id="ch07fn08">[8]</a></sup> Before Java 5.0, the only way to control the <tt class="calibre35">UncaughtExceptionHandler</tt> was by subclassing <tt class="calibre35">THReadGroup</tt>. In Java 5.0 and later, you can set an <tt class="calibre35">UncaughtExceptionHandler</tt> on a per-thread basis with <tt class="calibre35">THRead.setUncaughtExceptionHandler</tt>, and can also set the default <tt class="calibre35">UncaughtExceptionHandler</tt> with <tt class="calibre35">Thread.setDefaultUncaughtExceptionHandler</tt>. However, only one of these handlers is calledfirst the JVM looks for a per-thread handler, then for a <tt class="calibre35">THReadGroup</tt> handler. The default handler implementation in <tt class="calibre35">THReadGroup</tt> delegates to its parent thread group, and so on up the chain until one of the <tt class="calibre35">ThreadGroup</tt> handlers deals with the uncaught exception or it bubbles up to the toplevel thread group. The top-level thread group handler delegates to the default system handler (if one exists; the default is none) and otherwise prints the stack trace to the console.</p></blockquote>
<p class="docText1"></p><a name="ch07list24" class="calibre18" id="ch07list24"></a><h5 id="title-IDAUAA1T" class="docExampleTitle">Listing 7.24. <tt class="calibre33">UncaughtExceptionHandler</tt> Interface.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle2208" class="calibre18" id="iddle2208"></a><a name="iddle2231" class="calibre18" id="iddle2231"></a><a name="iddle2232" class="calibre18" id="iddle2232"></a><a name="iddle2241" class="calibre18" id="iddle2241"></a><a name="iddle2242" class="calibre18" id="iddle2242"></a><a name="iddle2523" class="calibre18" id="iddle2523"></a><a name="iddle3167" class="calibre18" id="iddle3167"></a><a name="iddle3168" class="calibre18" id="iddle3168"></a><a name="iddle3632" class="calibre18" id="iddle3632"></a><a name="iddle4508" class="calibre18" id="iddle4508"></a><a name="iddle4509" class="calibre18" id="iddle4509"></a><a name="iddle4980" class="calibre18" id="iddle4980"></a><a name="iddle5000" class="calibre18" id="iddle5000"></a>What the handler should do with an uncaught exception depends on your quality-of-service requirements. The most common response is to write an error message and stack trace to the application log, as shown in <a class="calibre2" href="#ch07list25">Listing 7.25</a>. Handlers can also take more direct action, such as trying to restart the thread, shutting down the application, paging an operator, or other corrective or diagnostic action.</p>
<a name="ch07list25" class="calibre18" id="ch07list25"></a><h5 id="title-IDASGPLH" class="docExampleTitle">Listing 7.25. <tt class="calibre33">UncaughtExceptionHandler</tt> that Logs the Exception.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class UEHLogger implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.SEVERE,
              "Thread terminated with exception: " + t.getName(),
              e);
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07sb08" class="calibre18" id="ch07sb08"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">In long-running applications, always use uncaught exception handlers for all threads that at least log the exception.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">To set an <tt class="calibre25">UncaughtExceptionHandler</tt> for pool threads, provide a <tt class="calibre25">THReadFactory</tt> to the <tt class="calibre25">ThreadPoolExecutor</tt> constructor. (As with all thread manipulation, only the thread's owner should change its <tt class="calibre25">UncaughtExceptionHandler</tt>.) The standard thread pools allow an uncaught task exception to terminate the pool thread, but use a <tt class="calibre25">try-finally</tt> block to be notified when this happens so the thread can be replaced. Without an uncaught exception handler or other failure notification mechanism, tasks can appear to fail silently, which can be very confusing. If you want to be notified when a task fails due to an exception so that you can take some task-specific recovery action, either wrap the task with a <tt class="calibre25">Runnable</tt> or <tt class="calibre25">Callable</tt> that catches the exception or override the <tt class="calibre25">afterExecute</tt> hook in <tt class="calibre25">THReadPoolExecutor</tt>.</p>
<p class="docText1">Somewhat confusingly, exceptions thrown from tasks make it to the uncaught exception handler only for tasks submitted with <tt class="calibre25">execute</tt>; for tasks submitted with <tt class="calibre25">submit</tt>, <span class="docEmphasis">any</span> thrown exception, checked or not, is considered to be part of the task's return status. If a task submitted with <tt class="calibre25">submit</tt> terminates with an exception, it is rethrown by <tt class="calibre25">Future.get</tt>, wrapped in an <tt class="calibre25">ExecutionException</tt>.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

