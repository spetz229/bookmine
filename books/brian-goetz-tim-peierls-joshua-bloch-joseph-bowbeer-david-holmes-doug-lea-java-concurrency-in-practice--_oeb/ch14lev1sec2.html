---
layout: page
title: "Java Concurrency in Practice"
prev: ch14lev1sec1.html
next: ch14lev1sec3.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch14lev1sec2" class="calibre18" id="ch14lev1sec2"></a>
<h3 id="title-IDAJVRAJ" class="docSection1Title">14.2. Using Condition Queues</h3>
<p class="docText1">Condition queues make it easier to build efficient and responsive state-dependent classes, but they are still easy to use incorrectly; there are a lot of rules regarding their proper use that are not enforced by the compiler or platform. (This is one of the reasons to build on top of classes like <tt class="calibre25">LinkedBlockingQueue</tt>, <tt class="calibre25">CountDown-Latch</tt>, <tt class="calibre25">Semaphore</tt>, and <tt class="calibre25">FutureTask</tt> when you can; if you can get away with it, it is a lot easier.)</p>
<a name="ch14lev2sec4" class="calibre18" id="ch14lev2sec4"></a>
<h4 id="title-IDAAWRAJ" class="docSection2Title">14.2.1. The Condition Predicate</h4>
<p class="docText1"><a name="iddle1499" class="calibre18" id="iddle1499"></a><a name="iddle15001" class="calibre18" id="iddle15001"></a><a name="iddle1500" class="calibre18" id="iddle1500"></a><a name="iddle1501" class="calibre18" id="iddle1501"></a><a name="iddle1512" class="calibre18" id="iddle1512"></a><a name="iddle1513" class="calibre18" id="iddle1513"></a><a name="iddle1901" class="calibre18" id="iddle1901"></a><a name="iddle1902" class="calibre18" id="iddle1902"></a><a name="iddle2508" class="calibre18" id="iddle2508"></a><a name="iddle2509" class="calibre18" id="iddle2509"></a><a name="iddle3163" class="calibre18" id="iddle3163"></a><a name="iddle3164" class="calibre18" id="iddle3164"></a><a name="iddle3641" class="calibre18" id="iddle3641"></a><a name="iddle4430" class="calibre18" id="iddle4430"></a><a name="iddle4431" class="calibre18" id="iddle4431"></a><a name="iddle5055" class="calibre18" id="iddle5055"></a><a name="iddle5056" class="calibre18" id="iddle5056"></a><a name="iddle5133" class="calibre18" id="iddle5133"></a><a name="iddle5134" class="calibre18" id="iddle5134"></a>The key to using condition queues correctly is identifying the <span class="docEmphasis">condition predicates</span> that the object may wait for. It is the condition predicate that causes much of the confusion surrounding <tt class="calibre25">wait</tt> and <tt class="calibre25">notify</tt>, because it has no instantiation in the API and nothing in either the language specification or the JVM implementation ensures its correct use. In fact, it is not mentioned directly at all in the language specification or the Javadoc. But without it, condition waits would not work.</p>
<p class="docText1"><span class="docEmphasis">The condition predicate is the precondition that makes an operation state-dependent in the first place.</span> In a bounded buffer, <tt class="calibre25">take</tt> can proceed only if the buffer is not empty; otherwise it must wait. For <tt class="calibre25">take</tt>, the condition predicate is "the buffer is not empty", which <tt class="calibre25">take</tt> must test for before proceeding. Similarly, the condition predicate for <tt class="calibre25">put</tt> is "the buffer is not full". Condition predicates are expressions constructed from the state variables of the class; <tt class="calibre25">BaseBoundedBuffer</tt> tests for "buffer not empty" by comparing <tt class="calibre25">count</tt> to zero, and tests for "buffer not full" by comparing <tt class="calibre25">count</tt> to the buffer size.</p>
<a name="ch14sb01" class="calibre18" id="ch14sb01"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Document the condition predicate(s) associated with a condition queue and the operations that wait on them.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">There is an important three-way relationship in a condition wait involving locking, the <tt class="calibre25">wait</tt> method, and a condition predicate. The condition predicate involves state variables, and the state variables are guarded by a lock, so before testing the condition predicate, we must hold that lock. The lock object and the condition queue object (the object on which <tt class="calibre25">wait</tt> and <tt class="calibre25">notify</tt> are invoked) must also be the same object.</p>
<p class="docText1">In <tt class="calibre25">BoundedBuffer</tt>, the buffer state is guarded by the buffer lock and the buffer object is used as the condition queue. The <tt class="calibre25">take</tt> method acquires the buffer lock and then tests the condition predicate (that the buffer is nonempty). If the buffer is indeed nonempty, it removes the first element, which it can do because it still holds the lock guarding the buffer state.</p>
<p class="docText1">If the condition predicate is not true (the buffer is empty), <tt class="calibre25">take</tt> must wait until another thread puts an object in the buffer. It does this by calling <tt class="calibre25">wait</tt> on the buffer's intrinsic condition queue, which requires holding the lock on the condition queue object. As careful design would have it, <tt class="calibre25">take</tt> already holds that lock, which it needed to test the condition predicate (and if the condition predicate was true, to modify the buffer state in the same atomic operation). The <tt class="calibre25">wait</tt> method releases the lock, blocks the current thread, and waits until the specified timeout expires, the thread is interrupted, or the thread is awakened by a notification. After the thread wakes up, <tt class="calibre25">wait</tt> reacquires the lock before returning. A thread waking up from <tt class="calibre25">wait</tt> gets no special priority in reacquiring the lock; it contends for the lock just like any other thread attempting to enter a <tt class="calibre25">synchronized</tt> block.</p>
<a name="ch14sb02" class="calibre18" id="ch14sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1"><a name="iddle1517" class="calibre18" id="iddle1517"></a><a name="iddle2510" class="calibre18" id="iddle2510"></a><a name="iddle3686" class="calibre18" id="iddle3686"></a><a name="iddle5139" class="calibre18" id="iddle5139"></a><a name="iddle5151" class="calibre18" id="iddle5151"></a>Every call to <tt class="calibre25">wait</tt> is implicitly associated with a specific <span class="docEmphasis">condition predicate</span>. When calling <tt class="calibre25">wait</tt> regarding a particular condition predicate, the caller must already hold the lock associated with the condition queue, and that lock must also guard the state variables from which the condition predicate is composed.</p>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch14lev2sec5" class="calibre18" id="ch14lev2sec5"></a>
<h4 id="title-IDAIBENU" class="docSection2Title">14.2.2. Waking Up Too Soon</h4>
<p class="docText1">As if the three-way relationship among the lock, the condition predicate, and the condition queue were not complicated enough, that <tt class="calibre25">wait</tt> returns does not necessarily mean that the condition predicate the thread is waiting for has become true.</p>
<p class="docText1"><span class="docEmphasis">A single intrinsic condition queue may be used with more than one condition predicate.</span> When your thread is awakened because someone called <tt class="calibre25">notifyAll</tt>, that doesn't mean that the condition predicate <span class="docEmphasis">you</span> were waiting for is now true. (This is like having your toaster and coffee maker share a single bell; when it rings, you still have to look to see which device raised the signal.)<sup class="docFootnote"><a class="calibre2" href="#ch14fn07">[7]</a></sup> Additionally, <tt class="calibre25">wait</tt> is even allowed to return "spuriously"not in response to any thread calling <tt class="calibre25">notify</tt>.<sup class="docFootnote"><a class="calibre2" href="#ch14fn08">[8]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch14fn07" class="calibre18" id="ch14fn07">[7]</a></sup> This situation actually describes Tim's kitchen pretty well; so many devices beep that when you hear one, you have to inspect the toaster, the microwave, the coffee maker, and several others to determine the cause of the signal.</p></blockquote><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch14fn08" class="calibre18" id="ch14fn08">[8]</a></sup> To push the breakfast analogy way too far, this is like a toaster with a loose connection that makes the bell go off when the toast is ready but also sometimes when it is not ready.</p></blockquote>
<p class="docText1">When control re-enters the code calling <tt class="calibre25">wait</tt>, it has reacquired the lock associated with the condition queue. Is the condition predicate now true? Maybe. It might have been true at the time the notifying thread called <tt class="calibre25">notifyAll</tt>, but could have become false again by the time <span class="docEmphasis">you</span> reacquire the lock. Other threads may have acquired the lock and changed the object's state between when your thread was awakened and when <tt class="calibre25">wait</tt> reacquired the lock. Or maybe it hasn't been true at all since you called <tt class="calibre25">wait</tt>. You don't know why another thread called <tt class="calibre25">notify</tt> or <tt class="calibre25">notifyAll</tt>; maybe it was because <span class="docEmphasis">another</span> condition predicate associated with the same condition queue became true. Multiple condition predicates per condition queue are quite common<tt class="calibre25">BoundedBuffer</tt> uses the same condition queue for both the "not full" and "not empty" predicates.<sup class="docFootnote"><a class="calibre2" href="#ch14fn09">[9]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch14fn09" class="calibre18" id="ch14fn09">[9]</a></sup> It is actually possible for threads to be waiting for both "not full" and "not empty" at the same time! This can happen when the number of producers/consumers exceeds the buffer capacity.</p></blockquote>
<p class="docText1">For all these reasons, when you wake up from <tt class="calibre25">wait</tt> you must test the condition predicate <span class="docEmphasis">again</span>, and go back to waiting (or fail) if it is not yet true. Since you can wake up repeatedly without your condition predicate being true, you must therefore always call <tt class="calibre25">wait</tt> from within a loop, testing the condition predicate in each iteration. The canonical form for a condition wait is shown in <a class="calibre2" href="#ch14list07">Listing 14.7</a>.</p>
<p class="docText1"></p><a name="ch14list07" class="calibre18" id="ch14list07"></a><h5 id="title-IDAXDENU" class="docExampleTitle">Listing 14.7. Canonical Form for State-dependent Methods.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">void stateDependentMethod() throws InterruptedException {
    <span class="docEmphasis">// condition predicate must be guarded by lock</span>
    synchronized(lock) {
        while (!conditionPredicate())
            lock.wait();
        <span class="docEmphasis">// object is now in desired state</span>
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch14sb03" class="calibre18" id="ch14sb03"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1"><a name="iddle1514" class="calibre18" id="iddle1514"></a><a name="iddle2511" class="calibre18" id="iddle2511"></a><a name="iddle2637" class="calibre18" id="iddle2637"></a><a name="iddle3213" class="calibre18" id="iddle3213"></a><a name="iddle3214" class="calibre18" id="iddle3214"></a><a name="iddle4436" class="calibre18" id="iddle4436"></a><a name="iddle5135" class="calibre18" id="iddle5135"></a>When using condition waits (<tt class="calibre25">Object.wait</tt> or <tt class="calibre25">Condition.await</tt>):</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1">Always have a condition predicatesome test of object state that must hold before proceeding;</p></li><li class="calibre16"><p class="docText1">Always test the condition predicate before calling <tt class="calibre25">wait</tt>, and again after returning from <tt class="calibre25">wait</tt>;</p></li><li class="calibre16"><p class="docText1">Always call <tt class="calibre25">wait</tt> in a loop;</p></li><li class="calibre16"><p class="docText1">Ensure that the state variables making up the condition predicate are guarded by the lock associated with the condition queue;</p></li><li class="calibre16"><p class="docText1">Hold the lock associated with the the condition queue when calling <tt class="calibre25">wait</tt>, <tt class="calibre25">notify</tt>, or <tt class="calibre25">notifyAll</tt>; and</p></li><li class="calibre16"><p class="docText1">Do not release the lock after checking the condition predicate but before acting on it.</p></li></ul>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch14lev2sec6" class="calibre18" id="ch14lev2sec6"></a>
<h4 id="title-IDAYA0MU" class="docSection2Title">14.2.3. Missed Signals</h4>
<p class="docText1"><a class="calibre2" href="ch10.html#ch10">Chapter 10</a> discussed liveness failures such as deadlock and livelock. Another form of liveness failure is <span class="docEmphasis">missed signals</span>. A missed signal occurs when a thread must wait for a specific condition that is already true, but fails to check the condition predicate before waiting. Now the thread is waiting to be notified of an event that has already occurred. This is like starting the toast, going out to get the newspaper, having the bell go off while you are outside, and then sitting down at the kitchen table waiting for the toast bell. You could wait a long timepotentially forever.<sup class="docFootnote"><a class="calibre2" href="#ch14fn10">[10]</a></sup> Unlike the marmalade for your toast, notification is not "sticky"if thread <span class="docEmphasis">A</span> notifies on a condition queue and thread <span class="docEmphasis">B</span> subsequently waits on that same condition queue, <span class="docEmphasis">B</span> does <span class="docEmphasis">not</span> immediately wake upanother notification is required to wake <span class="docEmphasis">B</span>. Missed signals are the result of coding errors like those warned against in the list above, such as failing to test the condition predicate before calling <tt class="calibre25">wait</tt>. If you structure your condition waits as in <a class="calibre2" href="#ch14list07">Listing 14.7</a>, you will not have problems with missed signals.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch14fn10" class="calibre18" id="ch14fn10">[10]</a></sup> In order to emerge from this wait, someone else would have to make toast, but this will just make matters worse; when the bell rings, you will then have a disagreement about toast ownership.</p></blockquote>
<a name="ch14lev2sec7" class="calibre18" id="ch14lev2sec7"></a>
<h4 id="title-IDAHC0MU" class="docSection2Title">14.2.4. Notification</h4>
<p class="docText1"><a name="iddle3215" class="calibre18" id="iddle3215"></a><a name="iddle3310" class="calibre18" id="iddle3310"></a><a name="iddle3311" class="calibre18" id="iddle3311"></a><a name="iddle3312" class="calibre18" id="iddle3312"></a><a name="iddle3313" class="calibre18" id="iddle3313"></a><a name="iddle3314" class="calibre18" id="iddle3314"></a><a name="iddle3315" class="calibre18" id="iddle3315"></a><a name="iddle3316" class="calibre18" id="iddle3316"></a><a name="iddle3317" class="calibre18" id="iddle3317"></a><a name="iddle3318" class="calibre18" id="iddle3318"></a><a name="iddle3331" class="calibre18" id="iddle3331"></a><a name="iddle3332" class="calibre18" id="iddle3332"></a><a name="iddle3336" class="calibre18" id="iddle3336"></a><a name="iddle3337" class="calibre18" id="iddle3337"></a>So far, we've described half of what goes on in a condition wait: waiting. The other half is notification. In a bounded buffer, <tt class="calibre25">take</tt> blocks if called when the buffer is empty. In order for <tt class="calibre25">take</tt> to <span class="docEmphasis">unblock</span> when the buffer becomes nonempty, we must ensure that <span class="docEmphasis">every</span> code path in which the buffer could become nonempty performs a notification. In <tt class="calibre25">BoundedBuffer</tt>, there is only one such placeafter a <tt class="calibre25">put</tt>. So <tt class="calibre25">put</tt> calls <tt class="calibre25">notifyAll</tt> after successfully adding an object to the buffer. Similarly, <tt class="calibre25">take</tt> calls <tt class="calibre25">notifyAll</tt> after removing an element to indicate that the buffer may no longer be full, in case any threads are waiting on the "not full" condition.</p>
<a name="ch14sb04" class="calibre18" id="ch14sb04"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Whenever you wait on a condition, make sure that someone will perform a notification whenever the condition predicate becomes true.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">There are two notification methods in the condition queue API<tt class="calibre25">notify</tt> and <tt class="calibre25">notifyAll</tt>. To call either, you must hold the lock associated with the condition queue object. Calling <tt class="calibre25">notify</tt> causes the JVM to select one thread waiting on that condition queue to wake up; calling <tt class="calibre25">notifyAll</tt> wakes up <span class="docEmphasis">all</span> the threads waiting on that condition queue. Because you must hold the lock on the condition queue object when calling <tt class="calibre25">notify</tt> or <tt class="calibre25">notifyAll</tt>, and waiting threads cannot return from <tt class="calibre25">wait</tt> without reacquiring the lock, the notifying thread should release the lock quickly to ensure that the waiting threads are unblocked as soon as possible.</p>
<p class="docText1">Because multiple threads could be waiting on the same condition queue for different condition predicates, using <tt class="calibre25">notify</tt> instead of <tt class="calibre25">notifyAll</tt> can be dangerous, primarily because single notification is prone to a problem akin to missed signals.</p>
<p class="docText1"><tt class="calibre25">BoundedBuffer</tt> provides a good illustration of why <tt class="calibre25">notifyAll</tt> should be preferred to single <tt class="calibre25">notify</tt> in most cases. The condition queue is used for two different condition predicates: "not full" and "not empty". Suppose thread <span class="docEmphasis">A</span> waits on a condition queue for predicate <span class="docEmphasis">PA</span>, while thread <span class="docEmphasis">B</span> waits on the same condition queue for predicate <span class="docEmphasis">PB</span>. Now, suppose <span class="docEmphasis">PB</span> becomes true and thread <span class="docEmphasis">C</span> performs a single <tt class="calibre25">notify</tt>: the JVM will wake up one thread of its own choosing. If <span class="docEmphasis">A</span> is chosen, it will wake up, see that <span class="docEmphasis">PA</span> is not yet true, and go back to waiting. Meanwhile, <span class="docEmphasis">B</span>, which could now make progress, does not wake up. This is not exactly a missed signalit's more of a "hijacked signal"but the problem is the same: a thread is waiting for a signal that has (or should have) already occurred.</p>
<a name="ch14sb05" class="calibre18" id="ch14sb05"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1"><a name="iddle1519" class="calibre18" id="iddle1519"></a><a name="iddle1520" class="calibre18" id="iddle1520"></a><a name="iddle2555" class="calibre18" id="iddle2555"></a><a name="iddle3321" class="calibre18" id="iddle3321"></a><a name="iddle3322" class="calibre18" id="iddle3322"></a><a name="iddle3328" class="calibre18" id="iddle3328"></a><a name="iddle3329" class="calibre18" id="iddle3329"></a><a name="iddle3335" class="calibre18" id="iddle3335"></a><a name="iddle3397" class="calibre18" id="iddle3397"></a><a name="iddle3510" class="calibre18" id="iddle3510"></a><a name="iddle4290" class="calibre18" id="iddle4290"></a><a name="iddle4291" class="calibre18" id="iddle4291"></a>Single <tt class="calibre25">notify</tt> can be used instead of <tt class="calibre25">notifyAll</tt> only when both of the following conditions hold:</p>
<blockquote class="calibre19"><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Uniform waiters.</span> Only one condition predicate is associated with the condition queue, and each thread executes the same logic upon returning from <tt class="calibre25">wait</tt>; and</p></blockquote></td></tr></table></p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">One-in, one-out.</span> A notification on the condition variable enables at most one thread to proceed.</p>
<p class="calibre1"> </p>
<p class="docText1"><tt class="calibre25">BoundedBuffer</tt> meets the one-in, one-out requirement, but does not meet the uniform waiters requirement because waiting threads might be waiting for either the "not full" and "not empty" condition. A "starting gate" latch like that used in <tt class="calibre25">TestHarness</tt> on page <a class="calibre2" href="ch05lev1sec5.html#ch05list11">96</a>, in which a single event releases a set of threads, does not meet the one-in, one-out requirement because opening the starting gate lets multiple threads proceed.</p>
<p class="docText1">Most classes don't meet these requirements, so the prevailing wisdom is to use <tt class="calibre25">notifyAll</tt> in preference to single <tt class="calibre25">notify</tt>. While this may be inefficient, it is much easier to ensure that your classes behave correctly when using <tt class="calibre25">notifyAll</tt> instead of <tt class="calibre25">notify</tt>.</p>
<p class="docText1">This "prevailing wisdom" makes some people uncomfortable, and for good reason. Using <tt class="calibre25">notifyAll</tt> when only one thread can make progress is inefficientsometimes a little, sometimes grossly so. If ten threads are waiting on a condition queue, calling <tt class="calibre25">notifyAll</tt> causes each of them to wake up and contend for the lock; then most or all of them will go right back to sleep. This means a lot of context switches and a lot of contended lock acquisitions for each event that enables (maybe) a single thread to make progress. (In the worst case, using <tt class="calibre25">notify-All</tt> results in <span class="docEmphasis">O</span>(<span class="docEmphasis">n</span><sup class="calibre49">2</sup>) wakeups where <span class="docEmphasis">n</span> would suffice.) This is another situation where performance concerns support one approach and safety concerns support the other.</p>
<p class="docText1">The notification done by <tt class="calibre25">put</tt> and <tt class="calibre25">take</tt> in <tt class="calibre25">BoundedBuffer</tt> is conservative: a notification is performed every time an object is put into or removed from the buffer. This could be optimized by observing that a thread can be released from a wait only if the buffer goes from empty to not empty or from full to not full, and notifying only if a <tt class="calibre25">put</tt> or <tt class="calibre25">take</tt> effected one of these state transitions. This is called <span class="docEmphasis">conditional notification.</span> While conditional notification can improve performance, it is tricky to get right (and also complicates the implementation of subclasses) and so should be used carefully. <a class="calibre2" href="#ch14list08">Listing 14.8</a> illustrates using conditional notification in <tt class="calibre25">BoundedBuffer</tt>.<tt class="calibre25">put</tt>.</p>
<p class="docText1">Single notification and conditional notification are optimizations. As always, follow the principle "First make it right, and then make it fast<span class="docEmphasis">if</span> it is not already fast enough" when using these optimizations; it is easy to introduce strange liveness failures by applying them incorrectly.</p>
<p class="docText1"></p><a name="ch14list08" class="calibre18" id="ch14list08"></a><h5 id="title-IDADE1MU" class="docExampleTitle">Listing 14.8. Using Conditional Notification in <tt class="calibre33">BoundedBuffer.put</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public synchronized void put(V v) throws InterruptedException {
    while (isFull())
        wait();
    <span class="docEmphStrong">boolean wasEmpty = isEmpty();</span>
    doPut(v);
    <span class="docEmphStrong">if (wasEmpty)</span>
<span class="docEmphStrong">notifyAll();</span>
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch14lev2sec8" class="calibre18" id="ch14lev2sec8"></a>
<h4 id="title-IDABF1MU" class="docSection2Title">14.2.5. Example: A Gate Class</h4>
<p class="docText1"><a name="iddle1202" class="calibre18" id="iddle1202"></a><a name="iddle1450" class="calibre18" id="iddle1450"></a><a name="iddle1521" class="calibre18" id="iddle1521"></a><a name="iddle1522" class="calibre18" id="iddle1522"></a><a name="iddle1962" class="calibre18" id="iddle1962"></a><a name="iddle2397" class="calibre18" id="iddle2397"></a><a name="iddle2447" class="calibre18" id="iddle2447"></a><a name="iddle2938" class="calibre18" id="iddle2938"></a><a name="iddle2942" class="calibre18" id="iddle2942"></a><a name="iddle3323" class="calibre18" id="iddle3323"></a><a name="iddle3333" class="calibre18" id="iddle3333"></a><a name="iddle3334" class="calibre18" id="iddle3334"></a><a name="iddle3799" class="calibre18" id="iddle3799"></a><a name="iddle4045" class="calibre18" id="iddle4045"></a><a name="iddle4506" class="calibre18" id="iddle4506"></a><a name="iddle4507" class="calibre18" id="iddle4507"></a>The starting gate latch in <tt class="calibre25">TestHarness</tt> on page <a class="calibre2" href="ch05lev1sec5.html#ch05list11">96</a> was constructed with an initial count of one, creating a <span class="docEmphasis">binary latch</span>: one with two states, the initial state and the terminal state. The latch prevents threads from passing the starting gate until it is opened, at which point all the threads can pass through. While this latching mechanism is often exactly what is needed, sometimes it is a drawback that a gate constructed in this manner cannot be reclosed once opened.</p>
<p class="docText1">It is easy to develop a recloseable <tt class="calibre25">ThreadGate</tt> class using condition waits, as shown in <a class="calibre2" href="#ch14list09">Listing 14.9</a>. <tt class="calibre25">ThreadGate</tt> lets the gate be opened and closed, providing an <tt class="calibre25">await</tt> method that blocks until the gate is opened. The <tt class="calibre25">open</tt> method uses <tt class="calibre25">notifyAll</tt> because the semantics of this class fail the "one-in, one-out" test for single notification.</p>
<p class="docText1">The condition predicate used by <tt class="calibre25">await</tt> is more complicated than simply testing <tt class="calibre25">isOpen</tt>. This is needed because if <span class="docEmphasis">N</span> threads are waiting at the gate at the time it is opened, they should all be allowed to proceed. But, if the gate is opened and closed in rapid succession, all threads might not be released if <tt class="calibre25">await</tt> examines only <tt class="calibre25">isOpen</tt>: by the time all the threads receive the notification, reacquire the lock, and emerge from <tt class="calibre25">wait</tt>, the gate may have closed again. So <tt class="calibre25">THReadGate</tt> uses a somewhat more complicated condition predicate: every time the gate is closed, a "generation" counter is incremented, and a thread may pass <tt class="calibre25">await</tt> if the gate is open now or if the gate has opened since this thread arrived at the gate.</p>
<p class="docText1">Since <tt class="calibre25">ThreadGate</tt> only supports waiting for the gate to open, it performs notification only in <tt class="calibre25">open</tt>; to support both "wait for open" and "wait for close" operations, it would have to notify in both <tt class="calibre25">open</tt> and <tt class="calibre25">close</tt>. This illustrates why state-dependent classes can be fragile to maintainthe addition of a new statedependent operation may require modifying many code paths that modify the object state so that the appropriate notifications can be performed.</p>
<a name="ch14lev2sec9" class="calibre18" id="ch14lev2sec9"></a>
<h4 id="title-IDAUM1MU" class="docSection2Title">14.2.6. Subclass Safety Issues</h4>
<p class="docText1">Using conditional or single notification introduces constraints that can complicate subclassing [CPJ 3.3.3.3]. If you want to support subclassing at all, you must structure your class so subclasses can add the appropriate notification on behalf <a name="iddle1988" class="calibre18" id="iddle1988"></a><a name="iddle2201" class="calibre18" id="iddle2201"></a>of the base class if it is subclassed in a way that violates one of the requirements for single or conditional notification.</p>
<a name="ch14list09" class="calibre18" id="ch14list09"></a><h5 id="title-IDAXN1MU" class="docExampleTitle">Listing 14.9. Recloseable Gate Using <tt class="calibre33">Wait</tt> and <tt class="calibre33">Notifyall</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class ThreadGate {
    <span class="docEmphasis">// CONDITION-PREDICATE: opened-since(n) (isOpen || generation&gt;n)</span>
    @GuardedBy("this") private boolean isOpen;
    @GuardedBy("this") private int generation;

    public synchronized void close() {
        isOpen = false;
    }

    public synchronized void open() {
        ++generation;
        isOpen = true;
        notifyAll();
    }

    <span class="docEmphasis">// BLOCKS-UNTIL: opened-since(generation on entry)</span>
    public synchronized void await() throws InterruptedException {
        int arrivalGeneration = generation;
        while (!isOpen &amp;&amp; arrivalGeneration == generation)
            wait();
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><span class="docEmphasis">A state-dependent class should either fully expose (and document) its waiting and notification protocols to subclasses, or prevent subclasses from participating in them at all.</span> (This is an extension of "design and document for inheritance, or else prohibit it" [EJ Item 15].) At the very least, designing a state-dependent class for inheritance requires exposing the condition queues and locks and documenting the condition predicates and synchronization policy; it may also require exposing the underlying state variables. (The worst thing a state-dependent class can do is expose its state to subclasses but <span class="docEmphasis">not</span> document its protocols for waiting and notification; this is like a class exposing its state variables but not documenting its invariants.)</p>
<p class="docText1">One option for doing this is to effectively prohibit subclassing, either by making the class <tt class="calibre25">final</tt> or by hiding the condition queues, locks, and state variables from subclasses. Otherwise, if the subclass does something to undermine the way the base class uses <tt class="calibre25">notify</tt>, it needs to be able to repair the damage. Consider an unbounded blocking stack in which the pop operation blocks if the stack is empty but the push operation can always proceed. This meets the requirements for single notification. If this class uses single notification and a subclass adds a blocking "pop two consecutive elements" method, there are now two classes of <a name="iddle1118" class="calibre18" id="iddle1118"></a><a name="iddle1362" class="calibre18" id="iddle1362"></a><a name="iddle1496" class="calibre18" id="iddle1496"></a><a name="iddle1506" class="calibre18" id="iddle1506"></a><a name="iddle1508" class="calibre18" id="iddle1508"></a><a name="iddle1510" class="calibre18" id="iddle1510"></a><a name="iddle1511" class="calibre18" id="iddle1511"></a><a name="iddle1900" class="calibre18" id="iddle1900"></a><a name="iddle2017" class="calibre18" id="iddle2017"></a><a name="iddle2037" class="calibre18" id="iddle2037"></a><a name="iddle2038" class="calibre18" id="iddle2038"></a><a name="iddle2279" class="calibre18" id="iddle2279"></a><a name="iddle2280" class="calibre18" id="iddle2280"></a><a name="iddle2825" class="calibre18" id="iddle2825"></a><a name="iddle3068" class="calibre18" id="iddle3068"></a><a name="iddle3346" class="calibre18" id="iddle3346"></a><a name="iddle3347" class="calibre18" id="iddle3347"></a><a name="iddle3706" class="calibre18" id="iddle3706"></a><a name="iddle3707" class="calibre18" id="iddle3707"></a><a name="iddle3760" class="calibre18" id="iddle3760"></a><a name="iddle5048" class="calibre18" id="iddle5048"></a><a name="iddle5049" class="calibre18" id="iddle5049"></a><a name="iddle5100" class="calibre18" id="iddle5100"></a><a name="iddle5101" class="calibre18" id="iddle5101"></a>waiters: those waiting to pop one element and those waiting to pop two. But if the base class exposes the condition queue and documents its protocols for using it, the subclass can override the push method to perform a <tt class="calibre25">notifyAll</tt>, restoring safety.</p>
<a name="ch14lev2sec10" class="calibre18" id="ch14lev2sec10"></a>
<h4 id="title-IDABX1MU" class="docSection2Title">14.2.7. Encapsulating Condition Queues</h4>
<p class="docText1">It is generally best to encapsulate the condition queue so that it is not accessible outside the class hierarchy in which it is used. Otherwise, callers might be tempted to think they understand your protocols for waiting and notification and use them in a manner inconsistent with your design. (It is impossible to enforce the uniform waiters requirement for single notification unless the condition queue object is inaccessible to code you do not control; if alien code mistakenly waits on your condition queue, this could subvert your notification protocol and cause a hijacked signal.)</p>
<p class="docText1">Unfortunately, this adviceto encapsulate objects used as condition queuesis not consistent with the most common design pattern for thread-safe classes, in which an object's intrinsic lock is used to guard its state. <tt class="calibre25">BoundedBuffer</tt> illustrates this common idiom, where the buffer object itself is the lock and condition queue. However, <tt class="calibre25">BoundedBuffer</tt> could be easily restructured to use a private lock object and condition queue; the only difference would be that it would no longer support any form of client-side locking.</p>
<a name="ch14lev2sec11" class="calibre18" id="ch14lev2sec11"></a>
<h4 id="title-IDAUX1MU" class="docSection2Title">14.2.8. Entry and Exit Protocols</h4>
<p class="docText1">Wellings (<a class="calibre2" href="bib01.html#biblio01_032">Wellings, 2004</a>) characterizes the proper use of <tt class="calibre25">wait</tt> and <tt class="calibre25">notify</tt> in terms of <span class="docEmphasis">entry</span> and <span class="docEmphasis">exit protocols</span>. For each state-dependent operation and for each operation that modifies state on which another operation has a state dependency, you should define and document an entry and exit protocol. The entry protocol is the operation's condition predicate; the exit protocol involves examining any state variables that have been changed by the operation to see if they might have caused some other condition predicate to become true, and if so, notifying on the associated condition queue.</p>
<p class="docText1"><tt class="calibre25">AbstractQueuedSynchronizer</tt>, upon which most of the state-dependent classes in <tt class="calibre25">java.util.concurrent</tt> are built (see <a class="calibre2" href="ch14lev1sec4.html#ch14lev1sec4">Section 14.4</a>), exploits the concept of exit protocol. Rather than letting synchronizer classes perform their own notification, it instead requires synchronizer methods to return a value indicating whether its action might have unblocked one or more waiting threads. This explicit API requirement makes it harder to "forget" to notify on some state transitions.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

