---
layout: page
title: "Java Concurrency in Practice"
prev: ch14lev1sec6.html
next: ch15.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch14lev1sec7" class="calibre18" id="ch14lev1sec7"></a>
<h3 id="title-IDARI5WK" class="docSection1Title">Summary</h3>
<p class="docText1">If you need to implement a state-dependent classone whose methods must block if a state-based precondition does not holdthe best strategy is usually to build upon an existing library class such as <tt class="calibre25">Semaphore</tt>, <tt class="calibre25">BlockingQueue</tt>, or <tt class="calibre25">CountDownLatch</tt>, as in <tt class="calibre25">ValueLatch</tt> on page <a class="calibre2" href="ch08lev1sec5.html#ch08list15">187</a>. However, sometimes existing library classes do not provide a sufficient foundation; in these cases, you can build your own synchronizers using intrinsic condition queues, explicit <tt class="calibre25">Condition</tt> objects, or <tt class="calibre25">AbstractQueuedSynchronizer</tt>. Intrinsic condition queues are tightly bound to intrinsic locking, since the mechanism for managing state dependence is necessarily tied to the mechanism for ensuring state consistency. Similarly, explicit <tt class="calibre25">Condition</tt>s are tightly bound to explicit <tt class="calibre25">Lock</tt>s, and offer an extended feature set compared to intrinsic condition queues, including multiple wait sets per lock, interruptible or uninterruptible condition waits, fair or nonfair queuing, and deadline-based waiting.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3">Â </p>

</div>

{% endraw %}

