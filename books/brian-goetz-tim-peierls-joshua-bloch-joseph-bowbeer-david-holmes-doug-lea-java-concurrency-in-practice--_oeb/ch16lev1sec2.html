---
layout: page
title: "Java Concurrency in Practice"
prev: ch16lev1sec1.html
next: ch16lev1sec3.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch16lev1sec2" class="calibre18" id="ch16lev1sec2"></a>
<h3 id="647011-935" class="docSection1Title">16.2. Publication</h3>
<p class="docText1"><a class="calibre2" href="ch03.html#ch03">Chapter 3</a> explored how an object could be safely or improperly published. The safe publication techniques described there derive their safety from guarantees provided by the JMM; the risks of improper publication are consequences of the absence of a <span class="docEmphasis">happens-before</span> ordering between publishing a shared object and accessing it from another thread.</p>
<a name="ch16lev2sec5" class="calibre18" id="ch16lev2sec5"></a>
<h4 id="title-IDAWI5TX" class="docSection2Title">16.2.1. Unsafe Publication</h4>
<p class="docText1">The possibility of reordering in the absence of a <span class="docEmphasis">happens-before</span> relationship explains why publishing an object without adequate synchronization can allow another thread to see a <span class="docEmphasis">partially constructed object</span> (see <a class="calibre2" href="ch03lev1sec5.html#ch03lev1sec5">Section 3.5</a>). Initializing a new object involves writing to variablesthe new object's fields. Similarly, publishing a reference involves writing to another variablethe reference to the new object. <a name="iddle2211" class="calibre18" id="iddle2211"></a><a name="iddle2739" class="calibre18" id="iddle2739"></a><a name="iddle2949" class="calibre18" id="iddle2949"></a>If you do not ensure that publishing the shared reference <span class="docEmphasis">happens-before</span> another thread loads that shared reference, then the write of the reference to the new object can be reordered (from the perspective of the thread consuming the object) with the writes to its fields. In that case, another thread could see an up-to-date value for the object reference but <span class="docEmphasis">out-of-date values for some or all of that object's state</span>a partially constructed object.</p>
<p class="docText1">Unsafe publication can happen as a result of an incorrect lazy initialization, as shown in Figure 16.3. At first glance, the only problem here seems to be the race condition described in <a class="calibre2" href="ch02lev1sec2.html#ch02lev2sec3">Section 2.2.2</a>. Under certain circumstances, such as when all instances of the <tt class="calibre25">Resource</tt> are identical, you might be willing to overlook these (along with the inefficiency of possibly creating the <tt class="calibre25">Resource</tt> more than once). Unfortunately, even if these defects are overlooked, <tt class="calibre25">UnsafeLazyInitialization</tt> is still not safe, because another thread could observe a reference to a partially constructed <tt class="calibre25">Resource</tt>.</p>
<a name="ch16list03" class="calibre18" id="ch16list03"></a><h5 id="title-IDAIL5TX" class="docExampleTitle">Listing 16.3. Unsafe Lazy Initialization. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" id="195131084199" src="face.jpg" class="calibre29"/>
<pre class="calibre30">@NotThreadSafe
public class UnsafeLazyInitialization {
    private static Resource resource;

    public static Resource getInstance() {
        if (resource == null)
            resource = new Resource();  // unsafe publication
        return resource;
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Suppose thread <span class="docEmphasis">A</span> is the first to invoke <tt class="calibre25">getInstance</tt>. It sees that <tt class="calibre25">resource</tt> is <tt class="calibre25">null</tt>, instantiates a new <tt class="calibre25">Resource</tt>, and sets <tt class="calibre25">resource</tt> to reference it. When thread <span class="docEmphasis">B</span> later calls <tt class="calibre25">getInstance</tt>, it might see that <tt class="calibre25">resource</tt> already has a non-null value and just use the already constructed <tt class="calibre25">Resource</tt>. This might look harmless at first, but <span class="docEmphasis">there is no happens-before ordering between the writing of resource in A and the reading of resource in B</span>. A data race has been used to publish the object, and therefore <span class="docEmphasis">B</span> is not guaranteed to see the correct state of the <tt class="calibre25">Resource</tt>.</p>
<p class="docText1">The <tt class="calibre25">Resource</tt> constructor changes the fields of the freshly allocated <tt class="calibre25">Resource</tt> from their default values (written by the <tt class="calibre25">Object</tt> constructor) to their initial values. Since neither thread used synchronization, <span class="docEmphasis">B</span> could possibly see <span class="docEmphasis">A</span>'s actions in a different order than <span class="docEmphasis">A</span> performed them. So even though <span class="docEmphasis">A</span> initialized the <tt class="calibre25">Resource</tt> before setting <tt class="calibre25">resource</tt> to reference it, <span class="docEmphasis">B</span> could see the write to <tt class="calibre25">resource</tt> as occurring <span class="docEmphasis">before</span> the writes to the fields of the <tt class="calibre25">Resource</tt>. <span class="docEmphasis">B</span> could thus see a partially constructed <tt class="calibre25">Resource</tt> that may well be in an invalid stateand whose state may unexpectedly change later.</p>
<a name="ch16sb02" class="calibre18" id="ch16sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1"><a name="iddle2529" class="calibre18" id="iddle2529"></a><a name="iddle2699" class="calibre18" id="iddle2699"></a><a name="iddle2743" class="calibre18" id="iddle2743"></a><a name="iddle2901" class="calibre18" id="iddle2901"></a><a name="iddle3727" class="calibre18" id="iddle3727"></a><a name="iddle4035" class="calibre18" id="iddle4035"></a>With the exception of immutable objects, it is not safe to use an object that has been initialized by another thread unless the publication <span class="docEmphasis">happensbefore</span> the consuming thread uses it.</p>
</td></tr></table></p><p class="calibre1">Â </p>
<a name="ch16lev2sec6" class="calibre18" id="ch16lev2sec6"></a>
<h4 id="title-IDAPQ5TX" class="docSection2Title">16.2.2. Safe Publication</h4>
<p class="docText1">The safe-publication idioms described in <a class="calibre2" href="ch03.html#ch03">Chapter 3</a> ensure that the published object is visible to other threads because they ensure the publication <span class="docEmphasis">happens-before</span> the consuming thread loads a reference to the published object. If thread <span class="docEmphasis">A</span> places <span class="docEmphasis">X</span> on a <tt class="calibre25">BlockingQueue</tt> (and no thread subsequently modifies it) and thread <span class="docEmphasis">B</span> retrieves it from the queue, <span class="docEmphasis">B</span> is guaranteed to see <span class="docEmphasis">X</span> as <span class="docEmphasis">A</span> left it. This is because the <tt class="calibre25">BlockingQueue</tt> implementations have sufficient internal synchronization to ensure that the <tt class="calibre25">put</tt> <span class="docEmphasis">happens-before</span> the <tt class="calibre25">take</tt>. Similarly, using a shared variable guarded by a lock or a shared volatile variable ensures that reads and writes of that variable are ordered by <span class="docEmphasis">happens-before</span>.</p>
<p class="docText1">This <span class="docEmphasis">happens-before</span> guarantee is actually a stronger promise of visibility and ordering than made by safe publication. When <span class="docEmphasis">X</span> is safely published from <span class="docEmphasis">A</span> to <span class="docEmphasis">B</span>, the safe publication guarantees visibility of the state of <span class="docEmphasis">X</span>, but not of the state of other variables <span class="docEmphasis">A</span> may have touched. But if <span class="docEmphasis">A</span> putting <span class="docEmphasis">X</span> on a queue <span class="docEmphasis">happens-before B</span> fetches <span class="docEmphasis">X</span> from that queue, not only does <span class="docEmphasis">B</span> see <span class="docEmphasis">X</span> in the state that <span class="docEmphasis">A</span> left it (assuming that <span class="docEmphasis">X</span> has not been subsequently modified by <span class="docEmphasis">A</span> or anyone else), but <span class="docEmphasis">B</span> sees <span class="docEmphasis">everything A</span> did before the handoff (again, subject to the same caveat).<sup class="docFootnote"><a class="calibre2" href="#ch16fn05">[5]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch16fn05" class="calibre18" id="ch16fn05">[5]</a></sup> The JMMguarantees that <span class="docEmphasis">B</span> sees a value at least as up-to-date as the value that <span class="docEmphasis">A</span> wrote; subsequent writes may or may not be visible.</p></blockquote>
<p class="docText1">Why did we focus so heavily on <tt class="calibre25">@GuardedBy</tt> and safe publication, when the JMM already provides us with the more powerful <span class="docEmphasis">happens-before</span>? Thinking in terms of handing off object ownership and publication fits better into most program designs than thinking in terms of visibility of individual memory writes. The <span class="docEmphasis">happens-before</span> ordering operates at the level of individual memory accessesit is a sort of "concurrency assembly language". Safe publication operates at a level closer to that of your program's design.</p>
<a name="ch16lev2sec7" class="calibre18" id="ch16lev2sec7"></a>
<h4 id="title-IDAUT5TX" class="docSection2Title">16.2.3. Safe Initialization Idioms</h4>
<p class="docText1">It sometimes makes sense to defer initialization of objects that are expensive to initialize until they are actually needed, but we have seen how the misuse of lazy initialization can lead to trouble. <tt class="calibre25">UnsafeLazyInitialization</tt> can be fixed by making the <tt class="calibre25">geTResource</tt> method <tt class="calibre25">synchronized</tt>, as shown in <a class="calibre2" href="#ch16list04">Listing 16.4</a>. Because the code path through <tt class="calibre25">getInstance</tt> is fairly short (a test and a predicted branch), if <tt class="calibre25">getInstance</tt> is not called frequently by many threads, there is little enough contention for the <tt class="calibre25">SafeLazyInitialization</tt> lock that this approach offers adequate performance.</p>
<p class="docText1">The treatment of static fields with initializers (or fields whose value is initialized in a static initialization block [JPL 2.2.1 and 2.5.3]) is somewhat special and <a name="iddle1990" class="calibre18" id="iddle1990"></a><a name="iddle2696" class="calibre18" id="iddle2696"></a><a name="iddle4440" class="calibre18" id="iddle4440"></a>offers additional thread-safety guarantees. Static initializers are run by the JVM at class initialization time, after class loading but before the class is used by any thread. Because the JVM acquires a lock during initialization [JLS 12.4.2] and this lock is acquired by each thread at least once to ensure that the class has been loaded, memory writes made during static initialization are automatically visible to all threads. Thus statically initialized objects require no explicit synchronization either during construction or when being referenced. However, this applies only to the <span class="docEmphasis">as-constructed</span> stateif the object is mutable, synchronization is still required by both readers and writers to make subsequent modifications visible and to avoid data corruption.</p>
<a name="ch16list04" class="calibre18" id="ch16list04"></a><h5 id="title-IDAZV5TX" class="docExampleTitle">Listing 16.4. Thread-safe Lazy Initialization.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class SafeLazyInitialization {
    private static Resource resource;

    public  <span class="docEmphStrong">synchronized</span>  static Resource getInstance() {
        if (resource == null)
            resource = new Resource();
        return resource;
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch16list05" class="calibre18" id="ch16list05"></a><h5 id="title-IDAOW5TX" class="docExampleTitle">Listing 16.5. Eager Initialization.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class EagerInitialization {
    private static Resource resource  = <span class="docEmphStrong">new Resource();</span>

    public static Resource getResource() { return resource; }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Using eager initialization, shown in <a class="calibre2" href="#ch16list05">Listing 16.5</a>, eliminates the synchronization cost incurred on each call to <tt class="calibre25">getInstance</tt> in <tt class="calibre25">SafeLazyInitialization</tt>. This technique can be combined with the JVM's lazy class loading to create a lazy initialization technique that does not require synchronization on the common code path. The <span class="docEmphasis">lazy initialization holder class</span> idiom [EJ Item 48] in <a class="calibre2" href="#ch16list06">Listing 16.6</a> uses a class whose only purpose is to initialize the <tt class="calibre25">Resource</tt>. The JVM defers initializing the <tt class="calibre25">ResourceHolder</tt> class until it is actually used [JLS 12.4.1], and because the <tt class="calibre25">Resource</tt> is initialized with a static initializer, no additional synchronization is needed. The first call to <tt class="calibre25">getresource</tt> by any thread causes <tt class="calibre25">ResourceHolder</tt> to be loaded and initialized, at which time the initialization of the <tt class="calibre25">Resource</tt> happens through the static initializer.</p>
<p class="docText1"></p><a name="ch16list06" class="calibre18" id="ch16list06"></a><h5 id="title-IDAJY5TX" class="docExampleTitle">Listing 16.6. Lazy Initialization Holder Class Idiom.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class ResourceFactory {
     private static class <span class="docEmphStrong">ResourceHolder {</span>
         public static Resource resource = new Resource();
     }

     public static Resource getResource() {
         return  <span class="docEmphStrong">ResourceHolder.resource ;</span>
     }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch16lev2sec8" class="calibre18" id="ch16lev2sec8"></a>
<h4 id="title-IDABZ5TX" class="docSection2Title">16.2.4. Double-checked Locking</h4>
<p class="docText1"><a name="iddle1047" class="calibre18" id="iddle1047"></a><a name="iddle1048" class="calibre18" id="iddle1048"></a><a name="iddle1049" class="calibre18" id="iddle1049"></a><a name="iddle1943" class="calibre18" id="iddle1943"></a><a name="iddle1944" class="calibre18" id="iddle1944"></a><a name="iddle1945" class="calibre18" id="iddle1945"></a><a name="iddle1968" class="calibre18" id="iddle1968"></a><a name="iddle2687" class="calibre18" id="iddle2687"></a><a name="iddle2688" class="calibre18" id="iddle2688"></a><a name="iddle2689" class="calibre18" id="iddle2689"></a><a name="iddle2690" class="calibre18" id="iddle2690"></a><a name="iddle2691" class="calibre18" id="iddle2691"></a><a name="iddle2692" class="calibre18" id="iddle2692"></a><a name="iddle2693" class="calibre18" id="iddle2693"></a><a name="iddle2694" class="calibre18" id="iddle2694"></a><a name="iddle2695" class="calibre18" id="iddle2695"></a><a name="iddle2697" class="calibre18" id="iddle2697"></a><a name="iddle2738" class="calibre18" id="iddle2738"></a><a name="iddle2948" class="calibre18" id="iddle2948"></a><a name="iddle3514" class="calibre18" id="iddle3514"></a><a name="iddle3860" class="calibre18" id="iddle3860"></a><a name="iddle3861" class="calibre18" id="iddle3861"></a><a name="iddle3862" class="calibre18" id="iddle3862"></a><a name="iddle3863" class="calibre18" id="iddle3863"></a><a name="iddle4537" class="calibre18" id="iddle4537"></a><a name="iddle4538" class="calibre18" id="iddle4538"></a>No book on concurrency would be complete without a discussion of the infamous double-checked locking (DCL) antipattern, shown in <a class="calibre2" href="#ch16list07">Listing 16.7</a>. In very early JVMs, synchronization, even uncontended synchronization, had a significant performance cost. As a result, many clever (or at least clever-looking) tricks were invented to reduce the impact of synchronizationsome good, some bad, and some ugly. DCL falls into the "ugly" category.</p>
<p class="docText1">Again, because the performance of early JVMs left something to be desired, lazy initialization was often used to avoid potentially unnecessary expensive operations or reduce application startup time. A properly written lazy initialization method requires synchronization. But at the time, synchronization was slow and, more importantly, not completely understood: the exclusion aspects were well enough understood, but the visibility aspects were not.</p>
<p class="docText1">DCL purported to offer the best of both worldslazy initialization without paying the synchronization penalty on the common code path. The way it worked was first to check whether initialization was needed without synchronizing, and if the <tt class="calibre25">resource</tt> reference was not <tt class="calibre25">null</tt>, use it. Otherwise, synchronize and check again if the <tt class="calibre25">Resource</tt> is initialized, ensuring that only one thread actually initializes the shared <tt class="calibre25">Resource</tt>. The common code pathfetching a reference to an already constructed <tt class="calibre25">Resource</tt>doesn't use synchronization. And that's where the problem is: as described in <a class="calibre2" href="#ch16lev2sec5">Section 16.2.1</a>, it is possible for a thread to see a partially constructed <tt class="calibre25">Resource</tt>.</p>
<p class="docText1">The real problem with DCL is the assumption that the worst thing that can happen when reading a shared object reference without synchronization is to erroneously see a stale value (in this case, <tt class="calibre25">null</tt>); in that case the DCL idiom compensates for this risk by trying again with the lock held. But the worst case is actually considerably worseit is possible to see a current value of the reference but stale values for the object's state, meaning that the object could be seen to be in an invalid or incorrect state.</p>
<p class="docText1">Subsequent changes in the JMM (Java 5.0 and later) have enabled DCL to work <span class="docEmphasis">if</span> <tt class="calibre25">resource</tt> is made <tt class="calibre25">volatile</tt>, and the performance impact of this is small since volatile reads are usually only slightly more expensive than nonvolatile reads. <a name="iddle1969" class="calibre18" id="iddle1969"></a><a name="iddle2112" class="calibre18" id="iddle2112"></a><a name="iddle2535" class="calibre18" id="iddle2535"></a><a name="iddle2744" class="calibre18" id="iddle2744"></a><a name="iddle4036" class="calibre18" id="iddle4036"></a>However, this is an idiom whose utility has largely passedthe forces that motivated it (slow uncontended synchronization, slow JVM startup) are no longer in play, making it less effective as an optimization. The lazy initialization holder idiom offers the same benefits and is easier to understand.</p>
<a name="ch16list07" class="calibre18" id="ch16list07"></a><h5 id="title-IDAUIAUX" class="docExampleTitle">Listing 16.7. Double-checked-locking Antipattern. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" id="195131084199" src="face.jpg" class="calibre29"/>
<pre class="calibre30">@NotThreadSafe
public class DoubleCheckedLocking {
    private static Resource resource;

    public static Resource getInstance() {
        if (resource == null) {
            synchronized (DoubleCheckedLocking.class) {
                if (resource == null)
                    resource = new Resource();
            }
        }
        return resource;
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>

<p class="calibre1">Â </p>

</div>

{% endraw %}

