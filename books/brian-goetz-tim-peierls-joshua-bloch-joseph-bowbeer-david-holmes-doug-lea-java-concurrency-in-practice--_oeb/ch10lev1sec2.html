---
layout: page
title: "Java Concurrency in Practice"
prev: ch10lev1sec1.html
next: ch10lev1sec3.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch10lev1sec2" class="calibre18" id="ch10lev1sec2"></a>
<h3 id="title-IDAN5WRH" class="docSection1Title">10.2. Avoiding and Diagnosing Deadlocks</h3>
<p class="docText1">A program that never acquires more than one lock at a time cannot experience lock-ordering deadlock. Of course, this is not always practical, but if you can get away with it, it's a lot less work. If you must acquire multiple locks, lock ordering must be a part of your design: try to minimize the number of potential locking interactions, and follow and document a lock-ordering protocol for locks that may be acquired together.</p>
<p class="docText1">In programs that use fine-grained locking, audit your code for deadlock freedom using a two-part strategy: first, identify where multiple locks could be acquired (try to make this a small set), and then perform a global analysis of all such instances to ensure that lock ordering is consistent across your entire program. Using open calls wherever possible simplifies this analysis substantially. With no non-open calls, finding instances where multiple locks are acquired is fairly easy, either by code review or by automated bytecode or source code analysis.</p>
<a name="ch10lev2sec6" class="calibre18" id="ch10lev2sec6"></a>
<h4 id="title-IDA05WRH" class="docSection2Title">10.2.1. Timed Lock Attempts</h4>
<p class="docText1">Another technique for detecting and recovering from deadlocks is to use the timed <tt class="calibre25">tryLock</tt> feature of the explicit <tt class="calibre25">Lock</tt> classes (see <a class="calibre2" href="ch13.html#ch13">Chapter 13</a>) instead of intrinsic locking. Where intrinsic locks wait forever if they cannot acquire the lock, explicit locks let you specify a timeout after which <tt class="calibre25">tryLock</tt> returns failure. By using a timeout that is much longer than you expect acquiring the lock to take, you can regain control when something unexpected happens. (<a class="calibre2" href="ch13lev1sec1.html#ch13list03">Listing 13.3</a> on page 280 shows an alternative implementation of <tt class="calibre25">transferMoney</tt> using the polled <tt class="calibre25">tryLock</tt> with retries for probabilistic deadlock avoidance.)</p>
<p class="docText1">When a timed lock attempt fails, you do not necessarily know <span class="docEmphasis">why</span>. Maybe there was a deadlock; maybe a thread erroneously entered an infinite loop while <a name="iddle1086" class="calibre18" id="iddle1086"></a><a name="iddle1087" class="calibre18" id="iddle1087"></a><a name="iddle1795" class="calibre18" id="iddle1795"></a><a name="iddle1796" class="calibre18" id="iddle1796"></a><a name="iddle1833" class="calibre18" id="iddle1833"></a><a name="iddle3155" class="calibre18" id="iddle3155"></a><a name="iddle4362" class="calibre18" id="iddle4362"></a><a name="iddle4363" class="calibre18" id="iddle4363"></a><a name="iddle4767" class="calibre18" id="iddle4767"></a><a name="iddle4768" class="calibre18" id="iddle4768"></a><a name="iddle4976" class="calibre18" id="iddle4976"></a>holding that lock; or maybe some activity is just running a lot slower than you expected. Still, at least you have the opportunity to record that your attempt failed, log any useful information about what you were trying to do, and restart the computation somewhat more gracefully than killing the entire process.</p>
<p class="docText1">Using timed lock acquisition to acquire multiple locks can be effective against deadlock even when timed locking is not used consistently throughout the program. If a lock acquisition times out, you can release the locks, back off and wait for a while, and try again, possibly clearing the deadlock condition and allowing the program to recover. (This technique works only when the two locks are acquired together; if multiple locks are acquired due to the nesting of method calls, you cannot just release the outer lock, even if you know you hold it.)</p>
<a name="ch10lev2sec7" class="calibre18" id="ch10lev2sec7"></a>
<h4 id="title-IDABFXRH" class="docSection2Title">10.2.2. Deadlock Analysis with Thread Dumps</h4>
<p class="docText1">While preventing deadlocks is mostly your problem, the JVM can help identify them when they do happen using <span class="docEmphasis">thread dumps</span>. A thread dump includes a stack trace for each running thread, similar to the stack trace that accompanies an exception. Thread dumps also include locking information, such as which locks are held by each thread, in which stack frame they were acquired, and which lock a blocked thread is waiting to acquire.<sup class="docFootnote"><a class="calibre2" href="#ch10fn04">[4]</a></sup> Before generating a thread dump, the JVM searches the is-waiting-for graph for cycles to find deadlocks. If it finds one, it includes deadlock information identifying which locks and threads are involved, and where in the program the offending lock acquisitions are.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch10fn04" class="calibre18" id="ch10fn04">[4]</a></sup> This information is useful for debugging even when you don't have a deadlock; periodically triggering thread dumps lets you observe your program's locking behavior.</p></blockquote>
<p class="docText1">To trigger a thread dump, you can send the JVM process a <tt class="calibre25">SIGQUIT</tt> signal (<tt class="calibre25">kill -3</tt>) on Unix platforms, or press the <tt class="calibre25">Ctrl-\</tt> key on Unix or <tt class="calibre25">Ctrl-Break</tt> on Windows platforms. Many IDEs can request a thread dump as well.</p>
<p class="docText1">If you are using the explicit <tt class="calibre25">Lock</tt> classes instead of intrinsic locking, Java 5.0 has no support for associating <tt class="calibre25">Lock</tt> information with the thread dump; explicit <tt class="calibre25">Lock</tt>s do not show up at all in thread dumps. Java 6 does include thread dump support and deadlock detection with explicit <tt class="calibre25">Lock</tt>s, but the information on where <tt class="calibre25">Lock</tt>s are acquired is necessarily less precise than for intrinsic locks. Intrinsic locks are associated with the stack frame in which they were acquired; explicit <tt class="calibre25">Lock</tt>s are associated only with the acquiring thread.</p>
<p class="docText1"><a class="calibre2" href="#ch10list07">Listing 10.7</a> shows portions of a thread dump taken from a production J2EE application. The failure that caused the deadlock involves three componentsa J2EE application, a J2EE container, and a JDBC driver, each from different vendors. (The names have been changed to protect the guilty.) All three were commercial products that had been through extensive testing cycles; each had a bug that was harmless until they all interacted and caused a fatal server failure.</p>
<p class="docText1">We've shown only the portion of the thread dump relevant to identifying the deadlock. The JVM has done a lot of work for us in diagnosing the deadlockwhich locks are causing the problem, which threads are involved, which other locks they hold, and whether other threads are being indirectly inconvenienced. One thread holds the lock on the <tt class="calibre25">MumbleDBConnection</tt> and is waiting to acquire the lock on the <tt class="calibre25">MumbleDBCallableStatement</tt>; the other holds the lock on the <tt class="calibre25">MumbleDBCallableStatement</tt> and is waiting for the lock on the <tt class="calibre25">MumbleDBConnection</tt>.</p>
<a name="ch10list07" class="calibre18" id="ch10list07"></a><h5 id="title-IDAFHXRH" class="docExampleTitle">Listing 10.7. Portion of Thread Dump After Deadlock.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">Found one Java-level deadlock:
=============================
"ApplicationServerThread":
  waiting to lock monitor 0x080f0cdc (a MumbleDBConnection),
  which is held by "ApplicationServerThread"
"ApplicationServerThread":
  waiting to lock monitor 0x080f0ed4 (a MumbleDBCallableStatement),
  which is held by "ApplicationServerThread"

Java stack information for the threads listed above:
"ApplicationServerThread":
        at MumbleDBConnection.remove_statement
        - waiting to lock &lt;0x650f7f30&gt; (a MumbleDBConnection)
        at MumbleDBStatement.close
        - locked &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement)
     ...

"ApplicationServerThread":
        at MumbleDBCallableStatement.sendBatch
        - waiting to lock &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement)
        at MumbleDBConnection.commit
        - locked &lt;0x650f7f30&gt; (a MumbleDBConnection)
     ...
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">The JDBC driver being used here clearly has a lock-ordering bug: different call chains through the JDBC driver acquire multiple locks in different orders. But this problem would not have manifested itself were it not for another bug: multiple threads were trying to use the same JDBC <tt class="calibre25">Connection</tt> at the same time. This was not how the application was supposed to workthe developers were surprised to see the same <tt class="calibre25">Connection</tt> used concurrently by two threads. There's nothing in the JDBC specification that requires a <tt class="calibre25">Connection</tt> to be thread-safe, and it is common to confine use of a <tt class="calibre25">Connection</tt> to a single thread, as was intended here. This vendor tried to deliver a thread-safe JDBC driver, as evidenced by the synchronization on multiple JDBC objects within the driver code. Unfortunately, because the vendor did not take lock ordering into account, the driver was prone to deadlock, but it was only the interaction of the deadlock-prone driver and the incorrect <tt class="calibre25">Connection</tt> sharing by the application that disclosed the problem. Because neither bug was fatal in isolation, both persisted despite extensive testing.</p>

<p class="calibre1">Â </p>

</div>

{% endraw %}

