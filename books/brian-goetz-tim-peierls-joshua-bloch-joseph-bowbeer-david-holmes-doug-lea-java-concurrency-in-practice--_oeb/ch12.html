---
layout: page
title: "Java Concurrency in Practice"
prev: ch11lev1sec7.html
next: ch12lev1sec1.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch12" class="calibre18" id="ch12"></a>
<div class="calibre32" id="calibre_pb_0"></div><div class="calibre32"></div><h2 id="title-IDAWPKP0" class="docPrefaceTitle">Chapter 12. Testing Concurrent Programs</h2>
<p class="docText1"><a name="iddle1479" class="calibre18" id="iddle1479"></a><a name="iddle1678" class="calibre18" id="iddle1678"></a><a name="iddle2310" class="calibre18" id="iddle2310"></a><a name="iddle2311" class="calibre18" id="iddle2311"></a><a name="iddle2632" class="calibre18" id="iddle2632"></a><a name="iddle3536" class="calibre18" id="iddle3536"></a><a name="iddle3672" class="calibre18" id="iddle3672"></a><a name="iddle3673" class="calibre18" id="iddle3673"></a><a name="iddle4047" class="calibre18" id="iddle4047"></a><a name="iddle4693" class="calibre18" id="iddle4693"></a><a name="iddle4709" class="calibre18" id="iddle4709"></a><a name="iddle4714" class="calibre18" id="iddle4714"></a>Concurrent programs employ similar design principles and patterns to sequential programs. The difference is that concurrent programs have a degree of nondeterminism that sequential programs do not, increasing the number of potential interactions and failure modes that must be planned for and analyzed.</p>
<p class="docText1">Similarly, testing concurrent programs uses and extends ideas from testing sequential ones. The same techniques for testing correctness and performance in sequential programs can be applied to concurrent programs, but with concurrent programs the space of things that can go wrong is much larger. The major challenge in constructing tests for concurrent programs is that potential failures may be rare probabalistic occurrences rather than deterministic ones; tests that disclose such failures must be more extensive and run for longer than typical sequential tests.</p>
<p class="docText1">Most tests of concurrent classes fall into one or both of the classic categories of <span class="docEmphasis">safety</span> and <span class="docEmphasis">liveness</span>. In <a class="calibre2" href="ch01.html#ch01">Chapter 1</a>, we defined safety as "nothing bad ever happens" and liveness as "something good eventually happens".</p>
<p class="docText1">Tests of safety, which verify that a class's behavior conforms to its specification, usually take the form of testing invariants. For example, in a linked list implementation that caches the size of the list every time it is modified, one safety test would be to compare the cached count against the actual number of elements in the list. In a single-threaded program this is easy, since the list contents do not change while you are testing its properties. But in a concurrent program, such a test is likely to be fraught with races unless you can observe the count field and count the elements in a single atomic operation. This can be done by locking the list for exclusive access, employing some sort of "atomic snapshot" feature provided by the implementation, or by using "test points" provided by the implementation that let tests assert invariants or execute test code atomically.</p>
<p class="docText1">In this book, we've used timing diagrams to depict "unlucky" interactions that could cause failures in incorrectly constructed classes; test programs attempt to search enough of the state space that such bad luck eventually occurs. Unfortunately, test code can introduce timing or synchronization artifacts that can mask bugs that might otherwise manifest themselves.<sup class="docFootnote"><a class="calibre2" href="#ch12fn01">[1]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch12fn01" class="calibre18" id="ch12fn01">[1]</a></sup> Bugs that disappear when you add debugging or test code are playfully called <span class="docEmphasis">Heisenbugs</span>.</p></blockquote>
<p class="docText1"><a name="iddle1266" class="calibre18" id="iddle1266"></a><a name="iddle2086" class="calibre18" id="iddle2086"></a><a name="iddle4140" class="calibre18" id="iddle4140"></a><a name="iddle1211" class="calibre18" id="iddle1211"></a><a name="iddle1268" class="calibre18" id="iddle1268"></a><a name="iddle1272" class="calibre18" id="iddle1272"></a><a name="iddle1677" class="calibre18" id="iddle1677"></a><a name="iddle1702" class="calibre18" id="iddle1702"></a><a name="iddle1779" class="calibre18" id="iddle1779"></a><a name="iddle2085" class="calibre18" id="iddle2085"></a><a name="iddle3029" class="calibre18" id="iddle3029"></a><a name="iddle3030" class="calibre18" id="iddle3030"></a><a name="iddle3537" class="calibre18" id="iddle3537"></a><a name="iddle3949" class="calibre18" id="iddle3949"></a><a name="iddle4059" class="calibre18" id="iddle4059"></a><a name="iddle4141" class="calibre18" id="iddle4141"></a><a name="iddle4151" class="calibre18" id="iddle4151"></a><a name="iddle4697" class="calibre18" id="iddle4697"></a><a name="iddle4698" class="calibre18" id="iddle4698"></a><a name="iddle4700" class="calibre18" id="iddle4700"></a><a name="iddle4707" class="calibre18" id="iddle4707"></a><a name="iddle4708" class="calibre18" id="iddle4708"></a><a name="iddle4712" class="calibre18" id="iddle4712"></a><a name="iddle4868" class="calibre18" id="iddle4868"></a><a name="iddle5010" class="calibre18" id="iddle5010"></a>Liveness properties present their own testing challenges. Liveness tests include tests of progress and nonprogress, which are hard to quantifyhow do you verify that a method is blocking and not merely running slowly? Similarly, how do you test that an algorithm does <span class="docEmphasis">not</span> deadlock? How long should you wait before you declare it to have failed?</p>
<p class="docText1">Related to liveness tests are performance tests. Performance can be measured in a number of ways, including:</p>
<p class="docText1"><span class="docEmphStrong">Throughput:</span> the rate at which a set of concurrent tasks is completed;</p>
<p class="docText1"><span class="docEmphStrong">Responsiveness:</span> the delay between a request for and completion of some action (also called <span class="docEmphasis">latency</span>); or</p>
<p class="docText1"><span class="docEmphStrong">Scalability:</span> the improvement in throughput (or lack thereof) as more resources (usually CPUs) are made available.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3">Â </p>

</div>

{% endraw %}

