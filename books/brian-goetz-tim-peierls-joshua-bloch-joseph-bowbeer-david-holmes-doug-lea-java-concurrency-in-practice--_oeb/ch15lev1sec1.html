---
layout: page
title: "Java Concurrency in Practice"
prev: ch15.html
next: ch15lev1sec2.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch15lev1sec1" class="calibre18" id="ch15lev1sec1"></a>
<h3 id="647011-958" class="docSection1Title">15.1. Disadvantages of Locking</h3>
<p class="docText1">Coordinating access to shared state using a consistent locking protocol ensures that whichever thread holds the lock guarding a set of variables has exclusive <a name="iddle1589" class="calibre18" id="iddle1589"></a><a name="iddle1590" class="calibre18" id="iddle1590"></a><a name="iddle2917" class="calibre18" id="iddle2917"></a><a name="iddle3657" class="calibre18" id="iddle3657"></a><a name="iddle3658" class="calibre18" id="iddle3658"></a><a name="iddle3691" class="calibre18" id="iddle3691"></a><a name="iddle4512" class="calibre18" id="iddle4512"></a><a name="iddle4827" class="calibre18" id="iddle4827"></a><a name="iddle5126" class="calibre18" id="iddle5126"></a>access to those variables, and that any changes made to those variables are visible to other threads that subsequently acquire the lock.</p>
<p class="docText1">Modern JVMs can optimize uncontended lock acquisition and release fairly effectively, but if multiple threads request the lock at the same time the JVM enlists the help of the operating system. If it gets to this point, some unfortunate thread will be suspended and have to be resumed later.<sup class="docFootnote"><a class="calibre2" href="#ch15fn01">[1]</a></sup> When that thread is resumed, it may have to wait for other threads to finish their scheduling quanta before it is actually scheduled. Suspending and resuming a thread has a lot of overhead and generally entails a lengthy interruption. For lock-based classes with fine-grained operations (such as the synchronized collections classes, where most methods contain only a few operations), the ratio of scheduling overhead to useful work can be quite high <span class="docEmphasis">when the lock is frequently contended</span>.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch15fn01" class="calibre18" id="ch15fn01">[1]</a></sup> A smart JVM need not necessarily suspend a thread if it contends for a lock; it could use profiling data to decide adaptively between suspension and spin locking based on how long the lock has been held during previous acquisitions.</p></blockquote>
<p class="docText1">Volatile variables are a lighter-weight synchronization mechanism than locking because they do not involve context switches or thread scheduling. However, volatile variables have some limitations compared to locking: while they provide similar visibility guarantees, they cannot be used to construct atomic compound actions. This means that volatile variables cannot be used when one variable depends on another, or when the new value of a variable depends on its old value. This limits when volatile variables are appropriate, since they cannot be used to reliably implement common tools such as counters or mutexes.<sup class="docFootnote"><a class="calibre2" href="#ch15fn02">[2]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch15fn02" class="calibre18" id="ch15fn02">[2]</a></sup> It is theoretically possible, though wholly impractical, to use the semantics of <tt class="calibre35">volatile</tt> to construct mutexes and other synchronizers; see (<a class="calibre2" href="bib01.html#biblio01_029">Raynal, 1986</a>).</p></blockquote>
<p class="docText1">For example, while the increment operation (<tt class="calibre25">++i</tt>) may <span class="docEmphasis">look</span> like an atomic operation, it is actually three distinct operationsfetch the current value of the variable, add one to it, and then write the updated value back. In order to not lose an update, the entire read-modify-write operation must be atomic. So far, the only way we've seen to do this is with locking, as in <tt class="calibre25">Counter</tt> on page <a class="calibre2" href="ch04lev1sec1.html#ch04list01">56</a>.</p>
<p class="docText1"><tt class="calibre25">Counter</tt> is thread-safe, and in the presence of little or no contention performs just fine. But under contention, performance suffers because of context-switch overhead and scheduling delays. When locks are held so briefly, being put to sleep is a harsh penalty for asking for the lock at the wrong time.</p>
<p class="docText1">Locking has a few other disadvantages. When a thread is waiting for a lock, it cannot do anything else. If a thread holding a lock is delayed (due to a page fault, scheduling delay, or the like), then no thread that needs that lock can make progress. This can be a serious problem if the blocked thread is a high-priority thread but the thread holding the lock is a lower-priority threada performance hazard known as <span class="docEmphasis">priority inversion</span>. Even though the higher-priority thread should have precedence, it must wait until the lock is released, and this effectively downgrades its priority to that of the lower-priority thread. If a thread holding a lock is permanently blocked (due to an infinite loop, deadlock, livelock, or other liveness failure), any threads waiting for that lock can never make progress.</p>
<p class="docText1">Even ignoring these hazards, locking is simply a heavyweight mechanism for fine-grained operations such as incrementing a counter. It would be nice to have a finer-grained technique for managing contention between threadssomething <a name="iddle1321" class="calibre18" id="iddle1321"></a><a name="iddle1389" class="calibre18" id="iddle1389"></a><a name="iddle1605" class="calibre18" id="iddle1605"></a><a name="iddle1606" class="calibre18" id="iddle1606"></a><a name="iddle2617" class="calibre18" id="iddle2617"></a><a name="iddle3096" class="calibre18" id="iddle3096"></a><a name="iddle4513" class="calibre18" id="iddle4513"></a>like volatile variables, but offering the possibility of atomic updates as well. Happily, modern processors offer us precisely such a mechanism.</p>

<p class="calibre1">Â </p>

</div>

{% endraw %}

