---
layout: page
title: "Java Concurrency in Practice"
prev: ch09.html
next: ch09lev1sec2.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch09lev1sec1" class="calibre18" id="ch09lev1sec1"></a>
<h3 id="title-IDANGUMZ" class="docSection1Title">9.1. Why are GUIs Single-threaded?</h3>
<p class="docText1">In the old days, GUI applications were single-threaded and GUI events were processed from a "main event loop". Modern GUI frameworks use a model that is only slightly different: they create a dedicated <span class="docEmphasis">event dispatch thread</span> (EDT) for handling GUI events.</p>
<p class="docText1">Single-threaded GUI frameworks are not unique to Java; Qt, NextStep, MacOS Cocoa, X Windows, and many others are also single-threaded. This is not for lack of trying; there have been many attempts to write multithreaded GUI frameworks, but because of persistent problems with race conditions and deadlock, they all eventually arrived at the single-threaded event queue model in which a dedicated thread fetches events off a queue and dispatches them to applicationdefined event handlers. (AWT originally tried to support a greater degree of multithreaded access, and the decision to make Swing single-threaded was based largely on experience with AWT.)</p>
<p class="docText1"><a name="iddle1545" class="calibre18" id="iddle1545"></a><a name="iddle1630" class="calibre18" id="iddle1630"></a><a name="iddle1631" class="calibre18" id="iddle1631"></a><a name="iddle1644" class="calibre18" id="iddle1644"></a><a name="iddle1645" class="calibre18" id="iddle1645"></a><a name="iddle1807" class="calibre18" id="iddle1807"></a><a name="iddle2998" class="calibre18" id="iddle2998"></a><a name="iddle2999" class="calibre18" id="iddle2999"></a><a name="iddle3127" class="calibre18" id="iddle3127"></a><a name="iddle3225" class="calibre18" id="iddle3225"></a><a name="iddle3226" class="calibre18" id="iddle3226"></a><a name="iddle3287" class="calibre18" id="iddle3287"></a><a name="iddle3288" class="calibre18" id="iddle3288"></a><a name="iddle3408" class="calibre18" id="iddle3408"></a><a name="iddle4753" class="calibre18" id="iddle4753"></a><a name="iddle5087" class="calibre18" id="iddle5087"></a><a name="iddle5088" class="calibre18" id="iddle5088"></a>Multithreaded GUI frameworks tend to be particularly susceptible to deadlock, partially because of the unfortunate interaction between input event processing and any sensible object-oriented modeling of GUI components. Actions initiated by the user tend to "bubble up" from the OS to the applicationa mouse click is detected by the OS, is turned into a "mouse click" event by the toolkit, and is eventually delivered to an application listener as a higher level event such as a "button pressed" event. On the other hand, application-initiated actions "bubble down" from the application to the OSchanging the background color of a component originates in the application and is dispatched to a specific component class and eventually into the OS for rendering. Combining this tendency for activities to access the same GUI objects in the opposite order with the requirement of making each object thread-safe yields a recipe for inconsistent lock ordering, which leads to deadlock (see <a class="calibre2" href="ch10.html#ch10">Chapter 10</a>). And this is exactly what nearly every GUI toolkit development effort rediscovered through experience.</p>
<p class="docText1">Another factor leading to deadlock in multithreaded GUI frameworks is the prevalence of the model-view-control (MVC) pattern. Factoring user interactions into cooperating model, view, and controller objects greatly simplifies implementing GUI applications, but again raises the risk of inconsistent lock ordering. The controller calls into the model, which notifies the view that something has changed. But the controller can also call into the view, which may in turn call back into the model to query the model state. The result is again inconsistent lock ordering, with the attendant risk of deadlock.</p>
<p class="docText1">In his weblog,<sup class="docFootnote"><a class="calibre2" href="#ch09fn01">[1]</a></sup> Sun VP Graham Hamilton nicely sums up the challenges, describing why the multithreaded GUI toolkit is one of the recurring "failed dreams" of computer science.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch09fn01" class="calibre18" id="ch09fn01">[1]</a></sup> <tt class="calibre35"><a class="calibre2" target="_blank" href="http://weblogs.java.net/blog/kgh/archive/2004/10">http://weblogs.java.net/blog/kgh/archive/2004/10</a></tt></p></blockquote>
<blockquote class="calibre19">
<p class="docText1">I believe you can program successfully with multithreaded GUI toolkits if the toolkit is very carefully designed; if the toolkit exposes its locking methodology in gory detail; if you are very smart, very careful, and have a global understanding of the whole structure of the toolkit. If you get one of these things slightly wrong, things will mostly work, but you will get occasional hangs (due to deadlocks) or glitches (due to races). This multithreaded approach works best for people who have been intimately involved in the design of the toolkit.</p>
<p class="docText1">Unfortunately, I don't think this set of characteristics scales to widespread commercial use. What you tend to end up with is normal smart programmers building apps that don't quite work reliably for reasons that are not at all obvious. So the authors get very disgruntled and frustrated and use bad words on the poor innocent toolkit.</p>
</blockquote>
<p class="docText1">Single-threaded GUI frameworks achieve thread safety via thread confinement; all GUI objects, including visual components and data models, are accessed exclusively from the event thread. Of course, this just pushes some of the thread safety burden back onto the application developer, who must make sure these objects are properly confined.</p>
<a name="ch09lev2sec1" class="calibre18" id="ch09lev2sec1"></a>
<h4 id="title-IDA5NUMZ" class="docSection2Title">9.1.1. Sequential Event Processing</h4>
<p class="docText1"><a name="iddle1179" class="calibre18" id="iddle1179"></a><a name="iddle1541" class="calibre18" id="iddle1541"></a><a name="iddle1621" class="calibre18" id="iddle1621"></a><a name="iddle1622" class="calibre18" id="iddle1622"></a><a name="iddle1623" class="calibre18" id="iddle1623"></a><a name="iddle2059" class="calibre18" id="iddle2059"></a><a name="iddle2072" class="calibre18" id="iddle2072"></a><a name="iddle2073" class="calibre18" id="iddle2073"></a><a name="iddle2187" class="calibre18" id="iddle2187"></a><a name="iddle2256" class="calibre18" id="iddle2256"></a><a name="iddle2335" class="calibre18" id="iddle2335"></a><a name="iddle2483" class="calibre18" id="iddle2483"></a><a name="iddle2484" class="calibre18" id="iddle2484"></a><a name="iddle2485" class="calibre18" id="iddle2485"></a><a name="iddle2996" class="calibre18" id="iddle2996"></a><a name="iddle3365" class="calibre18" id="iddle3365"></a><a name="iddle3366" class="calibre18" id="iddle3366"></a><a name="iddle3528" class="calibre18" id="iddle3528"></a><a name="iddle3652" class="calibre18" id="iddle3652"></a><a name="iddle3699" class="calibre18" id="iddle3699"></a><a name="iddle3801" class="calibre18" id="iddle3801"></a><a name="iddle3802" class="calibre18" id="iddle3802"></a><a name="iddle4161" class="calibre18" id="iddle4161"></a><a name="iddle4162" class="calibre18" id="iddle4162"></a><a name="iddle4519" class="calibre18" id="iddle4519"></a><a name="iddle4522" class="calibre18" id="iddle4522"></a><a name="iddle4523" class="calibre18" id="iddle4523"></a><a name="iddle4526" class="calibre18" id="iddle4526"></a><a name="iddle4754" class="calibre18" id="iddle4754"></a><a name="iddle4954" class="calibre18" id="iddle4954"></a><a name="iddle5023" class="calibre18" id="iddle5023"></a>GUI applications are oriented around processing fine-grained <span class="docEmphasis">events</span> such as mouse clicks, key presses, or timer expirations. Events are a kind of task; the event handling machinery provided by AWT and Swing is structurally similar to an <tt class="calibre25">Executor</tt>.</p>
<p class="docText1">Because there is only a single thread for processing GUI tasks, they are processed sequentiallyone task finishes before the next one begins, and no two tasks overlap. Knowing this makes writing task code easieryou don't have to worry about interference from other tasks.</p>
<p class="docText1">The downside of sequential task processing is that if one task takes a long time to execute, other tasks must wait until it is finished. If those other tasks are responsible for responding to user input or providing visual feedback, the application will appear to have frozen. If a lengthy task is running in the event thread, the user cannot even click "Cancel" because the cancel button listener is not called until the lengthy task completes. Therefore, tasks that execute in the event thread must return control to the event thread quickly. To initiate a longrunning task such as spell-checking a large document, searching the file system, or fetching a resource over a network, you must run that task in another thread so control can return quickly to the event thread. To update a progress indicator while a long-running task executes or provide visual feedback when it completes, you again need to execute code in the event thread. This can get complicated quickly.</p>
<a name="ch09lev2sec2" class="calibre18" id="ch09lev2sec2"></a>
<h4 id="title-IDABNVMZ" class="docSection2Title">9.1.2. Thread Confinement in Swing</h4>
<p class="docText1">All Swing components (such as <tt class="calibre25">JButton</tt> and <tt class="calibre25">JTable</tt>) and data model objects (such as <tt class="calibre25">TableModel</tt> and <tt class="calibre25">TReeModel</tt>) are confined to the event thread, so any code that accesses these objects must run in the event thread. GUI objects are kept consistent not by synchronization, but by thread confinement. The upside is that tasks that run in the event thread need not worry about synchronization when accessing presentation objects; the downside is that you cannot access presentation objects from outside the event thread at all.</p>
<a name="ch09sb01" class="calibre18" id="ch09sb01"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">The <span class="docEmphasis">Swing single-thread rule</span>: Swing components and models should be created, modified, and queried only from the event-dispatching thread.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">As with all rules, there are a few exceptions. A small number of Swing methods may be called safely from any thread; these are clearly identified in the Javadoc as being thread-safe. Other exceptions to the single-thread rule include:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1"><tt class="calibre25">SwingUtilities</tt>.<tt class="calibre25">isEventDispatchThread</tt>, which determines whether the current thread is the event thread;</p></li><li class="calibre16"><p class="docText1"><tt class="calibre25">SwingUtilities</tt>.<tt class="calibre25">invokeLater</tt>, which schedules a <tt class="calibre25">Runnable</tt> for execution on the event thread (callable from any thread);</p></li><li class="calibre16"><p class="docText1"><a name="iddle2189" class="calibre18" id="iddle2189"></a><a name="iddle2119" class="calibre18" id="iddle2119"></a><a name="iddle2188" class="calibre18" id="iddle2188"></a><a name="iddle2257" class="calibre18" id="iddle2257"></a><a name="iddle4520" class="calibre18" id="iddle4520"></a><a name="iddle4521" class="calibre18" id="iddle4521"></a><a name="iddle4627" class="calibre18" id="iddle4627"></a><a name="iddle4924" class="calibre18" id="iddle4924"></a><tt class="calibre25">SwingUtilities</tt>.<tt class="calibre25">invokeAndWait</tt>, which schedules a <tt class="calibre25">Runnable</tt> task for execution on the event thread and blocks the current thread until it completes (callable <span class="docEmphasis">only</span> from a non-GUI thread);</p></li><li class="calibre16"><p class="docText1">methods to enqueue a repaint or revalidation request on the event queue (callable from any thread); and</p></li><li class="calibre16"><p class="docText1">methods for adding and removing listeners (can be called from any thread, but listeners will always be invoked in the event thread).</p></li></ul>
<p class="docText1">The <tt class="calibre25">invokeLater</tt> and <tt class="calibre25">invokeAndWait</tt> methods function a lot like an <tt class="calibre25">Executor</tt>. In fact, it is trivial to implement the threading-related methods from <tt class="calibre25">SwingUtilities</tt> using a single-threaded <tt class="calibre25">Executor</tt>, as shown in <a class="calibre2" href="ch09lev1sec2.html#ch09list01">Listing 9.1</a>. This is not how <tt class="calibre25">SwingUtilities</tt> is actually implemented, as Swing predates the <tt class="calibre25">Executor</tt> framework, but is probably how it would be if Swing were being implemented today.</p>
<p class="docText1">The Swing event thread can be thought of as a single-threaded <tt class="calibre25">Executor</tt> that processes tasks from the event queue. As with thread pools, sometimes the worker thread dies and is replaced by a new one, but this should be transparent to tasks. Sequential, single-threaded execution is a sensible execution policy when tasks are short-lived, scheduling predictability is not important, or it is imperative that tasks not execute concurrently.</p>
<p class="docText1"><tt class="calibre25">GuiExecutor</tt> in <a class="calibre2" href="ch09lev1sec2.html#ch09list02">Listing 9.2</a> is an <tt class="calibre25">Executor</tt> that delegates tasks to <tt class="calibre25">SwingUtilities</tt> for execution. It could be implemented in terms of other GUI frameworks as well; for example, SWT provides the <tt class="calibre25">Display.asyncExec</tt> method, which is similar to Swing's <tt class="calibre25">invokeLater</tt>.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

