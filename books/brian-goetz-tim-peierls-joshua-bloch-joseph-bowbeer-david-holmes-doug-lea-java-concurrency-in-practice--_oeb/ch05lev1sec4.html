---
layout: page
title: "Java Concurrency in Practice"
prev: ch05lev1sec3.html
next: ch05lev1sec5.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch05lev1sec4" class="calibre18" id="ch05lev1sec4"></a>
<h3 id="title-IDAZOJNZ" class="docSection1Title">5.4. Blocking and Interruptible Methods</h3>
<p class="docText1">Threads may <span class="docEmphasis">block</span>, or pause, for several reasons: waiting for I/O completion, waiting to acquire a lock, waiting to wake up from <tt class="calibre25">Thread.sleep</tt>, or waiting for the result of a computation in another thread. When a thread blocks, it is usually suspended and placed in one of the blocked thread states (<tt class="calibre25">BLOCKED</tt>, <tt class="calibre25">WAITING</tt>, or <a name="iddle1641" class="calibre18" id="iddle1641"></a><a name="iddle1642" class="calibre18" id="iddle1642"></a><a name="iddle1929" class="calibre18" id="iddle1929"></a><a name="iddle1930" class="calibre18" id="iddle1930"></a><a name="iddle2787" class="calibre18" id="iddle2787"></a><a name="iddle2790" class="calibre18" id="iddle2790"></a><a name="iddle2791" class="calibre18" id="iddle2791"></a><a name="iddle2792" class="calibre18" id="iddle2792"></a><a name="iddle2793" class="calibre18" id="iddle2793"></a><a name="iddle2794" class="calibre18" id="iddle2794"></a><a name="iddle2795" class="calibre18" id="iddle2795"></a><a name="iddle2816" class="calibre18" id="iddle2816"></a><a name="iddle2817" class="calibre18" id="iddle2817"></a><a name="iddle4125" class="calibre18" id="iddle4125"></a><a name="iddle4327" class="calibre18" id="iddle4327"></a><a name="iddle4328" class="calibre18" id="iddle4328"></a><a name="iddle4329" class="calibre18" id="iddle4329"></a><a name="iddle4330" class="calibre18" id="iddle4330"></a><a name="iddle4463" class="calibre18" id="iddle4463"></a><a name="iddle4464" class="calibre18" id="iddle4464"></a><a name="iddle4469" class="calibre18" id="iddle4469"></a><a name="iddle4515" class="calibre18" id="iddle4515"></a><a name="iddle4516" class="calibre18" id="iddle4516"></a><a name="iddle4974" class="calibre18" id="iddle4974"></a><tt class="calibre25">TIMED_WAITING</tt>). The distinction between a blocking operation and an ordinary operation that merely takes a long time to finish is that a blocked thread must wait for an event that is beyond its control before it can proceedthe I/O completes, the lock becomes available, or the external computation finishes. When that external event occurs, the thread is placed back in the <tt class="calibre25">RUNNABLE</tt> state and becomes eligible again for scheduling.</p>
<p class="docText1">The <tt class="calibre25">put</tt> and <tt class="calibre25">take</tt> methods of <tt class="calibre25">BlockingQueue</tt> throw the checked <tt class="calibre25">InterruptedException</tt>, as do a number of other library methods such as <tt class="calibre25">Thread.sleep</tt>. When a method can throw <tt class="calibre25">InterruptedException</tt>, it is telling you that it is a blocking method, and further that if it is <span class="docEmphasis">interrupted</span>, it will make an effort to stop blocking early.</p>
<p class="docText1"><tt class="calibre25">Thread</tt> provides the <tt class="calibre25">interrupt</tt> method for interrupting a thread and for querying whether a thread has been interrupted. Each thread has a boolean property that represents its interrupted status; interrupting a thread sets this status.</p>
<p class="docText1">Interruption is a <span class="docEmphasis">cooperative</span> mechanism. One thread cannot force another to stop what it is doing and do something else; when thread <span class="docEmphasis">A</span> interrupts thread <span class="docEmphasis">B</span>, <span class="docEmphasis">A</span> is merely requesting that <span class="docEmphasis">B</span> stop what it is doing when it gets to a convenient stopping pointif it feels like it. While there is nothing in the API or language specification that demands any specific application-level semantics for interruption, the most sensible use for interruption is to cancel an activity. Blocking methods that are responsive to interruption make it easier to cancel long-running activities on a timely basis.</p>
<p class="docText1">When your code calls a method that throws <tt class="calibre25">InterruptedException</tt>, then your method is a blocking method too, and must have a plan for responding to interruption. For library code, there are basically two choices:</p>
<p class="docText1"><span class="docEmphStrong">Propagate the InterruptedException.</span> This is often the most sensible policy if you can get away with itjust propagate the <tt class="calibre25">InterruptedException</tt> to your caller. This could involve not catching <tt class="calibre25">InterruptedException</tt>, or catching it and throwing it again after performing some brief activity-specific cleanup.</p>
<p class="docText1"><span class="docEmphStrong">Restore the interrupt.</span> Sometimes you cannot throw <tt class="calibre25">InterruptedException</tt>, for instance when your code is part of a <tt class="calibre25">Runnable</tt>. In these situations, you must catch <tt class="calibre25">InterruptedException</tt> and restore the interrupted status by calling <tt class="calibre25">interrupt</tt> on the current thread, so that code higher up the call stack can see that an interrupt was issued, as demonstrated in <a class="calibre2" href="#ch05list10">Listing 5.10</a>.</p>
<p class="docText1">You can get much more sophisticated with interruption, but these two approaches should work in the vast majority of situations. But there is one thing you should <span class="docEmphasis">not</span> do with <tt class="calibre25">InterruptedException</tt>catch it and do nothing in response. This deprives code higher up on the call stack of the opportunity to act on the interruption, because the evidence that the thread was interrupted is lost. <span class="docEmphasis">The only situation in which it is acceptable to swallow an interrupt is when you are extending Thread and therefore control all the code higher up on the call stack.</span> Cancellation and interruption are covered in greater detail in <a class="calibre2" href="ch07.html#ch07">Chapter 7</a>.</p>
<p class="docText1"></p><a name="ch05list10" class="calibre18" id="ch05list10"></a><h5 id="title-IDAS3JNZ" class="docExampleTitle">Listing 5.10. Restoring the Interrupted Status so as Not to Swallow the Interrupt.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class TaskRunnable implements Runnable {
    BlockingQueue&lt;Task&gt; queue;
    ...
    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
             <span class="docEmphasis">// restore interrupted status</span>
<span class="docEmphStrong">Thread.currentThread().interrupt();</span>
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3">Â </p>

</div>

{% endraw %}

