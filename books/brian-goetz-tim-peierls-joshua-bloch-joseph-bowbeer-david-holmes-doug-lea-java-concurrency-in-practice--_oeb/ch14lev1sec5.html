---
layout: page
title: "Java Concurrency in Practice"
prev: ch14lev1sec4.html
next: ch14lev1sec6.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch14lev1sec5" class="calibre18" id="ch14lev1sec5"></a>
<h3 id="title-IDAOXBEV" class="docSection1Title">14.5. AbstractQueuedSynchronizer</h3>
<p class="docText1">Most developers will probably never use AQS directly; the standard set of synchronizers covers a fairly wide range of situations. But seeing how the standard synchronizers are implemented can help clarify how they work.</p>
<p class="docText1">The basic operations that an AQS-based synchronizer performs are some variants of <span class="docEmphasis">acquire</span> and <span class="docEmphasis">release</span>. Acquisition is the state-dependent operation and can always block. With a lock or semaphore, the meaning of acquire is straightforwardacquire the lock or a permitand the caller may have to wait until the synchronizer is in a state where that can happen. With <tt class="calibre25">CountDownLatch</tt>, acquire means "wait until the latch has reached its terminal state", and with <tt class="calibre25">FutureTask</tt>, it means "wait until the task has completed". Release is not a blocking operation; a release may allow threads blocked in acquire to proceed.</p>
<p class="docText1">For a class to be state-dependent, it must have some state. AQS takes on the task of managing some of the state for the synchronizer class: it manages a single integer of state information that can be manipulated through the protected <tt class="calibre25">getState</tt>, <tt class="calibre25">setState</tt>, and <tt class="calibre25">compareAndSetState</tt> methods. This can be used to represent arbitrary state; for example, <tt class="calibre25">ReentrantLock</tt> uses it to represent the count of times the owning thread has acquired the lock, <tt class="calibre25">Semaphore</tt> uses it to represent the number of permits remaining, and <tt class="calibre25">FutureTask</tt> uses it to represent the state of the task (not yet started, running, completed, cancelled). Synchronizers can also manage additional state variables themselves; for example, <tt class="calibre25">ReentrantLock</tt> keeps track of the current lock owner so it can distinguish between reentrant and contended lock-acquisition requests.</p>
<p class="docText1">Acquisition and release in AQS take the forms shown in <a class="calibre2" href="#ch14list13">Listing 14.13</a>. Depending on the synchronizer, acquisition might be <span class="docEmphasis">exclusive</span>, as with <tt class="calibre25">Reentrant-Lock</tt>, or <span class="docEmphasis">nonexclusive</span>, as with <tt class="calibre25">Semaphore</tt> and <tt class="calibre25">CountDownLatch</tt>. An acquire operation has two parts. First, the synchronizer decides whether the current state permits acquisition; if so, the thread is allowed to proceed, and if not, the acquire blocks or fails. This decision is determined by the synchronizer semantics; for example, acquiring a lock can succeed if the lock is unheld, and acquiring a latch can succeed if the latch is in its terminal state.</p>
<p class="docText1"><a name="iddle1504" class="calibre18" id="iddle1504"></a>The second part involves possibly updating the synchronizer state; one thread acquiring the synchronizer can affect whether other threads can acquire it. For example, acquiring a lock changes the lock state from "unheld" to "held", and acquiring a permit from a <tt class="calibre25">Semaphore</tt> reduces the number of permits left. On the other hand, the acquisition of a latch by one thread does not affect whether other threads can acquire it, so acquiring a latch does not change its state.</p>
<a name="ch14list13" class="calibre18" id="ch14list13"></a><h5 id="title-IDA5ZBEV" class="docExampleTitle">Listing 14.13. Canonical Forms for Acquisition and Release in AQS.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">boolean acquire() throws InterruptedException {
    while (state does not permit acquire) {
        if (blocking acquisition requested) {
            enqueue current thread if not already queued
            block current thread
        }
        else
            return failure
    }
    possibly update synchronization state
    dequeue thread if it was queued
    return success
}

void release() {
    update synchronization state
    if (new state may permit a blocked thread to acquire)
        unblock one or more queued threads
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">A synchronizer supporting exclusive acquisition should implement the protected methods <tt class="calibre25">TRyAcquire</tt>, <tt class="calibre25">TRyRelease</tt>, and <tt class="calibre25">isHeldExclusively</tt>, and those supporting shared acquisition should implement <tt class="calibre25">tryAcquireShared</tt> and <tt class="calibre25">TRyReleaseShared</tt>. The <tt class="calibre25">acquire</tt>, <tt class="calibre25">acquireShared</tt>, <tt class="calibre25">release</tt>, and <tt class="calibre25">releaseShared</tt> methods in AQS call the <tt class="calibre25">TRy</tt> forms of these methods in the synchronizer subclass to determine if the operation can proceed. The synchronizer subclass can use <tt class="calibre25">getState</tt>, <tt class="calibre25">setState</tt>, and <tt class="calibre25">compareAndSetState</tt> to examine and update the state according to its acquire and release semantics, and informs the base class through the return status whether the attempt to acquire or release the synchronizer was successful. For example, returning a negative value from <tt class="calibre25">TRyAcquireShared</tt> indicates acquisition failure; returning zero indicates the synchronizer was acquired exclusively; and returning a positive value indicates the synchronizer was acquired nonexclusively. The <tt class="calibre25">TRyRelease</tt> and <tt class="calibre25">TRyReleaseShared</tt> methods should return <tt class="calibre25">true</tt> if the release may have unblocked threads attempting to acquire the synchronizer.</p>
<p class="docText1">To simplify implementation of locks that support condition queues (like <tt class="calibre25">ReentrantLock</tt>), AQS also provides machinery for constructing condition variables <a name="iddle1203" class="calibre18" id="iddle1203"></a><a name="iddle2148" class="calibre18" id="iddle2148"></a><a name="iddle2939" class="calibre18" id="iddle2939"></a>associated with synchronizers.</p>
<a name="ch14lev2sec12" class="calibre18" id="ch14lev2sec12"></a>
<h4 id="title-IDA12BEV" class="docSection2Title">14.5.1. A Simple Latch</h4>
<p class="docText1"><tt class="calibre25">OneShotLatch</tt> in <a class="calibre2" href="#ch14list14">Listing 14.14</a> is a binary latch implemented using AQS. It has two public methods, <tt class="calibre25">await</tt> and <tt class="calibre25">signal</tt>, that correspond to acquisition and release. Initially, the latch is closed; any thread calling <tt class="calibre25">await</tt> blocks until the latch is opened. Once the latch is opened by a call to <tt class="calibre25">signal</tt>, waiting threads are released and threads that subsequently arrive at the latch will be allowed to proceed.</p>
<a name="ch14list14" class="calibre18" id="ch14list14"></a><h5 id="title-IDAY3BEV" class="docExampleTitle">Listing 14.14. Binary Latch Using <tt class="calibre33">AbstractQueuedSynchronizer</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class OneShotLatch {
    private final Sync sync = new Sync();

    public void signal() { sync.releaseShared(0); }

    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(0);
    }

    private class Sync extends AbstractQueuedSynchronizer {
        protected int tryAcquireShared(int ignored) {
            <span class="docEmphasis">// Succeed if latch is open (state == 1), else fail</span>
            return (getState() == 1) ? 1 : -1;
        }

        protected boolean tryReleaseShared(int ignored) {
            setState(1);  <span class="docEmphasis">// Latch is now open</span>
            return true;  <span class="docEmphasis">// Other threads may now be able to acquire</span>

        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">In <tt class="calibre25">OneShotLatch</tt>, the AQS state holds the latch stateclosed (zero) or open (one). The <tt class="calibre25">await</tt> method calls <tt class="calibre25">acquireSharedInterruptibly</tt> in AQS, which in turn consults the <tt class="calibre25">TRyAcquireShared</tt> method in <tt class="calibre25">OneShotLatch</tt>. The <tt class="calibre25">tryAcquire-Shared</tt> implementation must return a value indicating whether or not acquisition can proceed. If the latch has been previously opened, <tt class="calibre25">tryAcquireShared</tt> returns success, allowing the thread to pass; otherwise it returns a value indicating that the acquisition attempt failed. The <tt class="calibre25">acquireSharedInterruptibly</tt> method interprets failure to mean that the thread should be placed on the queue of waiting threads. Similarly, <tt class="calibre25">signal</tt> calls <tt class="calibre25">releaseShared</tt>, which causes <tt class="calibre25">tryReleaseShared</tt> to be consulted. The <tt class="calibre25">TRyReleaseShared</tt> implementation unconditionally sets the latch state to open and indicates (through its return value) that the synchronizer <a name="iddle1858" class="calibre18" id="iddle1858"></a><a name="iddle1859" class="calibre18" id="iddle1859"></a><a name="iddle1989" class="calibre18" id="iddle1989"></a><a name="iddle3811" class="calibre18" id="iddle3811"></a><a name="iddle3812" class="calibre18" id="iddle3812"></a>is in a fully released state. This causes AQS to let all waiting threads attempt to reacquire the synchronizer, and acquisition will now succeed because <tt class="calibre25">tryAcquireShared</tt> returns success.</p>
<p class="docText1"><tt class="calibre25">OneShotLatch</tt> is a fully functional, usable, performant synchronizer, implemented in only twenty or so lines of code. Of course, it is missing some useful featuressuch as timed acquisition or the ability to inspect the latch statebut these are easy to implement as well, since AQS provides timed versions of the acquisition methods and utility methods for common inspection operations.</p>
<p class="docText1"><tt class="calibre25">OneShotLatch</tt> could have been implemented by extending AQS rather than delegating to it, but this is undesirable for several reasons [EJ Item 14]. Doing so would undermine the simple (two-method) interface of <tt class="calibre25">OneShotLatch</tt>, and while the public methods of AQS won't allow callers to corrupt the latch state, callers could easily use them incorrectly. None of the synchronizers in <tt class="calibre25">java.util.concurrent</tt> extends AQS directlythey all delegate to private inner subclasses of AQS instead.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

