---
layout: page
title: "Java Concurrency in Practice"
prev: ch07.html
next: ch07lev1sec2.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch07lev1sec1" class="calibre18" id="ch07lev1sec1"></a>
<h3 id="title-IDALKTSY" class="docSection1Title">7.1. Task Cancellation</h3>
<p class="docText1">An activity is <span class="docEmphasis">cancellable</span> if external code can move it to completion before its normal completion. There are a number of reasons why you might want to cancel an activity:</p>
<blockquote class="calibre19"><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">User-requested cancellation.</span> <a name="iddle1114" class="calibre18" id="iddle1114"></a><a name="iddle1115" class="calibre18" id="iddle1115"></a><a name="iddle1310" class="calibre18" id="iddle1310"></a><a name="iddle1313" class="calibre18" id="iddle1313"></a><a name="iddle2041" class="calibre18" id="iddle2041"></a><a name="iddle2042" class="calibre18" id="iddle2042"></a><a name="iddle2060" class="calibre18" id="iddle2060"></a><a name="iddle2221" class="calibre18" id="iddle2221"></a><a name="iddle2222" class="calibre18" id="iddle2222"></a><a name="iddle2223" class="calibre18" id="iddle2223"></a><a name="iddle2276" class="calibre18" id="iddle2276"></a><a name="iddle2277" class="calibre18" id="iddle2277"></a><a name="iddle2278" class="calibre18" id="iddle2278"></a><a name="iddle2301" class="calibre18" id="iddle2301"></a><a name="iddle2302" class="calibre18" id="iddle2302"></a><a name="iddle2303" class="calibre18" id="iddle2303"></a><a name="iddle2304" class="calibre18" id="iddle2304"></a><a name="iddle2369" class="calibre18" id="iddle2369"></a><a name="iddle2370" class="calibre18" id="iddle2370"></a><a name="iddle3574" class="calibre18" id="iddle3574"></a><a name="iddle3988" class="calibre18" id="iddle3988"></a><a name="iddle3989" class="calibre18" id="iddle3989"></a><a name="iddle4196" class="calibre18" id="iddle4196"></a><a name="iddle4197" class="calibre18" id="iddle4197"></a><a name="iddle4250" class="calibre18" id="iddle4250"></a><a name="iddle4610" class="calibre18" id="iddle4610"></a><a name="iddle4612" class="calibre18" id="iddle4612"></a><a name="iddle4613" class="calibre18" id="iddle4613"></a><a name="iddle4891" class="calibre18" id="iddle4891"></a><a name="iddle4892" class="calibre18" id="iddle4892"></a><a name="iddle4977" class="calibre18" id="iddle4977"></a><a name="iddle4979" class="calibre18" id="iddle4979"></a><a name="iddle5003" class="calibre18" id="iddle5003"></a><a name="iddle5024" class="calibre18" id="iddle5024"></a><a name="iddle5025" class="calibre18" id="iddle5025"></a><a name="iddle5116" class="calibre18" id="iddle5116"></a><a name="iddle5117" class="calibre18" id="iddle5117"></a>The user clicked on the "cancel" button in a GUI application, or requested cancellation through a management interface such as JMX (Java Management Extensions).</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Time-limited activities.</span> An application searches a problem space for a finite amount of time and chooses the best solution found within that time. When the timer expires, any tasks still searching are cancelled.</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Application events.</span> An application searches a problem space by decomposing it so that different tasks search different regions of the problem space. When one task finds a solution, all other tasks still searching are cancelled.</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Errors.</span> A web crawler searches for relevant pages, storing pages or summary data to disk. When a crawler task encounters an error (for example, the disk is full), other crawling tasks are cancelled, possibly recording their current state so that they can be restarted later.</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Shutdown.</span> When an application or service is shut down, something must be done about work that is currently being processed or queued for processing. In a graceful shutdown, tasks currently in progress might be allowed to complete; in a more immediate shutdown, currently executing tasks might be cancelled.</p></blockquote>
<p class="docText1">There is no safe way to preemptively stop a thread in Java, and therefore no safe way to preemptively stop a task. There are only cooperative mechanisms, by which the task and the code requesting cancellation follow an agreed-upon protocol.</p>
<p class="docText1">One such cooperative mechanism is setting a "cancellation requested" flag that the task checks periodically; if it finds the flag set, the task terminates early. <tt class="calibre25">PrimeGenerator</tt> in <a class="calibre2" href="#ch07list01">Listing 7.1</a>, which enumerates prime numbers until it is cancelled, illustrates this technique. The <tt class="calibre25">cancel</tt> method sets the <tt class="calibre25">cancelled</tt> flag, and the main loop polls this flag before searching for the next prime number. (For this to work reliably, <tt class="calibre25">cancelled</tt> must be <tt class="calibre25">volatile</tt>.)</p>
<p class="docText1"><a class="calibre2" href="#ch07list02">Listing 7.2</a> shows a sample use of this class that lets the prime generator run for one second before cancelling it. The generator won't necessarily stop after exactly one second, since there may be some delay between the time that cancellation is requested and the time that the <tt class="calibre25">run</tt> loop next checks for cancellation. The <tt class="calibre25">cancel</tt> method is called from a <tt class="calibre25">finally</tt> block to ensure that the prime generator is cancelled even if the the call to <tt class="calibre25">sleep</tt> is interrupted. If <tt class="calibre25">cancel</tt> were not called, the prime-seeking thread would run forever, consuming CPU cycles and preventing the JVM from exiting.</p>
<p class="docText1">A task that wants to be cancellable must have a <span class="docEmphasis">cancellation policy</span> that specifies the "how", "when", and "what" of cancellationhow other code can request cancellation, when the task checks whether cancellation has been requested, and what actions the task takes in response to a cancellation request.</p>
<p class="docText1">Consider the real-world example of stopping payment on a check. Banks have rules about how to submit a stop-payment request, what responsiveness guarantees it makes in processing such requests, and what procedures it follows when <a name="iddle1214" class="calibre18" id="iddle1214"></a><a name="iddle1223" class="calibre18" id="iddle1223"></a><a name="iddle1304" class="calibre18" id="iddle1304"></a><a name="iddle2371" class="calibre18" id="iddle2371"></a><a name="iddle2394" class="calibre18" id="iddle2394"></a><a name="iddle2538" class="calibre18" id="iddle2538"></a><a name="iddle2539" class="calibre18" id="iddle2539"></a><a name="iddle2785" class="calibre18" id="iddle2785"></a><a name="iddle2797" class="calibre18" id="iddle2797"></a><a name="iddle2820" class="calibre18" id="iddle2820"></a><a name="iddle3751" class="calibre18" id="iddle3751"></a><a name="iddle4448" class="calibre18" id="iddle4448"></a><a name="iddle4725" class="calibre18" id="iddle4725"></a><a name="iddle4779" class="calibre18" id="iddle4779"></a><a name="iddle4781" class="calibre18" id="iddle4781"></a><a name="iddle2157" class="calibre18" id="iddle2157"></a>payment is actually stopped (such as notifying the other bank involved in the transaction and assessing a fee against the payor's account). Taken together, these procedures and guarantees comprise the cancellation policy for check payment.</p>
<a name="ch07list01" class="calibre18" id="ch07list01"></a><h5 id="title-IDAAL40Z" class="docExampleTitle">Listing 7.1. Using a <tt class="calibre33">Volatile</tt> Field to Hold Cancellation State.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class PrimeGenerator implements Runnable {
     @GuardedBy("this")
     private final List&lt;BigInteger&gt; primes
             = new ArrayList&lt;BigInteger&gt;();
     private  <span class="docEmphStrong">volatile</span> boolean <span class="docEmphStrong">cancelled;</span>

     public void run() {
         BigInteger p = BigInteger.ONE;
         while (<span class="docEmphStrong">!cancelled</span> ) {
             p = p.nextProbablePrime();
             synchronized (this) {
                 primes.add(p);
             }
         }
     }

     public void cancel() { <span class="docEmphStrong">cancelled = true;</span>  }

     public synchronized List&lt;BigInteger&gt; get() {
         return new ArrayList&lt;BigInteger&gt;(primes);
     }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07list02" class="calibre18" id="ch07list02"></a><h5 id="title-IDAFM40Z" class="docExampleTitle">Listing 7.2. Generating a Second's Worth of Prime Numbers.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException {
    PrimeGenerator generator = new PrimeGenerator();
    new Thread(generator).start();
    try {
        SECONDS.sleep(1);
    } finally {
        generator.cancel();
    }
    return generator.get();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><tt class="calibre25">PrimeGenerator</tt> uses a simple cancellation policy: client code requests cancellation by calling <tt class="calibre25">cancel</tt>, <tt class="calibre25">PrimeGenerator</tt> checks for cancellation once per prime found and exits when it detects cancellation has been requested.</p>
<a name="ch07lev2sec1" class="calibre18" id="ch07lev2sec1"></a>
<h4 id="title-IDA2M40Z" class="docSection2Title">7.1.1. Interruption</h4>
<p class="docText1">The cancellation mechanism in <tt class="calibre25">PrimeGenerator</tt> will eventually cause the primeseeking task to exit, but it might take a while. If, however, a task that uses this approach calls a blocking method such as <tt class="calibre25">BlockingQueue.put</tt>, we could have a more serious problemthe task might never check the cancellation flag and therefore might never terminate.</p>
<p class="docText1"><tt class="calibre25">BrokenPrimeProducer</tt> in <a class="calibre2" href="#ch07list03">Listing 7.3</a> illustrates this problem. The producer thread generates primes and places them on a blocking queue. If the producer gets ahead of the consumer, the queue will fill up and <tt class="calibre25">put</tt> will block. What happens if the consumer tries to cancel the producer task while it is blocked in <tt class="calibre25">put</tt>? It can call <tt class="calibre25">cancel</tt> which will set the <tt class="calibre25">cancelled</tt> flagbut the producer will never check the flag because it will never emerge from the blocking <tt class="calibre25">put</tt> (because the consumer has stopped retrieving primes from the queue).</p>
<p class="docText1">As we hinted in <a class="calibre2" href="ch05.html#ch05">Chapter 5</a>, certain blocking library methods support <span class="docEmphasis">interruption</span>. Thread interruption is a cooperative mechanism for a thread to signal another thread that it should, at its convenience and if it feels like it, stop what it is doing and do something else.</p>
<a name="ch07sb01" class="calibre18" id="ch07sb01"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">There is nothing in the API or language specification that ties interruption to any specific cancellation semantics, but in practice, using interruption for anything but cancellation is fragile and difficult to sustain in larger applications.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">Each thread has a boolean <span class="docEmphasis">interrupted status</span>; interrupting a thread sets its interrupted status to true. <tt class="calibre25">Thread</tt> contains methods for interrupting a thread and querying the interrupted status of a thread, as shown in <a class="calibre2" href="#ch07list04">Listing 7.4</a>. The <tt class="calibre25">interrupt</tt> method interrupts the target thread, and <tt class="calibre25">isInterrupted</tt> returns the interrupted status of the target thread. The poorly named static <tt class="calibre25">interrupted</tt> method <span class="docEmphasis">clears</span> the interrupted status of the current thread and returns its previous value; this is the only way to clear the interrupted status.</p>
<p class="docText1">Blocking library methods like <tt class="calibre25">Thread.sleep</tt> and <tt class="calibre25">Object.wait</tt> try to detect when a thread has been interrupted and return early. They respond to interruption by clearing the interrupted status and throwing <tt class="calibre25">InterruptedException</tt>, indicating that the blocking operation completed early due to interruption. The JVM makes no guarantees on how quickly a blocking method will detect interruption, but in practice this happens reasonably quickly.</p>
<p class="docText1"></p><a name="ch07list03" class="calibre18" id="ch07list03"></a><h5 id="title-IDAXP40Z" class="docExampleTitle">Listing 7.3. <a name="iddle2092" class="calibre18" id="iddle2092"></a><a name="iddle4726" class="calibre18" id="iddle4726"></a>Unreliable Cancellation that can Leave Producers Stuck in a Blocking Operation. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" src="face.jpg" class="calibre29"/>
<pre class="calibre30">class BrokenPrimeProducer extends Thread {
    private final BlockingQueue&lt;BigInteger&gt; queue;
    private volatile boolean cancelled = false;

    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (<span class="docEmphStrong">!cancelled)</span>
                queue.put(p = p.nextProbablePrime());
        } catch (InterruptedException consumed) { }
    }

    public void cancel() { <span class="docEmphStrong">cancelled = true;</span>  }
}

void consumePrimes() throws InterruptedException {
    BlockingQueue&lt;BigInteger&gt; primes = ...;
    BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);
    producer.start();
    try {
        while (needMorePrimes())
            consume(primes.take());
    } finally {
        producer.cancel();
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07list04" class="calibre18" id="ch07list04"></a><h5 id="title-IDATZA1Z" class="docExampleTitle">Listing 7.4. Interruption Methods in <tt class="calibre33">Thread</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class Thread {
    public void interrupt() { ... }
    public boolean isInterrupted() { ... }
    public static boolean interrupted() { ... }
    ...
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle1224" class="calibre18" id="iddle1224"></a><a name="iddle1309" class="calibre18" id="iddle1309"></a><a name="iddle1312" class="calibre18" id="iddle1312"></a><a name="iddle1848" class="calibre18" id="iddle1848"></a><a name="iddle2781" class="calibre18" id="iddle2781"></a><a name="iddle2782" class="calibre18" id="iddle2782"></a><a name="iddle2813" class="calibre18" id="iddle2813"></a><a name="iddle2814" class="calibre18" id="iddle2814"></a><a name="iddle2818" class="calibre18" id="iddle2818"></a><a name="iddle3557" class="calibre18" id="iddle3557"></a><a name="iddle3576" class="calibre18" id="iddle3576"></a><a name="iddle3752" class="calibre18" id="iddle3752"></a><a name="iddle3873" class="calibre18" id="iddle3873"></a><a name="iddle3874" class="calibre18" id="iddle3874"></a><a name="iddle3875" class="calibre18" id="iddle3875"></a><a name="iddle4470" class="calibre18" id="iddle4470"></a><a name="iddle4517" class="calibre18" id="iddle4517"></a><a name="iddle4727" class="calibre18" id="iddle4727"></a>If a thread is interrupted when it is <span class="docEmphasis">not</span> blocked, its interrupted status is set, and it is up to the activity being cancelled to poll the interrupted status to detect interruption. In this way interruption is "sticky"if it doesn't trigger an <tt class="calibre25">InterruptedException</tt>, evidence of interruption persists until someone deliberately clears the interrupted status.</p>
<a name="ch07sb02" class="calibre18" id="ch07sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Calling <tt class="calibre25">interrupt</tt> does not necessarily stop the target thread from doing what it is doing; it merely delivers the message that interruption has been requested.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">A good way to think about interruption is that it does not actually interrupt a running thread; it just <span class="docEmphasis">requests</span> that the thread interrupt itself at the next convenient opportunity. (These opportunities are called <span class="docEmphasis">cancellation points</span>.) Some methods, such as <tt class="calibre25">wait</tt>, <tt class="calibre25">sleep</tt>, and <tt class="calibre25">join</tt>, take such requests seriously, throwing an exception when they receive an interrupt request or encounter an already set interrupt status upon entry. Well behaved methods may totally ignore such requests so long as they leave the interruption request in place so that calling code can do something with it. Poorly behaved methods swallow the interrupt request, thus denying code further up the call stack the opportunity to act on it.</p>
<p class="docText1">The static <tt class="calibre25">interrupted</tt> method should be used with caution, because it clears the current thread's interrupted status. If you call <tt class="calibre25">interrupted</tt> and it returns <tt class="calibre25">TRue</tt>, unless you are planning to swallow the interruption, you should do something with iteither throw <tt class="calibre25">InterruptedException</tt> or restore the interrupted status by calling <tt class="calibre25">interrupt</tt> again, as in <a class="calibre2" href="ch05lev1sec4.html#ch05list10">Listing 5.10</a> on page <a class="calibre2" href="ch05lev1sec4.html#ch05list10">94</a>.</p>
<p class="docText1"><tt class="calibre25">BrokenPrimeProducer</tt> illustrates how custom cancellation mechanisms do not always interact well with blocking library methods. If you code your tasks to be responsive to interruption, you can use interruption as your cancellation mechanism and take advantage of the interruption support provided by many library classes.</p>
<a name="ch07sb03" class="calibre18" id="ch07sb03"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Interruption is usually the most sensible way to implement cancellation.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1"><tt class="calibre25">BrokenPrimeProducer</tt> can be easily fixed (and simplified) by using interruption instead of a boolean flag to request cancellation, as shown in <a class="calibre2" href="#ch07list05">Listing 7.5</a>. There are two points in each loop iteration where interruption may be detected: in the blocking <tt class="calibre25">put</tt> call, and by explicitly polling the interrupted status in the loop header. The explicit test is not strictly necessary here because of the blocking <tt class="calibre25">put</tt> call, but it makes <tt class="calibre25">PrimeProducer</tt> more responsive to interruption because it checks for interruption <span class="docEmphasis">before</span> starting the lengthy task of searching for a prime, rather than after. When calls to interruptible blocking methods are not frequent enough to deliver the desired responsiveness, explicitly testing the interrupted status can help.</p>
<p class="docText1"></p><a name="ch07list05" class="calibre18" id="ch07list05"></a><h5 id="title-IDAK1S0Z" class="docExampleTitle">Listing 7.5. Using Interruption for Cancellation.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">class PrimeProducer extends Thread {
    private final BlockingQueue&lt;BigInteger&gt; queue;

    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (<span class="docEmphStrong">!Thread.currentThread().isInterrupted())</span>
                queue.put(p = p.nextProbablePrime());
        } catch (InterruptedException consumed) {
            <span class="docEmphasis">/*  Allow thread to exit  */</span>
        }
    }
    public void cancel() { interrupt(); }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07lev2sec2" class="calibre18" id="ch07lev2sec2"></a>
<h4 id="title-IDAA2S0Z" class="docSection2Title">7.1.2. Interruption Policies</h4>
<p class="docText1"><a name="iddle1311" class="calibre18" id="iddle1311"></a><a name="iddle2158" class="calibre18" id="iddle2158"></a><a name="iddle2809" class="calibre18" id="iddle2809"></a><a name="iddle2810" class="calibre18" id="iddle2810"></a><a name="iddle3575" class="calibre18" id="iddle3575"></a><a name="iddle3584" class="calibre18" id="iddle3584"></a><a name="iddle3585" class="calibre18" id="iddle3585"></a><a name="iddle4611" class="calibre18" id="iddle4611"></a><a name="iddle4657" class="calibre18" id="iddle4657"></a><a name="iddle4658" class="calibre18" id="iddle4658"></a><a name="iddle4833" class="calibre18" id="iddle4833"></a>Just as tasks should have a cancellation policy, threads should have an <span class="docEmphasis">interruption policy</span>. An interruption policy determines how a thread interprets an interruption requestwhat it does (if anything) when one is detected, what units of work are considered atomic with respect to interruption, and how quickly it reacts to interruption.</p>
<p class="docText1">The most sensible interruption policy is some form of thread-level or servicelevel cancellation: exit as quickly as practical, cleaning up if necessary, and possibly notifying some owning entity that the thread is exiting. It is possible to establish other interruption policies, such as pausing or resuming a service, but threads or thread pools with nonstandard interruption policies may need to be restricted to tasks that have been written with an awareness of the policy.</p>
<p class="docText1">It is important to distinguish between how <span class="docEmphasis">tasks</span> and <span class="docEmphasis">threads</span> should react to interruption. A single interrupt request may havemore than one desired recipientinterrupting a worker thread in a thread pool can mean both "cancel the current task" and "shut down the worker thread".</p>
<p class="docText1">Tasks do not execute in threads they own; they borrow threads owned by a service such as a thread pool. Code that doesn't own the thread (for a thread pool, any code outside of the thread pool implementation) should be careful to preserve the interrupted status so that the owning code can eventually act on it, even if the "guest" code acts on the interruption as well. (If you are house-sitting for someone, you don't throw out the mail that comes while they're awayyou save it and let them deal with it when they get back, even if you do read their magazines.)</p>
<p class="docText1"><a name="iddle1352" class="calibre18" id="iddle1352"></a><a name="iddle1353" class="calibre18" id="iddle1353"></a><a name="iddle1684" class="calibre18" id="iddle1684"></a><a name="iddle1685" class="calibre18" id="iddle1685"></a><a name="iddle1775" class="calibre18" id="iddle1775"></a><a name="iddle1776" class="calibre18" id="iddle1776"></a><a name="iddle2378" class="calibre18" id="iddle2378"></a><a name="iddle2540" class="calibre18" id="iddle2540"></a><a name="iddle2783" class="calibre18" id="iddle2783"></a><a name="iddle2784" class="calibre18" id="iddle2784"></a><a name="iddle2801" class="calibre18" id="iddle2801"></a><a name="iddle2802" class="calibre18" id="iddle2802"></a><a name="iddle2803" class="calibre18" id="iddle2803"></a><a name="iddle2815" class="calibre18" id="iddle2815"></a><a name="iddle3701" class="calibre18" id="iddle3701"></a><a name="iddle3702" class="calibre18" id="iddle3702"></a><a name="iddle3953" class="calibre18" id="iddle3953"></a><a name="iddle3954" class="calibre18" id="iddle3954"></a><a name="iddle3975" class="calibre18" id="iddle3975"></a><a name="iddle4008" class="calibre18" id="iddle4008"></a><a name="iddle4471" class="calibre18" id="iddle4471"></a>This is why most blocking library methods simply throw <tt class="calibre25">InterruptedException</tt> in response to an interrupt. They will never execute in a thread they own, so they implement the most reasonable cancellation policy for task or library code: get out of the way as quickly as possible and communicate the interruption back to the caller so that code higher up on the call stack can take further action.</p>
<p class="docText1">A task needn't necessarily drop everything when it detects an interruption requestit can choose to postpone it until a more opportune time by remembering that it was interrupted, finishing the task it was performing, and <span class="docEmphasis">then</span> throwing <tt class="calibre25">InterruptedException</tt> or otherwise indicating interruption. This technique can protect data structures from corruption when an activity is interrupted in the middle of an update.</p>
<p class="docText1">A task should not assume anything about the interruption policy of its executing thread unless it is explicitly designed to run within a service that has a specific interruption policy. Whether a task interprets interruption as cancellation or takes some other action on interruption, it should take care to preserve the executing thread's interruption status. If it is not simply going to propagate <tt class="calibre25">InterruptedException</tt> to its caller, it should restore the interruption status after catching <tt class="calibre25">InterruptedException</tt>:</p>
<div class="docText2"><pre class="calibre36">Thread.currentThread().interrupt();
</pre></div><p class="calibre1"> </p>
<p class="docText1">Just as task code should not make assumptions about what interruption means to its executing thread, cancellation code should not make assumptions about the interruption policy of arbitrary threads. A thread should be interrupted only by its owner; the owner can encapsulate knowledge of the thread's interruption policy in an appropriate cancellation mechanism such as a shutdown method.</p>
<a name="ch07sb04" class="calibre18" id="ch07sb04"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Because each thread has its own interruption policy, you should not interrupt a thread unless you know what interruption means to that thread.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">Critics have derided the Java interruption facility because it does not provide a preemptive interruption capability and yet forces developers to handle <tt class="calibre25">InterruptedException</tt>. However, the ability to postpone an interruption request enables developers to craft flexible interruption policies that balance responsiveness and robustness as appropriate for the application.</p>
<a name="ch07lev2sec3" class="calibre18" id="ch07lev2sec3"></a>
<h4 id="title-IDAFJT0Z" class="docSection2Title">7.1.3. Responding to Interruption</h4>
<p class="docText1">As mentioned in <a class="calibre2" href="ch05lev1sec4.html#ch05lev1sec4">Section 5.4</a>, when you call an interruptible blocking method such as <tt class="calibre25">Thread.sleep</tt> or <tt class="calibre25">BlockingQueue.put</tt>, there are two practical strategies for handling <tt class="calibre25">InterruptedException</tt>:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1">Propagate the exception (possibly after some task-specific cleanup), making your method an interruptible blocking method, too; or</p></li><li class="calibre16"><p class="docText1">Restore the interruption status so that code higher up on the call stack can deal with it.</p></li></ul>
<p class="docText1"><a name="iddle1215" class="calibre18" id="iddle1215"></a><a name="iddle1216" class="calibre18" id="iddle1216"></a><a name="iddle1992" class="calibre18" id="iddle1992"></a><a name="iddle1993" class="calibre18" id="iddle1993"></a><a name="iddle2542" class="calibre18" id="iddle2542"></a><a name="iddle2786" class="calibre18" id="iddle2786"></a><a name="iddle2805" class="calibre18" id="iddle2805"></a><a name="iddle2819" class="calibre18" id="iddle2819"></a><a name="iddle3174" class="calibre18" id="iddle3174"></a><a name="iddle3175" class="calibre18" id="iddle3175"></a><a name="iddle3604" class="calibre18" id="iddle3604"></a><a name="iddle3951" class="calibre18" id="iddle3951"></a><a name="iddle3952" class="calibre18" id="iddle3952"></a><a name="iddle4014" class="calibre18" id="iddle4014"></a><a name="iddle4015" class="calibre18" id="iddle4015"></a><a name="iddle4518" class="calibre18" id="iddle4518"></a>Propagating <tt class="calibre25">InterruptedException</tt> can be as easy as adding <tt class="calibre25">InterruptedException</tt> to the <tt class="calibre25">throws</tt> clause, as shown by <tt class="calibre25">getNextTask</tt> in <a class="calibre2" href="#ch07list06">Listing 7.6</a>.</p>
<a name="ch07list06" class="calibre18" id="ch07list06"></a><h5 id="title-IDAHQT0Z" class="docExampleTitle">Listing 7.6. Propagating <tt class="calibre33">InterruptedException</tt> to Callers.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">BlockingQueue&lt;Task&gt; queue;
...
public Task getNextTask() throws InterruptedException {
    return queue.take();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">If you don't want to or cannot propagate <tt class="calibre25">InterruptedException</tt> (perhaps because your task is defined by a <tt class="calibre25">Runnable</tt>), you need to find another way to preserve the interruption request. The standard way to do this is to restore the interrupted status by calling <tt class="calibre25">interrupt</tt> again. What you should <span class="docEmphasis">not</span> do is swallow the <tt class="calibre25">InterruptedException</tt> by catching it and doing nothing in the <tt class="calibre25">catch</tt> block, unless your code is actually implementing the interruption policy for a thread. <tt class="calibre25">PrimeProducer</tt> swallows the interrupt, but does so with the knowledge that the thread is about to terminate and that therefore there is no code higher up on the call stack that needs to know about the interruption. Most code does not know what thread it will run in and so should preserve the interrupted status.</p>
<a name="ch07sb05" class="calibre18" id="ch07sb05"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Only code that implements a thread's interruption policy may swallow an interruption request. General-purpose task and library code should never swallow interruption requests.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">Activities that do not support cancellation but still call interruptible blocking methods will have to call them in a loop, retrying when interruption is detected. In this case, they should save the interruption status locally and restore it just before returning, as shown in <a class="calibre2" href="#ch07list07">Listing 7.7</a>, rather than immediately upon catching <tt class="calibre25">InterruptedException</tt>. Setting the interrupted status too early could result in an infinite loop, because most interruptible blocking methods check the interrupted status on entry and throw <tt class="calibre25">InterruptedException</tt> immediately if it is set. (Interruptible methods usually poll for interruption before blocking or doing any significant work, so as to be as responsive to interruption as possible.)</p>
<p class="docText1">If your code does not call interruptible blocking methods, it can still be made responsive to interruption by polling the current thread's interrupted status throughout the task code. Choosing a polling frequency is a tradeoff between efficiency and responsiveness. If you have high responsiveness requirements, you cannot call potentially long-running methods that are not themselves responsive to interruption, potentially restricting your options for calling library code.</p>
<p class="docText1">Cancellation can involve state other than the interruption status; interruption can be used to get the thread's attention, and information stored elsewhere by the interrupting thread can be used to provide further instructions for the interrupted thread. (Be sure to use synchronization when accessing that information.)</p>
<p class="docText1"></p><a name="ch07list07" class="calibre18" id="ch07list07"></a><h5 id="title-IDAHST0Z" class="docExampleTitle">Listing 7.7. Noncancelable Task that Restores Interruption Before Exit.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public Task getNextTask(BlockingQueue&lt;Taskgt; queue) {
    boolean interrupted = false;
    try {
        while (true) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                interrupted = true;
                <span class="docEmphasis">// fall through and retry</span>
            }
        }
    } finally {
        if (interrupted)
            Thread.currentThread().interrupt();
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle4894" class="calibre18" id="iddle4894"></a>For example, when a worker thread owned by a <tt class="calibre25">THReadPoolExecutor</tt> detects interruption, it checks whether the pool is being shut down. If so, it performs some pool cleanup before terminating; otherwise it may create a new thread to restore the thread pool to the desired size.</p>
<a name="ch07lev2sec4" class="calibre18" id="ch07lev2sec4"></a>
<h4 id="title-IDAKTT0Z" class="docSection2Title">7.1.4. Example: Timed Run</h4>
<p class="docText1">Many problems can take forever to solve (e.g., enumerate all the prime numbers); for others, the answer might be found reasonably quickly but also might take forever. Being able to say "spend up to ten minutes looking for the answer" or "enumerate all the answers you can in ten minutes" can be useful in these situations.</p>
<p class="docText1">The <tt class="calibre25">aSecondOfPrimes</tt> method in <a class="calibre2" href="#ch07list02">Listing 7.2</a> starts a <tt class="calibre25">PrimeGenerator</tt> and interrupts it after a second. While the <tt class="calibre25">PrimeGenerator</tt> might take somewhat longer than a second to stop, it will eventually notice the interrupt and stop, allowing the thread to terminate. But another aspect of executing a task is that you want to find out if the task throws an exception. If <tt class="calibre25">PrimeGenerator</tt> throws an unchecked exception before the timeout expires, it will probably go unnoticed, since the prime generator runs in a separate thread that does not explicitly handle exceptions.</p>
<p class="docText1"><a class="calibre2" href="#ch07list08">Listing 7.8</a> shows an attempt at running an arbitrary <tt class="calibre25">Runnable</tt> for a given amount of time. It runs the task in the calling thread and schedules a cancellation task to interrupt it after a given time interval. This addresses the problem of unchecked exceptions thrown from the task, since they can then be caught by the caller of <tt class="calibre25">timedRun</tt>.</p>
<p class="docText1">This is an appealingly simple approach, but it violates the rules: you should know a thread's interruption policy before interrupting it. Since <tt class="calibre25">timedRun</tt> can be called from an arbitrary thread, it cannot know the calling thread's interruption <a name="iddle1301" class="calibre18" id="iddle1301"></a><a name="iddle2173" class="calibre18" id="iddle2173"></a><a name="iddle2422" class="calibre18" id="iddle2422"></a><a name="iddle2541" class="calibre18" id="iddle2541"></a><a name="iddle2909" class="calibre18" id="iddle2909"></a><a name="iddle2910" class="calibre18" id="iddle2910"></a><a name="iddle2911" class="calibre18" id="iddle2911"></a><a name="iddle4457" class="calibre18" id="iddle4457"></a><a name="iddle4458" class="calibre18" id="iddle4458"></a><a name="iddle4720" class="calibre18" id="iddle4720"></a><a name="iddle4721" class="calibre18" id="iddle4721"></a><a name="iddle4722" class="calibre18" id="iddle4722"></a>policy. If the task completes before the timeout, the cancellation task that interrupts the thread in which <tt class="calibre25">timedRun</tt> was called could go off <span class="docEmphasis">after</span> <tt class="calibre25">timedRun</tt> has returned to its caller. We don't know what code will be running when that happens, but the result won't be good. (It is possible but surprisingly tricky to eliminate this risk by using the <tt class="calibre25">ScheduledFuture</tt> returned by <tt class="calibre25">schedule</tt> to cancel the cancellation task.)</p>
<a name="ch07list08" class="calibre18" id="ch07list08"></a><h5 id="title-IDALZT0Z" class="docExampleTitle">Listing 7.8. Scheduling an Interrupt on a Borrowed Thread. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" src="face.jpg" class="calibre29"/>
<pre class="calibre30">private static final ScheduledExecutorService cancelExec = ...;

public static void timedRun(Runnable r,
                           long timeout, TimeUnit unit) {
    final Thread taskThread = Thread.currentThread();
    cancelExec.schedule(new Runnable() {
        public void run() { <span class="docEmphStrong">taskThread.interrupt();</span> }
    }, timeout, unit);
    <span class="docEmphStrong">r.run();</span>
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Further, if the task is not responsive to interruption, <tt class="calibre25">timedRun</tt> will not return until the task finishes, which may be long after the desired timeout (or even not at all). A timed run service that doesn't return after the specified time is likely to be irritating to its callers.</p>
<p class="docText1"><a class="calibre2" href="#ch07list09">Listing 7.9</a> addresses the exception-handling problem of <tt class="calibre25">aSecondOfPrimes</tt> and the problems with the previous attempt. The thread created to run the task can have its own execution policy, and even if the task doesn't respond to the interrupt, the timed run method can still return to its caller. After starting the task thread, <tt class="calibre25">timedRun</tt> executes a timed <tt class="calibre25">join</tt> with the newly created thread. After <tt class="calibre25">join</tt> returns, it checks if an exception was thrown from the task and if so, rethrows it in the thread calling <tt class="calibre25">timedRun</tt>. The saved <tt class="calibre25">Throwable</tt> is shared between the two threads, and so is declared <tt class="calibre25">volatile</tt> to safely publish it from the task thread to the <tt class="calibre25">timedRun</tt> thread.</p>
<p class="docText1">This version addresses the problems in the previous examples, but because it relies on a timed <tt class="calibre25">join</tt>, it shares a deficiency with <tt class="calibre25">join</tt>: we don't know if control was returned because the thread exited normally or because the <tt class="calibre25">join</tt> timed out.<sup class="docFootnote"><a class="calibre2" href="#ch07fn02">[2]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch07fn02" class="calibre18" id="ch07fn02">[2]</a></sup> This is a flaw in the <tt class="calibre35">Thread</tt> API, because whether or not the <tt class="calibre35">join</tt> completes successfully has memory visibility consequences in the Java Memory Model, but <tt class="calibre35">join</tt> does not return a status indicating whether it was successful.</p></blockquote>
<a name="ch07lev2sec5" class="calibre18" id="ch07lev2sec5"></a>
<h4 id="title-IDA51T0Z" class="docSection2Title">7.1.5. Cancellation Via <tt class="calibre33">Future</tt></h4>
<p class="docText1">We've already used an abstraction for managing the lifecycle of a task, dealing with exceptions, and facilitating cancellation<tt class="calibre25">Future</tt>. Following the general principle that it is better to use existing library classes than to roll your own, let's build <tt class="calibre25">timedRun</tt> using <tt class="calibre25">Future</tt> and the task execution framework.</p>
<p class="docText1"></p><a name="ch07list09" class="calibre18" id="ch07list09"></a><h5 id="title-IDAW2T0Z" class="docExampleTitle">Listing 7.9. Interrupting a Task in a Dedicated Thread.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" src="face1.jpg" class="calibre31"/>
<pre class="calibre30">public static void timedRun(final Runnable r,
                            long timeout, TimeUnit unit)
                            throws InterruptedException {
    class RethrowableTask implements Runnable {
        private volatile Throwable t;
        public void run() {
            try { r.run(); }
            catch (Throwable t) { this.t = t; }
        }
        void rethrow() {
            if (t != null)
                throw launderThrowable(t);
        }
    }

    RethrowableTask task = new RethrowableTask();
    final Thread taskThread = new Thread(task);
    <span class="docEmphStrong">taskThread.start();</span>
    cancelExec.schedule(new Runnable() {
        public void run() { <span class="docEmphStrong">taskThread.interrupt();</span>  }
    }, timeout, unit);
    <span class="docEmphStrong">taskThread.join</span>(unit.toMillis(timeout));
    task.rethrow();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle2272" class="calibre18" id="iddle2272"></a><a name="iddle4472" class="calibre18" id="iddle4472"></a><tt class="calibre25">ExecutorService.submit</tt> returns a <tt class="calibre25">Future</tt> describing the task. <tt class="calibre25">Future</tt> has a <tt class="calibre25">cancel</tt> method that takes a boolean argument, <tt class="calibre25">mayInterruptIfRunning</tt>, and returns a value indicating whether the cancellation attempt was successful. (This tells you only whether it was able to deliver the interruption, not whether the task detected and acted on it.) When <tt class="calibre25">mayInterruptIfRunning</tt> is <tt class="calibre25">true</tt> and the task is currently running in some thread, then that thread is interrupted. Setting this argument to <tt class="calibre25">false</tt> means "don't run this task if it hasn't started yet", and should be used for tasks that are not designed to handle interruption.</p>
<p class="docText1">Since you shouldn't interrupt a thread unless you know its interruption policy, when is it OK to call <tt class="calibre25">cancel</tt> with an argument of <tt class="calibre25">TRue</tt>? The task execution threads created by the standard <tt class="calibre25">Executor</tt> implementations implement an interruption policy that lets tasks be cancelled using interruption, so it is safe to set <tt class="calibre25">mayInterruptIfRunning</tt> when cancelling tasks through their <tt class="calibre25">Future</tt>s when they are running in a standard <tt class="calibre25">Executor</tt>. You should not interrupt a pool thread directly when attempting to cancel a task, because you won't know what task is running when the interrupt request is delivereddo this only through the task's <tt class="calibre25">Future</tt>. This is yet another reason to code tasks to treat interruption as a cancellation request: then they can be cancelled through their <tt class="calibre25">Future</tt>s.</p>
<p class="docText1"><a name="iddle1217" class="calibre18" id="iddle1217"></a><a name="iddle1308" class="calibre18" id="iddle1308"></a><a name="iddle2596" class="calibre18" id="iddle2596"></a><a name="iddle2597" class="calibre18" id="iddle2597"></a><a name="iddle2788" class="calibre18" id="iddle2788"></a><a name="iddle2789" class="calibre18" id="iddle2789"></a><a name="iddle2806" class="calibre18" id="iddle2806"></a><a name="iddle2807" class="calibre18" id="iddle2807"></a><a name="iddle3990" class="calibre18" id="iddle3990"></a><a name="iddle4931" class="calibre18" id="iddle4931"></a><a class="calibre2" href="#ch07list10">Listing 7.10</a> shows a version of <tt class="calibre25">timedRun</tt> that submits the task to an <tt class="calibre25">ExecutorService</tt> and retrieves the result with a timed <tt class="calibre25">Future.get</tt>. If <tt class="calibre25">get</tt> terminates with a <tt class="calibre25">TimeoutException</tt>, the task is cancelled via its <tt class="calibre25">Future</tt>. (To simplify coding, this version calls <tt class="calibre25">Future.cancel</tt> unconditionally in a <tt class="calibre25">finally</tt> block, taking advantage of the fact that cancelling a completed task has no effect.) If the underlying computation throws an exception prior to cancellation, it is rethrown from <tt class="calibre25">timedRun</tt>, which is the most convenient way for the caller to deal with the exception. <a class="calibre2" href="#ch07list10">Listing 7.10</a> also illustrates another good practice: cancelling tasks whose result is no longer needed. (This technique was also used in <a class="calibre2" href="ch06lev1sec3.html#ch06list13">Listing 6.13</a> on page <a class="calibre2" href="ch06lev1sec3.html#ch06list13">128</a> and <a class="calibre2" href="ch06lev1sec3.html#ch06list16">Listing 6.16</a> on page <a class="calibre2" href="ch06lev1sec3.html#ch06list16">132</a>.)</p>
<a name="ch07list10" class="calibre18" id="ch07list10"></a><h5 id="title-IDAKFU0Z" class="docExampleTitle">Listing 7.10. Cancelling a Task Using <tt class="calibre33">Future</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public static void timedRun(Runnable r,
                            long timeout, TimeUnit unit)
                            throws InterruptedException {
    <span class="docEmphStrong">Future&lt;?&gt; task = taskExec.submit(r);</span>
    try {
        <span class="docEmphStrong">task.get(timeout, unit);</span>
    } catch (TimeoutException e) {
        <span class="docEmphasis">// task will be cancelled below</span>
    } catch (ExecutionException e) {
        <span class="docEmphasis">// exception thrown in task; rethrow</span>
        throw launderThrowable(e.getCause());
    } finally {
        <span class="docEmphasis">// Harmless if task already completed</span>
<span class="docEmphStrong">task.cancel(true);</span> <span class="docEmphasis">// interrupt if running</span>
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07sb06" class="calibre18" id="ch07sb06"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">When <tt class="calibre25">Future.get</tt> throws <tt class="calibre25">InterruptedException</tt> or <tt class="calibre25">TimeoutException</tt> and you know that the result is no longer needed by the program, cancel the task with <tt class="calibre25">Future.cancel</tt>.</p>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch07lev2sec6" class="calibre18" id="ch07lev2sec6"></a>
<h4 id="title-IDACHU0Z" class="docSection2Title">7.1.6. Dealing with Non-interruptible Blocking</h4>
<p class="docText1">Many blocking library methods respond to interruption by returning early and throwing <tt class="calibre25">InterruptedException</tt>, which makes it easier to build tasks that are responsive to cancellation. However, not all blocking methods or blocking mechanisms are responsive to interruption; if a thread is blocked performing synchronous socket I/O or waiting to acquire an intrinsic lock, interruption has no effect other than setting the thread's interrupted status. We can sometimes convince threads blocked in noninterruptible activities to stop by means similar to interruption, but this requires greater awareness of why the thread is blocked.</p>
<p class="docText1"><span class="docEmphStrong">Synchronous socket I/O in java.io.</span> <a name="iddle1132" class="calibre18" id="iddle1132"></a><a name="iddle1306" class="calibre18" id="iddle1306"></a><a name="iddle1307" class="calibre18" id="iddle1307"></a><a name="iddle2016" class="calibre18" id="iddle2016"></a><a name="iddle2282" class="calibre18" id="iddle2282"></a><a name="iddle2294" class="calibre18" id="iddle2294"></a><a name="iddle2424" class="calibre18" id="iddle2424"></a><a name="iddle2672" class="calibre18" id="iddle2672"></a><a name="iddle2673" class="calibre18" id="iddle2673"></a><a name="iddle2681" class="calibre18" id="iddle2681"></a><a name="iddle2682" class="calibre18" id="iddle2682"></a><a name="iddle2808" class="calibre18" id="iddle2808"></a><a name="iddle2832" class="calibre18" id="iddle2832"></a><a name="iddle2902" class="calibre18" id="iddle2902"></a><a name="iddle2903" class="calibre18" id="iddle2903"></a><a name="iddle2904" class="calibre18" id="iddle2904"></a><a name="iddle3042" class="calibre18" id="iddle3042"></a><a name="iddle3053" class="calibre18" id="iddle3053"></a><a name="iddle3100" class="calibre18" id="iddle3100"></a><a name="iddle3108" class="calibre18" id="iddle3108"></a><a name="iddle3299" class="calibre18" id="iddle3299"></a><a name="iddle4118" class="calibre18" id="iddle4118"></a><a name="iddle4119" class="calibre18" id="iddle4119"></a><a name="iddle4325" class="calibre18" id="iddle4325"></a><a name="iddle4326" class="calibre18" id="iddle4326"></a><a name="iddle4595" class="calibre18" id="iddle4595"></a><a name="iddle4596" class="calibre18" id="iddle4596"></a><a name="iddle4859" class="calibre18" id="iddle4859"></a>The common form of blocking I/O in server applications is reading or writing to a socket. Unfortunately, the <tt class="calibre25">read</tt> and <tt class="calibre25">write</tt> methods in <tt class="calibre25">InputStream</tt> and <tt class="calibre25">OutputStream</tt> are not responsive to interruption, but closing the underlying socket makes any threads blocked in <tt class="calibre25">read</tt> or <tt class="calibre25">write</tt> throw a <tt class="calibre25">SocketException</tt>.</p>
<p class="docText1"><span class="docEmphStrong">Synchronous I/O in java.nio.</span> Interrupting a thread waiting on an <tt class="calibre25">InterruptibleChannel</tt> causes it to throw <tt class="calibre25">ClosedByInterruptException</tt> and close the channel (and also causes all other threads blocked on the channel to throw <tt class="calibre25">ClosedByInterruptException</tt>). Closing an <tt class="calibre25">InterruptibleChannel</tt> causes threads blocked on channel operations to throw <tt class="calibre25">AsynchronousCloseException</tt>. Most standard <tt class="calibre25">Channel</tt>s implement <tt class="calibre25">InterruptibleChannel</tt>.</p>
<p class="docText1"><span class="docEmphStrong">Asynchronous I/O with Selector.</span> If a thread is blocked in <tt class="calibre25">Selector.select</tt> (in <tt class="calibre25">java.nio.channels</tt>), <tt class="calibre25">wakeup</tt> causes it to return prematurely by throwing a <tt class="calibre25">ClosedSelectorException</tt>.</p>
<p class="docText1"><span class="docEmphStrong">Lock acquisition.</span> If a thread is blocked waiting for an intrinsic lock, there is nothing you can do to stop it short of ensuring that it eventually acquires the lock and makes enough progress that you can get its attention some other way. However, the explicit <tt class="calibre25">Lock</tt> classes offer the <tt class="calibre25">lockInterruptibly</tt> method, which allows you to wait for a lock and still be responsive to interruptssee <a class="calibre2" href="ch13.html#ch13">Chapter 13</a>.</p>
<p class="docText1"><tt class="calibre25">ReaderThread</tt> in <a class="calibre2" href="#ch07list11">Listing 7.11</a> shows a technique for encapsulating nonstandard cancellation. <tt class="calibre25">ReaderThread</tt> manages a single socket connection, reading synchronously from the socket and passing any data received to <tt class="calibre25">processBuffer</tt>. To facilitate terminating a user connection or shutting down the server, <tt class="calibre25">ReaderThread</tt> overrides <tt class="calibre25">interrupt</tt> to both deliver a standard interrupt and close the underlying socket; thus interrupting a <tt class="calibre25">ReaderThread</tt> makes it stop what it is doing whether it is blocked in <tt class="calibre25">read</tt> or in an interruptible blocking method.</p>
<a name="ch07lev2sec7" class="calibre18" id="ch07lev2sec7"></a>
<h4 id="title-IDAF2U0Z" class="docSection2Title">7.1.7. Encapsulating Nonstandard Cancellation with <tt class="calibre33">Newtaskfor</tt></h4>
<p class="docText1">The technique used in <tt class="calibre25">ReaderThread</tt> to encapsulate nonstandard cancellation can be refined using the <tt class="calibre25">newTaskFor</tt> hook added to <tt class="calibre25">ThreadPoolExecutor</tt> in Java 6. When a <tt class="calibre25">Callable</tt> is submitted to an <tt class="calibre25">ExecutorService</tt>, <tt class="calibre25">submit</tt> returns a <tt class="calibre25">Future</tt> that can be used to cancel the task. The <tt class="calibre25">newTaskFor</tt> hook is a factory method that creates the <tt class="calibre25">Future</tt> representing the task. It returns a <tt class="calibre25">RunnableFuture</tt>, an interface that extends both <tt class="calibre25">Future</tt> and <tt class="calibre25">Runnable</tt> (and is implemented by <tt class="calibre25">FutureTask</tt>).</p>
<p class="docText1">Customizing the task <tt class="calibre25">Future</tt> allows you to override <tt class="calibre25">Future.cancel</tt>. Custom cancellation code can perform logging or gather statistics on cancellation, and can also be used to cancel activities that are not responsive to interruption. <tt class="calibre25">ReaderThread</tt> encapsulates cancellation of socket-using threads by overriding <tt class="calibre25">interrupt</tt>; the same can be done for tasks by overriding <tt class="calibre25">Future.cancel</tt>.</p>
<p class="docText1"><tt class="calibre25">CancellableTask</tt> in <a class="calibre2" href="ch07lev1sec2.html#ch07list12">Listing 7.12</a> defines a <tt class="calibre25">CancellableTask</tt> interface that extends <tt class="calibre25">Callable</tt> and adds a <tt class="calibre25">cancel</tt> method and a <tt class="calibre25">newTask</tt> factory method for <a name="iddle2166" class="calibre18" id="iddle2166"></a><a name="iddle1364" class="calibre18" id="iddle1364"></a><a name="iddle2030" class="calibre18" id="iddle2030"></a><a name="iddle2605" class="calibre18" id="iddle2605"></a><a name="iddle2606" class="calibre18" id="iddle2606"></a><a name="iddle2772" class="calibre18" id="iddle2772"></a><a name="iddle2773" class="calibre18" id="iddle2773"></a><a name="iddle2822" class="calibre18" id="iddle2822"></a><a name="iddle2823" class="calibre18" id="iddle2823"></a><a name="iddle2983" class="calibre18" id="iddle2983"></a><a name="iddle3069" class="calibre18" id="iddle3069"></a><a name="iddle3169" class="calibre18" id="iddle3169"></a><a name="iddle3170" class="calibre18" id="iddle3170"></a><a name="iddle3443" class="calibre18" id="iddle3443"></a><a name="iddle3872" class="calibre18" id="iddle3872"></a><a name="iddle4194" class="calibre18" id="iddle4194"></a><a name="iddle4195" class="calibre18" id="iddle4195"></a><a name="iddle4198" class="calibre18" id="iddle4198"></a><a name="iddle4199" class="calibre18" id="iddle4199"></a><a name="iddle4258" class="calibre18" id="iddle4258"></a><a name="iddle4262" class="calibre18" id="iddle4262"></a><a name="iddle4487" class="calibre18" id="iddle4487"></a><a name="iddle4493" class="calibre18" id="iddle4493"></a><a name="iddle4494" class="calibre18" id="iddle4494"></a><a name="iddle4495" class="calibre18" id="iddle4495"></a><a name="iddle4788" class="calibre18" id="iddle4788"></a><a name="iddle4791" class="calibre18" id="iddle4791"></a><a name="iddle4816" class="calibre18" id="iddle4816"></a><a name="iddle4817" class="calibre18" id="iddle4817"></a>constructing a <tt class="calibre25">RunnableFuture</tt>. <tt class="calibre25">CancellingExecutor</tt> extends <tt class="calibre25">THReadPoolExecutor</tt>, and overrides <tt class="calibre25">newTaskFor</tt> to let a <tt class="calibre25">CancellableTask</tt> create its own <tt class="calibre25">Future</tt>.</p>
<a name="ch07list11" class="calibre18" id="ch07list11"></a><h5 id="title-IDA1IV0Z" class="docExampleTitle">Listing 7.11. Encapsulating Nonstandard Cancellation in a <tt class="calibre33">THRead</tt> by Overriding <tt class="calibre33">Interrupt</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class ReaderThread extends Thread {
    private final Socket socket;
    private final InputStream in;

    public ReaderThread(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }

    public void  <span class="docEmphStrong">interrupt()</span>  {
        try {
            socket.close();
        }
        catch (IOException ignored) { }
        finally {
            <span class="docEmphStrong">super.interrupt();</span>
        }
    }

    public void run() {
        try {
            byte[] buf = new byte[BUFSZ];
            while (true) {
                int count = in.read(buf);
                if (count &lt; 0)
                    break;
                else if (count &gt; 0)
                    processBuffer(buf, count);
            }
        } catch (IOException e) { <span class="docEmphasis">/*  Allow thread to exit  */</span>  }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><tt class="calibre25">SocketUsingTask</tt> implements <tt class="calibre25">CancellableTask</tt> and defines <tt class="calibre25">Future.cancel</tt> to close the socket as well as call <tt class="calibre25">super.cancel</tt>. If a <tt class="calibre25">SocketUsingTask</tt> is cancelled through its <tt class="calibre25">Future</tt>, the socket is closed <span class="docEmphasis">and</span> the executing thread is interrupted. This increases the task's responsiveness to cancellation: not only can it safely call interruptible blocking methods while remaining responsive to cancellation, but it can also call blocking socket I/O methods.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

