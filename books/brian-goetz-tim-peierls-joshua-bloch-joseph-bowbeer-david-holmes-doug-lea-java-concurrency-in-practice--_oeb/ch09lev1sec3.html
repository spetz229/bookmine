---
layout: page
title: "Java Concurrency in Practice"
prev: ch09lev1sec2.html
next: ch09lev1sec4.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch09lev1sec3" class="calibre18" id="ch09lev1sec3"></a>
<h3 id="631532-859" class="docSection1Title">9.3. Long-running GUI Tasks</h3>
<p class="docText1">If all tasks were short-running (and the application had no significant non-GUI portion), then the entire application could run within the event thread and you wouldn't have to pay any attention to threads at all. However, sophisticated GUI applications may execute tasks that may take longer than the user is willing to wait, such as spell checking, background compilation, or fetching remote resources. These tasks must run in another thread so that the GUI remains responsive while they run.</p>
<p class="docText1">Swing makes it easy to have a task run in the event thread, but (prior to Java 6) doesn't provide any mechanism for helping GUI tasks execute code in other threads. But we don't need Swing to help us here: we can create our own <tt class="calibre25">Executor</tt> for processing long-running tasks. A cached thread pool is a good choice for long-running tasks; only rarely do GUI applications initiate a large number of long-running tasks, so there is little risk of the pool growing without bound.</p>
<p class="docText1">We start with a simple task that does not support cancellation or progress indication and that does not update the GUI on completion, and then add those features one by one. <a class="calibre2" href="#ch09list04">Listing 9.4</a> shows an action listener, bound to a visual component, that submits a long-running task to an <tt class="calibre25">Executor</tt>. Despite the two layers of inner classes, having a GUI task initiate a task in this manner is fairly straightforward: the UI action listener is called in the event thread and submits a <tt class="calibre25">Runnable</tt> to execute in the thread pool.</p>
<p class="docText1">This example gets the long-running task out of the event thread in a "fire and forget" manner, which is probably not very useful. There is usually some sort of visual feedback when a long-running task completes. But you cannot access presentation objects from the background thread, so on completion the task must submit another task to run in the event thread to update the user interface.</p>
<p class="docText1"></p><a name="ch09list04" class="calibre18" id="ch09list04"></a><h5 id="title-IDATD0HQ" class="docExampleTitle">Listing 9.4. Binding a Long-running Task to a Visual Component.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">ExecutorService backgroundExec = Executors.newCachedThreadPool();
...
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        backgroundExec.execute(new Runnable() {
            public void run() { doBigComputation(); }
        });
}});
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle2336" class="calibre18" id="iddle2336"></a><a name="iddle2337" class="calibre18" id="iddle2337"></a><a name="iddle5026" class="calibre18" id="iddle5026"></a><a name="iddle5027" class="calibre18" id="iddle5027"></a><a class="calibre2" href="#ch09list05">Listing 9.5</a> illustrates the obvious way to do this, which is starting to get complicated; we're now up to three layers of inner classes. The action listener first dims the button and sets a label indicating that a computation is in progress, then submits a task to the background executor. When that task finishes, it queues another task to run in the event thread, which reenables the button and restores the label text.</p>
<a name="ch09list05" class="calibre18" id="ch09list05"></a><h5 id="title-IDAYF0HQ" class="docExampleTitle">Listing 9.5. Long-running Task with User Feedback.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        button.setEnabled(false);
        label.setText("busy");
        backgroundExec.execute(new Runnable() {
            public void run() {
                try {
                    doBigComputation();
                } finally {
                    GuiExecutor.instance().execute(new Runnable() {
                        public void run() {
                            button.setEnabled(true);
                            label.setText("idle");
                        }
                    });
                }
            }
        });
    }
});
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">The task triggered when the button is pressed is composed of three sequential subtasks whose execution alternates between the event thread and the background thread. The first subtask updates the user interface to show that a longrunning operation has begun and starts the second subtask in a background <a name="iddle1305" class="calibre18" id="iddle1305"></a><a name="iddle2420" class="calibre18" id="iddle2420"></a><a name="iddle2421" class="calibre18" id="iddle2421"></a>thread. Upon completion, the second subtask queues the third subtask to run again in the event thread, which updates the user interface to reflect that the operation has completed. This sort of "thread hopping" is typical of handling long-running tasks in GUI applications.</p>
<a name="ch09lev2sec3" class="calibre18" id="ch09lev2sec3"></a>
<h4 id="title-IDAMH0HQ" class="docSection2Title">9.3.1. Cancellation</h4>
<p class="docText1">Any task that takes long enough to run in another thread probably also takes long enough that the user might want to cancel it. You could implement cancellation directly using thread interruption, but it is much easier to use <tt class="calibre25">Future</tt>, which was designed to manage cancellable tasks.</p>
<p class="docText1">When you call <tt class="calibre25">cancel</tt> on a <tt class="calibre25">Future</tt> with <tt class="calibre25">mayInterruptIfRunning</tt> set to <tt class="calibre25">true</tt>, the <tt class="calibre25">Future</tt> implementation interrupts the thread that is executing the task if it is currently running. If your task is written to be responsive to interruption, it can return early if it is cancelled. <a class="calibre2" href="#ch09list06">Listing 9.6</a> illustrates a task that polls the thread's interrupted status and returns early on interruption.</p>
<a name="ch09list06" class="calibre18" id="ch09list06"></a><h5 id="title-IDASI0HQ" class="docExampleTitle">Listing 9.6. Cancelling a Long-running Task.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30"><span class="docEmphStrong">Future&lt;?&gt;</span>  runningTask = null;    // thread-confined
...
startButton.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        if (runningTask != null) {
            runningTask = backgroundExec<span class="docEmphStrong">.submit</span>(new Runnable() {
                public void run() {
                   while (moreWork()) {
                       if (Thread.currentThread().isInterrupted()) {
                           cleanUpPartialWork();
                           break;
                       }
                       doSomeWork();
                   }
                }
            });
    };
}});

cancelButton.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
        if (runningTask != null)
            runningTask<span class="docEmphStrong">.cancel</span>(true);
}});
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Because <tt class="calibre25">runningTask</tt> is confined to the event thread, no synchronization is required when setting or checking it, and the start button listener ensures that <a name="iddle1398" class="calibre18" id="iddle1398"></a><a name="iddle1399" class="calibre18" id="iddle1399"></a><a name="iddle1757" class="calibre18" id="iddle1757"></a><a name="iddle2433" class="calibre18" id="iddle2433"></a><a name="iddle2434" class="calibre18" id="iddle2434"></a><a name="iddle2646" class="calibre18" id="iddle2646"></a><a name="iddle2647" class="calibre18" id="iddle2647"></a><a name="iddle3231" class="calibre18" id="iddle3231"></a><a name="iddle3319" class="calibre18" id="iddle3319"></a><a name="iddle3320" class="calibre18" id="iddle3320"></a><a name="iddle3700" class="calibre18" id="iddle3700"></a><a name="iddle4226" class="calibre18" id="iddle4226"></a><a name="iddle4530" class="calibre18" id="iddle4530"></a><a name="iddle4531" class="calibre18" id="iddle4531"></a><a name="iddle4918" class="calibre18" id="iddle4918"></a><a name="iddle4919" class="calibre18" id="iddle4919"></a>only one background task is running at a time. However, it would be better to be notified when the task completes so that, for example, the cancel button could be disabled. We address this in the next section.</p>
<a name="ch09lev2sec4" class="calibre18" id="ch09lev2sec4"></a>
<h4 id="title-IDAEP0HQ" class="docSection2Title">9.3.2. Progress and Completion Indication</h4>
<p class="docText1">Using a <tt class="calibre25">Future</tt> to represent a long-running task greatly simplified implementing cancellation. <tt class="calibre25">FutureTask</tt> also has a <tt class="calibre25">done</tt> hook that similarly facilitates completion notification. After the background <tt class="calibre25">Callable</tt> completes, <tt class="calibre25">done</tt> is called. By having <tt class="calibre25">done</tt> TRigger a completion task in the event thread, we can construct a <tt class="calibre25">BackgroundTask</tt> class providing an <tt class="calibre25">onCompletion</tt> hook that is called in the event thread, as shown in <a class="calibre2" href="ch09lev1sec4.html#ch09list07">Listing 9.7</a>.</p>
<p class="docText1"><tt class="calibre25">BackgroundTask</tt> also supports progress indication. The <tt class="calibre25">compute</tt> method can call <tt class="calibre25">setProgress</tt>, indicating progress in numerical terms. This causes <tt class="calibre25">onProgress</tt> to be called from the event thread, which can update the user interface to indicate progress visually.</p>
<p class="docText1">To implement a <tt class="calibre25">BackgroundTask</tt> you need only implement <tt class="calibre25">compute</tt>, which is called in the background thread. You also have the option of overriding <tt class="calibre25">onCompletion</tt> and <tt class="calibre25">onProgress</tt>, which are invoked in the event thread.</p>
<p class="docText1">Basing <tt class="calibre25">BackgroundTask</tt> on <tt class="calibre25">FutureTask</tt> also simplifies cancellation. Rather than having to poll the thread's interrupted status, <tt class="calibre25">compute</tt> can call <tt class="calibre25">Future. is-Cancelled</tt>. <a class="calibre2" href="ch09lev1sec4.html#ch09list08">Listing 9.8</a> recasts the example from <a class="calibre2" href="#ch09list06">Listing 9.6</a> using <tt class="calibre25">Background-Task</tt>.</p>
<a name="ch09lev2sec5" class="calibre18" id="ch09lev2sec5"></a>
<h4 id="title-IDA0R0HQ" class="docSection2Title">9.3.3. <tt class="calibre33">SwingWorker</tt></h4>
<p class="docText1">We've built a simple framework using <tt class="calibre25">FutureTask</tt> and <tt class="calibre25">Executor</tt> to execute longrunning tasks in background threads without undermining the responsiveness of the GUI. These techniques can be applied to any single-threaded GUI framework, not just Swing. In Swing, many of the features developed here are provided by the <tt class="calibre25">SwingWorker</tt> class, including cancellation, completion notification, and progress indication. Various versions of <tt class="calibre25">SwingWorker</tt> have been published in <span class="docEmphasis">The Swing Connection</span> and <span class="docEmphasis">The Java Tutorial</span>, and an updated version is included in Java 6.</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

