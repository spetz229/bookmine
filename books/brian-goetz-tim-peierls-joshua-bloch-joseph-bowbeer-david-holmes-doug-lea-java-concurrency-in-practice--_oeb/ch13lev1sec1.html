---
layout: page
title: "Java Concurrency in Practice"
prev: ch13.html
next: ch13lev1sec2.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch13lev1sec1" class="calibre18" id="ch13lev1sec1"></a>
<h3 id="title-IDAJGNNJ" class="docSection1Title">13.1. Lock and ReentrantLock</h3>
<p class="docText1">The <tt class="calibre25">Lock</tt> interface, shown in <a class="calibre2" href="#ch13list01">Listing 13.1</a>, defines a number of abstract locking operations. Unlike intrinsic locking, <tt class="calibre25">Lock</tt> offers a choice of unconditional, polled, timed, and interruptible lock acquisition, and all lock and unlock operations are explicit. <tt class="calibre25">Lock</tt> implementations must provide the same memory-visibility semantics as intrinsic locks, but can differ in their locking semantics, scheduling algorithms, ordering guarantees, and performance characteristics. (<tt class="calibre25">Lock.newCondition</tt> is covered in <a class="calibre2" href="ch14.html#ch14">Chapter 14</a>.)</p>
<a name="ch13list01" class="calibre18" id="ch13list01"></a><h5 id="title-IDAMHNNJ" class="docExampleTitle">Listing 13.1. <tt class="calibre33">Lock</tt> Interface.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit)
        throws InterruptedException;
    void unlock();
    Condition newCondition();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><tt class="calibre25">ReentrantLock</tt> implements <tt class="calibre25">Lock</tt>, providing the same mutual exclusion and memory-visibility guarantees as <tt class="calibre25">synchronized</tt>. Acquiring a <tt class="calibre25">ReentrantLock</tt> has the same memory semantics as entering a <tt class="calibre25">synchronized</tt> block, and releasing a <tt class="calibre25">ReentrantLock</tt> has the same memory semantics as exiting a <tt class="calibre25">synchronized</tt> block. <a name="iddle2361" class="calibre18" id="iddle2361"></a><a name="iddle2365" class="calibre18" id="iddle2365"></a><a name="iddle3136" class="calibre18" id="iddle3136"></a><a name="iddle3140" class="calibre18" id="iddle3140"></a><a name="iddle3808" class="calibre18" id="iddle3808"></a><a name="iddle3838" class="calibre18" id="iddle3838"></a><a name="iddle4129" class="calibre18" id="iddle4129"></a>(Memory visibility is covered in <a class="calibre2" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a> and in <a class="calibre2" href="ch16.html#ch16">Chapter 16</a>.) And, like <tt class="calibre25">synchronized</tt>, <tt class="calibre25">ReentrantLock</tt> offers reentrant locking semantics (see <a class="calibre2" href="ch02lev1sec3.html#ch02lev2sec6">Section 2.3.2</a>). <tt class="calibre25">ReentrantLock</tt> supports all of the lock-acquisition modes defined by <tt class="calibre25">Lock</tt>, providing more flexibility for dealing with lock unavailability than does <tt class="calibre25">synchronized</tt>.</p>
<p class="docText1">Why create a new locking mechanism that is so similar to intrinsic locking? Intrinsic locking works fine in most situations but has some functional limitationsit is not possible to interrupt a thread waiting to acquire a lock, or to attempt to acquire a lock without being willing to wait for it forever. Intrinsic locks also must be released in the same block of code in which they are acquired; this simplifies coding and interacts nicely with exception handling, but makes non-blockstructured locking disciplines impossible. None of these are reasons to abandon <tt class="calibre25">synchronized</tt>, but in some cases a more flexible locking mechanism offers better liveness or performance.</p>
<p class="docText1"><a class="calibre2" href="#ch13list02">Listing 13.2</a> shows the canonical form for using a <tt class="calibre25">Lock</tt>. This idiomis somewhat more complicated than using intrinsic locks: the lock <span class="docEmphasis">must</span> be released in a <tt class="calibre25">finally</tt> block. Otherwise, the lock would never be released if the guarded code were to throw an exception. When using locking, you must also consider what happens if an exception is thrown out of the <tt class="calibre25">try</tt> block; if it is possible for the object to be left in an inconsistent state, additional <tt class="calibre25">TRy-catch</tt> or <tt class="calibre25">TRy-finally</tt> blocks may be needed. (You should always consider the effect of exceptions when using any form of locking, including intrinsic locking.)</p>
<p class="docText1">Failing to use <tt class="calibre25">finally</tt> to release a <tt class="calibre25">Lock</tt> is a ticking time bomb. When it goes off, you will have a hard time tracking down its origin as there will be no record of where or when the <tt class="calibre25">Lock</tt> should have been released. This is one reason not to use <tt class="calibre25">ReentrantLock</tt> as a blanket substitute for <tt class="calibre25">synchronized</tt>: it is more "dangerous" because it doesn't automatically clean up the lock when control leaves the guarded block. While remembering to release the lock from a <tt class="calibre25">finally</tt> block is not all that difficult, it is also not impossible to forget.<sup class="docFootnote"><a class="calibre2" href="#ch13fn01">[1]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch13fn01" class="calibre18" id="ch13fn01">[1]</a></sup> FindBugs has an "unreleased lock" detector identifying when a <tt class="calibre35">Lock</tt> is not released in all code paths out of the block in which it was acquired.</p></blockquote>
<a name="ch13list02" class="calibre18" id="ch13list02"></a><h5 id="title-IDAYNNNJ" class="docExampleTitle">Listing 13.2. Guarding Object State Using <tt class="calibre33">ReentrantLock</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">Lock lock = new ReentrantLock();
...
lock.lock();
try {
    <span class="docEmphasis">// update object state</span>
<span class="docEmphasis">// catch exceptions and restore invariants if necessary</span>
} finally {
    lock.unlock();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch13lev2sec1" class="calibre18" id="ch13lev2sec1"></a>
<h4 id="title-IDAQONNJ" class="docSection2Title">13.1.1. Polled and Timed Lock Acquisition</h4>
<p class="docText1"><a name="iddle1813" class="calibre18" id="iddle1813"></a><a name="iddle4984" class="calibre18" id="iddle4984"></a><a name="iddle1302" class="calibre18" id="iddle1302"></a><a name="iddle1318" class="calibre18" id="iddle1318"></a><a name="iddle1448" class="calibre18" id="iddle1448"></a><a name="iddle1812" class="calibre18" id="iddle1812"></a><a name="iddle2804" class="calibre18" id="iddle2804"></a><a name="iddle3052" class="calibre18" id="iddle3052"></a><a name="iddle3055" class="calibre18" id="iddle3055"></a><a name="iddle3058" class="calibre18" id="iddle3058"></a><a name="iddle3098" class="calibre18" id="iddle3098"></a><a name="iddle3605" class="calibre18" id="iddle3605"></a><a name="iddle3670" class="calibre18" id="iddle3670"></a><a name="iddle3671" class="calibre18" id="iddle3671"></a><a name="iddle4175" class="calibre18" id="iddle4175"></a><a name="iddle4685" class="calibre18" id="iddle4685"></a><a name="iddle4906" class="calibre18" id="iddle4906"></a>The timed and polled lock-acqusition modes provided by <tt class="calibre25">TRyLock</tt> allow more sophisticated error recovery than unconditional acquisition. With intrinsic locks, a deadlock is fatalthe only way to recover is to restart the application, and the only defense is to construct your program so that inconsistent lock ordering is impossible. Timed and polled locking offer another option: probabalistic deadlock avoidance.</p>
<p class="docText1">Using timed or polled lock acquisition (<tt class="calibre25">TRyLock</tt>) lets you regain control if you cannot acquire all the required locks, release the ones you did acquire, and try again (or at least log the failure and do something else). <a class="calibre2" href="#ch13list03">Listing 13.3</a> shows an alternate way of addressing the dynamic ordering deadlock from <a class="calibre2" href="ch10lev1sec1.html#ch10lev2sec2">Section 10.1.2</a>: use <tt class="calibre25">TRyLock</tt> to attempt to acquire both locks, but back off and retry if they cannot both be acquired. The sleep time has a fixed component and a random component to reduce the likelihood of livelock. If the locks cannot be acquired within the specified time, <tt class="calibre25">transferMoney</tt> returns a failure status so that the operation can fail gracefully. (See [CPJ 2.5.1.2] and [CPJ 2.5.1.3] for more examples of using polled locks for deadlock avoidance.)</p>
<p class="docText1">Timed locks are also useful in implementing activities that manage a time budget (see <a class="calibre2" href="ch06lev1sec3.html#ch06lev2sec15">Section 6.3.7</a>). When an activity with a time budget calls a blocking method, it can supply a timeout corresponding to the remaining time in the budget. This lets activities terminate early if they cannot deliver a result within the desired time. With intrinsic locks, there is no way to cancel a lock acquisition once it is started, so intrinsic locks put the ability to implement time-budgeted activities at risk.</p>
<p class="docText1">The travel portal example in <a class="calibre2" href="ch06lev1sec4.html#ch06list17">Listing 6.17</a> on page <a class="calibre2" href="ch06lev1sec4.html#ch06list17">134</a> creates a separate task for each car-rental company from which it was soliciting bids. Soliciting a bid probably involves some sort of network-based request mechanism, such as a web service request. But soliciting a bid might also require exclusive access to a scarce resource, such as a direct communications line to the company.</p>
<p class="docText1">We saw one way to ensure serialized access to a resource in <a class="calibre2" href="ch09lev1sec5.html#ch09lev1sec5">Section 9.5</a>: a single-threaded executor. Another approach is to use an exclusive lock to guard access to the resource. The code in <a class="calibre2" href="#ch13list04">Listing 13.4</a> tries to send a message on a shared communications line guarded by a <tt class="calibre25">Lock</tt>, but fails gracefully if it cannot do so within its time budget. The timed <tt class="calibre25">TRyLock</tt> makes it practical to incorporate exclusive locking into such a time-limited activity.</p>
<a name="ch13lev2sec2" class="calibre18" id="ch13lev2sec2"></a>
<h4 id="title-IDA2WNNJ" class="docSection2Title">13.1.2. Interruptible Lock Acquisition</h4>
<p class="docText1">Just as timed lock acquisition allows exclusive locking to be used within timelimited activities, interruptible lock acquisition allows locking to be used within cancellable activities. <a class="calibre2" href="ch07lev1sec1.html#ch07lev2sec6">Section 7.1.6</a> identified several mechanisms, such as acquiring an intrinsic lock, that are not responsive to interruption. These noninterruptible blocking mechanisms complicate the implementation of cancellable tasks. The <tt class="calibre25">lockInterruptibly</tt> method allows you to try to acquire a lock while remaining responsive to interruption, and its inclusion in <tt class="calibre25">Lock</tt> avoids creating another category of non-interruptible blocking mechanisms.</p>
<p class="docText1"></p><a name="ch13list03" class="calibre18" id="ch13list03"></a><h5 id="title-IDAXXNNJ" class="docExampleTitle">Listing 13.3. Avoiding Lock-ordering Deadlock Using <tt class="calibre33">trylock</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public boolean transferMoney(Account fromAcct,
                             Account toAcct,
                             DollarAmount amount,
                             long timeout,
                             TimeUnit unit)
        throws InsufficientFundsException, InterruptedException {
    long fixedDelay = getFixedDelayComponentNanos(timeout, unit);
    long randMod = getRandomDelayModulusNanos(timeout, unit);
    long stopTime = System.nanoTime() + unit.toNanos(timeout);

    while (true) {
        if (fromAcct.lock.tryLock()) {
            try {
                if (toAcct.lock.tryLock()) {
                    try {
                        if (fromAcct.getBalance().compareTo(amount)
                                &lt; 0)
                            throw new InsufficientFundsException();
                        else {
                            fromAcct.debit(amount);
                            toAcct.credit(amount);
                            return true;
                        }
                    } finally {
                        toAcct.lock.unlock();
                    }
                 }
             } finally {
                 fromAcct.lock.unlock();
             }
         }
         if (System.nanoTime() &lt; stopTime)
             return false;
         NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);
     }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"></p><a name="ch13list04" class="calibre18" id="ch13list04"></a><h5 id="title-IDAPYNNJ" class="docExampleTitle">Listing 13.4. Locking with a Time Budget.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public boolean trySendOnSharedLine(String message,
                                   long timeout, TimeUnit unit)
                                   throws InterruptedException {
    long nanosToLock = unit.toNanos(timeout)
                     - estimatedNanosToSend(message);
    if (!lock.tryLock(nanosToLock, NANOSECONDS))
        return false;
    try {
        return sendOnSharedLine(message);
    } finally {
        lock.unlock();
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle1303" class="calibre18" id="iddle1303"></a><a name="iddle3120" class="calibre18" id="iddle3120"></a><a name="iddle4157" class="calibre18" id="iddle4157"></a><a name="iddle4985" class="calibre18" id="iddle4985"></a>The canonical structure of interruptible lock acquisition is slightly more complicated than normal lock acquisition, as two <tt class="calibre25">TRy</tt> blocks are needed. (If the interruptible lock acquisition can throw <tt class="calibre25">InterruptedException</tt>, the standard <tt class="calibre25">try-finally</tt> locking idiom works.) <a class="calibre2" href="#ch13list05">Listing 13.5</a> uses <tt class="calibre25">lockInterruptibly</tt> to implement <tt class="calibre25">sendOnSharedLine</tt> from <a class="calibre2" href="#ch13list04">Listing 13.4</a> so that we can call it from a cancellable task. The timed <tt class="calibre25">TRyLock</tt> is also responsive to interruption and so can be used when you need both timed and interruptible lock acquisition.</p>
<a name="ch13list05" class="calibre18" id="ch13list05"></a><h5 id="title-IDA50NNJ" class="docExampleTitle">Listing 13.5. Interruptible Lock Acquisition.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public boolean sendOnSharedLine(String message)
        throws InterruptedException {
    lock.lockInterruptibly();
    try {
        return cancellableSendOnSharedLine(message);
    } finally {
        lock.unlock();
    }
}

private boolean cancellableSendOnSharedLine(String message)
    throws InterruptedException { ... }
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch13lev2sec3" class="calibre18" id="ch13lev2sec3"></a>
<h4 id="title-IDAP1NNJ" class="docSection2Title">13.1.3. Non-block-structured Locking</h4>
<p class="docText1">With intrinsic locks, acquire-release pairs are block-structureda lock is always released in the same basic block in which it was acquired, regardless of how control exits the block. Automatic lock release simplifies analysis and prevents potential coding errors, but sometimes a more flexible locking discipline is needed.</p>
<p class="docText1"><a name="iddle1449" class="calibre18" id="iddle1449"></a><a name="iddle1587" class="calibre18" id="iddle1587"></a><a name="iddle1588" class="calibre18" id="iddle1588"></a><a name="iddle2611" class="calibre18" id="iddle2611"></a><a name="iddle2838" class="calibre18" id="iddle2838"></a><a name="iddle3084" class="calibre18" id="iddle3084"></a><a name="iddle3104" class="calibre18" id="iddle3104"></a><a name="iddle3115" class="calibre18" id="iddle3115"></a><a name="iddle3138" class="calibre18" id="iddle3138"></a><a name="iddle3139" class="calibre18" id="iddle3139"></a><a name="iddle3521" class="calibre18" id="iddle3521"></a><a name="iddle3813" class="calibre18" id="iddle3813"></a><a name="iddle3814" class="calibre18" id="iddle3814"></a><a name="iddle3836" class="calibre18" id="iddle3836"></a><a name="iddle3837" class="calibre18" id="iddle3837"></a><a name="iddle4069" class="calibre18" id="iddle4069"></a><a name="iddle4070" class="calibre18" id="iddle4070"></a>In <a class="calibre2" href="ch11.html#ch11">Chapter 11</a>, we saw how reducing lock granularity can enhance scalability. Lock striping allows different hash chains in a hash-based collection to use different locks. We can apply a similar principle to reduce locking granularity in a linked list by using a separate lock for <span class="docEmphasis">each link node</span>, allowing different threads to operate independently on different portions of the list. The lock for a given node guards the link pointers and the data stored in that node, so when traversing or modifying the list we must hold the lock on one node until we acquire the lock on the next node; only then can we release the lock on the first node. An example of this technique, called <span class="docEmphasis">hand-over-hand locking</span> or <span class="docEmphasis">lock coupling</span>, appears in [CPJ 2.5.1.4].</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3">Â </p>

</div>

{% endraw %}

