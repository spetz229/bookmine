---
layout: page
title: "Java Concurrency in Practice"
prev: ch14lev1sec3.html
next: ch14lev1sec5.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch14lev1sec4" class="calibre18" id="ch14lev1sec4"></a>
<h3 id="title-IDAX4JSH" class="docSection1Title">14.4. Anatomy of a Synchronizer</h3>
<p class="docText1">The interfaces of <tt class="calibre25">ReentrantLock</tt> and <tt class="calibre25">Semaphore</tt> have a lot in common. Both classes act as a "gate", allowing only a limited number of threads to pass at a time; threads arrive at the gate and are allowed through (<tt class="calibre25">lock</tt> or <tt class="calibre25">acquire</tt> returns successfully), are made to wait (<tt class="calibre25">lock</tt> or <tt class="calibre25">acquire</tt> blocks), or are turned away (<tt class="calibre25">tryLock</tt> or <tt class="calibre25">tryAcquire</tt> returns false, indicating that the lock or permit did not become available in the time allowed). Further, both allow interruptible, uninterruptible, and timed acquisition attempts, and both allow a choice of fair or nonfair queueing of waiting threads.</p>
<p class="docText1">Given this commonality, you might think that <tt class="calibre25">Semaphore</tt> was implemented on top of <tt class="calibre25">ReentrantLock</tt>, or perhaps <tt class="calibre25">ReentrantLock</tt> was implemented as a <tt class="calibre25">Semaphore</tt> with one permit. This would be entirely practical; it is a common exercise to prove that a counting semaphore can be implemented using a lock (as in <tt class="calibre25">SemaphoreOnLock</tt> in <a class="calibre2" href="#ch14list12">Listing 14.12</a>) and that a lock can be implemented using a counting semaphore.</p>
<p class="docText1">In actuality, they are both implemented using a common base class, <tt class="calibre25">Abstract-QueuedSynchronizer</tt> (AQS)as are many other synchronizers. AQS is a framework for building locks and synchronizers, and a surprisingly broad range of synchronizers can be built easily and efficiently using it. Not only are <tt class="calibre25">ReentrantLock</tt> and <tt class="calibre25">Semaphore</tt> built using AQS, but so are <tt class="calibre25">CountDownLatch</tt>, <tt class="calibre25">ReentrantReadWriteLock</tt>, <tt class="calibre25">SynchronousQueue</tt>,<sup class="docFootnote"><a class="calibre2" href="#ch14fn12">[12]</a></sup> and <tt class="calibre25">FutureTask</tt>.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch14fn12" class="calibre18" id="ch14fn12">[12]</a></sup> Java6 replaces the AQS-based <tt class="calibre35">SynchronousQueue</tt> with a (more scalable) nonblocking version.</p></blockquote>
<p class="docText1"></p><a name="ch14list11" class="calibre18" id="ch14list11"></a><h5 id="title-IDAGRHNZ" class="docExampleTitle">Listing 14.11. Bounded Buffer Using Explicit Condition Variables.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class ConditionBoundedBuffer&lt;T&gt; {
    protected final Lock lock = new ReentrantLock();
    <span class="docEmphasis">// CONDITION PREDICATE: <span class="docEmphStrong">notFull</span> (count &lt; items.length)</span>
    private final Condition notFull    = lock.newCondition();
    <span class="docEmphasis">// CONDITION PREDICATE: notEmpty (count &gt; 0)</span>
    private final Condition <span class="docEmphStrong">notEmpty</span>  = lock.newCondition();
    @GuardedBy("lock")
    private final T[] items = (T[]) new Object[BUFFER_SIZE];
    @GuardedBy("lock") private int tail, head, count;

    <span class="docEmphasis">// BLOCKS-UNTIL: notFull</span>
    public void put(T x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                <span class="docEmphStrong">notFull.await();</span>
            items[tail] = x;
            if (++tail == items.length)
                tail = 0;
            ++count;
            <span class="docEmphStrong">notEmpty.signal();</span>
        } finally {
            lock.unlock();
        }
    }

    <span class="docEmphasis">// BLOCKS-UNTIL: notEmpty</span>
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                <span class="docEmphStrong">notEmpty.await();</span>
            T x = items[head];
            items[head] = null;
            if (++head == items.length)
                head = 0;
            --count;
            <span class="docEmphStrong">notFull.signal();</span>
            return x;
        } finally {
            lock.unlock();
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"></p><a name="ch14list12" class="calibre18" id="ch14list12"></a><h5 id="title-IDA0SHNZ" class="docExampleTitle">Listing 14.12. Counting Semaphore Implemented Using <tt class="calibre33">Lock</tt>.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30"><span class="docEmphasis">// Not really how java.util.concurrent.Semaphore is implemented</span>
@ThreadSafe
public class SemaphoreOnLock {
    private final Lock lock = new ReentrantLock();
    <span class="docEmphasis">// CONDITION PREDICATE: permitsAvailable (permits &gt; 0)</span>
    private final Condition permitsAvailable = lock.newCondition();
    @GuardedBy("lock") private int permits;

    SemaphoreOnLock(int initialPermits) {
        lock.lock();
        try {
            permits = initialPermits;
        } finally {
            lock.unlock();
        }
    }

    <span class="docEmphasis">// BLOCKS-UNTIL: permitsAvailable</span>
    public void acquire() throws InterruptedException {
        lock.lock();
        try {
            while (permits &lt;= 0)
                permitsAvailable.await();
            --permits;
        } finally {
            lock.unlock();
        }
    }

    public void release() {
        lock.lock();
        try {
            ++permits;
            permitsAvailable.signal();
        } finally {
            lock.unlock();
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle1703" class="calibre18" id="iddle1703"></a><a name="iddle2174" class="calibre18" id="iddle2174"></a><a name="iddle4152" class="calibre18" id="iddle4152"></a><a name="iddle1117" class="calibre18" id="iddle1117"></a><a name="iddle1600" class="calibre18" id="iddle1600"></a><a name="iddle1601" class="calibre18" id="iddle1601"></a><a name="iddle3049" class="calibre18" id="iddle3049"></a><a name="iddle3050" class="calibre18" id="iddle3050"></a><a name="iddle3063" class="calibre18" id="iddle3063"></a><a name="iddle3064" class="calibre18" id="iddle3064"></a><a name="iddle3834" class="calibre18" id="iddle3834"></a><a name="iddle3835" class="calibre18" id="iddle3835"></a><a name="iddle4088" class="calibre18" id="iddle4088"></a><a name="iddle4089" class="calibre18" id="iddle4089"></a><a name="iddle4404" class="calibre18" id="iddle4404"></a><a name="iddle4405" class="calibre18" id="iddle4405"></a><a name="iddle4592" class="calibre18" id="iddle4592"></a><a name="iddle4593" class="calibre18" id="iddle4593"></a>AQS handles many of the details of implementing a synchronizer, such as FIFO queuing of waiting threads. Individual synchronizers can define flexible criteria for whether a thread should be allowed to pass or be required to wait.</p>
<p class="docText1">Using AQS to build synchronizers offers several benefits. Not only does it substantially reduce the implementation effort, but you also needn't pay for multiple points of contention, as you would when constructing one synchronizer on top of another. In <tt class="calibre25">SemaphoreOnLock</tt>, acquiring a permit has two places where it might blockonce at the lock guarding the semaphore state, and then again if a permit is not available. Synchronizers built with AQS have only one point where they might block, reducing context-switch overhead and improving throughput. AQS was designed for scalability, and all the synchronizers in <tt class="calibre25">java.util.concurrent</tt> that are built with AQS benefit from this.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3">Â </p>

</div>

{% endraw %}

