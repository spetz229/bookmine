---
layout: page
title: "Java Concurrency in Practice"
prev: ch14lev1sec2.html
next: ch14lev1sec4.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch14lev1sec3" class="calibre18" id="ch14lev1sec3"></a>
<h3 id="title-IDAA45AH" class="docSection1Title">14.3. Explicit Condition Objects</h3>
<p class="docText1">As we saw in <a class="calibre2" href="ch13.html#ch13">Chapter 13</a>, explicit <tt class="calibre25">Lock</tt>s can be useful in some situations where intrinsic locks are too inflexible. Just as <tt class="calibre25">Lock</tt> is a generalization of intrinsic locks, <tt class="calibre25">Condition</tt> (see <a class="calibre2" href="#ch14list10">Listing 14.10</a>) is a generalization of intrinsic condition queues.</p>
<p class="docText1"><a name="iddle1495" class="calibre18" id="iddle1495"></a><a name="iddle1515" class="calibre18" id="iddle1515"></a><a name="iddle1516" class="calibre18" id="iddle1516"></a><a name="iddle1789" class="calibre18" id="iddle1789"></a><a name="iddle1790" class="calibre18" id="iddle1790"></a><a name="iddle2506" class="calibre18" id="iddle2506"></a><a name="iddle2507" class="calibre18" id="iddle2507"></a><a name="iddle2798" class="calibre18" id="iddle2798"></a><a name="iddle3041" class="calibre18" id="iddle3041"></a><a name="iddle4895" class="calibre18" id="iddle4895"></a><a name="iddle4896" class="calibre18" id="iddle4896"></a><a name="iddle5137" class="calibre18" id="iddle5137"></a><a name="iddle5138" class="calibre18" id="iddle5138"></a><a name="iddle5141" class="calibre18" id="iddle5141"></a>Intrinsic condition queues have several drawbacks. Each intrinsic lock can have only one associated condition queue, which means that in classes like <tt class="calibre25">BoundedBuffer</tt> multiple threads might wait on the same condition queue for different condition predicates, and the most common pattern for locking involves exposing the condition queue object. Both of these factors make it impossible to enforce the uniform waiter requirement for using <tt class="calibre25">notifyAll</tt>. If you want to write a concurrent object with multiple condition predicates, or you want to exercise more control over the visibility of the condition queue, the explicit <tt class="calibre25">Lock</tt> and <tt class="calibre25">Condition</tt> classes offer a more flexible alternative to intrinsic locks and condition queues.</p>
<p class="docText1">A <tt class="calibre25">Condition</tt> is associated with a single <tt class="calibre25">Lock</tt>, just as a condition queue is associated with a single intrinsic lock; to create a <tt class="calibre25">Condition</tt>, call <tt class="calibre25">Lock.newCondition</tt> on the associated lock. And just as <tt class="calibre25">Lock</tt> offers a richer feature set than intrinsic locking, <tt class="calibre25">Condition</tt> offers a richer feature set than intrinsic condition queues: multiple wait sets per lock, interruptible and uninterruptible condition waits, deadline-based waiting, and a choice of fair or nonfair queueing.</p>
<a name="ch14list10" class="calibre18" id="ch14list10"></a><h5 id="title-IDAJF3XF" class="docExampleTitle">Listing 14.10. <tt class="calibre33">Condition</tt> Interface.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public interface Condition {
    void await() throws InterruptedException;
    boolean await(long time, TimeUnit unit)
            throws InterruptedException;
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    void awaitUninterruptibly();
    boolean awaitUntil(Date deadline) throws InterruptedException;

    void signal();
    void signalAll();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Unlike intrinsic condition queues, you can have as many <tt class="calibre25">Condition</tt> objects per <tt class="calibre25">Lock</tt> as you want. <tt class="calibre25">Condition</tt> objects inherit the fairness setting of their associated <tt class="calibre25">Lock</tt>; for fair locks, threads are released from <tt class="calibre25">Condition.await</tt> in FIFO order.</p>
<a name="ch14sb06" class="calibre18" id="ch14sb06"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1"><b class="calibre9">Hazard warning:</b> The equivalents of <tt class="calibre25">wait</tt>, <tt class="calibre25">notify</tt>, and <tt class="calibre25">notifyAll</tt> for <tt class="calibre25">Condition</tt> objects are <tt class="calibre25">await</tt>, <tt class="calibre25">signal</tt>, and <tt class="calibre25">signalAll</tt>. However, <tt class="calibre25">Condition</tt> extends <tt class="calibre25">Object</tt>, which means that it also has <tt class="calibre25">wait</tt> and <tt class="calibre25">notify</tt> methods. Be sure to use the proper versions<tt class="calibre25">await</tt> and <tt class="calibre25">signal</tt>instead!</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1"><a class="calibre2" href="ch14lev1sec4.html#ch14list11">Listing 14.11</a> shows yet another bounded buffer implementation, this time using two <tt class="calibre25">Condition</tt>s, <tt class="calibre25">notFull</tt> and <tt class="calibre25">notEmpty</tt>, to represent explicitly the "not full" and "not empty" condition predicates. When <tt class="calibre25">take</tt> blocks because the buffer is empty, it waits on <tt class="calibre25">notEmpty</tt>, and <tt class="calibre25">put</tt> unblocks any threads blocked in <tt class="calibre25">take</tt> by signaling on <tt class="calibre25">notEmpty</tt>.</p>
<p class="docText1"><a name="iddle2102" class="calibre18" id="iddle2102"></a><a name="iddle1016" class="calibre18" id="iddle1016"></a><a name="iddle1104" class="calibre18" id="iddle1104"></a><a name="iddle1105" class="calibre18" id="iddle1105"></a><a name="iddle1106" class="calibre18" id="iddle1106"></a><a name="iddle1116" class="calibre18" id="iddle1116"></a><a name="iddle1497" class="calibre18" id="iddle1497"></a><a name="iddle1498" class="calibre18" id="iddle1498"></a><a name="iddle1502" class="calibre18" id="iddle1502"></a><a name="iddle1595" class="calibre18" id="iddle1595"></a><a name="iddle1619" class="calibre18" id="iddle1619"></a><a name="iddle2101" class="calibre18" id="iddle2101"></a><a name="iddle2403" class="calibre18" id="iddle2403"></a><a name="iddle2404" class="calibre18" id="iddle2404"></a><a name="iddle2405" class="calibre18" id="iddle2405"></a><a name="iddle2406" class="calibre18" id="iddle2406"></a><a name="iddle2407" class="calibre18" id="iddle2407"></a><a name="iddle3077" class="calibre18" id="iddle3077"></a><a name="iddle3817" class="calibre18" id="iddle3817"></a><a name="iddle4143" class="calibre18" id="iddle4143"></a><a name="iddle4192" class="calibre18" id="iddle4192"></a><a name="iddle4193" class="calibre18" id="iddle4193"></a><a name="iddle4278" class="calibre18" id="iddle4278"></a><a name="iddle4279" class="calibre18" id="iddle4279"></a><a name="iddle4591" class="calibre18" id="iddle4591"></a>The behavior of <tt class="calibre25">ConditionBoundedBuffer</tt> is the same as <tt class="calibre25">BoundedBuffer</tt>, but its use of condition queues is more readableit is easier to analyze a class that uses multiple <tt class="calibre25">Condition</tt>s than one that uses a single intrinsic condition queue with multiple condition predicates. By separating the two condition predicates into separate wait sets, <tt class="calibre25">Condition</tt> makes it easier to meet the requirements for single notification. Using the more efficient <tt class="calibre25">signal</tt> instead of <tt class="calibre25">signalAll</tt> reduces the number of context switches and lock acquisitions triggered by each buffer operation.</p>
<p class="docText1">Just as with built-in locks and condition queues, the three-way relationship among the lock, the condition predicate, and the condition variable must also hold when using explicit <tt class="calibre25">Lock</tt>s and <tt class="calibre25">Condition</tt>s. The variables involved in the condition predicate must be guarded by the <tt class="calibre25">Lock</tt>, and the <tt class="calibre25">Lock</tt> must be held when testing the condition predicate and when calling <tt class="calibre25">await</tt> and <tt class="calibre25">signal</tt>.<sup class="docFootnote"><a class="calibre2" href="#ch14fn11">[11]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch14fn11" class="calibre18" id="ch14fn11">[11]</a></sup> <tt class="calibre35">ReentrantLock</tt> requires that the <tt class="calibre35">Lock</tt> be held when calling <tt class="calibre35">signal</tt> or <tt class="calibre35">signalAll</tt>, but <tt class="calibre35">Lock</tt> implementations are permitted to construct <tt class="calibre35">Condition</tt>s that do not have this requirement.</p></blockquote>
<p class="docText1">Choose between using explicit <tt class="calibre25">Condition</tt>s and intrinsic condition queues in the same way as you would choose between <tt class="calibre25">ReentrantLock</tt> and <tt class="calibre25">synchronized</tt>: use <tt class="calibre25">Condition</tt> if you need its advanced features such as fair queueing or multiple wait sets per lock, and otherwise prefer intrinsic condition queues. (If you already use <tt class="calibre25">ReentrantLock</tt> because you need its advanced features, the choice is already made.)</p>

<p class="calibre1"> </p>

</div>

{% endraw %}

