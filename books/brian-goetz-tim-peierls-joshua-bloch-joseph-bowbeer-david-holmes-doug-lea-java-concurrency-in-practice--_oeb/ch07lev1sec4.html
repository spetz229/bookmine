---
layout: page
title: "Java Concurrency in Practice"
prev: ch07lev1sec3.html
next: ch07lev1sec5.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch07lev1sec4" class="calibre18" id="ch07lev1sec4"></a>
<h3 id="title-IDAXY35S" class="docSection1Title">7.4. JVM Shutdown</h3>
<p class="docText1"><a name="iddle1010" class="calibre18" id="iddle1010"></a><a name="iddle1355" class="calibre18" id="iddle1355"></a><a name="iddle2356" class="calibre18" id="iddle2356"></a><a name="iddle2357" class="calibre18" id="iddle2357"></a><a name="iddle2648" class="calibre18" id="iddle2648"></a><a name="iddle2649" class="calibre18" id="iddle2649"></a><a name="iddle2650" class="calibre18" id="iddle2650"></a><a name="iddle2651" class="calibre18" id="iddle2651"></a><a name="iddle2922" class="calibre18" id="iddle2922"></a><a name="iddle2924" class="calibre18" id="iddle2924"></a><a name="iddle3419" class="calibre18" id="iddle3419"></a><a name="iddle4166" class="calibre18" id="iddle4166"></a><a name="iddle4247" class="calibre18" id="iddle4247"></a><a name="iddle4248" class="calibre18" id="iddle4248"></a><a name="iddle4254" class="calibre18" id="iddle4254"></a><a name="iddle4255" class="calibre18" id="iddle4255"></a><a name="iddle4256" class="calibre18" id="iddle4256"></a><a name="iddle4259" class="calibre18" id="iddle4259"></a><a name="iddle4293" class="calibre18" id="iddle4293"></a><a name="iddle4731" class="calibre18" id="iddle4731"></a><a name="iddle4975" class="calibre18" id="iddle4975"></a>The JVM can shut down in either an <span class="docEmphasis">orderly</span> or <span class="docEmphasis">abrupt</span> manner. An orderly shutdown is initiated when the last "normal" (nondaemon) thread terminates, someone calls <tt class="calibre25">System.exit</tt>, or by other platform-specific means (such as sending a <tt class="calibre25">SIGINT</tt> or hitting <tt class="calibre25">Ctrl-C</tt>). While this is the standard and preferred way for the JVM to shut down, it can also be shut down abruptly by calling <tt class="calibre25">Runtime.halt</tt> or by killing the JVM process through the operating system (such as sending a <tt class="calibre25">SIGKILL</tt>).</p>
<a name="ch07lev2sec14" class="calibre18" id="ch07lev2sec14"></a>
<h4 id="title-IDAMY4TX" class="docSection2Title">7.4.1. Shutdown Hooks</h4>
<p class="docText1">In an orderly shutdown, the JVM first starts all registered <span class="docEmphasis">shutdown hooks</span>. Shutdown hooks are unstarted threads that are registered with <tt class="calibre25">Runtime.addShutdownHook</tt>. The JVM makes no guarantees on the order in which shutdown hooks are started. If any application threads (daemon or nondaemon) are still running at shutdown time, they continue to run concurrently with the shutdown process. When all shutdown hooks have completed, the JVM may choose to run finalizers if <tt class="calibre25">runFinalizersOnExit</tt> is <tt class="calibre25">true</tt>, and then halts. The JVM makes no attempt to stop or interrupt any application threads that are still running at shutdown time; they are abruptly terminated when the JVM eventually halts. If the shutdown hooks or finalizers don't complete, then the orderly shutdown process "hangs" and the JVM must be shut down abruptly. In an abrupt shutdown, the JVM is not required to do anything other than halt the JVM; shutdown hooks will not run.</p>
<p class="docText1">Shutdown hooks should be thread-safe: they must use synchronization when accessing shared data and should be careful to avoid deadlock, just like any other concurrent code. Further, they should not make assumptions about the state of the application (such as whether other services have shut down already or all normal threads have completed) or about why the JVM is shutting down, and must therefore be coded extremely defensively. Finally, they should exit as quickly as possible, since their existence delays JVM termination at a time when the user may be expecting the JVM to terminate quickly.</p>
<p class="docText1">Shutdown hooks can be used for service or application cleanup, such as deleting temporary files or cleaning up resources that are not automatically cleaned up by the OS. <a class="calibre2" href="#ch07list26">Listing 7.26</a> shows how <tt class="calibre25">LogService</tt> in <a class="calibre2" href="ch07lev1sec2.html#ch07list16">Listing 7.16</a> could register a shutdown hook from its <tt class="calibre25">start</tt> method to ensure the log file is closed on exit.</p>
<p class="docText1">Because shutdown hooks all run concurrently, closing the log file could cause trouble for other shutdown hooks who want to use the logger. To avoid this problem, shutdown hooks should not rely on services that can be shut down by the application or other shutdown hooks. One way to accomplish this is to use a single shutdown hook for all services, rather than one for each service, and have it call a series of shutdown actions. This ensures that shutdown actions execute sequentially in a single thread, thus avoiding the possibility of race conditions or deadlock between shutdown actions. This technique can be used whether or not you use shutdown hooks; executing shutdown actions sequentially rather than concurrently eliminates many potential sources of failure. In applications <a name="iddle1745" class="calibre18" id="iddle1745"></a><a name="iddle2358" class="calibre18" id="iddle2358"></a><a name="iddle2603" class="calibre18" id="iddle2603"></a><a name="iddle2604" class="calibre18" id="iddle2604"></a><a name="iddle2923" class="calibre18" id="iddle2923"></a><a name="iddle3293" class="calibre18" id="iddle3293"></a><a name="iddle3294" class="calibre18" id="iddle3294"></a><a name="iddle3922" class="calibre18" id="iddle3922"></a><a name="iddle4257" class="calibre18" id="iddle4257"></a><a name="iddle4766" class="calibre18" id="iddle4766"></a>that maintain explicit dependency information among services, this technique can also ensure that shutdown actions are performed in the right order.</p>
<a name="ch07list26" class="calibre18" id="ch07list26"></a><h5 id="title-IDAF34TX" class="docExampleTitle">Listing 7.26. Registering a Shutdown Hook to Stop the Logging Service.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public void start() {
    Runtime.getRuntime().addShutdownHook(new Thread() {
        public void run() {
            try { LogService.this.stop(); }
            catch (InterruptedException ignored) {}
        }
    });
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch07lev2sec15" class="calibre18" id="ch07lev2sec15"></a>
<h4 id="title-IDAV34TX" class="docSection2Title">7.4.2. Daemon Threads</h4>
<p class="docText1">Sometimes you want to create a thread that performs some helper function but you don't want the existence of this thread to prevent the JVM from shutting down. This is what <span class="docEmphasis">daemon threads</span> are for.</p>
<p class="docText1">Threads are divided into two types: normal threads and daemon threads. When the JVM starts up, all the threads it creates (such as garbage collector and other housekeeping threads) are daemon threads, except the main thread. When a new thread is created, it inherits the daemon status of the thread that created it, so by default any threads created by the main thread are also normal threads.</p>
<p class="docText1">Normal threads and daemon threads differ only in what happens when they exit. When a thread exits, the JVM performs an inventory of running threads, and if the only threads that are left are daemon threads, it initiates an orderly shutdown. When the JVM halts, any remaining daemon threads are abandoned<tt class="calibre25">finally</tt> blocks are not executed, stacks are not unwoundthe JVM just exits.</p>
<p class="docText1">Daemon threads should be used sparinglyfew processing activities can be safely abandoned at any time with no cleanup. In particular, it is dangerous to use daemon threads for tasks that might perform any sort of I/O. Daemon threads are best saved for "housekeeping" tasks, such as a background thread that periodically removes expired entries from an in-memory cache.</p>
<a name="ch07sb09" class="calibre18" id="ch07sb09"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Daemon threads are not a good substitute for properly managing the lifecycle of services within an application.</p>
</td></tr></table></p><p class="calibre1">Â </p>
<a name="ch07lev2sec16" class="calibre18" id="ch07lev2sec16"></a>
<h4 id="title-IDAW44TX" class="docSection2Title">7.4.3. Finalizers</h4>
<p class="docText1">The garbage collector does a good job of reclaiming memory resources when they are no longer needed, but some resources, such as file or socket handles, must be explicitly returned to the operating system when no longer needed. To assist in <a name="iddle1985" class="calibre18" id="iddle1985"></a><a name="iddle2528" class="calibre18" id="iddle2528"></a><a name="iddle4468" class="calibre18" id="iddle4468"></a>this, the garbage collector treats objects that have a nontrivial <tt class="calibre25">finalize</tt> method specially: after they are reclaimed by the collector, <tt class="calibre25">finalize</tt> is called so that persistent resources can be released.</p>
<p class="docText1">Since finalizers can run in a thread managed by the JVM, any state accessed by a finalizer will be accessed by more than one thread and therefore must be accessed with synchronization. Finalizers offer no guarantees on when or even if they run, and they impose a significant performance cost on objects with nontrivial finalizers. They are also extremely difficult to write correctly.<sup class="docFootnote"><a class="calibre2" href="#ch07fn09">[9]</a></sup> In most cases, the combination of <tt class="calibre25">finally</tt> blocks and explicit <tt class="calibre25">close</tt> methods does a better job of resource management than finalizers; the sole exception is when you need to manage objects that hold resources acquired by native methods. For these reasons and others, work hard to avoid writing or using classes with finalizers (other than the platform library classes) [EJ Item 6].</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch07fn09" class="calibre18" id="ch07fn09">[9]</a></sup> See (<a class="calibre2" href="bib01.html#biblio01_006">Boehm, 2005</a>) for some of the challenges involved in writing finalizers.</p></blockquote>
<a name="ch07sb10" class="calibre18" id="ch07sb10"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Avoid finalizers.</p>
</td></tr></table></p><p class="calibre1">Â </p>

<p class="calibre1">Â </p>

</div>

{% endraw %}

