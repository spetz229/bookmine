---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0064.html
next: f_0066.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 class="calibre13">A1.5 Server-Side Apps with Node.js</h2>
<p id="N147E1" class="calibre5">Answers to Section 6.6, <a href="f_0059.html#sec.nodeExercises">​<em class="emph">Exercises</em>​</a>:</p>
<ol class="calibre24">
<li class="calibre3">
<p id="N147EA" class="calibre5">
          The code given is, alas, an infinite loop:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">countdown = 10</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">h = setInterval (<strong class="prompt">-&gt;</strong> countdown--), 100</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">do</strong> (<strong class="prompt">-&gt;</strong>) <strong class="prompt">until</strong> countdown is 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">clearInterval h</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log <em class="string">'Surprise!'</em>
</code>
</td>
</tr>
</table>
<p id="N14811" class="calibre5">
           No matter how many hundreds of milliseconds pass, <code class="cf">countdown</code> will never decrease, because the loop code never finishes running. Here’s a working version:
        </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">countdown = 10</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">decreaseCountdown = <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  countdown--</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">if</strong> countdown is 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    clearInterval h</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    console.log <em class="string">'Surprise!'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">h = setInterval decreaseCountdown, 100</code>
</td>
</tr>
</table>
<p id="N1483B" class="calibre5">
          Note that it’s not a problem that <code class="cf">h</code> doesn’t exist yet when we write the line <code class="cf">clearInterval h</code>. When the line is run, the program will see that there’s no <code class="cf">h</code> in the current scope, check the outer scope, and thus find the handle returned by <code class="cf">setInterval</code>. Such nonlinear thinking is, alas, the price we pay to be rid of the scourge of threads.
        </p>
</li>
</ol>

<div class="copyright">Copyright © 2011, The Pragmatic Bookshelf.</div>




<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

