---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0023.html
next: f_0025.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.functionsProject" class="calibre13">2.7 Project: 5x5 Input Parser</h2>
<p id="N1156A" class="calibre5">
      Remember our little word game idea (see <a href="f_0009.html#sec.5x5">​<em class="emph">About the Example Project: 5x5</em>​</a>)? Well, it’s time to turn it into a reality! Now, we don’t know enough about hashes, arrays, and loops yet to implement a fully working version (omissions we’ll rectify in Chapter 3, <a href="f_0027.html#chp.collections">​<em class="emph">Collections and Iteration</em>​</a>). Still, we can at least get our feet wet by writing a command-line prompt using Node.js.
    </p>
<p id="N1157A" class="calibre5">
      But before we get started, we need to understand nonblocking IO. In most languages, we could write something like this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">input = getInput()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment"># now process input...</em>
</code>
</td>
</tr>
</table>
<p id="N11597" class="calibre5">
      The <code class="cf">getInput</code> function would wait for the user to type something and then returns it. This is called <span class="emph">blocking</span> IO, because <code class="cf">getInput</code> would “block” the execution of our program until the input is available.
    </p>
<p id="N115A6" class="calibre5">
      However, we can’t do this with Node because its IO is <span class="emph">nonblocking</span> (with the exception of a handful of convenience functions whose names end with <code class="cf">Sync</code>). Instead, we need to give Node a callback, which will get run whenever there’s an input event. (We’ll go into more depth on Node’s event model in Section 6.3, <a href="f_0056.html#sec.async">​<em class="emph">Thinking Asynchronously</em>​</a>.) The closest analog to the above in Node is this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">stdin.on <em class="string">'data'</em>, (input) <strong class="prompt">-&gt;</strong>
<em class="comment"></em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="comment">  # now process input...</em>
</code>
</td>
</tr>
</table>
<p id="N115C7" class="calibre5">
      (The <code class="cf">stdin</code> object requires some initialization, which we’ll get to in a moment.) If you’re used to blocking IO, the transition to nonblocking IO can be jarring. But the benefits can be tremendous, because waiting for input (and, to a lesser extent, output) has long been a major source of performance degradation and limited scalability. Neither of these is really a big issue in this particular app, but designing applications to keep running while waiting for input is a good habit to develop, and Node essentially forces you to. The only way to write a blocking function is to create a native extension in C++.
    </p>
<p id="N115D3" class="calibre5">
      So let’s think a little bit about the structure of our app. Here’s what we need it to do:
    </p>
<ol class="calibre24">
<li class="calibre3">
<p id="N115D9" class="calibre5">
        Prompt for coordinates (<code class="cf">x, y</code>) for the first tile.
      </p>
</li>
<li class="calibre3">
<p id="N115E0" class="calibre5">
        If the input is valid (two integers, each between 1 and the size of the grid), then prompt for the coordinates of the second tile.
      </p>
</li>
<li class="calibre3">
<p id="N115E4" class="calibre5">
        Validate the input again. If it passes, say we’re swapping the two tiles. If it fails, explain why and offer a chance to try again.
      </p>
</li>
</ol>
<p id="N115E7" class="calibre5">
      Let’s start by “opening” the standard input:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">stdin = process.openStdin()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">stdin.setEncoding <em class="string">'utf8'</em>
</code>
</td>
</tr>
</table>
<p id="N115FB" class="calibre5">
      Where did <code class="cf">process</code> come from? It’s part of the Node environment, one of the few parts that doesn’t require a <code class="cf">require</code> statement to access. <code class="cf">process</code> provides methods for getting command-line arguments, managing memory, and, of course, dealing with standard IO.
    </p>
<p id="N1160B" class="calibre5">
      If we run the app at this point (with <code class="cf">coffee prompt.coffee</code>), we get a never-ending series of prompts. (<code class="cf">Ctrl</code>-<code class="cf">c</code> is your friend.) Each time you hit <code class="cf">Return</code>, Node looks for a callback to pass that input to. Since we haven’t given it a callback, nothing happens. Let’s fix that, shall we?
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">inputCallback = <strong class="prompt">null</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">stdin.on <em class="string">'data'</em>, (input) <strong class="prompt">-&gt;</strong> inputCallback input</code>
</td>
</tr>
</table>
<p id="N11631" class="calibre5">
      The <code class="cf">stdin.on ’data’</code> call tells Node, “Each time a new line of input comes in, pass it to this function.” That function simply forwards the input to another function, <code class="cf">inputCallback</code>. Or rather, <code class="cf">inputCallback</code> will be a function later—right now it’s just <code class="cf">null</code>. Why are we doing this? Because this proxy function makes it easy to change the callback behavior. The <code class="cf">inputCallback = null</code> line (where <code class="cf">null</code> is arbitrary) tells the compiler to give the variable module-level scope, allowing it to be modified outside of the anonymous function.
    </p>
<p id="N11646" class="calibre5">
      Note that if we tried to set multiple callbacks on <code class="cf">stdin.on ’data’</code>, they would simply “stack,” so each one would be called every time new input came in. We could unbind the existing callback using <code class="cf">stdin.removeListener</code> if we stored a reference to the listener, but that would entail a two-step process (unbind, bind). Instead, we just change the value of <code class="cf">inputCallback</code>.
      </p>
<p id="N11655" class="calibre5">
      Our simple app will have two “states”: prompting for the coordinates of the first tile and prompting for those of the second. Going into a state is a simple matter of displaying a message and then setting <code class="cf">inputCallback</code>:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">promptForTile1 = <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"Please enter coordinates for the first tile."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  inputCallback = (input) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    promptForTile2() <strong class="prompt">if</strong> strToCoordinates input</code>
</td>
</tr>
</table>
<p id="N11679" class="calibre5">
      When new input comes in, the callback checks with the not-yet-defined <code class="cf">strToCoordinates</code> function; if it gives the go-ahead, we pass control to the mirror image prompt for the second tile of the move:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">promptForTile2 = <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"Please enter coordinates for the second tile."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  inputCallback = (input) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">if</strong> strToCoordinates input</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log <em class="string">"Swapping tiles...done!"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      promptForTile1()</code>
</td>
</tr>
</table>
<p id="N116A6" class="calibre5">
      Now, what’s this about validation? Well, first let’s write a simple test for whether a (zero-indexed) <code class="cf">x, y</code> pair is on the grid or not:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">GRID_SIZE = 5</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">inRange = (x, y) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  0 &lt;= x &lt; GRID_SIZE and 0 &lt;= y &lt; GRID_SIZE</code>
</td>
</tr>
</table>
<p id="N116C6" class="calibre5">
<code class="cf">GRID_SIZE</code> is in all-caps to indicate that it’s a constant (a stylistic convention for us humans, not the compiler). The function takes advantage of CoffeeScript’s chained comparisons feature: <code class="cf">0 &lt;= x &lt; GRID_SIZE</code> is shorthand for <code class="cf">(0 &lt;= x) and (x &lt; GRID_SIZE)</code>.
    </p>
<p id="N116D4" class="calibre5">
      Here’s another simple test for whether a number is an integer:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">isInteger = (num) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  num is Math.round(num)</code>
</td>
</tr>
</table>
<p id="N116E8" class="calibre5">
      Now let’s use these to make a magical string-to-coordinate converter, complete with handy error messages:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">strToCoordinates = (input) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  halves = input.split(<em class="string">','</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">if</strong> halves.length is 2</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    x = parseFloat halves[0]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    y = parseFloat halves[1]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">if</strong> !isInteger(x) or !isInteger(y)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log <em class="string">"Each coordinate must be an integer."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">else</strong> <strong class="prompt">if</strong> not inRange x - 1, y - 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      console.log <em class="string">"Each coordinate must be between 1 and </em>#{GRID_SIZE}<em class="string">."</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      {x, y}</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    console.log <em class="string">'Input must be of the form `x, y`.'</em>
</code>
</td>
</tr>
</table>
<p id="N11739" class="calibre5">
      You might wonder how this works for the <code class="cf">if</code> conditions in the two <code class="cf">inputCallback</code> implementations. Well, <code class="cf">console.log</code> returns <code class="cf">undefined</code>, which gets coerced to <code class="cf">false</code> by condition checks, and any nonempty object gets coerced to <code class="cf">true</code>. So, we either return <code class="cf">{x, y}</code> or we give an error message, and all our boolean needs are taken care of for us.
    </p>
<p id="N11751" class="calibre5">
      Now there’s just one piece missing: we need to start in one of our states so that <code class="cf">inputCallback</code> gets defined before it’s called:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Functions/5x5/prompt.coffee" class="calibre23">Functions/5x5/prompt.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log <em class="string">"Welcome to 5x5!"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">promptForTile1()</code>
</td>
</tr>
</table>
<p id="N11768" class="calibre5">
      And that’s it! Run <code class="cf">prompt.coffee</code> to try it for yourself. It should look like Figure 3, <a href="#fig.5x5_prompt">​<em class="emph">Playing with our command-line prompt</em>​</a>.
    </p>
<table class="figure" id="fig.5x5_prompt">
<tr class="calibre8">
<td class="calibre10">
<img xmlns:str="http://exslt.org/strings" src="images/5x5_prompt.png" alt="images/5x5_prompt.png" class="calibre18"/>
</td>
</tr>
<tr class="calibre8">
<td class="calibre19">
<hr class="calibre20"/>
<b class="calibre21">Figure 3. Playing with our command-line prompt</b>
</td>
</tr>
</table>
<p id="N1177B" class="calibre5">
      Hopefully you’ve developed an appreciation for the power and syntactic ease of CoffeeScript functions. In the next chapter, we’ll learn about working with objects and arrays, and we’ll turn our little experiment in standard IO into a full-fledged game.
    </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

