---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0022.html
next: f_0024.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.splats" class="calibre13">2.6 Splats (...)</h2>
<p id="N11423" class="calibre5">
      Taking a varying number of arguments is both easy and hard in JavaScript: it’s easy because every argument passed to a function (regardless of the number in the function’s declaration) is available from the <code class="cf">arguments</code> object, and it’s hard because <code class="cf">arguments</code> doesn’t support standard <code class="cf">Array</code> methods like <code class="cf">slice</code> and <code class="cf">shift</code>.
    </p>
<p id="N1144D" class="calibre5">
      Fortunately, CoffeeScript lets you convert any range of arguments to an array automatically. Just add an ellipsis, <code class="cf">...</code> (also known as “the splat”), to the end of any argument name:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">refine = (wheat, chaff...) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"The best: </em>#{wheat}<em class="string">"</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log <em class="string">"The rest: </em>#{chaff.join(<em class="string">', '</em>)}<em class="string">"</em>
</code>
</td>
</tr>
</table>
<p id="N11473" class="calibre5">
      The splat here means “take every argument after the first one, <code class="cf">wheat</code>, and combine them into an array, <code class="cf">chaff</code>.” Calling <code class="cf">refine</code> with a list of four arguments results in the following:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">refine <em class="string">'great'</em>, <em class="string">'not bad'</em>, <em class="string">'so-so'</em>, <em class="string">'meh'</em>
</code>
</td>
</tr>
</table>
<p id="N11495" class="calibre5"></p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">The best: great</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">The rest: not bad, so-so, meh</code>
</td>
</tr>
</table>
<p id="N114A5" class="calibre5">
      If just one argument is given, or if none are, then <code class="cf">chaff</code> will just be an empty array.
    </p>
<p id="N114AB" class="calibre5">
      A splatted argument doesn’t have to go at the end of an argument list. The CoffeeScript compiler is smart about determining the appropriate arguments to put in the array:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">sandwich = (beginning, middle..., end) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  ...</code>
</td>
</tr>
</table>
<p id="N114BE" class="calibre5">
      Nonsplatted arguments always get filled in first. So if <code class="cf">sandwich</code> is called with only two arguments, those will become <code class="cf">beginning</code> and <code class="cf">end</code>. Only when there are three or more arguments is there a <code class="cf">middle</code>. <span class="emph">Splats soak up any and all extra arguments.</span>
</p>
<p id="N114CF" class="calibre5">
      Even if the splat comes first, the plain arguments take priority:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">spoiler = (filler..., theEnding) <strong class="prompt">-&gt;</strong> console.log theEnding</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">spoiler <em class="string">'Darth Vader is Luke\'s father!'</em>
</code>
</td>
</tr>
</table>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Darth Vader is Luke's father!</code>
</td>
</tr>
</table>
<p id="N114F0" class="calibre5">
      Of course, it only makes sense to have one splatted argument in a given function. Otherwise, the splats would have to duke it out over how to split the arguments amongst themselves.
    </p>
<p id="N114F3" class="calibre5">
      It’s worth mentioning that splats can also be used to divvy up arrays on the fly without the use of a function. Go ahead and launch the REPL (just run <code class="cf">coffee</code> with no arguments, remember?) and play with this feature a little:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> birds = ['duck', 'duck', 'duck', 'duck', 'goose!']</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> [ducks..., goose] = birds</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> ducks</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">duck,duck,duck,duck</code>
</td>
</tr>
</table>
<p id="N11516" class="calibre5">
      We’ll learn more about this syntax in Section 3.6, <a href="f_0033.html#sec.patternMatching">​<em class="emph">Pattern Matching (or, Destructuring Assignment)</em>​</a>.
      </p>
<p id="N11522" class="calibre5">
      In a function call, splats mean precisely the inverse of what they mean in argument lists and pattern-matching assignments: they expand an array into a series of arguments, rather than collapsing a series of arguments into an array. Let’s go to the REPL again:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> console.log 1, 2, 3, 4</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">1 2 3 4</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> arr = [1, 2, 3]</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> console.log arr, 4</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">[ 1, 2, 3 ] 4</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">coffee&gt;<strong class="prompt"> console.log arr..., 4</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">1 2 3 4</code>
</td>
</tr>
</table>
<p id="N11553" class="calibre5">
      As you might have guessed, this syntax uses <code class="cf">apply</code> (which we met in Section 2.3, <a href="f_0020.html#sec.context">​<em class="emph">Context (or, “What Is ’this’?”)</em>​</a>) behind the scenes.
      </p>
<p id="N11562" class="calibre5">
    Hopefully this chapter has given you a lot to take in. Now it’s time for us to put it all together with a small project, followed by a healthy helping of brainteasers.
  </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

