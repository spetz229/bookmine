---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0069.html
next: f_0071.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 class="calibre13">A2.4 CoffeeScript via Middleware</h2>
<p id="N1494D" class="calibre5">
      Wouldn’t it be nice if your app could think it’s using plain old JavaScript, while the server handles the CoffeeScript compilation transparently? Well, with middleware—software that fits snugly between your web framework and the server—all these dreams, and more, can come true!
    </p>
<p id="N14956" class="calibre5">
      In the Ruby world, the middleware of choice is Rack. The most mature Rack integration is the aptly named rack-coffee.<a id="FNPTR-58" href="f_0073.html#FOOTNOTE-58">[58]</a> It’s compatible with Rails, Sinatra, and all other major Ruby web frameworks (though Sinatra has actually had built-in CoffeeScript support since October 2010). More recently, the aforementioned Barista has been modified to run in any Rack-based framework, not just Rails.
    </p>
<p id="N14968" class="calibre5">
       Meanwhile, over in the land of Python, CoffeeCup offers some first-class CoffeeScript support for Django, Pylons, CherryPy, and countless other WSGI-based frameworks.<a id="FNPTR-59" href="f_0073.html#FOOTNOTE-59">[59]</a> If having significant whitespace in both your front and back end is important, that’s a great option. Of course, another option would be to write your front  and back end in the same language entirely.
      </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

