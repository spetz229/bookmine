---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0036.html
next: f_0038.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<div class="calibre17"></div><h1 class="chapter-title" id="chp.classes">
<span class="chapter-number">
	      Chapter
	      4</span>
<br class="calibre11"/>
<span class="chapter-name">Modules and Classes</span>
</h1>

<p id="N127D8" class="calibre5">
    In the preceding chapters, we learned how to make sentences out of the verbs and nouns of CoffeeScript. But strings of sentences do not always an elegant program make. What we need are higher-order abstractions. In particular, we need a clean way of describing <span class="emph">types</span> of objects.
  </p>
<p id="N127DE" class="calibre5">
    In classical object-oriented languages like C++, there’s a sharp distinction between objects and classes: an object is an instance of a class, inheriting its methods but storing its own data. Many dynamic languages, like Ruby, blur that distinction by allowing an object’s methods to be modified at runtime. JavaScript obliterates the distinction: there are no classes. There are only prototypes, which make it easy for objects to share methods. For that reason, JavaScript is sometimes described as a prototype-based language.
  </p>
<p id="N127E9" class="calibre5">
    This dynamic approach to sharing methods is powerful but has a cost in clarity. If you’re reading code in a strictly class-based language and you want to find out which methods a particular object supports, you just have to look at the code that defines that object’s class. But if you want to know which methods a JavaScript object has (without running the code), you have to track down every possible reference to that object or its prototype anywhere in the application.
  </p>
<p id="N127EC" class="calibre5">
    Several approaches have popped up over the years for organizing JavaScript code into something resembling classes. Over time, a standard pattern evolved. That pattern provides the basis for CoffeeScript’s <code class="cf">class</code> keyword. In this chapter, we’ll learn how CoffeeScript classes work and then use them to modularize our code for 5x5.
  </p>
<p id="N127F2" class="calibre5">
    But before we get into the workings of CoffeeScript classes, we need to talk a bit about how modules interact in CoffeeScript.
  </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

