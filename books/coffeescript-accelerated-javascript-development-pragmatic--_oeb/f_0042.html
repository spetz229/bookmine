---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0041.html
next: f_0043.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.classesProject" class="calibre13">4.5 Project: Refactoring 5x5</h2>
<p id="N12E58" class="calibre5">
      Classes give a nice clean way to reorganize the code we’ve written so far, to encourage modularity and extensibility. Let’s create three classes:
    </p>
<ol class="calibre24">
<li class="calibre3">
<p id="N12E66" class="calibre5">
<code class="cf">Dictionary</code>, which can find valid words on the grid
      </p>
</li>
<li class="calibre3">
<p id="N12E6C" class="calibre5">
<code class="cf">Grid</code>, which manages the letter tiles
      </p>
</li>
<li class="calibre3">
<p id="N12E72" class="calibre5">
<code class="cf">Player</code>, which keeps track of a player’s score
      </p>
</li>
</ol>
<p id="N12E77" class="calibre5">
      We’ll save these classes in three different <code class="cf">coffee</code> files. Also, we’ll make these classes compatible with all major browser environments as well as with Node.js, paving the way for the jQuery version of the game in the next chapter. To make the game playable under Node, we’ll have a <code class="cf">console.coffee</code> file that provides a prompt and <code class="cf">require</code>s the three classes.
    </p>
<h3 id="sec.classesProjectDictionary" class="calibre14">The Dictionary Class</h3>
<p id="N12E88" class="calibre5">
        Because we want to support browsers, it makes sense to convert our word list from a text file to JavaScript code that can be loaded directly. I wrote a short script to do just that:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/convert.coffee" class="calibre23">Classes/5x5/convert.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">fs = require <em class="string">'fs'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">owl2 = fs.readFileSync <em class="string">'OWL2.txt'</em>, <em class="string">'utf8'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">wordList = owl2.match /^(\w+)/mg</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">fileContents = <em class="string">"""</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">  root = typeof exports === "undefined" ? window : exports;</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">  root.OWL2 = ['</em>#{wordList.join <em class="string">"',\n'"</em>}<em class="string">']</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">"""</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">fs.writeFile <em class="string">'OWL2.js'</em>, fileContents</code>
</td>
</tr>
</table>
<p id="N12EC1" class="calibre5">
        The triple-quote <code class="cf">"""</code> syntax, which should be familiar to Python coders, is called a <span class="emph">heredoc string</span>. It allows you to write multiline strings in a human-readable format. You can also use three single quotes, <code class="cf">”’</code>, to delimit a heredoc string. The difference between <code class="cf">"""</code> and <code class="cf">”’</code> is the same as the difference between <code class="cf">"</code> and <code class="cf">’</code>: The former allows interpolation, while the latter does not.
      </p>
<p id="N12ED9" class="calibre5">
        After running the script, the resulting <code class="cf">OWL2.js</code> looks like this:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">root = <strong class="prompt">typeof</strong> global === <em class="string">"undefined"</em> ? window : global;</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">root.OWL2 = [<em class="string">'AA'</em>,</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">...</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<em class="string">'ZOOGEOGRAPHICAL'</em>];</code>
</td>
</tr>
</table>
<p id="N12EFE" class="calibre5">
        (I’ve omitted the middle 178,687 lines for the sake of brevity.)
      </p>
<p id="N12F01" class="calibre5">
        Now, in order to decouple <code class="cf">Dictionary</code> from Node, let’s have the word list and the game’s grid get passed in to <code class="cf">Dictionary</code>’s constructor:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Dictionary.coffee" class="calibre23">Classes/5x5/Dictionary.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Dictionary</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  constructor: (@originalWordList, grid) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @setGrid grid <strong class="prompt">if</strong> grid?</code>
</td>
</tr>
</table>
<p id="N12F23" class="calibre5">
        Note the implicit assignment of the first argument to <code class="cf">@originalWordList</code> (a feature we covered back in Section 2.4, <a href="f_0021.html#sec.propertyArguments">​<em class="emph">Property Arguments (@arg)</em>​</a>).
      </p>
<p id="N12F2C" class="calibre5">
        When a new game starts, we’ll call <code class="cf">setGrid</code> ourselves with the new grid. This grid could be of a different size, so we’ll copy and filter our original word list each time (<code class="cf">slice(0)</code> is a well-known trick for copying JavaScript arrays):
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Dictionary.coffee" class="calibre23">Classes/5x5/Dictionary.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">setGrid: (@grid) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @wordList = @originalWordList.slice(0)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @wordList = (word <strong class="prompt">for</strong> word <strong class="prompt">in</strong> @wordList <strong class="prompt">when</strong> word.length &lt;= @grid.size)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @minWordLength = Math.min.apply Math, (w.length <strong class="prompt">for</strong> w <strong class="prompt">in</strong> @wordList)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @usedWords = []</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> x <strong class="prompt">in</strong> [0...@grid.size]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">for</strong> y <strong class="prompt">in</strong> [0...@grid.size]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      @markUsed word <strong class="prompt">for</strong> word <strong class="prompt">in</strong> @wordsThroughTile x, y</code>
</td>
</tr>
</table>
<p id="N12F79" class="calibre5">
        Notice that we also reset the <code class="cf">usedWords</code> list here. We’ll want a way of indicating that a word has been used:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Dictionary.coffee" class="calibre23">Classes/5x5/Dictionary.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">markUsed: (str) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">if</strong> str <strong class="prompt">in</strong> @usedWords</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">false</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @usedWords.push str</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">true</strong>
</code>
</td>
</tr>
</table>
<p id="N12FA8" class="calibre5">
        Let’s provide one method that says whether a word is valid and another that says whether a word is usable at this point in the game:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Dictionary.coffee" class="calibre23">Classes/5x5/Dictionary.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">isWord: (str) <strong class="prompt">-&gt;</strong> str <strong class="prompt">in</strong> @wordList</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">isNewWord: (str) <strong class="prompt">-&gt;</strong> str <strong class="prompt">in</strong> @wordList and str not <strong class="prompt">in</strong> @usedWords</code>
</td>
</tr>
</table>
<p id="N12FC9" class="calibre5">
        Here’s the hard part: given a pair of coordinates, we’d like to be able to find all words that go through that tile of the <code class="cf">Grid</code> instance. I’ll spare you the excerpt, since it’s basically the same as our <code class="cf">wordsThroughTile</code> function from the last chapter.
      </p>
<p id="N12FD5" class="calibre5">
        Now in order to make the class accessible, let’s make it a global:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Dictionary.coffee" class="calibre23">Classes/5x5/Dictionary.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">root = exports ? window</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">root.Dictionary = Dictionary</code>
</td>
</tr>
</table>
<h3 id="sec.classesProjectGrid" class="calibre14">The Grid Class</h3>
<p id="N12FEC" class="calibre5">
        Before we define the <code class="cf">Grid</code> class, let’s put some other variables in <code class="cf">grid.coffee</code>, giving them module scope:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Grid.coffee" class="calibre23">Classes/5x5/Grid.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">tileCounts =</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  A: 9, B: 2, C: 2, D: 4, E: 12, F: 2, G: 3, H: 2, I: 9, J: 1, K: 1, L: 4</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  M: 2, N: 6, O: 8, P: 2, Q: 1, R: 6, S: 4, T: 6, U: 4, V: 2, W: 2, X: 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  Y: 2, Z: 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">totalTiles = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">totalTiles += count <strong class="prompt">for</strong> letter, count <strong class="prompt">of</strong> tileCounts</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">alphabet = (letter <strong class="prompt">for</strong> letter <strong class="prompt">of</strong> tileCounts).sort()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">randomLetter = <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  randomNumber = Math.ceil Math.random() * totalTiles</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  x = 1</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> letter <strong class="prompt">in</strong> alphabet</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    x += tileCounts[letter]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">return</strong> letter <strong class="prompt">if</strong> x &gt; randomNumber</code>
</td>
</tr>
</table>
<p id="N13043" class="calibre5">
        When we instantiate a grid, let’s generate its initial <code class="cf">tiles</code> matrix automatically:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Grid.coffee" class="calibre23">Classes/5x5/Grid.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Grid</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  constructor: <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @size = size = 5</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @tiles = <strong class="prompt">for</strong> x <strong class="prompt">in</strong> [0...size]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">for</strong> y <strong class="prompt">in</strong> [0...size]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">        randomLetter()</code>
</td>
</tr>
</table>
<p id="N13074" class="calibre5">
        Now we’ll define some simple functions that allow us to check whether an (<span class="emph">x</span>, <span class="emph">y</span>) pair is out of range, to swap two tiles (given an object with two coordinate pairs), and to get a transposed version of the grid (an array of rows rather than columns):
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Grid.coffee" class="calibre23">Classes/5x5/Grid.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">inRange: (x, y) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  0 &lt;= x &lt; @size and 0 &lt;= y &lt; @size</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">swap: ({x1, y1, x2, y2}) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  [@tiles[x1][y1], @tiles[x2][y2]] = [@tiles[x2][y2], @tiles[x1][y1]]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">rows: <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">for</strong> x <strong class="prompt">in</strong> [0...@size]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">for</strong> y <strong class="prompt">in</strong> [0...@size]</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      @tiles[y][x]</code>
</td>
</tr>
</table>
<p id="N130B6" class="calibre5">
        I’ll spare you the two lines where we make the class a global.
      </p>
<h3 id="sec.classesProjectPlayer" class="calibre14">The Player Class</h3>
<p id="N130BE" class="calibre5">
        Each <code class="cf">Player</code> instance should be given its own name and, optionally, an initial grid. (As with <code class="cf">Dictionary</code>, we’ll use <code class="cf">setGrid</code> when a new game starts.) The player starts with a score of 0, naturally:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Player.coffee" class="calibre23">Classes/5x5/Player.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Player</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  constructor: (@name, dictionary) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @setDictionary dictionary <strong class="prompt">if</strong> dictionary?</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  setDictionary: (@dictionary) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @score = 0</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @moveCount = 0</code>
</td>
</tr>
</table>
<p id="N130F0" class="calibre5">
        Let’s provide a way for a player to make a move:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/Player.coffee" class="calibre23">Classes/5x5/Player.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">makeMove: (swapCoordinates) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @dictionary.grid.swap swapCoordinates</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @moveCount++</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  result = scoreMove @dictionary, swapCoordinates</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  @score += result.moveScore</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  result</code>
</td>
</tr>
</table>
<h3 id="sec.classesProjectConsole" class="calibre14">The Console.Coffee Interface</h3>
<p id="N13115" class="calibre5">
        All of the code from the last chapter that we didn’t refactor into other classes—that is, everything related to command-line IO—is in <code class="cf">console.coffee</code>. I won’t repeat the recycled code here, but the important part is these first four lines:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td colspan="2" class="calibre22">
<a href="http://media.pragprog.com/titles/tbcoffee/code/Classes/5x5/console.coffee" class="calibre23">Classes/5x5/console.coffee</a>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">{Dictionary} = require <em class="string">'./Dictionary'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">{Grid} = require <em class="string">'./Grid'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">{Player} = require <em class="string">'./Player'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">{OWL2} = require <em class="string">'./OWL2'</em>
</code>
</td>
</tr>
</table>
<p id="N13138" class="calibre5">
        The <code class="cf">./</code> prefix in front of each filename tells Node to load the file from the current path. An alternative approach, added in Node 0.4, would be to create a <code class="cf">node_modules</code> directory in <code class="cf">console.coffee</code>’s working path and then put the files in there.<a id="FNPTR-34" href="f_0044.html#FOOTNOTE-34">[34]</a> Then no prefix would be needed.
      </p>
<p id="N1314A" class="calibre5">
      And we’re done! Try it for yourself:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">$ <strong class="prompt">coffee console.coffee</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">Welcome to 5x5!</code>
</td>
</tr>
</table>
<p id="N1315E" class="calibre5">
      We’ve refactored our old, haphazard code into four nice, clean modules, three of which we’ll be reusing in the next two chapters, first in a browser, then on a server. We saved ourselves a ton of work by separating the reusable game logic code from the command-line stuff, which (sigh of relief) we shall never speak of again. Onward!
      </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

