---
layout: page
title: "CoffeeScript (for jay muratore)"
prev: f_0040.html
next: f_0042.html
book_path: books/coffeescript-accelerated-javascript-development-pragmatic--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="sec.extendingClasses" class="calibre13">4.4 Inheritance with ’extends’</h2>
<p id="N12BB8" class="calibre5">
      So far, we’ve talked about how prototypes make it easy to share functionality across a set of objects and how CoffeeScript’s classes provide a useful syntax for bundling prototype properties together. And if that were all classes did, they’d be mildly useful. But where classes really shine is when we want to use inheritance.
    </p>
<p id="N12BBF" class="calibre5">
      JavaScript supports inheritance through something called “prototype chains.” Let’s say that <code class="cf">A</code>’s prototype, <code class="cf">B</code>, has its own prototype, <code class="cf">C</code>. Then we write this:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">a = <strong class="prompt">new</strong> A</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">console.log a.flurb()</code>
</td>
</tr>
</table>
<p id="N12BE1" class="calibre5">      
       First, the runtime checks to see if the particular <code class="cf">A</code> instance, <code class="cf">a</code>, has a property <code class="cf">flurb</code>; if not, it checks <code class="cf">A</code>’s prototype (<code class="cf">B</code>); and if that’s still no dice, it checks <code class="cf">B</code>’s prototype (<code class="cf">C</code>). In short, it’s traversing the prototype chain.
    </p>
<p id="N12BF9" class="calibre5">
      What happens if <code class="cf">C</code> has no <code class="cf">flurb</code>, either? Then the runtime checks the default object prototype (that is, the prototype of <code class="cf">{}</code>). So, every prototype inherits from <code class="cf">{}</code>’s prototype, but there may be other prototypes in between.
    </p>
<p id="N12C08" class="calibre5">
      All of this assigning prototypes to prototypes to prototypes gets a little messy. That’s where CoffeeScript’s <code class="cf">extends</code> keyword comes in.
    </p>
<p id="N12C13" class="calibre5">
      Let’s make a declaration:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> B <strong class="prompt">extends</strong> A</code>
</td>
</tr>
</table>
<p id="N12C26" class="calibre5">
      Then, <code class="cf">B</code>’s prototype inherits from <code class="cf">A</code>’s prototype. In addition, <code class="cf">A</code>’s class-level properties are copied over to <code class="cf">B</code>. So if we left the definition of <code class="cf">B</code> alone, <code class="cf">B</code> instances would have exactly the same behavior as <code class="cf">A</code> instances. (There is one exception: <code class="cf">B.name</code> would be <code class="cf">’B’</code> while <code class="cf">A.name</code> would be <code class="cf">’A’</code>—<code class="cf">name</code> is a special property).
    </p>
<p id="N12C4D" class="calibre5">
      Now let’s look at a slightly deeper example:
    </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Pet</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  constructor: <strong class="prompt">-&gt;</strong> @isHungry = <strong class="prompt">true</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  eat: <strong class="prompt">-&gt;</strong> @isHungry = <strong class="prompt">false</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Dog <strong class="prompt">extends</strong> Pet</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  eat: <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    console.log <em class="string">'*crunch, crunch*'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">super</strong>()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  fetch: <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    console.log <em class="string">'Yip yip!'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    @isHungry = <strong class="prompt">true</strong>
</code>
</td>
</tr>
</table>
<p id="N12C97" class="calibre5">
      The constructor from <code class="cf">Pet</code> is inherited by <code class="cf">Dog</code>, which means that dogs start out hungry. When a dog eats, it makes some noises and then invokes <code class="cf">super()</code>, which means “call the method of the same name on the parent class.” (More precisely, it means <code class="cf">Pet::eat.call this</code>.) Then the dog is no longer hungry.
    </p>
<p id="N12CA6" class="calibre5">
      If a constructor is defined on the child class, then it overrides the constructor from the parent class. It can invoke the parent constructor at any time using <code class="cf">super()</code>. It’s usually wise to call <code class="cf">super()</code> (or, more likely, <code class="cf">super</code>—see <a href="#sb.superParens">​<em class="emph">’super’ Isn’t ’super()’</em>​</a>) at the start of a subclass constructor.
    </p>
<div class="sidebar" id="sb.superParens">
<div class="sidebar-title">'super' Isn't 'super()'</div>
<div class="calibre1">
<p id="N12CB9" class="calibre5">
        What’s wrong with this code?
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">
<strong class="prompt">class</strong> Appliance</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">  constructor: (warranty) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">    warrantyDb.save(<strong class="prompt">this</strong>) <strong class="prompt">if</strong> warranty</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">
<strong class="prompt">class</strong> Toaster <strong class="prompt">extends</strong> Appliance</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">  constructor: (warranty) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix1"> </td>
<td class="codeline1">
<code class="calibre16">    <strong class="prompt">super</strong>()</code>
</td>
</tr>
</table>
<p id="N12CED" class="calibre5">
        When we create a new <code class="cf1">Toaster</code>, <code class="cf1">super()</code> will invoke the parent constructor without passing along the <code class="cf1">warranty</code> argument, which means that the toaster won’t be saved in the warranty database.
      </p>
<p id="N12CF9" class="calibre5">
        We could fix this by writing <code class="cf1">super(warranty)</code>, but there’s a shorthand we can use instead: <code class="cf1">super</code>. With no parentheses or arguments, <code class="cf1">super</code> will pass on every one of the current function’s arguments. If you’re a Rubyist, this will seem familiar. If not, just think of <code class="cf1">super</code> as a greedy, greedy keyword—if you don’t tell it which arguments you want it to pass along, it’ll take ’em all.
      </p>
</div>
</div>
<p id="N12D08" class="calibre5">
      Believe it or not, you now know everything there is to know about classes. As with everything in CoffeeScript, the syntax may be distant from JavaScript, but the translation is straightforward. If you’re a fan of classical OOP (object-oriented programming) methodology, this next section’s for you.
      </p>
<h3 id="sec.switch" class="calibre14">Polymorphism and Switching</h3>
<p id="N12D16" class="calibre5">
        One great use of classes is <span class="emph">polymorphism</span>, which is a fancy object-oriented programming term for “a thing can be a lot of different things, but not just <span class="emph">any</span> thing.” Here’s a classic example:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Shape</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  constructor: (@width) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  computeArea: <strong class="prompt">-&gt;</strong> <strong class="prompt">throw</strong> <strong class="prompt">new</strong> Error(<em class="string">'I am an abstract class!'</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Square <strong class="prompt">extends</strong> Shape</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  computeArea: <strong class="prompt">-&gt;</strong> Math.pow @width, 2</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">
<strong class="prompt">class</strong> Circle <strong class="prompt">extends</strong> Shape</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  radius: <strong class="prompt">-&gt;</strong> @width / 2</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  computeArea: <strong class="prompt">-&gt;</strong> Math.PI * Math.pow @radius(), 2</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">showArea = (shape) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">unless</strong> shape <strong class="prompt">instanceof</strong> Shape</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">throw</strong> <strong class="prompt">new</strong> Error(<em class="string">'showArea requires a Shape instance!'</em>)</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  console.log shape.computeArea()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16"></code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">showArea <strong class="prompt">new</strong> Square(2)<em class="comment">  # 4</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">showArea <strong class="prompt">new</strong> Circle(2)<em class="comment">  # pi</em>
</code>
</td>
</tr>
</table>
<p id="N12D9F" class="calibre5">
        Notice that the <code class="cf">showArea</code> function checks that the object passed to it is a <code class="cf">Shape</code> instance (using the <code class="cf">instanceof</code> keyword). But it doesn’t care what kind of shape it’s been given; both <code class="cf">Square</code> and <code class="cf">Circle</code> instances will work. While this is a trivial example, it’s not hard to imagine a rich geometry library that takes this approach.
      </p>
<p id="N12DB1" class="calibre5">
        If we didn’t use the <code class="cf">instanceof</code> check, that would be known as “duck typing” (as in, “If it looks like a duck…”). If the target object doesn’t have a <code class="cf">computeArea</code> function, then we’ll get a meaningful error message anyway. Duck typing is great, but there are times when you want to be sure that a particular object is what you think it is.
      </p>
<p id="N12DC6" class="calibre5">
        A common idiom in more classical object-oriented languages is to use polymorphism with <code class="cf">switch</code>. We haven’t talked about CoffeeScript’s <code class="cf">switch</code> yet, and there are a number of differences between it and JavaScript’s: first, there’s an implicit break between clauses to prevent unintended “fall­through”; second, the result of the switch is returned. (When the return value is used, break and return are not allowed. If you try, you’ll get <code class="cf">SyntaxError: cannot include a pure statement in an expression</code>. This is jargon for saying that it doesn’t make sense to say <code class="cf">a = return x</code>, so the compiler won’t allow it as a possibility.)
      </p>
<p id="N12DD9" class="calibre5">
        CoffeeScript also makes several syntactic changes, in part to remind JavaScripters of these hidden differences: <code class="cf">when</code> is used instead of <code class="cf">case</code> and <code class="cf">else</code> instead of <code class="cf">default</code>. (The keywords are borrowed from Ruby, where the <code class="cf">case</code> structure has similar semantics.) A single <code class="cf">when</code> can be followed by several potential matches, delimited by commas. Also, instead of <code class="cf">:</code>, those match clauses are separated from their outcomes by indentation (or <code class="cf">then</code>).
      </p>
<p id="N12DFE" class="calibre5">
        Here’s how it all comes together in a simple factory function:
      </p>
<table class="processedcode">
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">requisitionStarship = (captain) <strong class="prompt">-&gt;</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">  <strong class="prompt">switch</strong> captain</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'Kirk'</em>, <em class="string">'Picard'</em>, <em class="string">'Archer'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">new</strong> Enterprise()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">when</strong> <em class="string">'Janeway'</em>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">new</strong> Voyager()</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">    <strong class="prompt">else</strong>
</code>
</td>
</tr>
<tr class="calibre15">
<td class="codeprefix"> </td>
<td class="codeline">
<code class="calibre16">      <strong class="prompt">throw</strong> <strong class="prompt">new</strong> Error(<em class="string">'Invalid starship captain'</em>)</code>
</td>
</tr>
</table>
<p id="N12E47" class="calibre5">
    That’s it for our coverage of modules and classes. Just remember: CoffeeScript certainly doesn’t require you to use classes or classical object-oriented design patterns—most JavaScript developers do perfectly fine without either, after all—but for some applications, classes feel like a natural fit.
    </p>
<p id="N12E50" class="calibre5">
    Speaking of which, remember that mess of code from the project in the last chapter? Let’s see what we can do about it.
  </p>
<script src="scripts/book_local.js" type="text/javascript" class="calibre2"/>
</div>

{% endraw %}

