---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect19_d1e23695_split_001.html
next: find_traverse_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect19_d1e23695_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="find_traverse_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="find_predicate" class="calibre27" id="find_predicate"></a><h3 id="title-IDAFJLTG" class="docSection1Title">9.6. A Domain-Specific Language for Predicates</h3><a name="x_xO" class="calibre27" id="x_xO"></a><p class="docText">Let's<a name="I_indexterm9_d1e23955" class="calibre27" id="I_indexterm9_d1e23955"></a><a name="ch09-preddom" class="calibre27" id="ch09-preddom"></a> take a stab at writing a predicate that will check for a
    C++ source file that is over 128 KB in size:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
myTest path _ (Just size) _ =
    takeExtension path == ".cpp" &amp;&amp; size &gt; 131072
myTest _ _ _ _ = False</pre><br class="calibre48"/>
<a name="x_zO" class="calibre27" id="x_zO"></a><p class="docText">This isn't especially pleasing. The predicate takes four
    arguments, always ignores two of them, and requires two equations to
    define. Surely we can do better. Let's create some code that will help us
    write more concise predicates.</p><a name="x_CF1" class="calibre27" id="x_CF1"></a><p class="docText">Sometimes, this kind of library is referred to
    as<a name="ch09-embeddeddomain" class="calibre27" id="ch09-embeddeddomain"></a> an <span class="docEmphasis">embedded domain-specific language</span>:
    we use our programming language's native facilities (hence
    <span class="docEmphasis">embedded</span>) to write code that lets us solve some
    narrow problem (hence <span class="docEmphasis">domain-specific</span>) particularly
    <span class="docEmphasis">elegantly</span>.</p><a name="x_AP" class="calibre27" id="x_AP"></a><p class="docText">Our first step is to write a function that returns one of
    its arguments. This one extracts the path from the arguments passed to a
    Predicate:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
pathP path _ _ _ = path</pre><br class="calibre48"/>
<a name="x_BP" class="calibre27" id="x_BP"></a><p class="docText">If we don't provide a type signature, a Haskell
    implementation will infer a very general type for this function. This can
    later lead to error messages that are difficult to interpret, so let's
    give <i class="docEmphasis">pathP</i> a type:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
type InfoP a =  FilePath        -- path to directory entry
             -&gt; Permissions     -- permissions
             -&gt; Maybe Integer   -- file size (Nothing if not file)
             -&gt; ClockTime       -- last modified
             -&gt; a

pathP :: InfoP FilePath</pre><br class="calibre48"/>
<a name="x_CP" class="calibre27" id="x_CP"></a><p class="docText">We've created a type synonym that we can use as shorthand
    for writing other, similarly structured functions. Our type synonym
    accepts a type parameter so that we can specify different result
    types:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
sizeP :: InfoP Integer
sizeP _ _ (Just size) _ = size
sizeP _ _ Nothing     _ = -1</pre><br class="calibre48"/>
<a name="x_DP" class="calibre27" id="x_DP"></a><p class="docText">(We're being a little sneaky here and returning a size of
    –1 for entries that are not files or that we couldn't open.)</p><a name="x_EP" class="calibre27" id="x_EP"></a><p class="docText">In fact, a quick glance shows that the
    Predicate type that we defined near the beginning of this
    chapter is the same type as InfoP Bool. (We could thus
    legitimately get rid of the Predicate type.)</p><a name="x_FP" class="calibre27" id="x_FP"></a><p class="docText">What use are <i class="docEmphasis">pathP</i>
    and <i class="docEmphasis">sizeP</i>? With a little more glue,
    we can use them in a predicate (the <tt class="calibre34">P</tt> suffix on each name is
    intended to suggest "predicate"). This is where things start
    to get interesting:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
equalP :: (Eq a) =&gt; InfoP a -&gt; a -&gt; InfoP Bool
equalP f k = \w x y z -&gt; f w x y z == k</pre><br class="calibre48"/>
<a name="x_GP" class="calibre27" id="x_GP"></a><p class="docText">The type signature of <i class="docEmphasis">equalP</i> deserves a little attention.<a name="I_indexterm9_d1e24037" class="calibre27" id="I_indexterm9_d1e24037"></a> It takes an InfoP a type, which is compatible
    with both <i class="docEmphasis">pathP</i> and <i class="docEmphasis">sizeP</i>. It next takes an a and
    returns an InfoP Bool type, which we already observed is a
    synonym for Predicate. In other words, <i class="docEmphasis">equalP</i> constructs a predicate.</p><a name="x_HP" class="calibre27" id="x_HP"></a><p class="docText">The <i class="docEmphasis">equalP</i> function
    works by returning an anonymous function. That one takes the arguments
    accepted by a predicate, passes them to <span class="docMonofont">f</span>, and compares
    the result to <span class="docMonofont">k</span>.</p><a name="x_IP" class="calibre27" id="x_IP"></a><p class="docText">This equation for <i class="docEmphasis">equalP</i> emphasizes the fact that we think of it
    as taking two arguments. Since Haskell curries all functions, writing
    <i class="docEmphasis">equalP</i> in this way is not actually
    necessary. We can omit the anonymous function and rely on currying to work
    on our behalf, letting us write a function that behaves
    identically:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
equalP' :: (Eq a) =&gt; InfoP a -&gt; a -&gt; InfoP Bool
equalP' f k w x y z = f w x y z == k</pre><br class="calibre48"/>
<a name="x_JP" class="calibre27" id="x_JP"></a><p class="docText">Before we continue with our explorations, let's load our
    module into <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load BetterPredicate</b>
[1 of 2] Compiling RecursiveContents ( RecursiveContents.hs, interpreted )
[2 of 2] Compiling Main             ( BetterPredicate.hs, interpreted )
Ok, modules loaded: RecursiveContents, Main.
</pre><a name="x_KP" class="calibre27" id="x_KP"></a><p class="docText">Let's see if a simple predicate constructed from these
    functions will work:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type betterFind (sizeP `equalP` 1024)</b>
betterFind (sizeP `equalP` 1024) :: FilePath -&gt; IO [FilePath]
</pre><a name="x_LP" class="calibre27" id="x_LP"></a><p class="docText">Notice that we're not actually calling <i class="docEmphasis">betterFind</i>, we're merely making sure that our
    expression typechecks. We now have a more expressive way to list all files
    that are exactly some size. Our success gives us enough confidence to
    continue.</p><a name="find_predicate_lift" class="calibre27" id="find_predicate_lift"></a><h4 id="title-IDAHPLTG" class="docSection1Title">9.6.1. Avoiding Boilerplate with Lifting</h4><a name="x_MP" class="calibre27" id="x_MP"></a><p class="docText">Besides <i class="docEmphasis">equalP</i>,
      we'd<a name="I_indexterm9_d1e24117" class="calibre27" id="I_indexterm9_d1e24117"></a><a name="I_indexterm9_d1e24122" class="calibre27" id="I_indexterm9_d1e24122"></a> like to be able to write other binary functions. We'd
      prefer not to write a complete definition of each one, because that
      seems unnecessarily verbose.</p><a name="x_NP" class="calibre27" id="x_NP"></a><p class="docText">To address this, let's put Haskell's powers of
      abstraction to use. We'll take the definition of <i class="docEmphasis">equalP</i>, and instead of calling <i class="docEmphasis">(==)</i> directly,<a name="I_indexterm9_d1e24136" class="calibre27" id="I_indexterm9_d1e24136"></a> we'll pass in as another argument the binary function
      that we want to call:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
liftP :: (a -&gt; b -&gt; c) -&gt; InfoP a -&gt; b -&gt; InfoP c
liftP q f k w x y z = f w x y z `q` k

greaterP, lesserP :: (Ord a) =&gt; InfoP a -&gt; a -&gt; InfoP Bool
greaterP = liftP (&gt;)
lesserP = liftP (&lt;)</pre><br class="calibre48"/>
<a name="x_OP" class="calibre27" id="x_OP"></a><p class="docText">This act of taking a function, such as <i class="docEmphasis">(&gt;)</i>, <a name="I_indexterm9_d1e24147" class="calibre27" id="I_indexterm9_d1e24147"></a>and transforming it into another function that operates in
      a different context (here <i class="docEmphasis">greaterP</i>)
      is referred to as <span class="docEmphasis">lifting</span> it into<a name="I_indexterm9_d1e24157" class="calibre27" id="I_indexterm9_d1e24157"></a><a name="I_indexterm9_d1e24160" class="calibre27" id="I_indexterm9_d1e24160"></a> that context. (This explains the presence of
      <tt class="calibre34">lift</tt> in the function's name.) Lifting lets us reuse code
      and reduce boilerplate. We'll be using it a lot, in different guises,
      throughout the rest of this book.</p><a name="x_PP" class="calibre27" id="x_PP"></a><p class="docText">When we lift a function, we'll often refer to its
      original and new versions as <span class="docEmphasis">unlifted</span> and
      <span class="docEmphasis">lifted</span>, respectively.</p><a name="x_QP" class="calibre27" id="x_QP"></a><p class="docText">By the way, our placement of <span class="docMonofont">q</span> (the
      function to lift) as the first argument to <i class="docEmphasis">liftP</i> was quite deliberate. This made it
      possible for us to write such concise definitions of <i class="docEmphasis">greaterP</i> and <i class="docEmphasis">lesserP</i>. Partial application makes finding
      the "best" order for arguments a more important part of API
      design in Haskell than in other languages. In languages without partial
      application, argument ordering is a matter of taste and convention. Put
      an argument in the wrong place in Haskell, however, and we lose the
      concision that partial application gives.</p><a name="x_DF1" class="calibre27" id="x_DF1"></a><p class="docText">We can recover some of that conciseness via
      combinators. For instance, <i class="docEmphasis">forM</i> was
      not added to the <tt class="calibre34">Control.Monad</tt> module until 2007. Prior to
      that, people wrote <tt class="calibre34">flip mapM</tt> instead:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad</b>ghci&gt; <b class="calibre40">:t mapM</b>
mapM :: (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
ghci&gt; <b class="calibre40">:t forM</b>
forM :: (Monad m) =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]
ghci&gt; <b class="calibre40">:t flip mapM</b>
flip mapM :: (Monad m) =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]</pre><a name="find_predicate_combinator" class="calibre27" id="find_predicate_combinator"></a><h4 id="title-IDAKTLTG" class="docSection1Title">9.6.2. Gluing Predicates Together</h4><a name="x_RP" class="calibre27" id="x_RP"></a><p class="docText">If we want to combine predicates, we can, of course,
      follow the obvious path of doing so by hand:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
simpleAndP :: InfoP Bool -&gt; InfoP Bool -&gt; InfoP Bool
simpleAndP f g w x y z = f w x y z &amp;&amp; g w x y z</pre><br class="calibre48"/>
<a name="x_SP" class="calibre27" id="x_SP"></a><p class="docText">Now that we know about lifting, it becomes more natural
      to reduce the amount of code we must write by lifting our existing
      Boolean operators:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
liftP2 :: (a -&gt; b -&gt; c) -&gt; InfoP a -&gt; InfoP b -&gt; InfoP c
liftP2 q f g w x y z = f w x y z `q` g w x y z

andP = liftP2 (&amp;&amp;)
orP = liftP2 (||)</pre><br class="calibre48"/>
<a name="x_TP" class="calibre27" id="x_TP"></a><p class="docText">Notice that <i class="docEmphasis">liftP2</i>
      is very similar to our earlier <i class="docEmphasis">liftP</i>. In fact, it's more general, because we
      can write <i class="docEmphasis">liftP</i> in terms of
      <i class="docEmphasis">liftP2</i>:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
constP :: a -&gt; InfoP a
constP k _ _ _ _ = k

liftP' q f k w x y z = f w x y z `q` constP k w x y z</pre><br class="calibre48"/>
<a name="find_predicate_combinatord1e24608" class="calibre27" id="find_predicate_combinatord1e24608"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_UP" class="calibre27" id="x_UP"></a></p><p class="docText">In Haskell, we refer to functions that take other
        functions as arguments and return new functions <a name="I_indexterm9_d1e24257" class="calibre27" id="I_indexterm9_d1e24257"></a>as <span class="docEmphasis">combinators</span>.</p></div><a name="x_VP" class="calibre27" id="x_VP"></a><p class="docText">Now that we have some helper functions in place, we can
      return to the <i class="docEmphasis">myTest</i> function we
      defined earlier:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
myTest path _ (Just size) _ =
    takeExtension path == ".cpp" &amp;&amp; size &gt; 131072
myTest _ _ _ _ = False</pre><br class="calibre48"/>
<a name="x_WP" class="calibre27" id="x_WP"></a><p class="docText">How will this function look if we write it using our new
      combinators?</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
liftPath :: (FilePath -&gt; a) -&gt; InfoP a
liftPath f w _ _ _ = f w

myTest2 = (liftPath takeExtension `equalP` ".cpp") `andP`
          (sizeP `greaterP` 131072)</pre><br class="calibre48"/>
<a name="x_XP" class="calibre27" id="x_XP"></a><p class="docText">We've added one final combinator, <i class="docEmphasis">liftPath</i>, since manipulating filenames is
      such a common activity.</p><a name="find_predicated1e24637" class="calibre27" id="find_predicated1e24637"></a><h4 id="title-IDAZVLTG" class="docSection1Title">9.6.3. Defining and Using New Operators</h4><a name="x_ZP" class="calibre27" id="x_ZP"></a><p class="docText">We can take our <a name="I_indexterm9_d1e24286" class="calibre27" id="I_indexterm9_d1e24286"></a>domain-specific language further by defining new infix
      operators:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
(==?) = equalP
(&amp;&amp;?) = andP
(&gt;?) = greaterP

myTest3 = (liftPath takeExtension ==? ".cpp") &amp;&amp;? (sizeP &gt;? 131072)</pre><br class="calibre48"/>
<a name="x_aP" class="calibre27" id="x_aP"></a><p class="docText">We chose names such as <i class="docEmphasis">(==?)</i> for the lifted functions specifically
      for their visual similarity to their unlifted counterparts.</p><a name="x_bP" class="calibre27" id="x_bP"></a><p class="docText">The parentheses in our definition are necessary, because
      we haven't told Haskell about the precedence or associativity of our new
      operators. The language specifies that operators without fixity
      declarations should be treated as <tt class="calibre34">infixl 9</tt>, i.e., evaluated
      from left to right at the highest precedence level. If we were to omit
      the parentheses, the expression would thus be parsed as
      <tt class="calibre34">(((liftPath takeExtension) ==? ".cpp") &amp;&amp;? sizeP) &gt;?
      131072</tt>, which is horribly wrong.</p><a name="x_cP" class="calibre27" id="x_cP"></a><p class="docText">We can respond by writing fixity declarations for our
      new operators. Our first step is to find out what the fixities of the
      unlifted operators are, so that we can mimic them:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:info ==</b>
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  ...
  	-- Defined in GHC.Base
infix 4 ==
ghci&gt; <b class="calibre40">:info &amp;&amp;</b>
(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool 	-- Defined in GHC.Base
infixr 3 &amp;&amp;
ghci&gt; <b class="calibre40">:info &gt;</b>
class (Eq a) =&gt; Ord a where
  ...
  (&gt;) :: a -&gt; a -&gt; Bool
  ...
  	-- Defined in GHC.Base
infix 4 &gt;</pre><a name="x_dP" class="calibre27" id="x_dP"></a><p class="docText">With these in hand, we can now write a parenthesis-free
      expression that will be parsed identically to <i class="docEmphasis">myTest3</i>:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
infix 4 ==?
infixr 3 &amp;&amp;?
infix 4 &gt;?

myTest4 = liftPath takeExtension ==? ".cpp" &amp;&amp;? sizeP &gt;? 131072</pre><br class="calibre48"/>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect19_d1e23695_split_000.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="find_traverse_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

