---
layout: page
title: "Real World Haskell, 1st Edition"
prev: ffi_split_001.html
next: I_sect117_d1e37921.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="ffi_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect117_d1e37921.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect117_d1e37631" class="calibre27" id="I_sect117_d1e37631"></a><h3 id="title-IDAIC5XG" class="docSection1Title">17.1. Foreign Language Bindings: The Basics</h3><a name="x_DH1" class="calibre27" id="x_DH1"></a><p class="docText">The most common operation we'll want to do,
    unsurprisingly, is call a C function from Haskell. So let's do that, by
    binding to some functions from the standard C math library. We'll put the
    binding in a source file, and then compile it into a Haskell binary that
    makes use of the C code.</p><a name="x_EH1" class="calibre27" id="x_EH1"></a><p class="docText">To start with, we need to enable the FFI extension, as
    the FFI addendum support isn't enabled by default. We do this, as always,
    via a <tt class="calibre34">LANGUAGE</tt> pragma at the top of our source
    file:<a name="I_indexterm17_d1e37641" class="calibre27" id="I_indexterm17_d1e37641"></a></p><pre class="calibre39">-- file: ch17/SimpleFFI.hs
{-# LANGUAGE ForeignFunctionInterface #-}</pre><br class="calibre48"/>
<a name="x_FH1" class="calibre27" id="x_FH1"></a><p class="docText">The <tt class="calibre34">LANGUAGE</tt> pragmas indicate which
    extensions to Haskell 98<a name="I_indexterm17_d1e37653" class="calibre27" id="I_indexterm17_d1e37653"></a> a module uses. We bring just the FFI extension in play this
    time. It is important to track which extensions to the language you need.
    Fewer extensions generally means more portable, more robust code. Indeed,
    it is common for Haskell programs written more than a decade ago to
    compile perfectly well today, thanks to standardization, despite changes
    to the language's syntax, type system, and core libraries.</p><a name="x_GH1" class="calibre27" id="x_GH1"></a><p class="docText">The next step is to<a name="ch17-foreignmodules" class="calibre27" id="ch17-foreignmodules"></a> import the <tt class="calibre34">Foreign</tt> modules, which provide
    useful types (such as pointers, numerical types, and arrays) and utility
    functions (such as <tt class="calibre34">malloc</tt> and <tt class="calibre34">alloca</tt>)
    for<a name="I_indexterm17_d1e37674" class="calibre27" id="I_indexterm17_d1e37674"></a><a name="I_indexterm17_d1e37677" class="calibre27" id="I_indexterm17_d1e37677"></a> writing bindings to other languages:</p><pre class="calibre39">-- file: ch17/SimpleFFI.hs
import Foreign
import Foreign.C.Types</pre><br class="calibre48"/>
<a name="x_HH1" class="calibre27" id="x_HH1"></a><p class="docText">For extensive work with foreign libraries, a good
    knowledge of the <tt class="calibre34">Foreign</tt> module is essential. Other useful
    modules<a name="I_indexterm17_d1e37688" class="calibre27" id="I_indexterm17_d1e37688"></a><a name="I_indexterm17_d1e37691" class="calibre27" id="I_indexterm17_d1e37691"></a><a name="I_indexterm17_d1e37694" class="calibre27" id="I_indexterm17_d1e37694"></a> include <tt class="calibre34">Foreign.C.String</tt>,
    <tt class="calibre34">Foreign.Ptr</tt>, and <tt class="calibre34">Foreign.Marshal.Array</tt>.</p><a name="x_IH1" class="calibre27" id="x_IH1"></a><p class="docText">Now we can get down to work calling C functions. To do
    this, we need to know three things: the name of the C function, its type,
    and its associated header file. Additionally, for code that isn't provided
    by the standard C library, we'll need to know the C library's name for
    linking purposes. The actual binding work is done with<a name="I_indexterm17_d1e37710" class="calibre27" id="I_indexterm17_d1e37710"></a> a <tt class="calibre34">foreign import</tt> declaration, like so:</p><pre class="calibre39">-- file: ch17/SimpleFFI.hs
foreign import ccall "math.h sin"
     c_sin :: CDouble -&gt; CDouble</pre><br class="calibre48"/>
<a name="x_JH1" class="calibre27" id="x_JH1"></a><p class="docText">This defines a new Haskell function, <tt class="calibre34">c_sin</tt>,
    whose<a name="I_indexterm17_d1e37724" class="calibre27" id="I_indexterm17_d1e37724"></a> concrete implementation is in C, via the <tt class="calibre34">sin</tt>
    function. When <tt class="calibre34">c_sin</tt> is called, a call to the actual
    <tt class="calibre34">sin</tt> will be made (using the standard C calling convention,
    indicated by <tt class="calibre34">ccall</tt>).<a name="I_indexterm17_d1e37741" class="calibre27" id="I_indexterm17_d1e37741"></a> The Haskell runtime passes control to C, which returns its
    results back to Haskell. The result is then wrapped up as a Haskell value
    of type <tt class="calibre34">CDouble</tt>.</p><a name="x_KH1" class="calibre27" id="x_KH1"></a><p class="docText">A common idiom when writing FFI bindings is to expose the
    C function with the prefix <tt class="calibre34">c_</tt>, distinguishing it from
    more user-friendly, higher-level functions. The raw C function is
    specified by the <tt class="calibre34">math.h</tt> header, where it is declared to have
    the type:</p><pre class="calibre39">double sin(double x);</pre><br class="calibre48"/>
<a name="x_LH1" class="calibre27" id="x_LH1"></a><p class="docText">When writing the binding, the programmer has to translate
    C type signatures such as this into their Haskell FFI equivalents, making
    sure that the data representations match up. For example,
    <tt class="calibre34">double</tt> in C corresponds to <tt class="calibre34">CDouble</tt> in Haskell.
    We need to be careful here, since if a mistake is made, the Haskell
    compiler will happily generate incorrect code to call C! The poor Haskell
    compiler doesn't know anything about what types the C function actually
    requires, so if instructed to, it will call the C function with the wrong
    arguments. At best this will lead to C compiler warnings, and more likely,
    it will end with with a runtime crash. At worst the error will silently go
    unnoticed until some critical failure occurs. So make sure you use the
    correct FFI types, and don't be wary of using QuickCheck to test your C
    code via the bindings.<sup class="docFootnote"><a class="docLink1" href="#x_LH1d1e38099">[38]</a></sup></p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_LH1d1e38099" class="calibre5" id="x_LH1d1e38099">[38]</a></sup> Some more advanced binding tools provide greater
        degrees of type checking. For example, <tt class="calibre34">c2hs</tt> is able to
        parse the C header, and generate the binding definition for you, and
        it is especially suited for large projects where the full API is
        specified.</p></blockquote><a name="x_NH1" class="calibre27" id="x_NH1"></a><p class="docText">The most important primitive C types are represented in
    Haskell with the somewhat intuitive names (for signed and unsigned types)
    <tt class="calibre34">CChar</tt>, <tt class="calibre34">CUChar</tt>, <tt class="calibre34">CInt</tt>,
    <tt class="calibre34">CUInt</tt>, <tt class="calibre34">CLong</tt>, <tt class="calibre34">CULong</tt>,
    <tt class="calibre34">CSize</tt>, <tt class="calibre34">CFloat</tt>, and <tt class="calibre34">CDouble</tt>. More
    are defined in the FFI standard and can be found in the Haskell base
    library under <tt class="calibre34">Foreign.C.Types</tt>. It is also possible to define
    your own Haskell-side representation types for C, as we'll see
    later.</p><a name="I_sect117_d1e37631d1e38138" class="calibre27" id="I_sect117_d1e37631d1e38138"></a><h4 id="title-IDAYH5XG" class="docSection1Title">17.1.1. Be Careful of Side Effects</h4><a name="x_OH1" class="calibre27" id="x_OH1"></a><p class="docText">One point to note is that we bound <tt class="calibre34">sin</tt> as
      a pure function<a name="I_indexterm17_d1e37814" class="calibre27" id="I_indexterm17_d1e37814"></a> in Haskell, one with no side effects. That's fine in this
      case, since the <tt class="calibre34">sin</tt> function in C is referentially
      transparent. By binding pure C functions to pure Haskell functions, the
      Haskell compiler is taught something about the C code—namely, that it
      has no side effects, making optimizations easier. Pure code is also more
      flexible for the Haskell programmer, as it yields naturally persistent
      data structures and threadsafe functions. However, while pure Haskell
      code is always threadsafe, this is harder to guarantee of C. Even if the
      documentation indicates the function is likely to expose no side
      effects, there's little to ensure it is also threadsafe, unless
      explicitly documented as "reentrant." Pure, threadsafe C code, while
      rare, is a valuable commodity. It is the easiest flavor of C to use from
      Haskell.</p><a name="x_PH1" class="calibre27" id="x_PH1"></a><p class="docText">Of course, code with side effects is more common in
      imperative languages, where the explicit sequencing of statements
      encourages the use of effects. It is much more common in C for functions
      to return different values, given the same arguments, due to changes in
      global or local state, or to have other side effects. Typically, this is
      signalled in C by the function returning only a status value or some
      void type, rather than a useful result value. This indicates that the
      real work of the function was in its side effects. For such functions,
      we'll need to capture those side effects in the <tt class="calibre34">IO</tt>
      monad<a name="I_indexterm17_d1e37828" class="calibre27" id="I_indexterm17_d1e37828"></a> (by changing the return type to <tt class="calibre34">IO CDouble</tt>,
      for example). We also need to be very careful with pure C functions that
      aren't also reentrant, as multiple threads are extremely common in
      Haskell code, in comparison to C. We might need to moderate access to
      the FFI binding with a transactional lock, or by duplicating the
      underlying C state to make nonreentrant code safe for use.</p><a name="I_sect117_d1e37631d1e38169" class="calibre27" id="I_sect117_d1e37631d1e38169"></a><h4 id="title-IDAZI5XG" class="docSection1Title">17.1.2. A High-Level Wrapper</h4><a name="x_QH1" class="calibre27" id="x_QH1"></a><p class="docText">With the<a name="I_indexterm17_d1e37842" class="calibre27" id="I_indexterm17_d1e37842"></a> foreign imports out of the way, the next step is to
      convert the C types we pass to and receive from the foreign language
      call into native <a name="I_indexterm17_d1e37846" class="calibre27" id="I_indexterm17_d1e37846"></a>Haskell types, wrapping the binding so that it appears as
      a normal Haskell function:</p><pre class="calibre39">-- file: ch17/SimpleFFI.hs
fastsin :: Double -&gt; Double
fastsin x = realToFrac (c_sin (realToFrac x))</pre><br class="calibre48"/>
<a name="x_RH1" class="calibre27" id="x_RH1"></a><p class="docText">The main thing to remember when writing convenient
      wrappers over bindings such as this is to correctly convert input and
      output back to normal Haskell types. To convert between floating-point
      values, we can <a name="I_indexterm17_d1e37856" class="calibre27" id="I_indexterm17_d1e37856"></a>use <tt class="calibre34">realToFrac</tt>, which lets us translate
      different floating-point values to each other (and these conversions,
      such as from <tt class="calibre34">CDouble</tt> to <tt class="calibre34">Double</tt>, are usually
      free, as the underlying representations are unchanged). For integer
      <a name="I_indexterm17_d1e37869" class="calibre27" id="I_indexterm17_d1e37869"></a>values, <tt class="calibre34">fromIntegral</tt> is available. For other
      common C data types, such as arrays, we may need to unpack the data to a
      more workable Haskell type (such as a list), or possibly leave the C
      data opaque and operate on it indirectly only (perhaps via a
      <tt class="calibre34">ByteString</tt>). The choice depends on how costly the
      transformation is and the functions that are available on the source and
      destination types.</p><a name="x_SH1" class="calibre27" id="x_SH1"></a><p class="docText">We can now proceed to use the bound function in a
      program. For example, we can apply the C <tt class="calibre34">sin</tt> function to a
      Haskell list of 10ths:</p><pre class="calibre39">-- file: ch17/SimpleFFI.hs
main = mapM_ (print . fastsin) [0/10, 1/10 .. 10/10]</pre><br class="calibre48"/>
<a name="x_TH1" class="calibre27" id="x_TH1"></a><p class="docText">This simple program prints each result as it is
      computed. Putting the complete binding in the file
      <i class="docEmphasis">SimpleFFI.hs</i> allows us to run it in
      <tt class="calibre34">ghci</tt>:</p><pre class="calibre39">$ ghci SimpleFFI.hs
*Main&gt; main
0.0
9.983341664682815e-2
0.19866933079506122
0.2955202066613396
0.3894183423086505
0.479425538604203
0.5646424733950354
0.644217687237691
0.7173560908995227
0.7833269096274833
0.8414709848078964</pre><a name="x_UH1" class="calibre27" id="x_UH1"></a><p class="docText">Alternatively, we can compile the code to an
      executable, dynamically linked against the corresponding C
      library:</p><pre class="calibre39">$ <b class="calibre40">ghc -O --make SimpleFFI.hs</b>
[1 of 1] Compiling Main             ( SimpleFFI.hs, SimpleFFI.o )
Linking SimpleFFI ...
</pre><a name="x_VH1" class="calibre27" id="x_VH1"></a><p class="docText">and then run that:</p><pre class="calibre39">$ ./SimpleFFI 
0.0
9.983341664682815e-2
0.19866933079506122
0.2955202066613396
0.3894183423086505
0.479425538604203
0.5646424733950354
0.644217687237691
0.7173560908995227
0.7833269096274833
0.8414709848078964</pre><a name="x_WH1" class="calibre27" id="x_WH1"></a><p class="docText">We're well on our way now, with a full program,
      statically linked against C, which interleaves C and Haskell code and
      passes data across the language boundary. Simple bindings such as the
      one just shown are almost trivial, as the standard <tt class="calibre34">Foreign</tt>
      library provides convenient aliases for common types such as
      <tt class="calibre34">CDouble</tt>. In the next section, we'll look at a larger
      engineering task: binding to the PCRE library, which brings up issues of
      memory management and type safety.</p>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="ffi_split_000.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect117_d1e37921.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

