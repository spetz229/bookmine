---
layout: page
title: "Real World Haskell, 1st Edition"
prev: monadcase_monadplus.html
next: I_sect115_d1e34892.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="monadcase_monadplus.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect115_d1e34892.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect115_d1e34429" class="calibre27" id="I_sect115_d1e34429"></a><h3 id="title-IDAQCGIL" class="docSection1Title">15.4. Adventures in Hiding the Plumbing</h3><a name="x_wq" class="calibre27" id="x_wq"></a><p class="docText">In <a class="docLink" href="monads_state_split_000.html#monads_state_random">Section 14.13.4</a>, we showed how
    to use the State monad to give ourselves access to random
    numbers in a way that is easy to use.</p><a name="x_xq" class="calibre27" id="x_xq"></a><p class="docText">A drawback of the code we developed is that it's
    <span class="docEmphasis">leaky</span>: <a name="I_indexterm15_d1e34444" class="calibre27" id="I_indexterm15_d1e34444"></a> Users know that they're executing inside the
    State monad. This means that they can inspect and modify the
    state of the random number generator just as easily as we, the authors,
    can.</p><a name="x_yq" class="calibre27" id="x_yq"></a><p class="docText">Human nature dictates that if we leave our internal
    workings exposed, someone will surely come along and monkey with them. For
    a sufficiently small program, this may be fine, but in a larger software
    project, when one consumer of a library modifies its internals in a way
    that other consumers are not prepared for, the resulting bugs can be among
    the most difficult to track down. These bugs occur at a level where we're
    unlikely to question our basic assumptions about a library until long
    after we've exhausted all other avenues of inquiry.</p><a name="x_zq" class="calibre27" id="x_zq"></a><p class="docText">Even worse, once we leave our implementation exposed for a
    while, and some well-intentioned person inevitably bypasses our APIs and
    uses the implementation directly, we have a nasty quandary if we need to
    fix a bug or make an enhancement. Either we can modify our internals and
    break code that depends on them; or we're stuck with our existing
    internals and must try to find some other way to make the change that we
    need.</p><a name="x_Ar" class="calibre27" id="x_Ar"></a><p class="docText">How can we revise our random number monad so that the fact
    that we're using the State monad is hidden? We need to
    somehow prevent our users from being able to call <tt class="calibre34">get</tt> or
    <tt class="calibre34">put</tt>. This is not difficult to do, and it introduces some
    tricks that we'll reuse often in day-to-day Haskell programming.</p><a name="x_Br" class="calibre27" id="x_Br"></a><p class="docText">To widen our scope, we'll move beyond random numbers and
    implement a monad that supplies unique values of <span class="docEmphasis">any</span>
    kind. The name we'll give to our monad is Supply. We'll
    provide the execution function, <i class="docEmphasis">runSupply</i>, with a list of values (it will be up
    to us to ensure that each one is unique):</p><pre class="calibre39">-- file: ch15/Supply.hs
runSupply :: Supply s a -&gt; [s] -&gt; (a, [s])</pre><br class="calibre48"/>
<a name="x_Cr" class="calibre27" id="x_Cr"></a><p class="docText">The monad won't care what the values are. They might be
    random numbers, or names for temporary files, or identifiers for HTTP
    cookies.</p><a name="x_Dr" class="calibre27" id="x_Dr"></a><p class="docText">Within the monad, every time a consumer asks for a value,
    the <i class="docEmphasis">next</i> action will take the next
    one from the list and give it to the consumer. Each value is wrapped in a
    Maybe constructor in case the list isn't long enough to
    satisfy the demand:</p><pre class="calibre39">-- file: ch15/Supply.hs
next :: Supply s (Maybe s)</pre><br class="calibre48"/>
<a name="x_Er" class="calibre27" id="x_Er"></a><p class="docText">To hide our plumbing, in our module declaration, we export
    only the type constructor, the execution function, and the <i class="docEmphasis">next</i> action:</p><pre class="calibre39">-- file: ch15/Supply.hs
module Supply
    (
      Supply
    , next
    , runSupply
    ) where</pre><br class="calibre48"/>
<a name="x_Fr" class="calibre27" id="x_Fr"></a><p class="docText">Since a module that imports the library can't see the
    internals of the monad, it can't manipulate them.</p><a name="x_Gr" class="calibre27" id="x_Gr"></a><p class="docText">Our plumbing is exceedingly simple. We use a
    <tt class="calibre34">newtype</tt> declaration to wrap the existing State
    monad:</p><pre class="calibre39">-- file: ch15/Supply.hs
import Control.Monad.State

newtype Supply s a = S (State [s] a)</pre><br class="calibre48"/>
<a name="x_Hr" class="calibre27" id="x_Hr"></a><p class="docText">The <span class="docMonofont">s</span> parameter is the type
    of the unique values we are going to supply, and <span class="docMonofont">a</span> is the usual type parameter that we must provide
    in order to make our type a monad.</p><a name="x_Ir" class="calibre27" id="x_Ir"></a><p class="docText">Our use of <tt class="calibre34">newtype</tt> for the
    Supply type and our module header join forces to prevent our
    clients from using the State monad's <i class="docEmphasis">get</i> and <i class="docEmphasis">set</i> actions. Because our module does not export
    the <tt class="calibre34">S</tt> data constructor, clients have no programmatic way to
    see that we're wrapping the State monad, or to access
    it.</p><a name="x_Jr" class="calibre27" id="x_Jr"></a><p class="docText">At this point, we've got a type, Supply, that
    we need to make an instance of the Monad typeclass. We could
    follow the usual pattern of defining <i class="docEmphasis">(&gt;&gt;=)</i> and <tt class="calibre34">return</tt>, but this would be pure boilerplate code.
    All we'd be doing is wrapping and unwrapping the State
    monad's versions of <i class="docEmphasis">(&gt;&gt;=)</i> and
    <tt class="calibre34">return</tt> using our <tt class="calibre34">S</tt> value
    constructor. Here is how such code would look:</p><pre class="calibre39">-- file: ch15/AltSupply.hs
unwrapS :: Supply s a -&gt; State [s] a
unwrapS (S s) = s

instance Monad (Supply s) where
    s &gt;&gt;= m = S (unwrapS s &gt;&gt;= unwrapS . m)
    return = S . return</pre><br class="calibre48"/>
<a name="x_Kr" class="calibre27" id="x_Kr"></a><p class="docText">Haskell programmers are not fond of boilerplate, and sure
    enough, <span class="docMonofont">GHC</span> has a lovely
    language extension that eliminates the work. To use it, we add the
    following directive to the top of our source file, before the module
    header:</p><pre class="calibre39">-- file: ch15/Supply.hs
{-# LANGUAGE GeneralizedNewtypeDeriving #-}</pre><br class="calibre48"/>
<a name="x_Lr" class="calibre27" id="x_Lr"></a><p class="docText">Usually, we can only automatically derive instances of a
    handful of standard typeclasses, such as Show and
    Eq. As its name suggests, the<a name="I_indexterm15_d1e34588" class="calibre27" id="I_indexterm15_d1e34588"></a> <tt class="calibre34">GeneralizedNewtypeDeriving</tt> extension<a name="I_indexterm15_d1e34597" class="calibre27" id="I_indexterm15_d1e34597"></a> broadens our ability to derive typeclass instances, and it
    is specific to <tt class="calibre34">newtype</tt> declarations. If
    the type we're wrapping is an instance of any typeclass, the extensions
    can automatically make our new type an instance of that typeclass as
    <span class="docEmphasis">follows</span>:</p><pre class="calibre39">-- file: ch15/Supply.hs
    deriving (Monad)</pre><br class="calibre48"/>
<a name="x_Mr" class="calibre27" id="x_Mr"></a><p class="docText">This takes the underlying type's implementations of
    <i class="docEmphasis">(&gt;&gt;=)</i> and <tt class="calibre34">return</tt>, adds <a name="I_indexterm15_d1e34618" class="calibre27" id="I_indexterm15_d1e34618"></a><a name="I_indexterm15_d1e34623" class="calibre27" id="I_indexterm15_d1e34623"></a>the necessary wrapping and unwrapping with our
    <tt class="calibre34">S</tt> data constructor, and uses the new versions of those
    functions to derive a Monad instance for us.</p><a name="x_Nr" class="calibre27" id="x_Nr"></a><p class="docText">What we gain here is very useful beyond just this example.
    We can use <tt class="calibre34">newtype</tt> to wrap any underlying type; we
    selectively expose only those typeclass instances that we want; and we
    expend almost no effort to create these narrower, more specialized
    types.</p><a name="x_Or" class="calibre27" id="x_Or"></a><p class="docText">Now that we've seen the
    <tt class="calibre34">GeneralizedNewtypeDeriving</tt> technique, all that remains is to
    provide definitions of <i class="docEmphasis">next</i> and
    <i class="docEmphasis">runSupply</i>:</p><pre class="calibre39">-- file: ch15/Supply.hs
next = S $ do st &lt;- get
              case st of
                [] -&gt; return Nothing
                (x:xs) -&gt; do put xs
                             return (Just x)

runSupply (S m) xs = runState m xs</pre><br class="calibre48"/>
<a name="x_Pr" class="calibre27" id="x_Pr"></a><p class="docText">If we load our module into <i class="docEmphasis">ghci</i>, we can try it out in a few simple
    ways:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load Supply</b>
[1 of 1] Compiling Supply           ( Supply.hs, interpreted )
Ok, modules loaded: Supply.
ghci&gt; <b class="calibre40">runSupply next [1,2,3]</b>
Loading package mtl-1.1.0.1 ... linking ... done.
(Just 1,[2,3])
ghci&gt; <b class="calibre40">runSupply (liftM2 (,) next next) [1,2,3]</b>
((Just 1,Just 2),[3])
ghci&gt; <b class="calibre40">runSupply (liftM2 (,) next next) [1]</b>
((Just 1,Nothing),[])</pre><a name="x_Qr" class="calibre27" id="x_Qr"></a><p class="docText">We can also verify that the State monad has
    not somehow leaked out:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:browse Supply</b>
data Supply s a
next :: Supply s (Maybe s)
runSupply :: Supply s a -&gt; [s] -&gt; (a, [s])
ghci&gt; <b class="calibre40">:info Supply</b>
data Supply s a 	-- Defined at Supply.hs:17:8-13
instance Monad (Supply s) -- Defined at Supply.hs:17:8-13</pre><a name="I_sect115_d1e34429d1e35036" class="calibre27" id="I_sect115_d1e34429d1e35036"></a><h4 id="title-IDA1LGIL" class="docSection1Title">15.4.1. Supplying Random Numbers</h4><a name="x_Rr" class="calibre27" id="x_Rr"></a><p class="docText">If we want to use our Supply monad as a
      source of random numbers, we have a small difficulty<a name="I_indexterm15_d1e34703" class="calibre27" id="I_indexterm15_d1e34703"></a> to face. Ideally, we'd like to be able to provide it with
      an infinite stream of random numbers. We can get a StdGen
      in the IO monad, but<a name="I_indexterm15_d1e34715" class="calibre27" id="I_indexterm15_d1e34715"></a> we must "put back" a different
      StdGen when we're done. If we don't, the next piece of code
      to get a StdGen will get the same state as we did. This
      means it will generate the same random numbers as we did, which is
      potentially catastrophic.</p><a name="x_Sr" class="calibre27" id="x_Sr"></a><p class="docText">From the parts of the <tt class="calibre34">System.Random</tt>
      module<a name="I_indexterm15_d1e34736" class="calibre27" id="I_indexterm15_d1e34736"></a> we've seen so far, it's difficult to reconcile these
      demands. We can use <i class="docEmphasis">getStdRandom</i>,
      whose <a name="I_indexterm15_d1e34745" class="calibre27" id="I_indexterm15_d1e34745"></a>type ensures that when we get a StdGen, we
      put one back:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type getStdRandom</b>
getStdRandom :: (StdGen -&gt; (a, StdGen)) -&gt; IO a
</pre><a name="x_sG1" class="calibre27" id="x_sG1"></a><p class="docText">We can use <i class="docEmphasis">random</i>
      to get back a new StdGen when they give us a random number.
      And we can use <i class="docEmphasis">randoms</i> to get an
      infinite list of random numbers. But how do we get both an infinite list
      of random numbers <span class="docEmphasis">and</span> a new
      StdGen?</p><a name="x_Tr" class="calibre27" id="x_Tr"></a><p class="docText">The answer lies with the RandomGen
      typeclass's <i class="docEmphasis">split</i> function,
      <a name="I_indexterm15_d1e34783" class="calibre27" id="I_indexterm15_d1e34783"></a>which takes one random number generator and turns it into
      two generators. Splitting a random generator such as this is a most
      unusual thing to be able to do: it's obviously tremendously useful in a
      pure functional setting, but it is essentially either never necessary an
      impure language, or the language doesn't provide for it.</p><a name="x_Ur" class="calibre27" id="x_Ur"></a><p class="docText">With the <i class="docEmphasis">split</i>
      function, we can use one StdGen to generate an infinite
      list of random numbers to feed to <i class="docEmphasis">runSupply</i>, while we give the other back to
      the IO monad:</p><pre class="calibre39">-- file: ch15/RandomSupply.hs
import Supply
import System.Random hiding (next)

randomsIO :: Random a =&gt; IO [a]
randomsIO =
    getStdRandom $ \g -&gt;
        let (a, b) = split g
        in (randoms a, b)</pre><br class="calibre48"/>
<a name="x_Vr" class="calibre27" id="x_Vr"></a><p class="docText">If we've written this function properly, our example
      ought to print a different random number on each invocation:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load RandomSupply</b>
[1 of 2] Compiling Supply           ( Supply.hs, interpreted )
[2 of 2] Compiling RandomSupply     ( RandomSupply.hs, interpreted )
Ok, modules loaded: RandomSupply, Supply.
ghci&gt; <b class="calibre40">(fst . runSupply next) `fmap` randomsIO</b>

&lt;interactive&gt;:1:17:
    Ambiguous occurrence `next'
    It could refer to either `Supply.next', imported from Supply at RandomSupply.hs:4:
                                              (defined at Supply.hs:32:0)
                          or `System.Random.next', imported from System.Random
ghci&gt; <b class="calibre40">(fst . runSupply next) `fmap` randomsIO</b>

&lt;interactive&gt;:1:17:
    Ambiguous occurrence `next'
    It could refer to either `Supply.next', imported from Supply at RandomSupply.hs:4:
                                              (defined at Supply.hs:32:0)
                          or `System.Random.next', imported from System.Random</pre><a name="x_Wr" class="calibre27" id="x_Wr"></a><p class="docText">Recall that our <i class="docEmphasis">runSupply</i> function returns both the result of
      executing the monadic action and the unconsumed remainder of the list.
      Since we passed it an infinite list of random numbers, we compose with
      <i class="docEmphasis">fst</i> to ensure that we don't get
      drowned in random numbers when <i class="docEmphasis">ghci</i>
      tries to print the result.</p><a name="I_sect115_d1e34429d1e35176" class="calibre27" id="I_sect115_d1e34429d1e35176"></a><h4 id="title-IDAQQGIL" class="docSection1Title">15.4.2. Another Round of Golf</h4><a name="x_Xr" class="calibre27" id="x_Xr"></a><p class="docText">The pattern of applying a function to one element of a
      pair and constructing a new pair with the other original element
      untouched is common enough in Haskell code that it has been turned into
      standard code.</p><a name="x_Yr" class="calibre27" id="x_Yr"></a><p class="docText">Two functions, <i class="docEmphasis">first</i> and <i class="docEmphasis">second</i>, perform this operation <a name="I_indexterm15_d1e34848" class="calibre27" id="I_indexterm15_d1e34848"></a><a name="I_indexterm15_d1e34851" class="calibre27" id="I_indexterm15_d1e34851"></a><a name="I_indexterm15_d1e34854" class="calibre27" id="I_indexterm15_d1e34854"></a>in the <tt class="calibre34">Control.Arrow</tt> module:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Arrow</b>ghci&gt; <b class="calibre40">first (+3) (1,2)</b>
(4,2)
ghci&gt; <b class="calibre40">second odd ('a',1)</b>
('a',True)</pre><a name="x_Zr" class="calibre27" id="x_Zr"></a><p class="docText">(Indeed, we already encountered <i class="docEmphasis">second</i> in <a class="docLink" href="jsonclass_instances_split_000.html#jsonclass_instances">Section 6.9</a>.) We can use <i class="docEmphasis">first</i> to golf our definition of <i class="docEmphasis">randomsIO</i>, turning it into a
      one-liner:</p><pre class="calibre39">-- file: ch15/RandomGolf.hs
import Control.Arrow (first)

randomsIO_golfed :: Random a =&gt; IO [a]
randomsIO_golfed = getStdRandom (first randoms . split)</pre><br class="calibre48"/>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="monadcase_monadplus.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect115_d1e34892.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

