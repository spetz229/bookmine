---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect125_d1e48856.html
next: I_sect125_d1e49269.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="I_sect125_d1e48856.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect125_d1e49269.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect125_d1e49110" class="calibre27" id="I_sect125_d1e49110"></a><h3 id="title-IDAECQRD" class="docSection1Title">25.3. Understanding Core</h3><a name="x_xK1" class="calibre27" id="x_xK1"></a><p class="docText">Besides<a name="I_indexterm25_d1e49115" class="calibre27" id="I_indexterm25_d1e49115"></a><a name="ch25-cores" class="calibre27" id="ch25-cores"></a> looking at runtime profiling data, one sure way to
    determine exactly what your program is doing is to look at the final
    program source after the compiler is done <span class="docEmphasis">optimizing</span> it, particularly in the case of
    Haskell compilers, which can perform very aggressive transformations on
    the code. GHC uses what is humorously referred to as "a simple functional
    language"—known as Core—as the compiler intermediate representation. It is
    essentially a subset of Haskell, augmented with unboxed data types (raw
    machine types, directly corresponding to primitive data types in languages
    such as C), suitable for code generation. GHC optimizes Haskell by
    transformation, repeatedly rewriting the source into more and more
    efficient forms. The Core representation is the final functional version
    of your program, before translation to low-level <span class="docEmphasis">imperative</span> code. In other words, Core has
    the final say, and if all-out performance is your goal, it is worth
    understanding.</p><a name="x_yK1" class="calibre27" id="x_yK1"></a><p class="docText">To view the Core version of our Haskell program, we
    compile with the <tt class="calibre34">-ddump-simpl</tt> flag,<a name="I_indexterm25_d1e49131" class="calibre27" id="I_indexterm25_d1e49131"></a> or use the <tt class="calibre34">ghc-core</tt> tool, a third-party
    utility that lets us view Core in a pager. So let's look at the
    representation of our final <tt class="calibre34">fold</tt> using strict data types, in
    Core form:</p><pre class="calibre39">        $ 
        <b class="calibre40">ghc -O2 -ddump-simpl G.hs</b></pre><a name="x_zK1" class="calibre27" id="x_zK1"></a><p class="docText">A screenful of text is generated. If we look carefully at
    it, we'll see a loop (here, cleaned up slightly for clarity):</p><pre class="calibre39">lgo :: Integer -&gt; [Double] -&gt; Double# -&gt; (# Integer, Double #)

lgo = \ n xs s -&gt;
    case xs of
      []       -&gt; (# n, D# s #);
      (:) x ys -&gt;
        case plusInteger n 1 of
            n' -&gt; case x of
                D# y -&gt; lgo n' ys (+## s y)</pre><a name="x_AL1" class="calibre27" id="x_AL1"></a><p class="docText">This is the final version of our <tt class="calibre34">foldl'</tt>, and
    it tells us a lot about the next steps for optimization. The fold itself
    has been entirely inlined, yielding an explicit recursive loop over the
    list. The loop state, our strict pair, has disappeared entirely, and the
    function now takes its length and sum accumulators as direct arguments
    along with the list.</p><a name="x_BL1" class="calibre27" id="x_BL1"></a><p class="docText">The sum of the list elements is represented with an
    unboxed <tt class="calibre34">Double#</tt> value, a raw machine <tt class="calibre34">double</tt> kept
    in a floating-point register. This is ideal, as there will be no memory
    traffic involved in keeping the sum on the heap. However, the length of
    the list—since we gave no explicit type annotation—has been inferred to be
    a heap-allocated <tt class="calibre34">Integer</tt>, which requires
    a nonprimitive <tt class="calibre34">plusInteger</tt> to perform addition. If it is
    algorithmically sound to use a <tt class="calibre34">Int</tt> instead, we can replace
    <tt class="calibre34">Integer</tt> with it, via a type annotation, and GHC will then be
    able to use a raw machine <tt class="calibre34">Int#</tt> for the length. We can hope
    for an improvement in time and space by ensuring that both loop components
    are unboxed and kept in registers.</p><a name="x_CL1" class="calibre27" id="x_CL1"></a><p class="docText">The base case of the loop, its end, yields an unboxed
    pair (a pair allocated only in registers), storing the final length of the
    list and the accumulated sum. Notice that the return type is a
    heap-allocated <tt class="calibre34">Double</tt> value, indicated by the <tt class="calibre34">D#</tt>
    constructor, which lifts a raw double value onto the heap. Again this has
    implications for performance, as GHC will need to check that there is
    sufficient heap space available before it can allocate and return from the
    loop.</p><a name="x_DL1" class="calibre27" id="x_DL1"></a><p class="docText">We can use a custom pair type in the loop to make
    <tt class="calibre34">ghc</tt> return an unboxed <tt class="calibre34">Double#</tt> value, which
    avoids this final heap check. In addition, <tt class="calibre34">ghc</tt> provides an
    optimiztion that unboxes the strict fields of a data type, ensuring that
    the fields of the new pair type will be stored in registers. This
    optimization is turned on <a name="I_indexterm25_d1e49199" class="calibre27" id="I_indexterm25_d1e49199"></a>with <tt class="calibre34">-funbox-strict-fields</tt>.</p><a name="x_EL1" class="calibre27" id="x_EL1"></a><p class="docText">We can make both representation changes by replacing the
    polymorphic strict pair type with one whose fields are fixed as
    <tt class="calibre34">Int</tt> and <tt class="calibre34">Double</tt>:</p><pre class="calibre39">-- file: ch25/H.hs
data Pair = Pair !Int !Double

mean :: [Double] -&gt; Double
mean xs = s / fromIntegral n
  where
    Pair n s       = foldl' k (Pair 0 0) xs
    k (Pair n s) x = Pair (n+1) (s+x)</pre><br class="calibre48"/>
<a name="x_FL1" class="calibre27" id="x_FL1"></a><p class="docText">Compiling this with optimizations on and
    <tt class="calibre34">-funbox-strict-fields -ddump-simpl</tt>, we get a tighter inner
    loop in Core:</p><pre class="calibre39">lgo :: Int# -&gt; Double# -&gt; [Double] -&gt; (# Int#, Double# #)
lgo = \ n s xs -&gt;
    case xs of
      []       -&gt; (# n, s #)
      (:) x ys -&gt;
        case x of 
            D# y -&gt; lgo (+# n 1) (+## s y) ys</pre><a name="x_GL1" class="calibre27" id="x_GL1"></a><p class="docText">Now the pair we use to represent the loop state is
    represented and returned as unboxed primitive types and will be kept in
    registers. The final version now allocates heap memory for the list nodes
    only, as the list is lazily demanded. If we compile and run this tuned
    version, we can compare the allocation and time performance against our
    original program:</p><pre class="calibre39">$ <b class="calibre40">time ./H 1e7 +RTS -sstderr</b>
./H 1e7 +RTS -sstderr 
5000000.5
1,689,133,824 bytes allocated in the heap
    284,432 bytes copied during GC (scavenged)
         32 bytes copied during GC (not scavenged)
     45,056 bytes maximum residency (1 sample(s))

       3222 collections in generation 0 (  0.01s)
          1 collections in generation 1 (  0.00s)

          1 Mb total memory in use

  INIT  time    0.00s  (  0.00s elapsed)
  MUT   time    0.63s  (  0.63s elapsed)
  GC    time    0.01s  (  0.02s elapsed)
  EXIT  time    0.00s  (  0.00s elapsed)
  Total time    0.64s  (  0.64s elapsed)

  %GC time       1.0%  (2.4% elapsed)

  Alloc rate    2,667,227,478 bytes per MUT second

  Productivity  98.4% of total user, 98.2% of total elapsed

./H 1e7 +RTS -sstderr  0.64s user 0.00s system 99% cpu 0.644 total
</pre><a name="x_HL1" class="calibre27" id="x_HL1"></a><p class="docText">Our original program, when operating on a list of 10
    million elements, took more than a minute to run and allocated more than
    700 megabytes of memory. The final version, using a simple higher order
    fold and a strict data type, however runs in around half a second and
    allocates a total of 1 megabyte. Quite an improvement!</p><a name="x_IL1" class="calibre27" id="x_IL1"></a><p class="docText">The general rules we can learn from the profiling and
    optimization process are:</p><ul class="calibre18"><li class="calibre19"><p class="docText">Compile to native code, with optimizations on.</p></li><li class="calibre19"><p class="docText">When in doubt, use runtime statistics and time
        profiling.</p></li><li class="calibre19"><p class="docText">If you suspect allocation problems, use heap
        profiling.</p></li><li class="calibre19"><p class="docText">A careful mixture of strict and lazy evaluation can
        yield the best results.</p></li><li class="calibre19"><p class="docText">Prefer strict fields for atomic data types
        (<tt class="calibre34">Int</tt>, <tt class="calibre34">Double</tt>, and similar types).</p></li><li class="calibre19"><p class="docText">Use data types with simpler machine representations
        (prefer <tt class="calibre34">Int</tt> over <tt class="calibre34">Integer</tt>).</p></li></ul><a name="x_PL1" class="calibre27" id="x_PL1"></a><p class="docText">These simple strategies are enough to identify and squash
    untoward memory use issues, and when used wisely, can keep them from
    occurring in the first place.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="I_sect125_d1e48856.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect125_d1e49269.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

