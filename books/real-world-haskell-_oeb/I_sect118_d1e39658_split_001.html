---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect118_d1e39658_split_000.html
next: I_sect118_d1e39658_split_002.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<p class="calibre37"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="sfbody1"><tr class="calibre16"><td class="v3"><h2 class="docSidebarTitle" id="calibre_pb_0">Where's the Missing Type Parameter?</h2><p class="docText">You might have noticed that our <tt class="calibre34">type</tt> synonym doesn't have the usual type
      parameter <span class="docMonofont">a</span> that we associate with a monadic
      type:</p><pre class="calibre39">-- file: ch18/UglyStack.hs
type App2 a = ReaderT AppConfig (StateT AppState IO) a</pre><br class="calibre48"/>
<a name="x_jt" class="calibre27" id="x_jt"></a><p class="docText">Both App and App2 work fine in
      normal type signatures. The difference arises when we try to construct
      another type from one of these. Say we want to add another monad
      transformer to the stack: the compiler will allow WriterT [String]
      App a, but reject WriterT [String] App2 a.</p><a name="x_kt" class="calibre27" id="x_kt"></a><p class="docText">The reason for this is that Haskell does not allow us to
      partially apply a type synonym. The synonym App doesn't
      take a type parameter, so it doesn't pose a problem. However, because
      App2 takes a type parameter, we must supply some type for
      that parameter if we want to use App2 to create another
      type.</p><a name="x_lt" class="calibre27" id="x_lt"></a><p class="docText">This restriction is limited to type synonyms. When we
      create a monad transformer stack, we usually wrap it with a
      <tt class="calibre34">newtype</tt> (as we will see shortly). As a result, we will
      rarely run into this problem in practice.</p></td></tr></table></p><br class="calibre20"/><a name="x_mt" class="calibre5" id="x_mt"></a><p class="docText">The execution function for our monad stack is
    simple:</p><pre class="calibre35">-- file: ch18/UglyStack.hs
runApp :: App a -&gt; Int -&gt; IO (a, AppState)
runApp k maxDepth =
    let config = AppConfig maxDepth
        state = AppState 0
    in runStateT (runReaderT k config) state</pre><br class="calibre20"/>
<a name="x_nt" class="calibre5" id="x_nt"></a><p class="docText">Our application of <i class="docEmphasis">runReaderT</i> removes the ReaderT
    transformer wrapper, while <i class="docEmphasis">runStateT</i>
    removes the StateT wrapper, leaving us with a result in the
    IO monad.</p><a name="x_ot" class="calibre5" id="x_ot"></a><p class="docText">Compared to earlier versions, the only complications we
    added to our traversal function are slight. We track our current depth,
    and record the maximum depth we reach:</p><pre class="calibre35">-- file: ch18/UglyStack.hs
constrainedCount :: Int -&gt; FilePath -&gt; App [(FilePath, Int)]
constrainedCount curDepth path = do
  contents &lt;- liftIO . listDirectory $ path
  cfg &lt;- ask
  rest &lt;- forM contents $ \name -&gt; do
            let newPath = path &lt;/&gt; name
            isDir &lt;- liftIO $ doesDirectoryExist newPath
            if isDir &amp;&amp; curDepth &lt; cfgMaxDepth cfg
              then do
                let newDepth = curDepth + 1
                st &lt;- get
                when (stDeepestReached st &lt; newDepth) $
                  put st { stDeepestReached = newDepth }
                constrainedCount newDepth newPath
              else return []
  return $ (path, length contents) : concat rest</pre><br class="calibre20"/>
<a name="x_pt" class="calibre5" id="x_pt"></a><p class="docText">Our use of monad transformers here is admittedly a little
    contrived. Because we're writing a single straightforward function, we're
    not really winning anything. What's useful about this approach, though, is
    that it <span class="docEmphasis">scales</span> to bigger programs.</p><a name="x_qt" class="calibre5" id="x_qt"></a><p class="docText">We can write most of an application's imperative-style
    code in a monad stack similar to our App monad. In a real
    program, we'd carry around more complex configuration data, but we'd still
    use ReaderT to keep it read-only and hidden except when
    needed. We'd have more mutable state to manage, but we'd still use
    StateT to encapsulate it.</p><a name="I_sect118_d1e39658d1e40172" class="calibre5" id="I_sect118_d1e39658d1e40172"></a><h4 id="title-IDATQKVC" class="docSection1Title">18.4.1. Hiding Our Work</h4><a name="x_rt" class="calibre5" id="x_rt"></a><p class="docText">We can use the usual <tt class="calibre34">newtype</tt> technique to
      erect a solid barrier between the implementation of our custom monad and
      its interface:</p><pre class="calibre35">-- file: ch18/UglyStack.hs
newtype MyApp a = MyA {
      runA :: ReaderT AppConfig (StateT AppState IO) a
    } deriving (Monad, MonadIO, MonadReader AppConfig,
                MonadState AppState)

runMyApp :: MyApp a -&gt; Int -&gt; IO (a, AppState)
runMyApp k maxDepth =
    let config = AppConfig maxDepth
        state = AppState 0
    in runStateT (runReaderT (runA k) config) state</pre><br class="calibre20"/>
<a name="x_st" class="calibre5" id="x_st"></a><p class="docText">If we export the MyApp type constructor and
      the <i class="docEmphasis">runMyApp</i> execution function
      from a module, client code will not be able to tell that the internals
      of our monad is a stack of monad transformers.</p><a name="x_tt" class="calibre5" id="x_tt"></a><p class="docText">The large <tt class="calibre34">deriving</tt> clause requires
      the<a name="I_indexterm18_d1e39872" class="calibre27" id="I_indexterm18_d1e39872"></a> <tt class="calibre34">GeneralizedNewtypeDeriving</tt>
      language<a name="I_indexterm18_d1e39881" class="calibre27" id="I_indexterm18_d1e39881"></a> pragma. It seems somehow magical that the compiler can
      derive all of these instances for us. How does this work?</p><a name="x_ut" class="calibre5" id="x_ut"></a><p class="docText">Earlier, we mentioned that the <tt class="calibre34">mtl</tt> library
      provides instances of a number of typeclasses for each monad
      transformer. For example, the IO monad implements
      MonadIO. If the underlying monad is an instance of
      MonadIO, <tt class="calibre34">mtl</tt> makes StateT an
      instance, too, and likewise for ReaderT.</p><a name="x_vt" class="calibre5" id="x_vt"></a><p class="docText">There is thus no magic going on: the top-level monad
      transformer in the stack is an instance of all of the typeclasses that
      we're rederiving with our <tt class="calibre34">deriving</tt> clause. This is a
      consequence of <tt class="calibre34">mtl</tt> providing a carefully coordinated set of
      typeclasses and instances that fit together well. There is nothing more
      going on than the usual automatic derivation that we can perform with
      <tt class="calibre34">newtype</tt> declarations.</p><a name="I_sidebar18_d1e39921" class="calibre5" id="I_sidebar18_d1e39921"></a></div>

{% endraw %}

