---
layout: page
title: "Real World Haskell, 1st Edition"
prev: fp_lists_split_001.html
next: fp_loop_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="fp_lists_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="fp_anonymous.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="fp_loop" class="calibre27" id="fp_loop"></a><h3 id="643999-898" class="docSection1Title">4.6. How to Think About Loops</h3><a name="x_i7" class="calibre27" id="x_i7"></a><p class="docText">Unlike<a name="I_indexterm4_d1e10138" class="calibre27" id="I_indexterm4_d1e10138"></a><a name="ch04-loops0001" class="calibre27" id="ch04-loops0001"></a> traditional languages, Haskell has neither a
    <tt class="calibre34">for</tt> loop nor a <tt class="calibre34">while</tt> loop. If we've got a lot of
    data to process, what do we use instead? There are several possible
    answers to this question.</p><a name="fp_tailrecursion" class="calibre27" id="fp_tailrecursion"></a><h4 id="title-IDAHAJVC" class="docSection1Title">4.6.1. Explicit Recursion</h4><a name="x_j7" class="calibre27" id="x_j7"></a><p class="docText">A straightforward<a name="I_indexterm4_d1e10154" class="calibre27" id="I_indexterm4_d1e10154"></a><a name="I_indexterm4_d1e10157" class="calibre27" id="I_indexterm4_d1e10157"></a> way to make the jump from a language that has loops to
      one that doesn't is to run through a few examples, looking at the
      differences. Here's a C function that takes a string of decimal digits
      and turns them into an integer:</p><pre class="calibre39">int as_int(char *str)
{
    int acc; /* accumulate the partial result */

    for (acc = 0; isdigit(*str); str++) {
	acc = acc * 10 + (*str - '0');
    }

    return acc;
}</pre><br class="calibre48"/>
<a name="x_k7" class="calibre27" id="x_k7"></a><p class="docText">Given that Haskell doesn't have any looping constructs,
      how should we think about representing a fairly straightforward piece of
      code such as this?</p><a name="x_l7" class="calibre27" id="x_l7"></a><p class="docText">We don't have to start off by writing a type signature,
      but it helps to remind us of what we're working with:</p><pre class="calibre39">-- file: ch04/IntParse.hs
import Data.Char (digitToInt) -- we'll need ord shortly

asInt :: String -&gt; Int</pre><br class="calibre48"/>
<a name="x_m7" class="calibre27" id="x_m7"></a><p class="docText">The C code computes the result incrementally as it
      traverses the string; the Haskell code can do the same. However, in
      Haskell, we can express the equivalent of a loop as a function. We'll
      call ours <i class="docEmphasis">loop</i> just to keep things
      nice and explicit:</p><pre class="calibre39">-- file: ch04/IntParse.hs
loop :: Int -&gt; String -&gt; Int

asInt xs = loop 0 xs</pre><br class="calibre48"/>
<a name="x_n7" class="calibre27" id="x_n7"></a><p class="docText">That first parameter to <i class="docEmphasis">loop</i> is the accumulator variable we'll be
      using. Passing zero into it is equivalent to initializing the
      <span class="docMonofont">acc</span> variable in C at the beginning of the
      loop.</p><a name="x_o7" class="calibre27" id="x_o7"></a><p class="docText">Rather than leap into blazing code, let's think about
      the data we have to work with. Our familiar <tt class="calibre34">String</tt> is just
      a synonym for <tt class="calibre34">[Char]</tt>, a list of characters. The easiest way
      for us to get the traversal right is to think about the structure of a
      list: it's either empty or a single element followed by the rest of the
      list.</p><a name="x_p7" class="calibre27" id="x_p7"></a><p class="docText">We can express this structural thinking directly by
      pattern matching on the list type's constructors. It's often handy to
      think about the easy cases first; here, that means we will consider the
      empty list case:</p><pre class="calibre39">-- file: ch04/IntParse.hs
loop acc [] = acc</pre><br class="calibre48"/>
<a name="x_q7" class="calibre27" id="x_q7"></a><p class="docText">An empty list<a name="I_indexterm4_d1e10201" class="calibre27" id="I_indexterm4_d1e10201"></a> doesn't just mean "the input string is
      empty"; it's also the case that we'll encounter when we traverse
      all the way to the end of a nonempty list. So we don't want to
      "error out" if we see an empty list. Instead, we should do
      something sensible. Here, the sensible thing is to terminate the loop
      and return our accumulated value.</p><a name="x_r7" class="calibre27" id="x_r7"></a><p class="docText">The other case we have to consider arises when the input
      list is not empty. We need to do something with the current element of
      the list, and something with the rest of the list:</p><pre class="calibre39">-- file: ch04/IntParse.hs
loop acc (x:xs) = let acc' = acc * 10 + digitToInt x
                  in loop acc' xs</pre><br class="calibre48"/>
<a name="x_s7" class="calibre27" id="x_s7"></a><p class="docText">We compute a new value for the accumulator and give it
      the name <span class="docMonofont">acc'</span>. We then call <a name="I_indexterm4_d1e10222" class="calibre27" id="I_indexterm4_d1e10222"></a>the <i class="docEmphasis">loop</i> function
      again, passing it the updated value <span class="docMonofont">acc'</span> and the rest
      of the input list. This is equivalent to the loop starting another round
      in C.</p><a name="fp_tailrecursiond1e10292" class="calibre27" id="fp_tailrecursiond1e10292"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_t7" class="calibre27" id="x_t7"></a></p><p class="docText">Remember, a single quote is a legal character to use
        in a Haskell variable name, and it is pronounced "prime."
        There's a common idiom in Haskell programs involving a variable—say,
        <span class="docMonofont">foo</span>—and another variable—say,
        <span class="docMonofont">foo'</span>. We can usually assume that
        <span class="docMonofont">foo'</span> is somehow related to <span class="docMonofont">foo</span>.
        It's often a new value for <span class="docMonofont">foo</span>, as just shown in
        our code.</p><a name="x_u7" class="calibre27" id="x_u7"></a><p class="docText">Sometimes we'll see this idiom extended, such as
        <span class="docMonofont">foo''</span>. Since keeping track of the number of single
        quotes tacked onto the end of a name rapidly becomes tedious, use of
        more than two in a row is thankfully rare. Indeed, even one single
        quote can be easy to miss, which can lead to confusion on the part of
        readers. It might be better to think of the use of single quotes as a
        coding convention that you should be able to recognize, and less as
        one that you should actually follow.</p></div><a name="x_v7" class="calibre27" id="x_v7"></a><p class="docText">Each time the <i class="docEmphasis">loop</i>
      function calls itself, it has a new value for the accumulator, and it
      consumes one element of the input list. Eventually, it's going to hit
      the end of the list, at which time the <tt class="calibre34">[]</tt> pattern will
      match and the recursive calls will cease.</p><a name="x_w7" class="calibre27" id="x_w7"></a><p class="docText">How well does this function work? For positive integers,
      it's perfectly cromulent:</p><pre class="calibre39">ghci&gt; <b class="calibre40">asInt "33"</b>
33
</pre><a name="x_x7" class="calibre27" id="x_x7"></a><p class="docText">But because we were focusing on how to traverse lists,
      not error handling, our poor function misbehaves if we try to feed it
      nonsense:</p><pre class="calibre39">ghci&gt; <b class="calibre40">asInt ""</b>
0
ghci&gt; <b class="calibre40">asInt "potato"</b>
*** Exception: Char.digitToInt: not a digit 'p'</pre><a name="x_y7" class="calibre27" id="x_y7"></a><p class="docText">We'll defer fixing our function's shortcomings to <a class="docLink" href="#exercises1">Exercises</a>.</p><a name="x_z7" class="calibre27" id="x_z7"></a><p class="docText">Because the last thing that <i class="docEmphasis">loop</i> does is simply call itself, it's an
      example of a tail recursive function. There's another common idiom in
      this code, too. Thinking about the <span class="docEmphasis">structure</span> of the list, and handling the
      empty and nonempty cases separately, is a kind of approach <a name="I_indexterm4_d1e10303" class="calibre27" id="I_indexterm4_d1e10303"></a>called <span class="docEmphasis">structural recursion</span>.</p><a name="x_A8" class="calibre27" id="x_A8"></a><p class="docText">We call the nonrecursive case (when the list is empty)
      the <span class="docEmphasis">base case</span> (or sometimes the
      <span class="docEmphasis">terminating case</span>). We'll see people refer to the
      case where the function calls itself as the recursive case (surprise!),
      or they might give a nod to mathematical induction and call it
      <a name="I_indexterm4_d1e10318" class="calibre27" id="I_indexterm4_d1e10318"></a><a name="I_indexterm4_d1e10323" class="calibre27" id="I_indexterm4_d1e10323"></a>the <span class="docEmphasis">inductive case</span>.</p><a name="x_B8" class="calibre27" id="x_B8"></a><p class="docText">As a useful technique, structural recursion is not
      confined to lists; we can use it on other algebraic data types, too.
      We'll have more to say about it later.</p><a name="fp_tailrecursiond1e10392" class="calibre27" id="fp_tailrecursiond1e10392"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_QL" class="calibre27" id="x_QL"></a></p><p class="docText">In an imperative language, a loop executes in constant
        space. Lacking loops, we use tail recursive functions in Haskell
        instead. Normally, a recursive function allocates some space each time
        it applies itself, so it knows where to return to.</p><a name="x_RL" class="calibre27" id="x_RL"></a><p class="docText">Clearly, a recursive function would be at a huge
        disadvantage relative to a loop if it allocated memory for every
        recursive application—this would require linear space instead of
        constant space. However, functional language implementations detect
        uses of tail recursion and transform tail recursive calls to run in
        constant space; this is called <span class="docEmphasis">tail call
        optimization</span> (TCO).</p><a name="x_SL" class="calibre27" id="x_SL"></a><p class="docText">Few imperative language implementations perform TCO;
        this is why using any kind of ambitiously functional style in an
        imperative language often leads to memory leaks and poor
        performance.</p></div><a name="fp_loopd1e10404" class="calibre27" id="fp_loopd1e10404"></a><h4 id="title-IDAEHJVC" class="docSection1Title">4.6.2. Transforming Every Piece of Input</h4><a name="x_C8" class="calibre27" id="x_C8"></a><p class="docText">Consider another <a name="I_indexterm4_d1e10349" class="calibre27" id="I_indexterm4_d1e10349"></a><a name="I_indexterm4_d1e10354" class="calibre27" id="I_indexterm4_d1e10354"></a>C function, <i class="docEmphasis">square</i>,
      which squares every element in an array:</p><pre class="calibre39">void square(double *out, const double *in, size_t length)
{
    for (size_t i = 0; i &lt; length; i++) {
	out[i] = in[i] * in[i];
    }
}</pre><br class="calibre48"/>
<a name="x_D8" class="calibre27" id="x_D8"></a><p class="docText">This contains a straightforward and common kind of loop,
      one that does exactly the same thing to every element of its input
      array. How might we write this loop in Haskell?</p><pre class="calibre39">-- file: ch04/Map.hs
square :: [Double] -&gt; [Double]

square (x:xs) = x*x : square xs
square []     = []</pre><br class="calibre48"/>
<a name="x_E8" class="calibre27" id="x_E8"></a><p class="docText">Our <i class="docEmphasis">square</i> function
      consists of two pattern-matching equations. The first
      "deconstructs" the beginning of a nonempty list, in order
      to get its head and tail. It squares the first element, then puts that
      on the front of a new list, which is constructed by calling <i class="docEmphasis">square</i> on the remainder of the empty list.
      The second equation ensures that <i class="docEmphasis">square</i> halts when it reaches the end of the
      input list.</p><a name="x_F8" class="calibre27" id="x_F8"></a><p class="docText">The effect of <i class="docEmphasis">square</i> is to construct a new list that's the
      same length as its input list, with every element in the input list
      substituted with its square in the output list.</p><a name="x_G8" class="calibre27" id="x_G8"></a><p class="docText">Here's another such C loop, one that ensures that every
      letter in a string is converted to uppercase:</p><pre class="calibre39">#include &lt;ctype.h&gt;

char *uppercase(const char *in)
{
    char *out = strdup(in);
    
    if (out != NULL) {
	for (size_t i = 0; out[i] != '\0'; i++) {
	    out[i] = toupper(out[i]);
	}
    }

    return out;
}</pre><br class="calibre48"/>
<a name="x_H8" class="calibre27" id="x_H8"></a><p class="docText">Let's look at a Haskell equivalent:</p><pre class="calibre39">-- file: ch04/Map.hs
import Data.Char (toUpper)

upperCase :: String -&gt; String

upperCase (x:xs) = toUpper x : upperCase xs
upperCase []     = []</pre><br class="calibre48"/>
<a name="x_I8" class="calibre27" id="x_I8"></a><p class="docText">Here, we're importing the <i class="docEmphasis">toUpper</i> function<a name="I_indexterm4_d1e10402" class="calibre27" id="I_indexterm4_d1e10402"></a><a name="I_indexterm4_d1e10405" class="calibre27" id="I_indexterm4_d1e10405"></a> from the standard <tt class="calibre34">Data.Char</tt> module, which
      contains lots of useful functions for working with <tt class="calibre34">Char</tt>
      data.</p><a name="x_J8" class="calibre27" id="x_J8"></a><p class="docText">Our <i class="docEmphasis">upperCase</i>
      function follows a similar pattern to our earlier <i class="docEmphasis">square</i> function. It terminates with an empty
      list when the input list is empty; when the input isn't empty, it calls
      <i class="docEmphasis">toUpper</i> on the first element, then
      constructs a new list cell from that and the result of calling itself on
      the rest of the input list.</p><a name="x_K8" class="calibre27" id="x_K8"></a><p class="docText">These examples follow a common pattern for writing
      recursive functions over lists in Haskell.<a name="I_indexterm4_d1e10428" class="calibre27" id="I_indexterm4_d1e10428"></a> The base case handles the situation where our input list
      is empty. The <span class="docEmphasis">recursive case</span> deals with a nonempty
      list;<a name="I_indexterm4_d1e10435" class="calibre27" id="I_indexterm4_d1e10435"></a> it does something with the head of the list and calls
      itself recursively on the tail.</p><a name="fp_loopd1e10499" class="calibre27" id="fp_loopd1e10499"></a><h4 id="title-IDAALJVC" class="docSection1Title">4.6.3. Mapping over a List</h4><a name="x_L8" class="calibre27" id="x_L8"></a><p class="docText">The<a name="ch04-listsmapping" class="calibre27" id="ch04-listsmapping"></a><a name="I_indexterm4_d1e10449" class="calibre27" id="I_indexterm4_d1e10449"></a> <i class="docEmphasis">square</i> and <i class="docEmphasis">upperCase</i> functions that we just defined
      produce new lists that are the same lengths as their input lists, and
      they do only one piece of work per element. This is such a common
      pattern that Haskell's <tt class="calibre34">Prelude</tt> defines a function,
      <i class="docEmphasis">map</i>, in<a name="I_indexterm4_d1e10466" class="calibre27" id="I_indexterm4_d1e10466"></a> order to make it easier. <i class="docEmphasis">map</i> takes a function and applies it to every
      element of a list, returning a new list constructed from the results of
      these applications.</p><a name="x_M8" class="calibre27" id="x_M8"></a><p class="docText">Here are our <i class="docEmphasis">square</i>
      and <i class="docEmphasis">upperCase</i> functions rewritten
      to use <i class="docEmphasis">map</i>:</p><pre class="calibre39">-- file: ch04/Map.hs
square2 xs = map squareOne xs
    where squareOne x = x * x

upperCase2 xs = map toUpper xs</pre><br class="calibre48"/>
<a name="x_N8" class="calibre27" id="x_N8"></a><p class="docText">This is our first close look at a function that takes
      another function as its argument. We can learn a lot about what
      <i class="docEmphasis">map</i> does by simply inspecting its
      type:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type map</b>
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</pre><a name="x_O8" class="calibre27" id="x_O8"></a><p class="docText">The signature tells us that <i class="docEmphasis">map</i> takes two arguments. The first is a
      function that takes a value of one type, <span class="docMonofont">a</span>, and returns a value of another type, <span class="docMonofont">b</span>.</p><a name="x_P8" class="calibre27" id="x_P8"></a><p class="docText">Because <i class="docEmphasis">map</i> takes a
      function as an argument, we refer to it<a name="I_indexterm4_d1e10513" class="calibre27" id="I_indexterm4_d1e10513"></a><a name="I_indexterm4_d1e10516" class="calibre27" id="I_indexterm4_d1e10516"></a> as a <span class="docEmphasis">higher-order</span> function. (In
      spite of the name, there's nothing mysterious about higher-order
      functions; it's just a term for functions that take other functions as
      arguments, or return functions.)</p><a name="x_Q8" class="calibre27" id="x_Q8"></a><p class="docText">Since <i class="docEmphasis">map</i> abstracts
      out the pattern common to our <i class="docEmphasis">square</i> and <i class="docEmphasis">upperCase</i> functions so that we can reuse it
      with less boilerplate, we can look at what those functions have in
      common and figure out how to implement it ourselves:</p><pre class="calibre39">-- file: ch04/Map.hs
myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]

myMap f (x:xs) = f x : myMap f xs
myMap _ _      = []</pre><br class="calibre48"/>
<a name="idd1e10598" class="calibre27" id="idd1e10598"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_TL" class="calibre27" id="x_TL"></a></p><p class="docText">If you're new to functional programming, the reasons
        for matching <span class="docEmphasis">patterns</span> in certain
        ways won't always be obvious. For example, in the definition of
        <i class="docEmphasis">myMap</i> in the preceding code, the
        first equation binds the <span class="docEmphasis">function</span> we're mapping to the variable
        <span class="docMonofont">f</span>, but the second uses wild cards for both
        parameters. What's going on?</p><a name="x_UL" class="calibre27" id="x_UL"></a><p class="docText">We use a wild card in place of <span class="docMonofont">f</span> to
        indicate that we aren't calling the function <span class="docMonofont">f</span> on
        the righthand side of the equation. What about the list parameter? The
        list type has two constructors. We've already matched on the nonempty
        constructor in the first equation that defines <i class="docEmphasis">myMap</i>. By elimination, the constructor in
        the second equation is necessarily the empty list constructor, so
        there's no need to perform a match to see what its value really
        is.</p><a name="x_rC1" class="calibre27" id="x_rC1"></a><p class="docText">As a matter of style, it is fine to use wild cards
        for well-known simple types such as <tt class="calibre34">lists</tt> and
        <tt class="calibre34">Maybe</tt>. For more complicated or less familiar types, it
        can be safer and more readable to name constructors explicitly.</p></div><a name="x_R8" class="calibre27" id="x_R8"></a><p class="docText">We try out our <i class="docEmphasis">myMap</i> function to give ourselves some
      assurance that it behaves similarly to the standard <i class="docEmphasis">map</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:module +Data.Char</b>ghci&gt; <b class="calibre40">map toLower "SHOUTING"</b>
"shouting"
ghci&gt; <b class="calibre40">myMap toUpper "whispering"</b>
"WHISPERING"
ghci&gt; <b class="calibre40">map negate [1,2,3]</b>
[-1,-2,-3]</pre><a name="x_S8" class="calibre27" id="x_S8"></a><p class="docText">This pattern of spotting a repeated idiom, and then
      abstracting it so we can reuse (and write less!) code, is a common
      aspect of Haskell programming. While abstraction isn't unique to
      Haskell, higher-order functions make it remarkably easy.</p><a name="fp_filter" class="calibre27" id="fp_filter"></a><h4 id="title-IDANRJVC" class="docSection1Title">4.6.4. Selecting Pieces of Input</h4><a name="x_T8" class="calibre27" id="x_T8"></a><p class="docText">Another<a name="I_indexterm4_d1e10611" class="calibre27" id="I_indexterm4_d1e10611"></a> common operation on a sequence
      of data is to comb through it for elements that satisfy some criterion.
      Here's a function that walks a list of numbers and returns those that
      are odd. Our code has a recursive case that's a bit more complex than
      our earlier functions—it puts a number in the list it returns only if
      the number is odd. Using a guard expresses this nicely:</p><pre class="calibre39">-- file: ch04/Filter.hs
oddList :: [Int] -&gt; [Int]

oddList (x:xs) | odd x     = x : oddList xs
               | otherwise = oddList xs
oddList _                  = []</pre><br class="calibre48"/>
<a name="x_V8" class="calibre27" id="x_V8"></a><p class="docText">Let's see that in action:</p><pre class="calibre39">ghci&gt; <b class="calibre40">oddList [1,1,2,3,5,8,13,21,34]</b>
[1,1,3,5,13,21]
</pre><a name="x_W8" class="calibre27" id="x_W8"></a><p class="docText">Once again, this idiom is so common that the
      <tt class="calibre34">Prelude</tt> defines a<a name="I_indexterm4_d1e10628" class="calibre27" id="I_indexterm4_d1e10628"></a> function, <i class="docEmphasis">filter</i>,
      which we already introduced. It removes the need for boilerplate code to
      recurse over the list:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type filter</b>
filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
ghci&gt; <b class="calibre40">filter odd [3,1,4,1,5,9,2,6,5]</b>
[3,1,1,5,9,5]</pre><a name="x_X8" class="calibre27" id="x_X8"></a><p class="docText">The <i class="docEmphasis">filter</i> function
      takes a predicate and applies it to every element in its input list,
      returning a list of only those for which the predicate evaluates to
      <tt class="calibre34">true</tt>. We'll revisit <i class="docEmphasis">filter</i> again later in this chapter in <a class="docLink" href="#fp_foldr_filter">Section 4.6.8</a>.</p><a name="fp_loopd1e10718" class="calibre27" id="fp_loopd1e10718"></a><h4 id="title-IDAXTJVC" class="docSection1Title">4.6.5. Computing One Answer over a Collection</h4><a name="x_Z8" class="calibre27" id="x_Z8"></a><p class="docText">It is also common to reduce a collection to a single
      value. A simple example of this is summing the values of a list:</p><pre class="calibre39">-- file: ch04/Sum.hs
mySum xs = helper 0 xs
    where helper acc (x:xs) = helper (acc + x) xs
          helper acc _      = acc</pre><br class="calibre48"/>
<a name="x_a8" class="calibre27" id="x_a8"></a><p class="docText">Our <i class="docEmphasis">helper</i> function
      is tail-recursive and uses an accumulator parameter,
      <span class="docMonofont">acc</span>, to hold the current partial sum of the list. As
      we already saw with <i class="docEmphasis">asInt</i>, this is
      a "natural" way to represent a loop in a pure functional
      language.</p><a name="x_b8" class="calibre27" id="x_b8"></a><p class="docText">For something a little more complicated, let's take a
      look at the Adler-32 checksum. <a name="I_indexterm4_d1e10682" class="calibre27" id="I_indexterm4_d1e10682"></a>It is a popular checksum algorithm; it concatenates two
      16-bit checksums into a single 32-bit checksum. The first checksum is
      the sum of all input bytes, plus one. The second is the sum of all
      intermediate values of the first checksum. In each case, the sums are
      computed modulo 65521. Here's a straightforward, unoptimized Java
      implementation (it's safe to skip it if you don't read Java):</p><pre class="calibre39">public class Adler32 
{
    private static final int base = 65521;

    public static int compute(byte[] data, int offset, int length)
    {
	int a = 1, b = 0;

	for (int i = offset; i &lt; offset + length; i++) {
	    a = (a + (data[i] &amp; 0xff)) % base;
	    b = (a + b) % base;
	}

	return (b &lt;&lt; 16) | a;
    }
}</pre><br class="calibre48"/>
<a name="x_c8" class="calibre27" id="x_c8"></a><p class="docText">Although Adler-32 is a simple checksum, this code isn't
      particularly easy to read on account of the bit-twiddling involved. Can
      we do any better with a Haskell <span class="docEmphasis">implementation</span>?</p><pre class="calibre39">-- file: ch04/Adler32.hs
import Data.Char (ord)
import Data.Bits (shiftL, (.&amp;.), (.|.))

base = 65521

adler32 xs = helper 1 0 xs
    where helper a b (x:xs) = let a' = (a + (ord x .&amp;. 0xff)) `mod` base
                                  b' = (a' + b) `mod` base
                              in helper a' b' xs
          helper a b _     = (b `shiftL` 16) .|. a</pre><br class="calibre48"/>
<a name="x_d8" class="calibre27" id="x_d8"></a><p class="docText">This code isn't exactly easier to follow than the Java
      code, but let's look at what's going on. First of all, we've introduced
      some new functions. The <i class="docEmphasis">shiftL</i>
      function<a name="I_indexterm4_d1e10700" class="calibre27" id="I_indexterm4_d1e10700"></a><a name="I_indexterm4_d1e10703" class="calibre27" id="I_indexterm4_d1e10703"></a><a name="I_indexterm4_d1e10706" class="calibre27" id="I_indexterm4_d1e10706"></a><a name="I_indexterm4_d1e10709" class="calibre27" id="I_indexterm4_d1e10709"></a><a name="I_indexterm4_d1e10712" class="calibre27" id="I_indexterm4_d1e10712"></a> implements a logical shift left; <i class="docEmphasis">(.&amp;.)</i> provides a bitwise
      "and"; and <i class="docEmphasis">(.|.)</i>
      provides a bitwise "or".</p><a name="x_sC1" class="calibre27" id="x_sC1"></a><p class="docText">Once again, our <i class="docEmphasis">helper</i> function is tail-recursive. We've
      turned the two variables that we updated on every loop iteration in Java
      into accumulator parameters. When our recursion terminates on the end of
      the input list, we compute our checksum and return it.</p><a name="x_e8" class="calibre27" id="x_e8"></a><p class="docText">If we take a step back, we can restructure our Haskell
      <i class="docEmphasis">adler32</i> to more closely resemble
      our earlier <i class="docEmphasis">mySum</i> function. Instead
      of two accumulator parameters, we can use a pair as the
      accumulator:</p><pre class="calibre39">-- file: ch04/Adler32.hs
adler32_try2 xs = helper (1,0) xs
    where helper (a,b) (x:xs) =
              let a' = (a + (ord x .&amp;. 0xff)) `mod` base
                  b' = (a' + b) `mod` base
              in helper (a',b') xs
          helper (a,b) _     = (b `shiftL` 16) .|. a</pre><br class="calibre48"/>
<a name="x_f8" class="calibre27" id="x_f8"></a><p class="docText">Why would we want to make this seemingly meaningless
      structural change? Because as we've already seen with <i class="docEmphasis">map</i> and <i class="docEmphasis">filter</i>, we can extract the common behavior
      shared by <i class="docEmphasis">mySum</i> and <i class="docEmphasis">adler32_try2</i> into a higher-order function. We
      can describe this behavior as "do something to every element of a
      list, updating an accumulator as we go, and returning the accumulator
      when we're done."</p><a name="x_g8" class="calibre27" id="x_g8"></a><p class="docText">This kind of function is called a
      <span class="docEmphasis">fold</span>, because<a name="I_indexterm4_d1e10766" class="calibre27" id="I_indexterm4_d1e10766"></a><a name="I_indexterm4_d1e10769" class="calibre27" id="I_indexterm4_d1e10769"></a> it "folds up" a list. There are two kinds of
      fold-over lists: <i class="docEmphasis">foldl</i> for folding
      from the left (the start), and<a name="I_indexterm4_d1e10781" class="calibre27" id="I_indexterm4_d1e10781"></a> <i class="docEmphasis">foldr</i> for folding
      from the right (the end).</p><a name="fp_foldl" class="calibre27" id="fp_foldl"></a><h4 id="title-IDA1YJVC" class="docSection1Title">4.6.6. The Left Fold</h4><p class="docText">Here is the <a name="I_indexterm4_d1e10794" class="calibre27" id="I_indexterm4_d1e10794"></a><a name="I_indexterm4_d1e10797" class="calibre27" id="I_indexterm4_d1e10797"></a>definition of <i class="docEmphasis">foldl</i>:</p><pre class="calibre39">-- file: ch04/Fold.hs
foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a

foldl step zero (x:xs) = foldl step (step zero x) xs
foldl _    zero []     = zero</pre><br class="calibre48"/>
<a name="x_h8" class="calibre27" id="x_h8"></a><p class="docText">The <i class="docEmphasis">foldl</i> function
      takes a "step" function, an initial value for its
      accumulator, and a list. The "step" takes an accumulator
      and an element from the list and returns a new accumulator value. All
      <i class="docEmphasis">foldl</i> does is call the
      "stepper" on the current accumulator and an element of the
      list, and then passes the new accumulator value to itself recursively to
      consume the rest of the list.</p><a name="x_i8" class="calibre27" id="x_i8"></a><p class="docText">We refer to <i class="docEmphasis">foldl</i>
      as a <span class="docEmphasis">left fold</span> because<a name="I_indexterm4_d1e10833" class="calibre27" id="I_indexterm4_d1e10833"></a> it consumes the list from left (the head) to
      right.</p><a name="x_j8" class="calibre27" id="x_j8"></a><p class="docText">Here's a rewrite of <i class="docEmphasis">mySum</i> using <i class="docEmphasis">foldl</i>:</p><pre class="calibre39">-- file: ch04/Sum.hs
foldlSum xs = foldl step 0 xs
    where step acc x = acc + x</pre><br class="calibre48"/>
<a name="x_VL" class="calibre27" id="x_VL"></a><p class="docText">That local function <i class="docEmphasis">step</i> just adds two numbers, so let's simply
      use the addition operator instead, and eliminate the unnecessary
      <tt class="calibre34">where</tt> clause:</p><pre class="calibre39">-- file: ch04/Sum.hs
niceSum :: [Integer] -&gt; Integer
niceSum xs = foldl (+) 0 xs</pre><br class="calibre48"/>
<a name="x_k8" class="calibre27" id="x_k8"></a><p class="docText">Notice how much simpler this code is than our original
      <i class="docEmphasis">mySum</i>. We're no longer using
      explicit recursion, because <i class="docEmphasis">foldl</i>
      takes care of that for us. We've simplified our problem down to two
      things: what the initial value of the accumulator should be (the second
      parameter to <i class="docEmphasis">foldl</i>) and how to
      update the accumulator<a name="I_indexterm4_d1e10868" class="calibre27" id="I_indexterm4_d1e10868"></a><a name="I_indexterm4_d1e10871" class="calibre27" id="I_indexterm4_d1e10871"></a> (the <i class="docEmphasis">(+)</i> function).
      As an added bonus, our code is now shorter, too, which makes it easier
      to understand.</p><a name="x_WL" class="calibre27" id="x_WL"></a><p class="docText">Let's take a deeper look at what <i class="docEmphasis">foldl</i> is doing here, by manually writing out
      each step in its evaluation when we call <tt class="calibre34">niceSum
      [1,2,3]</tt>:</p><pre class="calibre39">-- file: ch04/Fold.hs
foldl (+) 0 (1:2:3:[])
          == foldl (+) (0 + 1)             (2:3:[])
          == foldl (+) ((0 + 1) + 2)       (3:[])
          == foldl (+) (((0 + 1) + 2) + 3) []
          ==           (((0 + 1) + 2) + 3)</pre><br class="calibre48"/>
<a name="x_l8" class="calibre27" id="x_l8"></a><p class="docText">We can rewrite <i class="docEmphasis">adler32_try2</i> using <i class="docEmphasis">foldl</i> to let us focus on the details that are
      <span class="docEmphasis">important</span>:</p><pre class="calibre39">-- file: ch04/Adler32.hs
adler32_foldl xs = let (a, b) = foldl step (1, 0) xs
                   in (b `shiftL` 16) .|. a
    where step (a, b) x = let a' = a + (ord x .&amp;. 0xff)
                          in (a' `mod` base, (a' + b) `mod` base)</pre><br class="calibre48"/>
<a name="x_m8" class="calibre27" id="x_m8"></a><p class="docText">Here, our accumulator is a pair, so the result of
      <i class="docEmphasis">foldl</i> will be, too. We pull the
      final accumulator apart when <i class="docEmphasis">foldl</i>
      returns, and then bit-twiddle it into a "proper" <span class="docEmphasis">checksum</span>.</p><a name="fp_loopd1e10975" class="calibre27" id="fp_loopd1e10975"></a><h4 id="title-IDA13JVC" class="docSection1Title">4.6.7. Why Use Folds, Maps, and Filters?</h4><a name="x_n8" class="calibre27" id="x_n8"></a><p class="docText">A quick glance reveals that <i class="docEmphasis">adler32_foldl</i> isn't really any shorter than
      <i class="docEmphasis">adler32_try2</i>. Why should we use a
      fold in this case? The advantage here lies in the fact that folds are
      extremely common in Haskell, and they have regular, predictable
      behavior.</p><a name="x_o8" class="calibre27" id="x_o8"></a><p class="docText">This means that a reader with a little experience will
      have an easier time understanding a use of a fold than code that uses
      explicit recursion. A fold isn't going to produce any surprises, but the
      behavior of a function that recurses explicitly isn't immediately
      obvious. Explicit recursion requires us to read closely to understand
      exactly what's going on.</p><a name="x_p8" class="calibre27" id="x_p8"></a><p class="docText">This line of reasoning applies to other higher-order
      library functions, including those we've already seen, <i class="docEmphasis">map</i> and <i class="docEmphasis">filter</i>. Because they're library functions
      with well-defined behavior, we need to learn what they do only once, and
      we'll have an advantage when we need to understand any code that uses
      them. These improvements in readability also carry over to writing code.
      Once we start to think with higher-order functions in mind, we'll
      produce concise code more quickly.</p><a name="fp_foldr_filter" class="calibre27" id="fp_foldr_filter"></a><h4 id="title-IDAY4JVC" class="docSection1Title">4.6.8. Folding from the Right</h4><a name="x_x8" class="calibre27" id="x_x8"></a><p class="docText">The counterpart to <i class="docEmphasis">foldl</i> is <i class="docEmphasis">foldr</i>, which<a name="ch04-foldfunctions001" class="calibre27" id="ch04-foldfunctions001"></a><a name="ch04-foldrfunc" class="calibre27" id="ch04-foldrfunc"></a><a name="ch04-foldlfunc" class="calibre27" id="ch04-foldlfunc"></a> folds from the right of a list:</p><pre class="calibre39">-- file: ch04/Fold.hs
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b

foldr step zero (x:xs) = step x (foldr step zero xs)
foldr _    zero []     = zero</pre><br class="calibre48"/>
<a name="x_XL" class="calibre27" id="x_XL"></a><p class="docText">Let's follow the same manual evaluation process with
      <i class="docEmphasis">foldr (+) 0 [1,2,3]</i> as we did with
      <i class="docEmphasis">niceSum</i> earlier in the section
      <a class="docLink" href="#fp_foldl">Section 4.6.6</a>:</p><pre class="calibre39">-- file: ch04/Fold.hs
foldr (+) 0 (1:2:3:[])
          == 1 +           foldr (+) 0 (2:3:[])
          == 1 + (2 +      foldr (+) 0 (3:[])
          == 1 + (2 + (3 + foldr (+) 0 []))
          == 1 + (2 + (3 + 0))</pre><br class="calibre48"/>
<a name="x_YL" class="calibre27" id="x_YL"></a><p class="docText">The difference between <i class="docEmphasis">foldl</i> and <i class="docEmphasis">foldr</i> should be clear from looking at where
      the parentheses and the empty list elements show up. With <i class="docEmphasis">foldl</i>, the empty list element is on the left,
      and all the <a name="I_indexterm4_d1e10987" class="calibre27" id="I_indexterm4_d1e10987"></a><a name="I_indexterm4_d1e10992" class="calibre27" id="I_indexterm4_d1e10992"></a>parentheses group to the left. With <i class="docEmphasis">foldr</i>, the <span class="docMonofont">zero</span> value is
      on the right, and the parentheses group to the right.</p><a name="x_ZL" class="calibre27" id="x_ZL"></a><p class="docText">There is a lovely intuitive explanation of how <i class="docEmphasis">foldr</i> works: it replaces the empty list with
      the <span class="docMonofont">zero</span> value, and replaces every constructor in the
      list with an application of the step function:</p><pre class="calibre39">-- file: ch04/Fold.hs
1 : (2 : (3 : []))
1 + (2 + (3 + 0 ))</pre><br class="calibre48"/>
<a name="x_y8" class="calibre27" id="x_y8"></a><p class="docText">At first glance, <i class="docEmphasis">foldr</i> might seem less useful than <i class="docEmphasis">foldl</i>: what use is a function that folds from
      the right? But consider the <tt class="calibre34">Prelude</tt>'s <i class="docEmphasis">filter</i> function, which we last encountered
      earlier in this chapter in <a class="docLink" href="#fp_filter">Section 4.6.4</a>. If we write
      <i class="docEmphasis">filter</i> using explicit recursion, it
      will look something like this:</p><pre class="calibre39">-- file: ch04/Fold.hs
filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter p []   = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs</pre><br class="calibre48"/>
<a name="x_z8" class="calibre27" id="x_z8"></a><p class="docText">Perhaps surprisingly, though, we can write <i class="docEmphasis">filter</i> as a fold, using <i class="docEmphasis">foldr</i>:</p><pre class="calibre39">-- file: ch04/Fold.hs
myFilter p xs = foldr step [] xs
    where step x ys | p x       = x : ys
                    | otherwise = ys</pre><br class="calibre48"/>
<a name="x_A9" class="calibre27" id="x_A9"></a><p class="docText">This is the sort of definition that could cause us a
      headache, so let's examine it in a little depth. Like <i class="docEmphasis">foldl</i>, <i class="docEmphasis">foldr</i> takes a function and a base case (what
      to do when the input list is empty) as arguments. From reading the type
      of <i class="docEmphasis">filter</i>, we know that our
      <i class="docEmphasis">myFilter</i> function must return a
      list of the same type as it consumes, so the base case should be a list
      of this type, and the <i class="docEmphasis">step</i> helper
      function must return a list.</p><a name="x_B9" class="calibre27" id="x_B9"></a><p class="docText">Since we know that <i class="docEmphasis">foldr
      </i>calls <i class="docEmphasis">step</i> on one
      element of the input list at a time, then with the accumulator as its
      second argument, <i class="docEmphasis">step</i>'s actions
      must be quite simple. If the predicate returns <i class="docEmphasis">True</i>, it pushes that element onto the
      accumulated list; otherwise, it leaves the list untouched.</p><a name="x_C9" class="calibre27" id="x_C9"></a><p class="docText">The class of functions that we can express using
      <i class="docEmphasis">foldr</i> is <a name="I_indexterm4_d1e11084" class="calibre27" id="I_indexterm4_d1e11084"></a>called <span class="docEmphasis">primitive recursive</span>. A
      surprisingly large number of list manipulation functions are primitive
      recursive. For example, here's <i class="docEmphasis">map</i>
      written in terms of <i class="docEmphasis">foldr</i>:</p><pre class="calibre39">-- file: ch04/Fold.hs
myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]

myMap f xs = foldr step [] xs
    where step x ys = f x : ys</pre><br class="calibre48"/>
<a name="x_D9" class="calibre27" id="x_D9"></a><p class="docText">In fact, we can even write <i class="docEmphasis">foldl</i> using <i class="docEmphasis">foldr</i>!</p><pre class="calibre39">-- file: ch04/Fold.hs
myFoldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a

myFoldl f z xs = foldr step id xs z
    where step x g a = g (f a x)</pre><br class="calibre48"/>
<p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Understanding foldl in terms of foldr</p><a name="x_E9" class="calibre27" id="x_E9"></a><p class="docText">If you want to set yourself a solid challenge, try to
        follow our definition of <i class="docEmphasis">foldl</i>
        using <i class="docEmphasis">foldr</i>. Be warned: this is
        not trivial! You might want to have the following tools at hand: some
        headache pills and a glass of water, <i class="docEmphasis">ghci</i> (so that you can find out what
        <a name="I_indexterm4_d1e11123" class="calibre27" id="I_indexterm4_d1e11123"></a>the <i class="docEmphasis">id</i> function
        does), and a pencil and paper.</p><a name="x_aL" class="calibre27" id="x_aL"></a><p class="docText">You will want to follow the same manual evaluation
        process as we just outlined to see what <i class="docEmphasis">foldl</i> and <i class="docEmphasis">foldr</i> were really doing. If you get stuck,
        you may find the task easier after reading <a class="docLink" href="fp_partialapp.html#fp_partialapp">Section 4.8</a>.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_H9" class="calibre27" id="x_H9"></a><p class="docText">Returning to our earlier intuitive explanation of what
      <i class="docEmphasis">foldr</i> does, another useful way to
      think about it is that it <span class="docEmphasis">transforms</span> its input
      list. Its first two arguments are "what to do with each head/tail
      element of the list," and "what to substitute for the end
      of the list."</p><a name="x_I9" class="calibre27" id="x_I9"></a><p class="docText">The "identity" transformation <a name="I_indexterm4_d1e11158" class="calibre27" id="I_indexterm4_d1e11158"></a>with <i class="docEmphasis">foldr</i> thus
      replaces the empty list with itself and applies the list constructor to
      each head/tail pair:</p><pre class="calibre39">-- file: ch04/Fold.hs
identity :: [a] -&gt; [a]
identity xs = foldr (:) [] xs</pre><br class="calibre48"/>
<a name="x_J9" class="calibre27" id="x_J9"></a><p class="docText">It transforms a list into a copy of itself:</p><pre class="calibre39">ghci&gt; <b class="calibre40">identity [1,2,3]</b>
[1,2,3]
</pre><a name="x_K9" class="calibre27" id="x_K9"></a><p class="docText">If <i class="docEmphasis">foldr</i> replaces
      the end of a list with some other value, this gives us another way to
      look at Haskell's <a name="I_indexterm4_d1e11181" class="calibre27" id="I_indexterm4_d1e11181"></a><a name="I_indexterm4_d1e11186" class="calibre27" id="I_indexterm4_d1e11186"></a>list append function, <i class="docEmphasis">(++)</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">[1,2,3] ++ [4,5,6]</b>
[1,2,3,4,5,6]
</pre><a name="x_L9" class="calibre27" id="x_L9"></a><p class="docText">All we have to do to append a list onto another is
      substitute that second list for the end of our first list:</p><pre class="calibre39">-- file: ch04/Fold.hs
append :: [a] -&gt; [a] -&gt; [a]
append xs ys = foldr (:) ys xs</pre><br class="calibre48"/>
<a name="x_M9" class="calibre27" id="x_M9"></a><p class="docText">Let's try this out:</p><pre class="calibre39">ghci&gt; <b class="calibre40">append [1,2,3] [4,5,6]</b>
[1,2,3,4,5,6]
</pre><a name="x_bL" class="calibre27" id="x_bL"></a><p class="docText">Here, we replace each list constructor with another list
      constructor, but we replace the empty list with the list we want to
      append onto the end of our first list.</p><a name="x_P9" class="calibre27" id="x_P9"></a><p class="docText">As our extended treatment of folds should indicate, the
      <i class="docEmphasis">foldr</i> function is nearly as
      important a member of our list-programming toolbox as the more basic
      list functions we saw in <a class="docLink" href="fp_lists_split_000.html#fp_lists">Section 4.5</a>. It can consume and
      produce a list incrementally, which makes it useful for writing lazy
      data-processing code.</p><a name="fp_loopd1e11281" class="calibre27" id="fp_loopd1e11281"></a><h4 id="title-IDA3KKVC" class="docSection1Title">4.6.9. Left Folds, Laziness, and Space Leaks</h4><a name="x_Q9" class="calibre27" id="x_Q9"></a><p class="docText">To<a name="I_indexterm4_d1e11227" class="calibre27" id="I_indexterm4_d1e11227"></a><a name="I_indexterm4_d1e11228" class="calibre27" id="I_indexterm4_d1e11228"></a><a name="I_indexterm4_d1e11229" class="calibre27" id="I_indexterm4_d1e11229"></a><a name="I_indexterm4_d1e11230" class="calibre27" id="I_indexterm4_d1e11230"></a> keep our initial discussion simple,<a name="I_indexterm4_d1e11236" class="calibre27" id="I_indexterm4_d1e11236"></a><a name="I_indexterm4_d1e11239" class="calibre27" id="I_indexterm4_d1e11239"></a> we use <i class="docEmphasis">foldl</i>
      throughout most of this section. This is convenient for testing, but we
      will never use <i class="docEmphasis">foldl</i> in practice.
      The reason has to do with Haskell's nonstrict evaluation. If we apply
      <tt class="calibre34">foldl (+) [1,2,3]</tt>, it evaluates to the expression
      <tt class="calibre34">(((0 + 1) + 2) + 3)</tt>. We can see this occur if we revisit
      the way in which the function gets expanded:</p><pre class="calibre39">-- file: ch04/Fold.hs
foldl (+) 0 (1:2:3:[])
          == foldl (+) (0 + 1)             (2:3:[])
          == foldl (+) ((0 + 1) + 2)       (3:[])
          == foldl (+) (((0 + 1) + 2) + 3) []
          ==           (((0 + 1) + 2) + 3)</pre><br class="calibre48"/>
<a name="x_uC1" class="calibre27" id="x_uC1"></a><p class="docText">The final expression will not be evaluated to
      <tt class="calibre34">6</tt> until its value is demanded. Before it is evaluated, it
      must be stored as a thunk. Not surprisingly, a thunk is more expensive
      to store than a single number, and the more complex the thunked
      expression, the more space it needs. For something cheap such as
      arithmetic, thunking an expression is more computationally expensive
      than evaluating it immediately. We thus end up paying both in space and
      in time.</p><a name="x_vC1" class="calibre27" id="x_vC1"></a><p class="docText">When <span class="docMonofont">GHC</span> is
      evaluating a thunked expression, it uses an internal stack to do so.
      Because a thunked expression could potentially be infinitely large,
      <span class="docMonofont">GHC</span> places a fixed limit on
      the maximum size of this stack. Thanks to this limit, we can try a large
      thunked expression in <i class="docEmphasis">ghci</i> without
      needing to worry that it might consume all the memory:</p><pre class="calibre39">ghci&gt; <b class="calibre40">foldl (+) 0 [1..1000]</b>
500500
</pre><a name="x_wC1" class="calibre27" id="x_wC1"></a><p class="docText">From looking at this expansion, we can surmise that
      this creates a thunk that consists of 1,000 integers and 999
      applications of <i class="docEmphasis">(+)</i>. That's a lot
      of memory and effort to represent a single number! With a larger
      expression, although the size is still modest, the results are more
      dramatic:</p><pre class="calibre39">ghci&gt; <b class="calibre40">foldl (+) 0 [1..1000000]</b>
*** Exception: stack overflow
</pre><a name="x_xC1" class="calibre27" id="x_xC1"></a><p class="docText">On small expressions, <i class="docEmphasis">foldl</i> will work correctly but slowly, due to
      the thunking overhead that it incurs. We refer to this invisible
      thunking as a <span class="docEmphasis">space leak</span>, because our code is
      operating normally, but it is using far more memory than it
      should.</p><a name="x_yC1" class="calibre27" id="x_yC1"></a><p class="docText">On larger expressions, code with a space leak will
      simply fail, as above. A space leak with <tt class="calibre34">foldl</tt> is a classic
      roadblock for new Haskell programmers. Fortunately, this is easy to
      avoid.</p><a name="x_zC1" class="calibre27" id="x_zC1"></a><p class="docText">The <tt class="calibre34">Data.List</tt> module defines a function
      named <i class="docEmphasis">foldl'</i> that is similar to
      <i class="docEmphasis">foldl</i>, but does not build up
      thunks. The difference in behavior between the two is immediately
      obvious:</p><pre class="calibre39">ghci&gt; <b class="calibre40">foldl  (+) 0 [1..1000000]</b>
*** Exception: stack overflow
ghci&gt; <b class="calibre40">:module +Data.List</b>
ghci&gt; <b class="calibre40">foldl' (+) 0 [1..1000000]</b>
500000500000</pre><a name="x_AD1" class="calibre27" id="x_AD1"></a><p class="docText">Due to <i class="docEmphasis">foldl</i>'s
      thunking behavior, it is wise to avoid this function in real programs,
      even if it doesn't fail outright, it will be unnecessarily inefficient.
      Instead, import <tt class="calibre34">Data.List</tt> and use <i class="docEmphasis">foldl'</i>.</p><a name="exercises1" class="calibre27" id="exercises1"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

