---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect125_d1e49110.html
next: bloomfilter_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="I_sect125_d1e49110.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="bloomfilter_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect125_d1e49269" class="calibre27" id="I_sect125_d1e49269"></a><h3 id="643999-873" class="docSection1Title">25.4. Advanced Techniques: Fusion</h3><a name="x_QL1" class="calibre27" id="x_QL1"></a><p class="docText">The<a name="I_indexterm25_d1e49274" class="calibre27" id="I_indexterm25_d1e49274"></a> final<a name="I_indexterm25_d1e49276" class="calibre27" id="I_indexterm25_d1e49276"></a> bottleneck in our program is the lazy list itself. While we
    can avoid allocating it all at once, there is still memory traffic each
    time around the loop, as we demand the next cons cell in the list,
    allocate it to the heap, operate on it, and continue. The list type is
    also polymorphic, so the elements of the list will be represented as
    heap-allocated <tt class="calibre34">Double</tt> values.</p><a name="x_RL1" class="calibre27" id="x_RL1"></a><p class="docText">What we'd like to do is eliminate the list entirely,
    keeping just the next element we need in a register. Perhaps surprisingly,
    GHC is able to transform the list program into a listless version, using
    an optimization known as deforestation, which refers to a general class of
    optimizations that involve eliminating intermediate data structures. Due
    to the absence of side effects, a Haskell compiler can be extremely
    aggressive when rearranging code, reordering and transforming wholesale at
    times. The specific deforestation optimization we will use here is stream
    fusion.</p><a name="x_SL1" class="calibre27" id="x_SL1"></a><p class="docText">This optimization transforms recursive list generation
    and transformation functions into nonrecursive <tt class="calibre34">unfolds</tt>. When
    an <tt class="calibre34">unfold</tt> appears next to a <tt class="calibre34">fold</tt>, the structure
    <span class="docEmphasis">between</span> them is then eliminated
    entirely, yielding a single, tight loop with no heap allocation. The
    optimization isn't enabled by default, and it can radically change the
    complexity of a piece of code, but it is enabled by a number of data
    structure libraries, which provide <span class="docEmphasis">rewrite rules</span>,
    custom optimizations, that the compiler applies to functions that the
    library exports.</p><a name="x_TL1" class="calibre27" id="x_TL1"></a><p class="docText">We'll use the <tt class="calibre34">uvector</tt> library, which
    provides a suite of list-like operations that use stream fusion to remove
    intermediate data structures. Rewriting our program to use streams is
    straightforward:</p><pre class="calibre39">-- file: ch25/I.hs
import System.Environment
import Text.Printf
import Data.Array.Vector

main = do
    [d] &lt;- map read `fmap` getArgs
    printf "%f\n" (mean (enumFromToFracU 1 d))

data Pair = Pair !Int !Double

mean :: UArr Double -&gt; Double
mean xs = s / fromIntegral n
  where
    Pair n s       = foldlU k (Pair 0 0) xs
    k (Pair n s) x = Pair (n+1) (s+x)</pre><br class="calibre48"/>
<a name="x_UL1" class="calibre27" id="x_UL1"></a><p class="docText">After installing the <tt class="calibre34">uvector</tt> library from
    Hackage, we can build our program, with <tt class="calibre34">-O2
    -funbox-strict-fields</tt>, and then inspect the Core that
    results:</p><pre class="calibre39">fold :: Int# -&gt; Double# -&gt; Double# -&gt; (# Int#, Double# #)
fold = \ n s t -&gt;
    case &gt;## t limit of {
      False -&gt; fold (+# n 1) (+## s t) (+## t 1.0)
      True  -&gt; (# n, s #)</pre><a name="x_VL1" class="calibre27" id="x_VL1"></a><p class="docText">This is really the optimal result! Our lists have been
    entirely fused away, yielding a tight loop where list generation is
    interleaved with accumulation, and all input and output variables are kept
    in registers. Running this, we see another improvement bump in
    performance, with runtime falling by another order of magnitude:</p><pre class="calibre39">$ time ./I 1e7
5000000.5
./I 1e7  0.06s user 0.00s system 72% cpu 0.083 total</pre><a name="I_sect125_d1e49269d1e49602" class="calibre27" id="I_sect125_d1e49269d1e49602"></a><h4 id="title-IDAO2DAD" class="docSection1Title">25.4.1. Tuning the Generated Assembly</h4><a name="x_WL1" class="calibre27" id="x_WL1"></a><p class="docText">Given that our Core is now optimal, the only step left
      to take this program further is to look directly at the assembly. Of
      course, there are only small gains left to make at this point. To view
      the generated assembly, we can use a tool such as <tt class="calibre34">ghc-core</tt>
      or generate assembly to standard output with the <tt class="calibre34">-ddump-asm</tt>
      flag to<a name="I_indexterm25_d1e49337" class="calibre27" id="I_indexterm25_d1e49337"></a> GHC. We have few levers available to adjust the generated
      assembly, but we may choose between the C and native code backends to
      GHC. And, if we then choose the C backend, which optimization flags to
      pass to GCC. Particularly with floating-point code, it is sometimes
      useful to compile via C, and enable specific high-performance C compiler
      <span class="docEmphasis">optimizations</span>.</p><a name="x_XL1" class="calibre27" id="x_XL1"></a><p class="docText">For example, we can squeeze out the last drops of
      performance from our final fused loop code by using
      <tt class="calibre34">-funbox-strict-fields -fvia-C -optc-O2</tt>, which<a name="I_indexterm25_d1e49349" class="calibre27" id="I_indexterm25_d1e49349"></a><a name="I_indexterm25_d1e49352" class="calibre27" id="I_indexterm25_d1e49352"></a><a name="I_indexterm25_d1e49355" class="calibre27" id="I_indexterm25_d1e49355"></a> cuts the running time in half again (as the C compiler is
      able to optimize away some redundant move instructions in the program's
      inner loop):</p><pre class="calibre39">$ <b class="calibre40">ghc -fforce-recomp --make -O2 -funbox-strict-fields -fvia-C -optc-O2 I.hs</b>
[1 of 1] Compiling Main             ( I.hs, I.o )
Linking I ...
$ <b class="calibre40">time ./I 1e7</b>
5000000.5
./I 1e7  0.04s user 0.00s system 98% cpu 0.047 total</pre><a name="x_YL1" class="calibre27" id="x_YL1"></a><p class="docText">Inspecting the <a name="I_indexterm25_d1e49372" class="calibre27" id="I_indexterm25_d1e49372"></a>final x86_64 assembly (via <tt class="calibre34">-keep-tmp-files</tt>),
      we<a name="I_indexterm25_d1e49379" class="calibre27" id="I_indexterm25_d1e49379"></a> see the generated loop contains only six
      instructions:</p><pre class="calibre39">go:
  ucomisd     5(%rbx), %xmm6
  ja  .L31
  addsd       %xmm6, %xmm5
  addq        $1, %rsi
  addsd       .LC0(%rip), %xmm6
  jmp go</pre><a name="x_ZL1" class="calibre27" id="x_ZL1"></a><p class="docText">We've effectively massaged the program through multiple
      source-level optimizations, all the way to the final assembly. There's
      nowhere else to go from here. Optimizing code to this level is very
      rarely necessary, of course, and typically makes sense only when writing
      low-level libraries or optimizing particularly important code, where all
      algorithm choices have already been determined. For day-to-day code,
      choosing better algorithms is always a more effective strategy, but it's
      useful to know we can optimize down to the metal if necessary.</p><a name="I_sect125_d1e49269d1e49664" class="calibre27" id="I_sect125_d1e49269d1e49664"></a><h4 id="title-IDA54DAD" class="docSection1Title">25.4.2. Conclusions</h4><a name="x_aL1" class="calibre27" id="x_aL1"></a><p class="docText">In this chapter, we've looked at a suite of tools and
      techniques you can use to track down and identify problematic areas of
      your code, along with a variety of conventions that can go a long way
      towards keeping your code lean and efficient. The goal is really to
      program in such a way that you have good knowledge of what your code is
      doing at all levels from source through the compiler to the metal, and
      to be able to focus in on particular levels when requirements
      demand.</p><a name="x_bL1" class="calibre27" id="x_bL1"></a><p class="docText">By sticking to simple rules, choosing the right data
      structures, and avoiding the traps of the unwary, it is perfectly
      possible to reliably achieve high performance from your Haskell code,
      while being able to develop at a very high level. The result is a sweet
      balance of productivity and ruthless<a name="I_indexterm25_d1e49395" class="calibre27" id="I_indexterm25_d1e49395"></a> efficiency.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="I_sect125_d1e49110.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="bloomfilter_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

