---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect124_d1e46438.html
next: I_sect124_d1e46934.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect124_d1e46438.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect124_d1e46934.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect124_d1e46566" class="calibre27" id="I_sect124_d1e46566"></a><h3 id="title-IDARM0XG" class="docSection1Title">24.4. The Main Thread and Waiting for Other Threads</h3><a name="x_u31" class="calibre27" id="x_u31"></a><p class="docText"><span class="docMonofont">GHC</span>'s
    runtime<a name="ch24-conmainthread" class="calibre27" id="ch24-conmainthread"></a><a name="ch24-threadswaiting" class="calibre27" id="ch24-threadswaiting"></a> system treats the program's original thread of control
    differently from other threads. When this thread finishes executing, the
    runtime system considers the program as a whole to have completed. If any
    other threads are executing at the time, they are terminated.</p><a name="x_v31" class="calibre27" id="x_v31"></a><p class="docText">As a result, when we have long-running threads that must
    not be killed, we need to make special arrangements to ensure that the
    main thread doesn't complete until the others do. Let's develop a small
    library that makes this easy to do:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
import Control.Concurrent
import Control.Exception (Exception, try)
import qualified Data.Map as M

data ThreadStatus = Running
                  | Finished         -- terminated normally
                  | Threw Exception  -- killed by uncaught exception
                    deriving (Eq, Show)

-- | Create a new thread manager.
newManager :: IO ThreadManager

-- | Create a new managed thread.
forkManaged :: ThreadManager -&gt; IO () -&gt; IO ThreadId

-- | Immediately return the status of a managed thread.
getStatus :: ThreadManager -&gt; ThreadId -&gt; IO (Maybe ThreadStatus)

-- | Block until a specific managed thread terminates.
waitFor :: ThreadManager -&gt; ThreadId -&gt; IO (Maybe ThreadStatus)

-- | Block until all managed threads terminate.
waitAll :: ThreadManager -&gt; IO ()</pre><br class="calibre48"/>
<a name="x_w31" class="calibre27" id="x_w31"></a><p class="docText">We keep our ThreadManager type abstract
    using the usual recipe: we wrap it in a <tt class="calibre34">newtype</tt> and prevent clients from creating
    values of this type. Among our module's exports, we list the type
    constructor and the IO action that constructs a manager, but
    we do not export the data constructor:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
module NiceFork
    (
      ThreadManager
    , newManager
    , forkManaged
    , getStatus
    , waitFor
    , waitAll
    ) where</pre><br class="calibre48"/>
<a name="x_x31" class="calibre27" id="x_x31"></a><p class="docText">For the implementation of ThreadManager, we
    maintain a map from thread ID to thread state. We'll refer to this as
    the<a name="I_indexterm24_d1e46606" class="calibre27" id="I_indexterm24_d1e46606"></a> <span class="docEmphasis">thread map</span>:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
newtype ThreadManager =
    Mgr (MVar (M.Map ThreadId (MVar ThreadStatus)))
    deriving (Eq)

newManager = Mgr `fmap` newMVar M.empty</pre><br class="calibre48"/>
<a name="x_y31" class="calibre27" id="x_y31"></a><p class="docText">We have two levels of MVar at use here. We
    keep the Map in an MVar. This lets us
    "modify" the <tt class="calibre34">Map</tt> by replacing it with a
    new version. We also ensure that any thread that uses the Map
    will see a consistent view of it.</p><a name="x_z31" class="calibre27" id="x_z31"></a><p class="docText">For each thread that we manage, we maintain an
    MVar. A per-thread MVar starts off empty, which
    indicates that the thread is executing. When the thread finishes or is
    killed by an uncaught exception, we put this information into the
    MVar.</p><a name="x_A41" class="calibre27" id="x_A41"></a><p class="docText">To create a thread and watch its status, we must perform
    a little bit of bookkeeping:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
forkManaged (Mgr mgr) body =
    modifyMVar mgr $ \m -&gt; do
      state &lt;- newEmptyMVar
      tid &lt;- forkIO $ do
        result &lt;- try body
        putMVar state (either Threw (const Finished) result)
      return (M.insert tid state m, tid)</pre><br class="calibre48"/>
<a name="I_sect124_d1e46566d1e46941" class="calibre27" id="I_sect124_d1e46566d1e46941"></a><h4 id="title-IDAPP0XG" class="docSection1Title">24.4.1. Safely Modifying an MVar</h4><a name="x_B41" class="calibre27" id="x_B41"></a><p class="docText">The <i class="docEmphasis">modifyMVar</i>
      function<a name="I_indexterm24_d1e46660" class="calibre27" id="I_indexterm24_d1e46660"></a><a name="I_indexterm24_d1e46663" class="calibre27" id="I_indexterm24_d1e46663"></a> that we used in <i class="docEmphasis">forkManaged</i> in the preceding code is very
      useful. It's a safe combination of <i class="docEmphasis">takeMVar</i> and <i class="docEmphasis">putMVar</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:t modifyMVar</b>
modifyMVar :: MVar a -&gt; (a -&gt; IO (a, b)) -&gt; IO b
</pre><a name="x_C41" class="calibre27" id="x_C41"></a><p class="docText">It takes the value from an MVar and passes
      it to a function. This function can both generate a new value and return
      a result. If the function throws an exception, <i class="docEmphasis">modifyMVar</i> puts the original value back into
      the MVar; otherwise, it puts in the new value. It returns
      the other element of the function as its own result.</p><a name="x_D41" class="calibre27" id="x_D41"></a><p class="docText">When we use <i class="docEmphasis">modifyMVar</i> instead of manually managing an
      MVar with <i class="docEmphasis">takeMVar</i> and
      <i class="docEmphasis">putMVar</i>, we avoid two common kinds
      of concurrency bugs:</p><ul class="calibre18"><li class="calibre19"><p class="docText">Forgetting to put a value back into an
          MVar. This can result in <span class="docEmphasis">deadlock</span>,
          in<a name="I_indexterm24_d1e46717" class="calibre27" id="I_indexterm24_d1e46717"></a> which some thread waits forever on an
          MVar that will never have a value put into it.</p></li><li class="calibre19"><p class="docText">Failure to account for the possibility that an
          exception might be thrown, disrupting the flow of a piece of code.
          This can result in a call to <i class="docEmphasis">putMVar</i> that <span class="docEmphasis">should</span>
          occur, but doesn't actually happen, again leading to
          deadlock.</p></li></ul><a name="x_G41" class="calibre27" id="x_G41"></a><p class="docText">Because of these nice safety properties, it's wise to
      use <i class="docEmphasis">modifyMVar</i> whenever
      possible.</p><a name="I_sect124_d1e46566d1e47027" class="calibre27" id="I_sect124_d1e46566d1e47027"></a><h4 id="title-IDAXS0XG" class="docSection1Title">24.4.2. Safe Resource Management: A Good Idea, and Easy Besides</h4><a name="x_H41" class="calibre27" id="x_H41"></a><p class="docText">We can the take the pattern that <i class="docEmphasis">modifyMVar</i> follows and apply it to many other
      resource management situations. Here are the steps of the
      pattern:</p><div class="calibre15"><ol class="docList2" type="1"><li class="calibre19"><div class="calibre15"><p class="docText">Acquire a resource.</p></div></li><li class="calibre19"><div class="calibre15"><p class="docText">Pass the resource to a function that will do
          something with it.</p></div></li><li class="calibre19"><div class="calibre15"><p class="docText">Always release the resource, even if the function
          throws an exception. If that occurs, rethrow the exception so
          application code can catch it.</p></div></li></ol></div><a name="x_L41" class="calibre27" id="x_L41"></a><p class="docText">Safety aside, this approach has another benefit: it can
      make our code shorter and easier to follow. As we can see from looking
      at <i class="docEmphasis">forkManaged</i> in<a name="I_indexterm24_d1e46761" class="calibre27" id="I_indexterm24_d1e46761"></a> the previous code listing, Haskell's lightweight syntax
      for anonymous functions makes this style of coding visually
      unobtrusive.</p><a name="x_M41" class="calibre27" id="x_M41"></a><p class="docText">Here's the definition of <i class="docEmphasis">modifyMVar</i> so that you can see a specific
      form of this pattern:</p><pre class="calibre39">-- file: ch24/ModifyMVar.hs
import Control.Concurrent (MVar, putMVar, takeMVar)
import Control.Exception (block, catch, throw, unblock)
import Prelude hiding (catch) -- use Control.Exception's version

modifyMVar :: MVar a -&gt; (a -&gt; IO (a,b)) -&gt; IO b
modifyMVar m io = 
  block $ do
    a &lt;- takeMVar m
    (b,r) &lt;- unblock (io a) `catch` \e -&gt;
             putMVar m a &gt;&gt; throw e
    putMVar m b
    return r</pre><br class="calibre48"/>
<a name="x_N41" class="calibre27" id="x_N41"></a><p class="docText">You should easily be able to adapt this to your
      particular needs, whether you're working with network connections,
      database handles, or data managed by a C library.</p><a name="I_sect124_d1e46566d1e47063" class="calibre27" id="I_sect124_d1e46566d1e47063"></a><h4 id="title-IDALU0XG" class="docSection1Title">24.4.3. Finding the Status of a Thread</h4><a name="x_O41" class="calibre27" id="x_O41"></a><p class="docText">Our <i class="docEmphasis">getStatus</i>
      function<a name="I_indexterm24_d1e46782" class="calibre27" id="I_indexterm24_d1e46782"></a><a name="I_indexterm24_d1e46787" class="calibre27" id="I_indexterm24_d1e46787"></a> tells us the current state of a thread. If the thread is
      no longer managed (or was never managed in the first place), it returns
      <tt class="calibre34">Nothing</tt>:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
getStatus (Mgr mgr) tid =
  modifyMVar mgr $ \m -&gt;
    case M.lookup tid m of
      Nothing -&gt; return (m, Nothing)
      Just st -&gt; tryTakeMVar st &gt;&gt;= \mst -&gt; case mst of
                   Nothing -&gt; return (m, Just Running)
                   Just sth -&gt; return (M.delete tid m, Just sth)</pre><br class="calibre48"/>
<a name="x_P41" class="calibre27" id="x_P41"></a><p class="docText">If the thread is still running, it returns <tt class="calibre34">Just
      Running</tt>. Otherwise, it indicates why the thread terminated
      <span class="docEmphasis">and</span> stops managing the thread.</p><a name="x_Q41" class="calibre27" id="x_Q41"></a><p class="docText">If the <i class="docEmphasis">tryTakeMVar</i>
      function finds that the MVar is empty, it returns
      <tt class="calibre34">Nothing</tt> immediately instead of blocking:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:t tryTakeMVar</b>
tryTakeMVar :: MVar a -&gt; IO (Maybe a)
</pre><a name="x_R41" class="calibre27" id="x_R41"></a><p class="docText">Otherwise, it extracts the value from the
      MVar as usual.</p><a name="x_S41" class="calibre27" id="x_S41"></a><p class="docText">The <i class="docEmphasis">waitFor</i>
      function<a name="I_indexterm24_d1e46831" class="calibre27" id="I_indexterm24_d1e46831"></a> behaves similarly, but instead of returning immediately,
      it blocks until the given thread terminates before returning:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
waitFor (Mgr mgr) tid = do
  maybeDone &lt;- modifyMVar mgr $ \m -&gt;
    return $ case M.updateLookupWithKey (\_ _ -&gt; Nothing) tid m of
      (Nothing, _) -&gt; (m, Nothing)
      (done, m') -&gt; (m', done)
  case maybeDone of
    Nothing -&gt; return Nothing
    Just st -&gt; Just `fmap` takeMVar st</pre><br class="calibre48"/>
<a name="x_T41" class="calibre27" id="x_T41"></a><p class="docText">It first extracts the MVar that holds the
      thread's state, if it exists. The Map type's <i class="docEmphasis">updateLookupWithKey</i> function<a name="I_indexterm24_d1e46848" class="calibre27" id="I_indexterm24_d1e46848"></a> is useful—it combines looking up a key with modifying or
      removing the value:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Data.Map</b>ghci&gt; <b class="calibre40">:t updateLookupWithKey</b>
updateLookupWithKey :: (Ord k) =&gt;
                       (k -&gt; a -&gt; Maybe a) -&gt; k -&gt; Map k a -&gt; (Maybe a, Map k a)</pre><a name="x_U41" class="calibre27" id="x_U41"></a><p class="docText">In this case, we want to always remove the
      MVar holding the thread's state if it is present so that
      our thread manager will no longer be managing the thread. If there is a
      value to extract, we take the thread's exit status from the
      MVar and return it.</p><a name="x_V41" class="calibre27" id="x_V41"></a><p class="docText">Our final useful function simply waits for all
      currently managed threads to complete and ignores their exit
      statuses:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
waitAll (Mgr mgr) = modifyMVar mgr elems &gt;&gt;= mapM_ takeMVar
    where elems m = return (M.empty, M.elems m)</pre><br class="calibre48"/>
<a name="I_sect124_d1e46566d1e47164" class="calibre27" id="I_sect124_d1e46566d1e47164"></a><h4 id="title-IDACY0XG" class="docSection1Title">24.4.4. Writing Tighter Code</h4><a name="x_W41" class="calibre27" id="x_W41"></a><p class="docText">Our definition of <i class="docEmphasis">waitFor</i> is a little <a name="I_indexterm24_d1e46884" class="calibre27" id="I_indexterm24_d1e46884"></a>unsatisfactory, because we're performing more or less the
      same case analysis in two places: inside the function called by
      <i class="docEmphasis">modifyMVar</i>, and again on its return
      value.</p><a name="x_X41" class="calibre27" id="x_X41"></a><p class="docText">Sure enough, we can apply a function that we came
      across earlier to eliminate this duplication. The function in question
      is <i class="docEmphasis">join</i>, from the<a name="I_indexterm24_d1e46898" class="calibre27" id="I_indexterm24_d1e46898"></a> <tt class="calibre34">Control.Monad</tt> module:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad</b>ghci&gt; <b class="calibre40">:t join</b>
join :: (Monad m) =&gt; m (m a) -&gt; m a</pre><a name="x_Y41" class="calibre27" id="x_Y41"></a><p class="docText">The trick here is to see that we can get rid of the
      second <tt class="calibre34">case</tt> expression by having the
      first one return the IO action that we should perform once
      we return from <i class="docEmphasis">modifyMVar</i>. We'll
      use <i class="docEmphasis">join</i> to execute the
      action:</p><pre class="calibre39">-- file: ch24/NiceFork.hs
waitFor2 (Mgr mgr) tid =
  join . modifyMVar mgr $ \m -&gt;
    return $ case M.updateLookupWithKey (\_ _ -&gt; Nothing) tid m of
      (Nothing, _) -&gt; (m, return Nothing)
      (Just st, m') -&gt; (m', Just `fmap` takeMVar st)</pre><br class="calibre48"/>
<a name="x_Z41" class="calibre27" id="x_Z41"></a><p class="docText">This is an interesting idea: we can create a monadic
      function or action in pure code, and then pass it around until we end up
      in a monad where we can use it. This can be a nimble way to write code,
      once you develop an eye for when it makes sense.</p>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect124_d1e46438.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect124_d1e46934.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

