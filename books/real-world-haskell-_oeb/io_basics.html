---
layout: page
title: "Real World Haskell, 1st Edition"
prev: io_split_001.html
next: io_files.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="io_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="io_files.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="io_basics" class="calibre27" id="io_basics"></a><h3 id="title-IDAZSLVC" class="docSection1Title">7.1. Classic I/O in Haskell</h3><a name="x_AC" class="calibre27" id="x_AC"></a><p class="docText">Let's get started with I/O in Haskell by looking at a
    program that appears to be surprisingly similar to I/O in other languages
    such as C or Perl:</p><pre class="calibre39">-- file: ch07/basicio.hs
main = do
       putStrLn "Greetings!  What is your name?"
       inpStr &lt;- getLine
       putStrLn $ "Welcome to Haskell, " ++ inpStr ++ "!"</pre><br class="calibre48"/>
<a name="x_BC" class="calibre27" id="x_BC"></a><p class="docText">You can compile this program to a standalone executable,
    run<a name="I_indexterm7_d1e18572" class="calibre27" id="I_indexterm7_d1e18572"></a><a name="I_indexterm7_d1e18577" class="calibre27" id="I_indexterm7_d1e18577"></a> it with <i class="docEmphasis">runghc</i>, or
    invoke <tt class="calibre34">main</tt> from<a name="I_indexterm7_d1e18587" class="calibre27" id="I_indexterm7_d1e18587"></a> within <i class="docEmphasis">ghci</i>. Here's a
    sample session using <i class="docEmphasis">runghc</i>:</p><pre class="calibre39">$ <b class="calibre40">runghc basicio.hs</b>
Greetings!  What is your name?
<b class="calibre40">John</b>
Welcome to Haskell, John!</pre><a name="x_CC" class="calibre27" id="x_CC"></a><p class="docText">That's a fairly simple, obvious result. You can see
    <a name="I_indexterm7_d1e18610" class="calibre27" id="I_indexterm7_d1e18610"></a>that <tt class="calibre34">putStrLn</tt> writes out
    a <tt class="calibre34">String</tt>, followed by an end-of-line
    character. <tt class="calibre34">getLine</tt> reads a line from
    standard input. The <tt class="calibre34">&lt;-</tt> syntax may be
    new to you. Put simply, that binds the result from executing an I/O action
    to a name.<sup class="docFootnote"><a class="docLink1" href="#x_CCd1e18982">[16]</a></sup> We use the simple list concatenation <a name="I_indexterm7_d1e18631" class="calibre27" id="I_indexterm7_d1e18631"></a>operator <tt class="calibre34">++</tt> to join the
    input string with our own text.</p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_CCd1e18982" class="calibre5" id="x_CCd1e18982">[16]</a></sup> You will later see that it has a more broad
        application, but it is sufficient to think of it in these terms for
        now.</p></blockquote><a name="x_GC" class="calibre27" id="x_GC"></a><p class="docText">Let's take a look at the types of <tt class="calibre34">putStrLn</tt> and <tt class="calibre34">getLine</tt>. You can find that information in the
    library reference, or just ask <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type putStrLn</b>
putStrLn :: String -&gt; IO ()
ghci&gt; <b class="calibre40">:type getLine</b>
getLine :: IO String</pre><a name="x_HC" class="calibre27" id="x_HC"></a><p class="docText">Notice that both of these types <a name="I_indexterm7_d1e18662" class="calibre27" id="I_indexterm7_d1e18662"></a>have IO in their return value. That is your key
    to knowing that they may have side effects, or they may return different
    values even when called with the same arguments, or both. The type of
    <tt class="calibre34">putStrLn</tt> looks like a function. It
    takes a parameter of type <tt class="calibre34">String</tt> and
    returns value of type <tt class="calibre34">IO ()</tt>. Just what
    is an <tt class="calibre34">IO ()</tt> though?</p><a name="x_IC" class="calibre27" id="x_IC"></a><p class="docText">Anything that is type <tt class="calibre34">IO
    </tt><tt class="calibre34"><i class="docEmphasis">something</i></tt> is an I/O
    <span class="docEmphasis">action</span>. You can store it and nothing will happen. I
    could say <tt class="calibre34">writefoo = putStrLn "foo"</tt> and
    nothing happens right then. But if I later use <tt class="calibre34">writefoo</tt> in the middle of another I/O action,
    the <tt class="calibre34">writefoo</tt> action will be executed
    when its parent action is executed—I/O actions can be glued together to
    form bigger I/O actions. The <tt class="calibre34">()</tt> is an
    empty tuple (pronounced "unit"), indicating that there is no
    return value from <tt class="calibre34">putStrLn</tt>. This is
    similar to <tt class="calibre34">void</tt> in Java or C.<sup class="docFootnote"><a class="docLink1" href="#x_ICd1e19069">[17]</a></sup></p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_ICd1e19069" class="calibre5" id="x_ICd1e19069">[17]</a></sup> The type of the value <tt class="calibre34">()</tt> is also <tt class="calibre34">()</tt>.</p></blockquote><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_qp" class="calibre27" id="x_qp"></a><p class="docText">Actions can be created, assigned, and passed anywhere.
      However, they may only be performed (executed) from within another I/O
      action.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_LN" class="calibre27" id="x_LN"></a><p class="docText">Let's look at this with <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let writefoo = putStrLn "foo"</b>ghci&gt; <b class="calibre40">writefoo</b>
foo</pre><a name="x_JC" class="calibre27" id="x_JC"></a><p class="docText">In this example, the output <tt class="calibre34">foo</tt> is not a return value from <tt class="calibre34">putStrLn</tt>. Rather, it's the side effect of
    <tt class="calibre34">putStrLn</tt> actually writing <tt class="calibre34">foo</tt> to the terminal.</p><a name="x_MN" class="calibre27" id="x_MN"></a><p class="docText">Notice one other thing: <i class="docEmphasis">ghci</i> actually executed <tt class="calibre34">writefoo</tt>. This means that, when given an I/O
    action, <i class="docEmphasis">ghci</i> will perform it for you on
    the spot.</p><a name="io_basicsd1e19122" class="calibre27" id="io_basicsd1e19122"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_NN" class="calibre27" id="x_NN"></a></p><p class="docText">Actions:</p><ul class="calibre18"><li class="calibre19"><p class="docText">Have the type <tt class="calibre34">IO
          </tt><tt class="calibre34"><i class="docEmphasis">t</i></tt>.</p></li><li class="calibre19"><p class="docText">Are first-class values in Haskell and fit seamlessly
          with Haskell's type system.</p></li><li class="calibre19"><p class="docText">Produce an effect when
          <span class="docEmphasis">performed</span>, but not when
          <span class="docEmphasis">evaluated</span>. That is, they produce an effect only
          when called by something else in an I/O context.</p></li><li class="calibre19"><p class="docText">Any expression may produce an action as its value,
          but the action will not perform I/O until it is executed inside
          another I/O action (or it is <tt class="calibre34">main</tt>).</p></li><li class="calibre19"><p class="docText">Performing (executing) an action of type <tt class="calibre34">IO t</tt> may perform I/O and will ultimately
          deliver a result of type <tt class="calibre34">t</tt>.</p></li></ul></div><a name="x_KC" class="calibre27" id="x_KC"></a><p class="docText">The type of <tt class="calibre34">getLine</tt> may
    look strange to you. It looks like a value, rather than a function. And in
    fact, that is one way to look at it: <tt class="calibre34">getLine</tt> is storing an I/O action. When that
    action is performed, you get a <tt class="calibre34">String</tt>.
    <a name="I_indexterm7_d1e18820" class="calibre27" id="I_indexterm7_d1e18820"></a>The <tt class="calibre34">&lt;-</tt> operator is
    used to "pull out" the result from performing an I/O action and store it
    in a variable.</p><a name="x_LC" class="calibre27" id="x_LC"></a><p class="docText"><tt class="calibre34">main</tt> itself is an I/O
    action with type <tt class="calibre34">IO ()</tt>. You can only
    perform I/O actions from within other I/O actions. All I/O in Haskell
    programs is driven from the top at <tt class="calibre34">main</tt>, which is where execution of every Haskell
    program begins. This, then, is the mechanism that provides isolation from
    side effects in Haskell: you perform I/O in your <tt class="calibre34">IO</tt> actions, and call pure (non-I/O) functions
    from there. Most Haskell code is pure; the I/O actions perform I/O and
    call that pure code.</p><a name="x_EC" class="calibre27" id="x_EC"></a><p class="docText"><tt class="calibre34">do</tt> is a convenient way
    to define a sequence of actions. As you'll see later, there are other
    ways. When you use <tt class="calibre34">do</tt> in this way,
    indentation is significant; make sure you line up your actions
    properly.</p><a name="x_FC" class="calibre27" id="x_FC"></a><p class="docText">You need to use <tt class="calibre34">do</tt> only
    if you have more than one action that you need to perform. The value of a
    <tt class="calibre34">do</tt> block is the value of the last
    action executed. For a complete description of <tt class="calibre34">do</tt> syntax, see <a class="docLink" href="monads_do.html#monads_do">Section 14.12</a>.</p><a name="x_MC" class="calibre27" id="x_MC"></a><p class="docText">Let's consider an example of calling pure code from within
    an I/O action:</p><pre class="calibre39">-- file: ch07/callingpure.hs
name2reply :: String -&gt; String
name2reply name =
    "Pleased to meet you, " ++ name ++ ".\n" ++
    "Your name contains " ++ charcount ++ " characters."
    where charcount = show (length name)

main :: IO ()
main = do
       putStrLn "Greetings once again.  What is your name?"
       inpStr &lt;- getLine
       let outStr = name2reply inpStr
       putStrLn outStr</pre><br class="calibre48"/>
<a name="x_NC" class="calibre27" id="x_NC"></a><p class="docText">Notice the <tt class="calibre34">name2reply</tt>
    function in this example. It is a regular Haskell function and obeys all
    the rules we've told you about: it always returns the same result when
    given the same input, it has no side effects, and it operates lazily. It
    uses other Haskell functions: <tt class="calibre34">(++)</tt>,
    <tt class="calibre34">show</tt>, and <tt class="calibre34">length</tt>.</p><a name="x_OC" class="calibre27" id="x_OC"></a><p class="docText">Down in <tt class="calibre34">main</tt>, we bind
    the result of <tt class="calibre34">name2reply inpStr</tt> to
    <tt class="calibre34">outStr</tt>. When you're working in a
    <tt class="calibre34">do</tt> block, use <tt class="calibre34">&lt;-</tt> to get results from IO
    actions and <tt class="calibre34">let</tt> to get results from
    pure code. When used in a <tt class="calibre34">do</tt> block, you
    should not put <tt class="calibre34">in</tt> after your <tt class="calibre34">let</tt> statement.</p><a name="x_PC" class="calibre27" id="x_PC"></a><p class="docText">You can see here how we read the person's name from the
    keyboard. Then, that data got passed to a pure function, and its result
    was printed. In fact, the last two lines of <tt class="calibre34">main</tt> could have been replaced with <tt class="calibre34">putStrLn (name2reply inpStr)</tt>. So, while <tt class="calibre34">main</tt> did have side effects—it caused things to
    appear on the terminal, for instance—<tt class="calibre34">name2reply</tt> did not and could not. That's because
    <tt class="calibre34">name2reply</tt> is a pure function, not an
    action.</p><a name="x_QC" class="calibre27" id="x_QC"></a><p class="docText">Let's examine this with <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load callingpure.hs</b>
[1 of 1] Compiling Main             ( callingpure.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">name2reply "John"</b>
"Pleased to meet you, John.\nYour name contains 4 characters."
ghci&gt; <b class="calibre40">putStrLn (name2reply "John")</b>
Pleased to meet you, John.
Your name contains 4 characters.</pre><a name="x_RC" class="calibre27" id="x_RC"></a><p class="docText">The <tt class="calibre34">\n</tt> within the
    string is the end-of-line (newline) character, which causes the terminal
    to begin a new line in its output. Just calling <tt class="calibre34">name2reply "John"</tt> in <i class="docEmphasis">ghci</i> will show you the <tt class="calibre34">\n</tt> literally, because it is using <tt class="calibre34">show</tt> to display the return value. But using
    <tt class="calibre34">putStrLn</tt> sends it to the terminal, and
    the terminal interprets <tt class="calibre34">\n</tt> to start a
    new line.</p><a name="x_SC" class="calibre27" id="x_SC"></a><p class="docText">What do you think will happen if you simply type
    <tt class="calibre34"><b class="calibre40">main</b></tt> at the <i class="docEmphasis">ghci</i> prompt? Give it a try.</p><a name="x_TC" class="calibre27" id="x_TC"></a><p class="docText">After looking at these example programs, you may be
    wondering if Haskell is really imperative rather than pure, lazy, and
    functional. Some of these examples look like a sequence of actions to be
    followed in order. There's more to it than that, though. We'll discuss
    that question later in this chapter in <a class="docLink" href="io_imperative.html#io_imperative">Section 7.6</a>
    and <a class="docLink" href="io_lazy.html#io_lazy">Section 7.4</a>.</p><a name="io_purevsimpure" class="calibre27" id="io_purevsimpure"></a><h4 id="title-IDAEEGZH" class="docSection1Title">7.1.1. Pure Versus I/O</h4><a name="x_UN" class="calibre27" id="x_UN"></a><p class="docText"><a class="docLink" href="#io_purevsimpure_table">Table 7-1</a> is a comparison
      table to help you<a name="I_indexterm7_d1e18994" class="calibre27" id="I_indexterm7_d1e18994"></a><a name="I_indexterm7_d1e18999" class="calibre27" id="I_indexterm7_d1e18999"></a><a name="I_indexterm7_d1e19004" class="calibre27" id="I_indexterm7_d1e19004"></a> understand the differences between pure code and I/O.
      When we speak of pure code, we are talking about Haskell functions that
      always return the same result when given the same input and have no side
      effects. In Haskell, only the execution of I/O actions avoid these
      rules.</p><a name="io_purevsimpure_table" class="calibre27" id="io_purevsimpure_table"></a><p class="calibre37"><table cellspacing="0" border="1" rules="all" cellpadding="4" width="100%" class="calibre54"><caption class="calibre55"><h5 class="docTableTitle">Table 7-1. Pure versus impure</h5></caption><colgroup span="2" class="calibre56"><col class="calibre57"/><col class="calibre57"/></colgroup><thead class="calibre58"><tr class="calibre59"><th class="thead" scope="col">Pure</th><th class="thead" scope="col">Impure</th></tr></thead><tr class="calibre16"><td class="docTableCell">Always produces the same result when given the same
              <span class="docEmphasis">parameters</span></td><td class="docTableCell">May produce different results for the same
              parameters</td></tr><tr class="calibre16"><td class="docTableCell">Never has side effects</td><td class="docTableCell">May have side effects</td></tr><tr class="calibre16"><td class="docTableCell">Never alters state</td><td class="docTableCell">May alter the global state of the program, system, or
              world</td></tr></table></p><br class="calibre48"/><a name="io_purity" class="calibre27" id="io_purity"></a><h4 id="title-IDA2FGZH" class="docSection1Title">7.1.2. Why Purity Matters</h4><a name="x_VN" class="calibre27" id="x_VN"></a><p class="docText">In this section,<a name="I_indexterm7_d1e19045" class="calibre27" id="I_indexterm7_d1e19045"></a> we've discussed how Haskell, unlike most languages, draws
      a clear distinction between pure code and I/O actions. In languages such
      as C or Java, there is no such thing as a function that is guaranteed by
      the compiler to always return the same result for the same arguments or
      a function that is guaranteed to never have side effects. The only way
      to know if a given function has side effects is to read its
      documentation and hope that it's accurate.</p><a name="x_WN" class="calibre27" id="x_WN"></a><p class="docText">Many bugs in programs are caused by unanticipated side
      effects. Still more are caused by misunderstanding circumstances in
      which functions <a name="I_indexterm7_d1e19051" class="calibre27" id="I_indexterm7_d1e19051"></a>may return different results for the same input. As
      multithreading and other forms of parallelism grow increasingly common,
      it becomes more difficult to manage global side effects.</p><a name="x_XN" class="calibre27" id="x_XN"></a><p class="docText">Haskell's method of isolating side effects into I/O
      actions provides a clear boundary. You can always know which parts of
      the system may alter state and which won't. You can always be sure that
      the pure parts of your program aren't having unanticipated results. This
      helps you to think about the program. It also helps the compiler to
      think about it. Recent versions of <i class="docEmphasis">ghc</i>, for instance, can provide a level of
      automatic parallelism for the pure parts of your code—something of a
      holy grail for computing.</p><a name="x_YN" class="calibre27" id="x_YN"></a><p class="docText">For more discussion on this topic, refer to <a class="docLink" href="io_sideeffects.html#io_sideeffects">Section 7.7</a>.</p>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="io_split_000.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="io_files.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

