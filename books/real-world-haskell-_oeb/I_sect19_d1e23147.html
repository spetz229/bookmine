---
layout: page
title: "Real World Haskell, 1st Edition"
prev: find_getRecursiveContents.html
next: find_simpleFind.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="find_getRecursiveContents.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="find_simpleFind.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect19_d1e23147" class="calibre27" id="I_sect19_d1e23147"></a><h3 id="643999-815" class="docSection1Title">9.2. Starting Simple: Recursively Listing a Directory</h3><a name="x_uN" class="calibre27" id="x_uN"></a><p class="docText">Before we plunge<a name="I_indexterm9_d1e23152" class="calibre27" id="I_indexterm9_d1e23152"></a> into designing our library, let's solve a few smaller
    issues. Our first problem is to recursively list the contents of a
    directory and its subdirectories:</p><pre class="calibre39">-- file: ch09/RecursiveContents.hs
module RecursiveContents (getRecursiveContents) where

import Control.Monad (forM)
import System.Directory (doesDirectoryExist, getDirectoryContents)
import System.FilePath ((&lt;/&gt;))

getRecursiveContents :: FilePath -&gt; IO [FilePath]

getRecursiveContents topdir = do
  names &lt;- getDirectoryContents topdir
  let properNames = filter (`notElem` [".", ".."]) names
  paths &lt;- forM properNames $ \name -&gt; do
    let path = topdir &lt;/&gt; name
    isDirectory &lt;- doesDirectoryExist path
    if isDirectory
      then getRecursiveContents path
      else return [path]
  return (concat paths)</pre><br class="calibre48"/>
<a name="x_vN" class="calibre27" id="x_vN"></a><p class="docText">The <i class="docEmphasis">filter</i> expression
    ensures that a listing for a single directory won't contain the special
    directory names <tt class="calibre34">.</tt> or <tt class="calibre34">..</tt>, which refer to the current and parent
    directory, respectively. If we forgot to filter these out, we'd recurse
    endlessly.</p><a name="x_wN" class="calibre27" id="x_wN"></a><p class="docText">We encountered <i class="docEmphasis">forM</i>
    in the previous chapter; it is <i class="docEmphasis">mapM</i>
    with its arguments flipped:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad</b>ghci&gt; <b class="calibre40">:type mapM</b>
mapM :: (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
ghci&gt; <b class="calibre40">:type forM</b>
forM :: (Monad m) =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]</pre><a name="x_xN" class="calibre27" id="x_xN"></a><p class="docText">The body of the loop checks to see whether the current
    entry is a directory. If it is, it recursively calls <i class="docEmphasis">getRecursiveContents</i> to list that directory.
    Otherwise, it returns a <span class="docEmphasis">single</span>-element list that is the name of the
    current entry. (Don't forget that the <tt class="calibre34">return</tt> function has a unique meaning in Haskell:
    it wraps a value with the monad's type constructor.)</p><a name="x_yN" class="calibre27" id="x_yN"></a><p class="docText">Another thing worth pointing out is the use of the
    variable <span class="docMonofont">isDirectory</span>. In an imperative language such as
    Python, we'd normally write <tt class="calibre34">if os.path.isdir(path)</tt>. However,
    the <i class="docEmphasis">doesDirectoryExist</i> function is an
    <span class="docEmphasis">action</span>; its return type is IO Bool, not
    Bool. Since an <tt class="calibre34">if</tt>
    expression requires an expression of type Bool, we have to
    use <tt class="calibre34">&lt;-</tt> to get the Bool result of the action
    out of its IO wrapper so that we can use the plain, unwrapped
    Bool in the <tt class="calibre34">if</tt>.</p><a name="x_zN" class="calibre27" id="x_zN"></a><p class="docText">Each iteration of the loop body yields a list of names, so
    the result type of <i class="docEmphasis">forM</i> here is
    IO [[FilePath]]. We use <i class="docEmphasis">concat</i> to flatten it into a single list.</p><a name="I_sect19_d1e23147d1e23618" class="calibre27" id="I_sect19_d1e23147d1e23618"></a><h4 id="title-IDA1DIHN" class="docSection1Title">9.2.1. Revisiting Anonymous and Named Functions</h4><a name="x_AO" class="calibre27" id="x_AO"></a><p class="docText">In <a class="docLink" href="fp_anonymous.html#fp_anonymous">Section 4.7</a><a name="I_indexterm9_d1e23266" class="calibre27" id="I_indexterm9_d1e23266"></a>, we listed some reasons not to use anonymous functions,
      and yet here we are, using one as the body of a loop. This is one of the
      most common uses of anonymous functions in Haskell.</p><a name="x_BO" class="calibre27" id="x_BO"></a><p class="docText">We've already seen from their types that <i class="docEmphasis">forM</i> and <i class="docEmphasis">mapM</i> take functions as arguments. Most loop
      bodies are blocks of code that appear only once in a program. Since
      we're most likely to use a loop body in one place only, why give it a
      name?</p><a name="x_CO" class="calibre27" id="x_CO"></a><p class="docText">Of course, it sometimes happens that we need to deploy
      exactly the same code in several different loops. Rather than cutting
      and pasting the same anonymous function, it makes sense in such cases to
      give a name to an existing anonymous function.</p><a name="I_sect19_d1e23147d1e23638" class="calibre27" id="I_sect19_d1e23147d1e23638"></a><h4 id="title-IDA0EIHN" class="docSection1Title">9.2.2. Why Provide Both mapM and forM?</h4><a name="x_DO" class="calibre27" id="x_DO"></a><p class="docText">It might seem<a name="I_indexterm9_d1e23285" class="calibre27" id="I_indexterm9_d1e23285"></a><a name="I_indexterm9_d1e23288" class="calibre27" id="I_indexterm9_d1e23288"></a> a bit odd that there exist two functions that are
      identical but for the order in which they accept their arguments.
      However, <i class="docEmphasis">mapM</i> and <i class="docEmphasis">forM</i> are convenient in <span class="docEmphasis">different</span> circumstances.</p><a name="x_EO" class="calibre27" id="x_EO"></a><p class="docText">Consider our previous example, using an anonymous
      function as a loop body. If we were to use <i class="docEmphasis">mapM</i> instead of <i class="docEmphasis">forM</i>, we'd have to place the variable
      <span class="docMonofont">properNames</span> after the body of the function. In order
      to get the code to parse correctly, we'd have to wrap the entire
      anonymous function in parentheses, or replace it with a named function
      that would otherwise be unnecessary. Try it yourself: copy the code just
      shown, replacing <i class="docEmphasis">forM</i> with
      <i class="docEmphasis">mapM</i>, and see what this does to the
      readability of the code.</p><a name="x_FO" class="calibre27" id="x_FO"></a><p class="docText">By contrast, if the body of the loop was already a named
      function, and the list over which we were looping was computed by a
      complicated expression, we'd have a good case for using <i class="docEmphasis">mapM</i> instead.</p><a name="x_GO" class="calibre27" id="x_GO"></a><p class="docText">The stylistic rule of thumb to follow here is to use
      whichever of <i class="docEmphasis">mapM</i> or <i class="docEmphasis">forM</i> lets you write the tidiest code. If the
      loop body and the expression computing the data over which you're
      looping are both short, it doesn't matter which you use. If the loop is
      short, but the data is long, use <i class="docEmphasis">mapM</i>. If the loop is long, but the data
      short, use <i class="docEmphasis">forM</i>. And if both are
      long, use a <tt class="calibre34">let</tt> or <tt class="calibre34">where</tt> clause to make one of them short. With
      just a little practice, it will become obvious which of these approaches
      is best in every <span class="docEmphasis">instance</span>.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="find_getRecursiveContents.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="find_simpleFind.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

