---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect112_d1e28385.html
next: I_sect112_d1e28992.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect112_d1e28385.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect112_d1e28992.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect112_d1e28808" class="calibre27" id="I_sect112_d1e28808"></a><h3 id="title-IDANBSTE" class="docSection1Title">12.10. Turning Digit Soup into an Answer</h3><a name="x_lV" class="calibre27" id="x_lV"></a><p class="docText">We've<a name="I_indexterm12_d1e28813" class="calibre27" id="I_indexterm12_d1e28813"></a><a name="I_indexterm12_d1e28814" class="calibre27" id="I_indexterm12_d1e28814"></a><a name="I_indexterm12_d1e28815" class="calibre27" id="I_indexterm12_d1e28815"></a> got yet another problem to solve.
    We have many candidates for the last 12 digits of the barcode. In
    addition, we need to use the parities of the first six digits to figure
    out what the first digit is. Finally, we need to ensure that our answer's
    check digit makes sense.</p><a name="x_mV" class="calibre27" id="x_mV"></a><p class="docText">This seems quite challenging! We have a lot of uncertain
    data; what should we do? It's reasonable to ask if we could perform a
    brute-force search. Given the candidates we saw in th preceding <i class="docEmphasis">ghci</i> session, how many combinations would we
    have to examine?</p><pre class="calibre39">ghci&gt; <b class="calibre40">product . map length . candidateDigits $ input</b>
34012224
</pre><a name="x_nV" class="calibre27" id="x_nV"></a><p class="docText">So much for that idea. Once again, we'll initially focus
    on a subproblem that we know how to solve and postpone worrying about the
    rest.</p><a name="I_sect112_d1e28808d1e29170" class="calibre27" id="I_sect112_d1e28808d1e29170"></a><h4 id="title-IDAWCSTE" class="docSection1Title">12.10.1. Solving for Check Digits in Parallel</h4><a name="x_oV" class="calibre27" id="x_oV"></a><p class="docText">Let's abandon the idea of searching for now, and focus
      on computing a check digit. The check digit for a barcode can assume 1
      of 12 possible values. For a given parity digit, which input sequences
      can cause that digit to be computed?</p><pre class="calibre39">-- file: ch12/Barcode.hs
type Map a = M.Map Digit [a]</pre><br class="calibre48"/>
<a name="x_pV" class="calibre27" id="x_pV"></a><p class="docText">In this map, the key is a check digit, and the value is
      a sequence that evaluates to this check digit. We have two further map
      types based on this definition:</p><pre class="calibre39">-- file: ch12/Barcode.hs
type DigitMap = Map Digit
type ParityMap = Map (Parity Digit)</pre><br class="calibre48"/>
<a name="x_qV" class="calibre27" id="x_qV"></a><p class="docText">We'll generically refer to these as <span class="docEmphasis">solution
      maps</span>, because<a name="I_indexterm12_d1e28846" class="calibre27" id="I_indexterm12_d1e28846"></a> they show us the digit sequence that "solves
      for" each check digit.</p><a name="x_rV" class="calibre27" id="x_rV"></a><p class="docText">Given a single digit, here's how we can update an
      existing solution map:</p><pre class="calibre39">-- file: ch12/Barcode.hs
updateMap :: Parity Digit       -- ^ new digit
          -&gt; Digit              -- ^ existing key
          -&gt; [Parity Digit]     -- ^ existing digit sequence
          -&gt; ParityMap          -- ^ map to update
          -&gt; ParityMap
updateMap digit key seq = insertMap key (fromParity digit) (digit:seq)

insertMap :: Digit -&gt; Digit -&gt; [a] -&gt; Map a -&gt; Map a
insertMap key digit val m = val `seq` M.insert key' val m
    where key' = (key + digit) `mod` 10</pre><br class="calibre48"/>
<a name="x_sV" class="calibre27" id="x_sV"></a><p class="docText">With an existing check digit drawn from the map, the
      sequence that solves for it, and a new input digit, this function
      updates the map with the new sequence that leads to the new check
      digit.</p><a name="x_tV" class="calibre27" id="x_tV"></a><p class="docText">This might seem a bit much to digest, but an example
      will make it clear. Let's say the check digit we're looking at is
      <tt class="calibre34">4</tt>, the sequence leading to it is <tt class="calibre34">[1,3]</tt>, and
      the digit we want to add to the map is <tt class="calibre34">8</tt>. The sum of
      <tt class="calibre34">4</tt> and <tt class="calibre34">8</tt>, modulo 10, is <tt class="calibre34">2</tt>, so this
      is the key we'll be inserting into the map. The sequence that leads to
      the new check digit <tt class="calibre34">2</tt> is thus <tt class="calibre34">[8,1,3]</tt>, so this
      is what we'll insert as the value.</p><a name="x_uV" class="calibre27" id="x_uV"></a><p class="docText">For each digit in a sequence, we'll generate a new
      solution map, using that digit and an older solution map:</p><pre class="calibre39">-- file: ch12/Barcode.hs
useDigit :: ParityMap -&gt; ParityMap -&gt; Parity Digit -&gt; ParityMap
useDigit old new digit =
    new `M.union` M.foldWithKey (updateMap digit) M.empty old</pre><br class="calibre48"/>
<a name="x_vV" class="calibre27" id="x_vV"></a><p class="docText">Once again, let's illustrate what this code is doing
      using some examples. This time, we'll use <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let single n = M.singleton n [Even n] :: ParityMap</b>ghci&gt; <b class="calibre40">useDigit (single 1) M.empty (Even 1)</b>
fromList [(2,[Even 1,Even 1])]
ghci&gt; <b class="calibre40">useDigit (single 1) (single 2) (Even 2)</b>
fromList [(2,[Even 2]),(3,[Even 2,Even 1])]</pre><a name="x_wV" class="calibre27" id="x_wV"></a><p class="docText">The new solution map that we feed to <i class="docEmphasis">useDigits</i> starts out empty. We populate it
      completely by folding <i class="docEmphasis">useDigits</i>
      over a sequence of input digits:</p><pre class="calibre39">-- file: ch12/Barcode.hs
incorporateDigits :: ParityMap -&gt; [Parity Digit] -&gt; ParityMap
incorporateDigits old digits = foldl' (useDigit old) M.empty digits</pre><br class="calibre48"/>
<a name="x_xV" class="calibre27" id="x_xV"></a><p class="docText">This generates a complete new solution map from an old
      one:</p><pre class="calibre39">ghci&gt; <b class="calibre40">incorporateDigits (M.singleton 0 []) [Even 1, Even 5]</b>
fromList [(1,[Even 1]),(5,[Even 5])]
</pre><a name="x_yV" class="calibre27" id="x_yV"></a><p class="docText">Finally, we must build the complete solution map. We
      start out with an empty map, then fold over each digit position from the
      barcode in turn. For each position, we create a new map from our guesses
      at the digits in that position. This becomes the old map for the next
      round of the fold:</p><pre class="calibre39">-- file: ch12/Barcode.hs
finalDigits :: [[Parity Digit]] -&gt; ParityMap
finalDigits = foldl' incorporateDigits (M.singleton 0 [])
            . mapEveryOther (map (fmap (*3)))</pre><br class="calibre48"/>
<a name="x_zV" class="calibre27" id="x_zV"></a><p class="docText">(From the <i class="docEmphasis">checkDigit</i> function that we defined in <a class="docLink" href="I_sect112_d1e27234.html#barcode_encode">Section 12.1.1</a>, we remember that the check digit
      computation requires that we multiply every other digit by
      <tt class="calibre34">3</tt>.)</p><a name="x_AW" class="calibre27" id="x_AW"></a><p class="docText">How long is the list with which we call <i class="docEmphasis">finalDigits</i>? We don't yet know what the first
      digit of our sequence is, so obviously we can't provide that. And we
      don't want to include our guess at the check digit, so the list must be
      11 elements long.</p><a name="x_BW" class="calibre27" id="x_BW"></a><p class="docText">Once we've returned from <i class="docEmphasis">finalDigits</i>, our solution map is necessarily
      incomplete, because we haven't yet figured out what the first digit
      is.</p><a name="I_sect112_d1e28808d1e29296" class="calibre27" id="I_sect112_d1e28808d1e29296"></a><h4 id="title-IDAPHSTE" class="docSection1Title">12.10.2. Completing the Solution Map with the First Digit</h4><a name="x_CW" class="calibre27" id="x_CW"></a><p class="docText">We haven't yet discussed how we should extract the value
      of the first digit from the parities of the left group of digits. This
      is a straightforward matter of reusing code that we've already
      written:</p><pre class="calibre39">-- file: ch12/Barcode.hs
firstDigit :: [Parity a] -&gt; Digit
firstDigit = snd
           . head
           . bestScores paritySRL
           . runLengths
           . map parityBit
           . take 6
  where parityBit (Even _) = Zero
        parityBit (Odd _) = One</pre><br class="calibre48"/>
<a name="x_DW" class="calibre27" id="x_DW"></a><p class="docText">Each element of our partial solution map now contains a
      reversed list of digits and parity data. Our next task is to create a
      completed solution map, by computing the first digit in each sequence,
      and using it to create that last solution map:</p><pre class="calibre39">-- file: ch12/Barcode.hs
addFirstDigit :: ParityMap -&gt; DigitMap
addFirstDigit = M.foldWithKey updateFirst M.empty

updateFirst :: Digit -&gt; [Parity Digit] -&gt; DigitMap -&gt; DigitMap
updateFirst key seq = insertMap key digit (digit:renormalize qes)
  where renormalize = mapEveryOther (`div` 3) . map fromParity
        digit = firstDigit qes
        qes = reverse seq</pre><br class="calibre48"/>
<a name="x_EW" class="calibre27" id="x_EW"></a><p class="docText">Along the way, we get rid of the Parity
      type and reverse our earlier multiplications by three. Our last step is
      to complete the check digit computation:</p><pre class="calibre39">-- file: ch12/Barcode.hs
buildMap :: [[Parity Digit]] -&gt; DigitMap
buildMap = M.mapKeys (10 -)
         . addFirstDigit
         . finalDigits</pre><br class="calibre48"/>
<a name="I_sect112_d1e28808d1e29314" class="calibre27" id="I_sect112_d1e28808d1e29314"></a><h4 id="title-IDANISTE" class="docSection1Title">12.10.3. Finding the Correct Sequence</h4><a name="x_FW" class="calibre27" id="x_FW"></a><p class="docText">We now have a map of all possible checksums and the
      sequences that lead to each. All that remains is to take our guesses at
      the check digit, and then see if we have a corresponding solution map
      entry:</p><pre class="calibre39">-- file: ch12/Barcode.hs
solve :: [[Parity Digit]] -&gt; [[Digit]]
solve [] = []
solve xs = catMaybes $ map (addCheckDigit m) checkDigits
    where checkDigits = map fromParity (last xs)
          m = buildMap (init xs)
          addCheckDigit m k = (++[k]) &lt;$&gt; M.lookup k m</pre><br class="calibre48"/>
<a name="x_GW" class="calibre27" id="x_GW"></a><p class="docText">Let's try this out on the row we picked from our photo
      and see if we get a sensible answer:</p><pre class="calibre39">ghci&gt; <b class="calibre40">listToMaybe . solve . candidateDigits $ input</b>
Just [9,7,8,0,1,3,2,1,1,4,6,7,7]
</pre><a name="x_HW" class="calibre27" id="x_HW"></a><p class="docText">Excellent! This is exactly the string encoded in the
      barcode that we photographed.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect112_d1e28385.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect112_d1e28992.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

