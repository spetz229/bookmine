---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect126_d1e50755.html
next: I_sect126_d1e51063_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect126_d1e50755.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="sockets_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect126_d1e51063" class="calibre27" id="I_sect126_d1e51063"></a><h3 id="title-IDAZNNEK" class="docSection1Title">26.11. Performance Analysis and Tuning</h3><a name="x_y91" class="calibre27" id="x_y91"></a><p class="docText">We now have a correctness base line: our QuickCheck tests
    pass. When we start tweaking performance, we can rerun the tests at any
    time to ensure that we haven't inadvertently broken anything.</p><a name="x_z91" class="calibre27" id="x_z91"></a><p class="docText">Our first step is to write a small test application that
    we can use for timing:</p><pre class="calibre39">-- file: examples/WordTest.hs
module Main where

import Control.Parallel.Strategies (NFData(..))
import Control.Monad (forM_, mapM_)
import qualified BloomFilter.Easy as B
import qualified Data.ByteString.Char8 as BS
import Data.Time.Clock (diffUTCTime, getCurrentTime)
import System.Environment (getArgs)
import System.Exit (exitFailure)

timed :: (NFData a) =&gt; String -&gt; IO a -&gt; IO a
timed desc act = do
    start &lt;- getCurrentTime
    ret &lt;- act
    end &lt;- rnf ret `seq` getCurrentTime
    putStrLn $ show (diffUTCTime end start) ++ " to " ++ desc
    return ret

instance NFData BS.ByteString where
    rnf _ = ()

instance NFData (B.Bloom a) where
    rnf filt = B.length filt `seq` ()</pre><br class="calibre48"/>
<a name="x_AA1" class="calibre27" id="x_AA1"></a><p class="docText">We borrow the <i class="docEmphasis">rnf</i>
    function that we introduced in <a class="docLink" href="I_sect124_d1e48019.html#concurrent_strategies">Section 24.10.1</a> to
    develop a simple timing harness. Out <i class="docEmphasis">timed</i> action ensures that a value is evaluated
    to normal form in order to accurately capture the cost of evaluating
    it.</p><a name="x_BA1" class="calibre27" id="x_BA1"></a><p class="docText">The application creates a Bloom filter from the contents
    of a file, treating each line as an element to add to the filter:</p><pre class="calibre39">-- file: examples/WordTest.hs
main = do
  args &lt;- getArgs
  let files | null args = ["/usr/share/dict/words"]
            | otherwise = args
  forM_ files $ \file -&gt; do

    words &lt;- timed "read words" $
      BS.lines `fmap` BS.readFile file

    let len = length words
        errRate = 0.01

    putStrLn $ show len ++ " words"
    putStrLn $ "suggested sizings: " ++
               show (B.suggestSizing (fromIntegral len) errRate)

    filt &lt;- timed "construct filter" $
      case B.easyList errRate words of
        Left errmsg -&gt; do
          putStrLn $ "Error: " ++ errmsg
          exitFailure
        Right filt -&gt; return filt

    timed "query every element" $
      mapM_ print $ filter (not . (`B.elem` filt)) words</pre><br class="calibre48"/>
<a name="x_CA1" class="calibre27" id="x_CA1"></a><p class="docText">We use <i class="docEmphasis">timed</i> to
    account for the costs of three distinct phases: reading and splitting the
    data into lines; populating the Bloom filter; and querying every element
    in it.</p><a name="x_DA1" class="calibre27" id="x_DA1"></a><p class="docText">If we compile this and run it a few times, we can see
    that the execution time is just long enough to be interesting, while the
    timing variation from run to run is small. We have created a
    plausible-looking microbenchmark:</p><pre class="calibre39">$<b class="calibre40">ghc -O2  --make WordTest</b>
[1 of 1] Compiling Main             ( WordTest.hs, WordTest.o )
Linking WordTest ...
$ <b class="calibre40">./WordTest</b>
0.196347s to read words
479829 words
1.063537s to construct filter
4602978 bits
0.766899s to query every element
$ <b class="calibre40">./WordTest</b>
0.179284s to read words
479829 words
1.069363s to construct filter
4602978 bits
0.780079s to query every element</pre><a name="I_sect126_d1e51063d1e51387" class="calibre27" id="I_sect126_d1e51063d1e51387"></a><h4 id="title-IDAZPNEK" class="docSection1Title">26.11.1. Profile-Driven Performance Tuning</h4><a name="x_EA1" class="calibre27" id="x_EA1"></a><p class="docText">To understand where our program might benefit from some
      tuning, we rebuild it and run it with profiling enabled.</p><a name="x_FA1" class="calibre27" id="x_FA1"></a><p class="docText">Since we already built <i class="docEmphasis">WordTest</i> and have not subsequently changed
      it, if we rerun <i class="docEmphasis">ghc</i> to enable
      profiling support, it will quite reasonably decide to do nothing. We
      must force it to rebuild, which we accomplish by updating the
      filesystem's idea of when we last edited the source file:</p><pre class="calibre39">$<b class="calibre40">touch WordTest.hs</b>$<b class="calibre40">ghc -O2 -prof -auto-all --make WordTest</b>
[1 of 1] Compiling Main             ( WordTest.hs, WordTest.o )
Linking WordTest ...

$ <b class="calibre40">./WordTest +RTS -p</b>
0.322675s to read words
479829 words
suggested sizings: Right (4602978,7)
2.475339s to construct filter
1.964404s to query every element

$ <b class="calibre40">head -20 WordTest.prof</b>
total time  =          4.10 secs   (205 ticks @ 20 ms)
total alloc = 2,752,287,168 bytes  (excludes profiling overheads)

COST CENTRE                    MODULE               %time %alloc

doubleHash                     BloomFilter.Hash      48.8   66.4
indices                        BloomFilter.Mutable   13.7   15.8
elem                           BloomFilter            9.8    1.3
hashByteString                 BloomFilter.Hash       6.8    3.8
easyList                       BloomFilter.Easy       5.9    0.3
hashIO                         BloomFilter.Hash       4.4    5.3
main                           Main                   4.4    3.8
insert                         BloomFilter.Mutable    2.9    0.0
len                            BloomFilter            2.0    2.4
length                         BloomFilter.Mutable    1.5    1.0</pre><a name="x_GA1" class="calibre27" id="x_GA1"></a><p class="docText">Our <i class="docEmphasis">doubleHash</i>
      function immediately leaps out as a huge time and memory sink.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Always profile before—and while—you tune!</p><a name="x_HA1" class="calibre27" id="x_HA1"></a><p class="docText">Before our first profiling run, we did not expect
        <i class="docEmphasis">doubleHash</i> to even appear in the
        top 10 of "hot" functions, much less dominate it. Without
        this knowledge, we would probably have started tuning something
        entirely irrelevant.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_IA1" class="calibre27" id="x_IA1"></a><p class="docText">Recall that the body of <i class="docEmphasis">doubleHash</i> is an innocuous list
      comprehension:</p><pre class="calibre39">-- file: BloomFilter/Hash.hs
doubleHash :: Hashable a =&gt; Int -&gt; a -&gt; [Word32]
doubleHash numHashes value = [h1 + h2 * i | i &lt;- [0..num]]
    where h   = hashSalt 0x9150a946c4a8966e value
          h1  = fromIntegral (h `shiftR` 32) .&amp;. maxBound
          h2  = fromIntegral h
          num = fromIntegral numHashes</pre><br class="calibre48"/>
<a name="x_JA1" class="calibre27" id="x_JA1"></a><p class="docText">Since the function returns a list, it makes
      <span class="docEmphasis">some</span> sense that it allocates so much memory, but
      when code this simple performs so badly, we should be suspicious.</p><a name="x_KA1" class="calibre27" id="x_KA1"></a><p class="docText">Faced with a performance mystery, the suspicious mind
      will naturally want to inspect the output of the compiler. We don't need
      to start scrabbling through assembly language dumps: it's best to start
      at a higher level.</p><a name="x_LA1" class="calibre27" id="x_LA1"></a><p class="docText"><span class="docMonofont">GHC</span>'s
      <i class="docEmphasis">-ddump-simpl</i> option<a name="I_indexterm26_d1e51192" class="calibre27" id="I_indexterm26_d1e51192"></a> prints out the code that it produces after performing all
      of its high-level optimizations:</p><pre class="calibre39">$<b class="calibre40">ghc -O2 -c -ddump-simpl --make BloomFilter/Hash.hs &gt; dump.txt</b>
[1 of 1] Compiling BloomFilter.Hash ( BloomFilter/Hash.hs )</pre><a name="x_MA1" class="calibre27" id="x_MA1"></a><p class="docText">The file thus produced is about 1,000 lines long. Most
      of the names in it are mangled somewhat from their original Haskell
      representations. Even so, searching for <i class="docEmphasis">doubleHash</i> will immediately drop us at the
      definition of the function. For example, here is how we might start
      exactly at the right spot from a Unix shell:</p><pre class="calibre39">          $
          <b class="calibre40">less +/doubleHash dump.txt</b></pre><a name="x_NA1" class="calibre27" id="x_NA1"></a><p class="docText">It can be difficult to start reading the output of
      <span class="docMonofont">GHC</span>'s simplifier. There are
      many automatically generated names, and the code has many obscure
      annotations. We can make substantial progress by ignoring things that we
      do not understand, focusing on those that look familiar. The Core
      language shares some features with regular Haskell, notably type
      signatures, <tt class="calibre34">let</tt> for variable binding,
      and <tt class="calibre34">case</tt> for pattern matching.</p><a name="x_OA1" class="calibre27" id="x_OA1"></a><p class="docText">If we skim through the definition of <i class="docEmphasis">doubleHash</i>, we will arrive at a section that
      looks something like this:</p><pre class="calibre39">__letrec { 
  go_s1YC :: [GHC.Word.Word32] -&gt; [GHC.Word.Word32] 
  [Arity 1
   Str: DmdType S]
  go_s1YC =
    \ (ds_a1DR :: [GHC.Word.Word32]) -&gt;
      case ds_a1DR of wild_a1DS {
	[] -&gt; GHC.Base.[] @ GHC.Word.Word32; 
	: y_a1DW ys_a1DX -&gt; 
	  GHC.Base.: @ GHC.Word.Word32 
	    (case h1_s1YA of wild1_a1Mk { GHC.Word.W32# x#_a1Mm -&gt; 
	     case h2_s1Yy of wild2_a1Mu { GHC.Word.W32# x#1_a1Mw -&gt;
	     case y_a1DW of wild11_a1My { GHC.Word.W32# y#_a1MA -&gt;
	     GHC.Word.W32# 
	       (GHC.Prim.narrow32Word#
		  (GHC.Prim.plusWord# 
		     x#_a1Mm (GHC.Prim.narrow32Word#
                              (GHC.Prim.timesWord# x#1_a1Mw y#_a1MA))))
	     }
	     }
	     })
	    (go_s1YC ys_a1DX) 
      };
} in 
  go_s1YC 
    (GHC.Word.$w$dmenumFromTo2
       __word 0 (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# ww_s1X3)))</pre><br class="calibre48"/>
<a name="x_PA1" class="calibre27" id="x_PA1"></a><p class="docText">This is the body of the list comprehension. It may seem
      daunting, but we can look through it piece by piece and find that it is
      not, after all, so complicated:</p><a name="x_bA1" class="calibre27" id="x_bA1"></a><p class="docText">From reading the Core for this code, we can see two
      interesting behaviors:</p><ul class="calibre18"><li class="calibre19"><p class="docText">We are creating a list, and then immediately
          deconstructing it in the <i class="docEmphasis">go_s1YC</i> loop.</p><p class="docText"><span class="docMonofont">GHC</span> can
          often spot this pattern of production followed immediately by
          consumption, and transform it into a loop in which no allocation
          occurs. This class of transformation is called
          <span class="docEmphasis">fusion</span>, because the producer and consumer
          become fused together. Unfortunately, it is not occurring
          here.</p></li><li class="calibre19"><p class="docText">The repeated unboxing of <span class="docMonofont">h1</span> and
          <span class="docMonofont">h2</span> in the body of the loop is wasteful.</p></li></ul><a name="x_fA1" class="calibre27" id="x_fA1"></a><p class="docText">To address these problems, we make a few tiny changes
      to our <i class="docEmphasis">doubleHash</i> function:</p><pre class="calibre39">-- file: BloomFilter/Hash.hs
doubleHash :: Hashable a =&gt; Int -&gt; a -&gt; [Word32]
doubleHash numHashes value = go 0
    where go n | n == num  = []
               | otherwise = h1 + h2 * n : go (n + 1)

          !h1 = fromIntegral (h `shiftR` 32) .&amp;. maxBound
          !h2 = fromIntegral h

          h   = hashSalt 0x9150a946c4a8966e value
          num = fromIntegral numHashes</pre><br class="calibre48"/>
<a name="x_gA1" class="calibre27" id="x_gA1"></a><p class="docText">We manually fused the <tt class="calibre34">[0..num]</tt> expression
      and the code that consumes it into a single loop. We added strictness
      annotations to <span class="docMonofont">h1</span> and <span class="docMonofont">h2</span>. And
      nothing more. This has turned a six-line function into an eight-line
      function. What effect does our change have on Core output?</p><pre class="calibre39">__letrec {
  $wgo_s1UH :: GHC.Prim.Word# -&gt; [GHC.Word.Word32]
  [Arity 1
   Str: DmdType L]
  $wgo_s1UH =
    \ (ww2_s1St :: GHC.Prim.Word#) -&gt;
      case GHC.Prim.eqWord# ww2_s1St a_s1T1 of wild1_X2m {
	GHC.Base.False -&gt;
	  GHC.Base.: @ GHC.Word.Word32
	    (GHC.Word.W32#
	     (GHC.Prim.narrow32Word#
	      (GHC.Prim.plusWord#
	       ipv_s1B2
	       (GHC.Prim.narrow32Word#
		(GHC.Prim.timesWord# ipv1_s1AZ ww2_s1St)))))
	    ($wgo_s1UH (GHC.Prim.narrow32Word#
                        (GHC.Prim.plusWord# ww2_s1St __word 1)));
	GHC.Base.True -&gt; GHC.Base.[] @ GHC.Word.Word32
      };
} in  $wgo_s1UH __word 0</pre><br class="calibre48"/>
<a name="x_hA1" class="calibre27" id="x_hA1"></a><p class="docText">Our new function has compiled down to a simple counting
      loop. This is very encouraging, but how does it actually perform?</p><pre class="calibre39">$<b class="calibre40">touch WordTest.hs</b>$<b class="calibre40">ghc -O2 -prof -auto-all --make WordTest</b>
[1 of 1] Compiling Main             ( WordTest.hs, WordTest.o )
Linking WordTest ...

$ <b class="calibre40">./WordTest +RTS -p</b>
0.304352s to read words
479829 words
suggested sizings: Right (4602978,7)
1.516229s to construct filter
1.069305s to query every element
~/src/darcs/book/examples/ch27/examples $ head -20 WordTest.prof 
total time  =        3.68 secs    (184 ticks @ 20 ms)
total alloc = 2,644,805,536 bytes (excludes profiling overheads)

COST CENTRE                    MODULE               %time %alloc

doubleHash                     BloomFilter.Hash      45.1   65.0
indices                        BloomFilter.Mutable   19.0   16.4
elem                           BloomFilter           12.5    1.3
insert                         BloomFilter.Mutable    7.6    0.0
easyList                       BloomFilter.Easy       4.3    0.3
len                            BloomFilter            3.3    2.5
hashByteString                 BloomFilter.Hash       3.3    4.0
main                           Main                   2.7    4.0
hashIO                         BloomFilter.Hash       2.2    5.5
length                         BloomFilter.Mutable    0.0    1.0</pre><a name="x_iA1" class="calibre27" id="x_iA1"></a><p class="docText">Our tweak has improved performance by about 11%—a good
      result for such<a name="I_indexterm26_d1e51447" class="calibre27" id="I_indexterm26_d1e51447"></a> a small change.</p><a name="I_sidebar26_d1e51449" class="calibre27" id="I_sidebar26_d1e51449"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

