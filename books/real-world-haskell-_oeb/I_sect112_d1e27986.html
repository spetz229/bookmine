---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect112_d1e27934.html
next: I_sect112_d1e28385.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect112_d1e27934.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect112_d1e28385.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect112_d1e27986" class="calibre27" id="I_sect112_d1e27986"></a><h3 id="title-IDADZRTE" class="docSection1Title">12.8. Finding Matching Digits</h3><a name="x_eU" class="calibre27" id="x_eU"></a><p class="docText">Our first problem is to find the digits that
    <span class="docEmphasis">might</span> be encoded at a given position. For the next
    while, we'll make a couple simplifying assumptions. The first is that
    we're working with a single row. The second is that we know exactly where
    in a row the left edge of a barcode begins.</p><a name="I_sect112_d1e27986d1e28339" class="calibre27" id="I_sect112_d1e27986d1e28339"></a><h4 id="title-IDAMZRTE" class="docSection1Title">12.8.1. Run Length Encoding</h4><a name="x_fU" class="calibre27" id="x_fU"></a><p class="docText">How can we overcome the problem of not even knowing how
      thick our bars are? The answer is to run length encode (instead of
      repeating a value some number of times, run length encoding presents it
      once, with a count of the number of consecutive repeats):</p><pre class="calibre39">-- file: ch12/Barcode.hs
type Run = Int
type RunLength a = [(Run, a)]

runLength :: Eq a =&gt; [a] -&gt; RunLength a
runLength = map rle . group
    where rle xs = (length xs, head xs)</pre><br class="calibre48"/>
<a name="x_gF1" class="calibre27" id="x_gF1"></a><p class="docText">The <i class="docEmphasis">group</i>
      function<a name="I_indexterm12_d1e28006" class="calibre27" id="I_indexterm12_d1e28006"></a> takes sequences of identical elements in a list and
      groups them into sublists:</p><pre class="calibre39">ghci&gt; <b class="calibre40">group [1,1,2,3,3,3,3]</b>
[[1,1],[2],[3,3,3,3]]
</pre><a name="x_hF1" class="calibre27" id="x_hF1"></a><p class="docText">Our <i class="docEmphasis">runLength</i>
      function represents each group as a pair of its length and first
      element:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let bits = [0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0]</b>ghci&gt; <b class="calibre40">runLength bits</b>
Loading package array-0.1.0.0 ... linking ... done.
Loading package containers-0.1.0.2 ... linking ... done.
Loading package bytestring-0.9.0.1.1 ... linking ... done.
[(2,0),(2,1),(2,0),(2,1),(6,0),(4,1),(4,0)]</pre><a name="x_gU" class="calibre27" id="x_gU"></a><p class="docText">Since the data we're run length encoding are just ones
      and zeros, the encoded numbers will simply alternate between one and
      zero. We can throw the encoded values away without losing any useful
      information, keeping only the length of each run:</p><pre class="calibre39">-- file: ch12/Barcode.hs
runLengths :: Eq a =&gt; [a] -&gt; [Run]
runLengths = map fst . runLength</pre><br class="calibre48"/>
<pre class="calibre39">ghci&gt; <b class="calibre40">runLengths bits</b>
[2,2,2,2,6,4,4]
</pre><a name="x_hU" class="calibre27" id="x_hU"></a><p class="docText">The bit patterns aren't random; they're the left outer
      guard and first encoded digit of a row from our captured image. If we
      drop the guard bars, we're left with the run lengths
      <tt class="calibre34">[2,6,4,4]</tt>. How do we find matches for these in the encoding
      tables we wrote in <a class="docLink" href="barcode_array_split_000.html#barcode_array">Section 12.2</a>?</p><a name="I_sect112_d1e27986d1e28393" class="calibre27" id="I_sect112_d1e27986d1e28393"></a><h4 id="title-IDAY1RTE" class="docSection1Title">12.8.2. Scaling Run Lengths, and Finding Approximate Matches</h4><a name="x_iU" class="calibre27" id="x_iU"></a><p class="docText">One possible approach is to scale the run lengths so
      that they sum to one. We'll use the Ratio Int
      type<a name="I_indexterm12_d1e28057" class="calibre27" id="I_indexterm12_d1e28057"></a> instead of the usual Double to manage these
      scaled values, as Ratios print out more readably in
      <i class="docEmphasis">ghci</i>. This makes interactive
      debugging and development much easier:</p><pre class="calibre39">-- file: ch12/Barcode.hs
type Score = Ratio Int

scaleToOne :: [Run] -&gt; [Score]
scaleToOne xs = map divide xs
    where divide d = fromIntegral d / divisor
          divisor = fromIntegral (sum xs)
-- A more compact alternative that "knows" we're using Ratio Int:
-- scaleToOne xs = map (% sum xs) xs

type ScoreTable = [[Score]]

-- "SRL" means "scaled run length".
asSRL :: [String] -&gt; ScoreTable
asSRL = map (scaleToOne . runLengths)

leftOddSRL = asSRL leftOddList
leftEvenSRL = asSRL leftEvenList
rightSRL = asSRL rightList
paritySRL = asSRL parityList</pre><br class="calibre48"/>
<a name="x_jU" class="calibre27" id="x_jU"></a><p class="docText">We use the Score type synonym so that most
      of our code won't have to care what the underlying type is. Once we're
      done developing our code and poking around with <i class="docEmphasis">ghci</i>, we could, if we wish, go back and turn
      the Score type synonym into Doubles without
      changing any code.</p><a name="x_kU" class="calibre27" id="x_kU"></a><p class="docText">We can use <i class="docEmphasis">scaleToOne</i> to scale a sequence of digits that
      we're searching for. We've now corrected for variations in bar widths
      due to distance, as there should be a pretty close match between an
      entry in a scaled run length encoding table and a run length sequence
      pulled from an image.</p><a name="x_lU" class="calibre27" id="x_lU"></a><p class="docText">The next question is how we turn the intuitive idea of
      "pretty close" into a measure of "close enough." Given two
      scaled run length sequences, we can calculate an approximate
      "distance" between them as follows:</p><pre class="calibre39">-- file: ch12/Barcode.hs
distance :: [Score] -&gt; [Score] -&gt; Score
distance a b = sum . map abs $ zipWith (-) a b</pre><br class="calibre48"/>
<a name="x_mU" class="calibre27" id="x_mU"></a><p class="docText">An exact match will give a distance of zero, with weaker
      matches resulting in larger distances:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let group = scaleToOne [2,6,4,4]</b>ghci&gt; <b class="calibre40">distance group (head leftEvenSRL)</b>
13%28
ghci&gt; <b class="calibre40">distance group (head leftOddSRL)</b>
17%28</pre><a name="x_nU" class="calibre27" id="x_nU"></a><p class="docText">Given a scaled run length table, we choose the best few
      matches in that table for a given input sequence:</p><pre class="calibre39">-- file: ch12/Barcode.hs
bestScores :: ScoreTable -&gt; [Run] -&gt; [(Score, Digit)]
bestScores srl ps = take 3 . sort $ scores
    where scores = zip [distance d (scaleToOne ps) | d &lt;- srl] digits
          digits = [0..9]</pre><br class="calibre48"/>
<a name="I_sect112_d1e27986d1e28466" class="calibre27" id="I_sect112_d1e27986d1e28466"></a><h4 id="title-IDAL4RTE" class="docSection1Title">12.8.3. List Comprehensions</h4><a name="x_iF1" class="calibre27" id="x_iF1"></a><p class="docText">The new<a name="I_indexterm12_d1e28128" class="calibre27" id="I_indexterm12_d1e28128"></a> notation that we introduced in the previous example is an
      illustration of a <span class="docEmphasis">list comprehension</span>, which creates
      a list from one or more other lists:</p><pre class="calibre39">ghci&gt; <b class="calibre40">[ (a,b) | a &lt;- [1,2], b &lt;- "abc" ]</b>
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
</pre><a name="x_jF1" class="calibre27" id="x_jF1"></a><p class="docText">The expression on the left of the vertical bar is
      evaluated for each combination <a name="I_indexterm12_d1e28143" class="calibre27" id="I_indexterm12_d1e28143"></a>of <span class="docEmphasis">generator expressions</span> on the
      right. A generator expression binds a variable on the left of a <tt class="calibre34">&lt;-</tt> to an element of the list on the right.
      As the preceding example shows, the combinations of generators are
      evaluated in depth first order: for the first element of the first list,
      we evaluate every element of the second, and so on.</p><a name="x_kF1" class="calibre27" id="x_kF1"></a><p class="docText">In addition to generators, we can also specify guards
      on the right of a list comprehension. A guard is a Bool
      expression. If it evaluates to <tt class="calibre34">False</tt>, that element is
      skipped over:</p><pre class="calibre39">ghci&gt; <b class="calibre40">[ (a,b) | a &lt;- [1..6], b &lt;- [5..7], even (a + b ^ 2) ]</b>
[(1,5),(1,7),(2,6),(3,5),(3,7),(4,6),(5,5),(5,7),(6,6)]
</pre><a name="x_lF1" class="calibre27" id="x_lF1"></a><p class="docText">We can also bind local variables using a <tt class="calibre34">let</tt> expression:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let vowel = (`elem` "aeiou")</b>ghci&gt; <b class="calibre40">[ x | a &lt;- "etaoin", b &lt;- "shrdlu", let x = [a,b], all vowel x ]</b>
["eu","au","ou","iu"]</pre><a name="x_mF1" class="calibre27" id="x_mF1"></a><p class="docText">If a pattern match fails in a generator expression, no
      error occurs. Instead, that list element is skipped:</p><pre class="calibre39">ghci&gt; <b class="calibre40">[ a | (3,a) &lt;- [(1,'y'),(3,'e'),(5,'p')] ]</b>
"e"
</pre><a name="x_nF1" class="calibre27" id="x_nF1"></a><p class="docText">List comprehensions are powerful and concise. As a
      result, they can be difficult to read, but when used with care, they can
      make code easier to follow:</p><pre class="calibre39">-- file: ch12/Barcode.hs
-- our original
zip [distance d (scaleToOne ps) | d &lt;- srl] digits

-- the same expression, expressed without a list comprehension
zip (map (flip distance (scaleToOne ps)) srl) digits

-- the same expression, written entirely as a list comprehension
[(distance d (scaleToOne ps), n) | d &lt;- srl, n &lt;- digits]</pre><br class="calibre48"/>
<a name="I_sect112_d1e27986d1e28538" class="calibre27" id="I_sect112_d1e27986d1e28538"></a><h4 id="title-IDAGBSTE" class="docSection1Title">12.8.4. Remembering a Match's Parity</h4><a name="x_oU" class="calibre27" id="x_oU"></a><p class="docText">For each match in the left group, we have to remember
      whether we found it in the even parity table or the odd table:</p><pre class="calibre39">-- file: ch12/Barcode.hs
data Parity a = Even a | Odd a | None a
                deriving (Show)

fromParity :: Parity a -&gt; a
fromParity (Even a) = a
fromParity (Odd a) = a
fromParity (None a) = a

parityMap :: (a -&gt; b) -&gt; Parity a -&gt; Parity b
parityMap f (Even a) = Even (f a)
parityMap f (Odd a) = Odd (f a)
parityMap f (None a) = None (f a)

instance Functor Parity where
    fmap = parityMap</pre><br class="calibre48"/>
<a name="x_pU" class="calibre27" id="x_pU"></a><p class="docText">We wrap a value in the parity with which it was encoded,
      and then make it a <tt class="calibre34">Functor</tt> instance so that we can easily
      manipulate parity-encoded values.</p><a name="x_qU" class="calibre27" id="x_qU"></a><p class="docText">We would like to be able to sort parity-encoded values
      based on the values they contain. <a name="I_indexterm12_d1e28210" class="calibre27" id="I_indexterm12_d1e28210"></a>The <tt class="calibre34">Data.Function</tt> module provides a lovely
      combinator that we can use for this, named <i class="docEmphasis">on</i>:</p><pre class="calibre39">-- file: ch12/Barcode.hs
on :: (a -&gt; a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; c -&gt; b
on f g x y = g x `f` g y

compareWithoutParity = compare `on` fromParity</pre><br class="calibre48"/>
<a name="x_rU" class="calibre27" id="x_rU"></a><p class="docText">In case it's unclear, try thinking of <i class="docEmphasis">on</i> as a function of two arguments,
      <span class="docMonofont">f</span> and <span class="docMonofont">g</span>, which return a function
      of two arguments, <span class="docMonofont">x</span> and <span class="docMonofont">y</span>. It
      applies <i class="docEmphasis">g</i> to <span class="docMonofont">x</span>
      and to <span class="docMonofont">y</span>, then <i class="docEmphasis">f</i>
      on the two results (hence the name <i class="docEmphasis">on</i>).</p><a name="x_tU" class="calibre27" id="x_tU"></a><p class="docText">Wrapping a match in a parity value is
      straightforward:</p><pre class="calibre39">-- file: ch12/Barcode.hs
type Digit = Word8

bestLeft :: [Run] -&gt; [Parity (Score, Digit)]
bestLeft ps = sortBy compareWithoutParity
              ((map Odd (bestScores leftOddSRL ps)) ++
               (map Even (bestScores leftEvenSRL ps)))

bestRight :: [Run] -&gt; [Parity (Score, Digit)]
bestRight = map None . bestScores rightSRL</pre><br class="calibre48"/>
<a name="x_uU" class="calibre27" id="x_uU"></a><p class="docText">Once we have the best lefthand matches from the even and
      odd tables, we sort them based only on the quality of each match.</p><a name="idd1e28605" class="calibre27" id="idd1e28605"></a><h5 id="title-IDASDSTE" class="docSection3Title">12.8.4.1. Another kind of laziness, of the keyboarding variety</h5><a name="x_vU" class="calibre27" id="x_vU"></a><p class="docText">In our definition of the Parity type, we
        could have used Haskell's record syntax to avoid the need to write a
        fromParity function. In other words, we could have
        written it as follows:</p><pre class="calibre39">-- file: ch12/Barcode.hs
data AltParity a = AltEven {fromAltParity :: a}
                 | AltOdd  {fromAltParity :: a}
                 | AltNone {fromAltParity :: a}
                   deriving (Show)</pre><br class="calibre48"/>
<a name="x_wU" class="calibre27" id="x_wU"></a><p class="docText">Why did we not do this? The answer is slightly
        shameful and has to do with interactive debugging in <i class="docEmphasis">ghci</i>. When we tell <span class="docMonofont">GHC</span> to automatically derive a
        Show instance for a type, it produces different code
        depending on whether or not we declare the type with record
        syntax:</p><pre class="calibre39">ghci&gt; <b class="calibre40">show $ Even 1</b>
"Even 1"
ghci&gt; <b class="calibre40">show $ AltEven 1</b>
"AltEven {fromAltParity = 1}"
ghci&gt; <b class="calibre40">length . show $ Even 1</b>
6
ghci&gt; <b class="calibre40">length . show $ AltEven 1</b>
27</pre><a name="x_xU" class="calibre27" id="x_xU"></a><p class="docText">The Show instance for the variant that
        uses record syntax is considerably more verbose. This creates much
        more noise that we must scan through when we're trying to read, say, a
        list of parity-encoded values output by <i class="docEmphasis">ghci</i>.</p><a name="x_yU" class="calibre27" id="x_yU"></a><p class="docText">Of course, we could write our own, less noisy,
        Show instance. It's simply less effort to avoid record
        syntax and write our own fromParity function instead,
        letting <span class="docMonofont">GHC</span> derive a more
        terse Show instance for us. This isn't an especially
        satisfying rationale, but programmer laziness can lead in odd
        directions at times.</p><a name="I_sect112_d1e27986d1e28672" class="calibre27" id="I_sect112_d1e27986d1e28672"></a><h4 id="title-IDAYFSTE" class="docSection1Title">12.8.5. Chunking a List</h4><a name="x_zU" class="calibre27" id="x_zU"></a><p class="docText">A common aspect of working with lists is needing to
      "chunk" them. For example, each digit in a barcode is
      encoded using a run of four digits. We can turn the flat list that
      represents a row into a list of four-element lists as follows:</p><pre class="calibre39">-- file: ch12/Barcode.hs
chunkWith :: ([a] -&gt; ([a], [a])) -&gt; [a] -&gt; [[a]]
chunkWith _ [] = []
chunkWith f xs = let (h, t) = f xs
                 in h : chunkWith f t

chunksOf :: Int -&gt; [a] -&gt; [[a]]
chunksOf n = chunkWith (splitAt n)</pre><br class="calibre48"/>
<a name="x_AV" class="calibre27" id="x_AV"></a><p class="docText">It's somewhat rare that we need to write generic list
      manipulation functions such as this. Often, a glance through the
      <tt class="calibre34">Data.List</tt> module will find us a function that does exactly
      or close enough to what we need.</p><a name="I_sect112_d1e27986d1e28687" class="calibre27" id="I_sect112_d1e27986d1e28687"></a><h4 id="title-IDAKGSTE" class="docSection1Title">12.8.6. Generating a List of Candidate Digits</h4><a name="x_BV" class="calibre27" id="x_BV"></a><p class="docText">With our small army of helper functions deployed, the
      function that generates lists of candidate matches for each digit group
      is easy to write. First of all, we take care of a few early checks to
      determine whether matching even makes sense. A list of runs must start
      on a black (<tt class="calibre34">Zero</tt>) bar, and contain enough bars. Here are
      the first few equations of our function:</p><pre class="calibre39">-- file: ch12/Barcode.hs
candidateDigits :: RunLength Bit -&gt; [[Parity Digit]]
candidateDigits ((_, One):_) = []
candidateDigits rle | length rle &lt; 59 = []</pre><br class="calibre48"/>
<a name="x_CV" class="calibre27" id="x_CV"></a><p class="docText">If any application of <i class="docEmphasis">bestLeft</i> or <i class="docEmphasis">bestRight</i> results in an empty list, we can't
      possibly have a match. Otherwise, we throw away the scores, and return a
      list of lists of parity-encoded candidate digits. The outer list is 12
      elements long, 1 per digit in the barcode. The digits in each sublist
      are ordered by match quality.</p><a name="x_oF1" class="calibre27" id="x_oF1"></a><p class="docText">Here is the remainder of the definition of our
      function:</p><pre class="calibre39">-- file: ch12/Barcode.hs
candidateDigits rle
    | any null match = []
    | otherwise      = map (map (fmap snd)) match
  where match = map bestLeft left ++ map bestRight right
        left = chunksOf 4 . take 24 . drop 3 $ runLengths
        right = chunksOf 4 . take 24 . drop 32 $ runLengths
        runLengths = map fst rle</pre><br class="calibre48"/>
<a name="x_DV" class="calibre27" id="x_DV"></a><p class="docText">Let's take a glance at the candidate digits chosen for
      each group of bars, from a row taken from Figure 12-5:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type input</b>
input :: [(Run, Bit)]
ghci&gt; <b class="calibre40">take 7 input</b>
[(2,Zero),(2,One),(2,Zero),(2,One),(6,Zero),(4,One),(4,Zero)]
ghci&gt; <b class="calibre40">mapM_ print $ candidateDigits input</b>
[Even 1,Even 5,Odd 7,Odd 1,Even 2,Odd 5]
[Even 8,Even 7,Odd 1,Odd 2,Odd 0,Even 6]
[Even 0,Even 1,Odd 8,Odd 2,Odd 4,Even 9]
[Odd 1,Odd 0,Even 8,Odd 2,Even 2,Even 4]
[Even 3,Odd 4,Odd 5,Even 7,Even 0,Odd 2]
[Odd 2,Odd 4,Even 7,Even 0,Odd 1,Even 1]
[None 1,None 5,None 0]
[None 1,None 5,None 2]
[None 4,None 5,None 2]
[None 6,None 8,None 2]
[None 7,None 8,None 3]
[None 7,None 3,None 8]</pre>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect112_d1e27934.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect112_d1e28385.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

