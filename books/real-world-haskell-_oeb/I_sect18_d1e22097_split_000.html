---
layout: page
title: "Real World Haskell, 1st Edition"
prev: glob_regex.html
next: I_sect18_d1e22097_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="glob_regex.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="glob_translate_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect18_d1e22097" class="calibre27" id="I_sect18_d1e22097"></a><h3 id="643999-811" class="docSection1Title">8.4. More About Regular Expressions</h3><a name="I_sect18_d1e22097d1e22464" class="calibre27" id="I_sect18_d1e22097d1e22464"></a><h4 id="title-IDA0NDBH" class="docSection1Title">8.4.1. Mixing and Matching String Types</h4><a name="x_cF" class="calibre27" id="x_cF"></a><p class="docText">As we noted earlier, the <i class="docEmphasis">=~</i> operator<a name="I_indexterm8_d1e22108" class="calibre27" id="I_indexterm8_d1e22108"></a> uses typeclasses for its argument types and its return
      type. We can use either String or strict
      ByteString values for both the regular expression and the
      text to match against:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:module +Data.ByteString.Char8</b>ghci&gt; <b class="calibre40">:type pack "foo"</b>
pack "foo" :: ByteString</pre><a name="x_dF" class="calibre27" id="x_dF"></a><p class="docText">We can then try using different combinations of
      String and ByteString:</p><pre class="calibre39">ghci&gt; <b class="calibre40">pack "foo" =~ "bar" :: Bool</b>
False
ghci&gt; <b class="calibre40">"foo" =~ pack "bar" :: Int</b>
0
ghci&gt; <b class="calibre40">pack "foo" =~ pack "o" :: [(Int, Int)]</b>
[(1,1),(2,1)]</pre><a name="x_eF" class="calibre27" id="x_eF"></a><p class="docText">However, we need to be aware that if we want a string
      value in the result of a match, the text we're matching against must be
      the same type of string. Let's see what this means in practice:</p><pre class="calibre39">ghci&gt; <b class="calibre40">pack "good food" =~ ".ood" :: [ByteString]</b>
["good","food"]
</pre><a name="x_fF" class="calibre27" id="x_fF"></a><p class="docText">In the above example, we've used the <i class="docEmphasis">pack</i> to turn a String into a
      ByteString. The type checker accepts this because
      ByteString appears in the result type. But if we try
      getting a String out, that <span class="docEmphasis">won't</span>
      work:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"good food" =~ ".ood" :: [ByteString]</b>

&lt;interactive&gt;:1:0:
    No instance for (Text.Regex.Base.RegexLike.RegexContext
                       Regex [Char] [ByteString])
      arising from a use of `=~' at &lt;interactive&gt;:1:0-20
    Possible fix:
      add an instance declaration for
      (Text.Regex.Base.RegexLike.RegexContext Regex [Char] [ByteString])
    In the expression: "good food" =~ ".ood" :: [ByteString]
    In the definition of `it':
        it = "good food" =~ ".ood" :: [ByteString]
</pre><a name="x_gF" class="calibre27" id="x_gF"></a><p class="docText">We can easily fix this problem by making the string
      types of the lefthand side and the result match once again:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"good food" =~ ".ood" :: [String]</b>
["good","food"]
</pre><a name="x_hF" class="calibre27" id="x_hF"></a><p class="docText">This restriction does <span class="docEmphasis">not</span> apply to
      the type of the regexp we're matching against. It can be either a
      String or ByteString, unconstrained by the
      other types in use.</p><a name="I_sect18_d1e22097d1e22573" class="calibre27" id="I_sect18_d1e22097d1e22573"></a><h4 id="title-IDANRDBH" class="docSection1Title">8.4.2. Other Things You Should Know</h4><a name="x_iF" class="calibre27" id="x_iF"></a><p class="docText">When you look through Haskell library documentation,
      you'll see several regexp-<span class="docEmphasis">related</span>
      modules. The modules under <i class="docEmphasis">Text.Regex.Base</i> define the common API adhered
      to by all of the other regexp modules. It's possible to have multiple
      implementations of the regexp API installed at one time. At the time of
      this writing, <span class="docMonofont">GHC</span> is bundled
      with one implementation, <i class="docEmphasis">Text.Regex.Posix</i>. As its name suggests, this
      package provides POSIX regexp semantics.</p><a name="I_sidebar8_d1e22227" class="calibre27" id="I_sidebar8_d1e22227"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

