---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect19_d1e24516.html
next: find_fold_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect19_d1e24516.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect19_d1e24785_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="find_fold" class="calibre27" id="find_fold"></a><h3 id="title-IDAAORZD" class="docSection1Title">9.9. Another Way of Looking at Traversal</h3><a name="x_QQ" class="calibre27" id="x_QQ"></a><p class="docText">While the <i class="docEmphasis">traverse</i>
    function<a name="I_indexterm9_d1e24593" class="calibre27" id="I_indexterm9_d1e24593"></a> gives us more control than our original <i class="docEmphasis">betterFind</i> function, it still has a significant
    failing: we can avoid recursing into directories, but we can't filter
    other names until after we've generated the entire list of names in a
    tree. If we are traversing a directory containing 100,000 files of which
    we care about only 3, we'll allocate a 100,000-element list before we have
    a chance to trim it down to the 3 we really want.</p><a name="x_RQ" class="calibre27" id="x_RQ"></a><p class="docText">One approach would be to provide a filter function as a
    new argument to <i class="docEmphasis">traverse</i>, which we
    would apply to the list of names as we generate it. This would allow us to
    allocate a list of only as many elements as we need.</p><a name="x_SQ" class="calibre27" id="x_SQ"></a><p class="docText">However, this approach also has a weakness. Say we know
    that we want at most 3 entries from our list, and that those 3 entries
    happen to be the first 3 of the 100,000 that we traverse. In this case,
    we'll needlessly visit 99,997 other entries. This is not by any means a
    contrived example: for instance, the Maildir mailbox format stores a
    folder of email messages as a directory of individual files. It's common
    for a single directory representing a mailbox to contain tens of thousands
    of files.</p><a name="x_TQ" class="calibre27" id="x_TQ"></a><p class="docText">We can address the weaknesses of our two prior traversal
    functions by taking a different perspective: what if we think of
    filesystem traversal as a <span class="docEmphasis">fold</span> over the directory
    <span class="docEmphasis">hierarchy</span>?</p><a name="x_UQ" class="calibre27" id="x_UQ"></a><p class="docText">The familiar folds, <i class="docEmphasis">foldr</i> and <i class="docEmphasis">foldl'</i>, neatly generalize the idea of
    traversing a list while accumulating a result. It's hardly a stretch to
    extend the idea of folding from lists to directory trees, but we'd like to
    add an element of <span class="docEmphasis">control</span> to our fold. We'll
    represent this control as an algebraic data type:</p><pre class="calibre39">-- file: ch09/FoldDir.hs
data Iterate seed = Done     { unwrap :: seed }
                  | Skip     { unwrap :: seed }
                  | Continue { unwrap :: seed }
                    deriving (Show)

type Iterator seed = seed -&gt; Info -&gt; Iterate seed</pre><br class="calibre48"/>
<a name="x_VQ" class="calibre27" id="x_VQ"></a><p class="docText">The Iterator type<a name="I_indexterm9_d1e24633" class="calibre27" id="I_indexterm9_d1e24633"></a> gives us a convenient alias for the function that we fold
    with. It takes a seed and an Info value representing a
    directory entry, and returns both a new seed and an instruction for our
    fold function, where the instructions are represented as the constructors
    of the Iterate type:</p><ul class="calibre18"><li class="calibre19"><p class="docText">If the instruction is <tt class="calibre34">Done</tt>, traversal
        should cease immediately. The value wrapped by <tt class="calibre34">Done</tt>
        should be returned as the result.</p></li><li class="calibre19"><p class="docText">If the instruction is <tt class="calibre34">Skip</tt> and the
        current Info type represents a directory, traversal will
        not recurse into that directory.</p></li><li class="calibre19"><p class="docText">Otherwise, the traversal should continue, using the
        wrapped value as the input to the next call to the fold
        function.</p></li></ul><a name="x_ZQ" class="calibre27" id="x_ZQ"></a><p class="docText">Our fold is logically a kind of left fold, because we
    start folding from the first entry we encounter. The seed for each step is
    the result of the prior step:</p><pre class="calibre39">-- file: ch09/FoldDir.hs
foldTree :: Iterator a -&gt; a -&gt; FilePath -&gt; IO a

foldTree iter initSeed path = do
    endSeed &lt;- fold initSeed path
    return (unwrap endSeed)
  where
    fold seed subpath = getUsefulContents subpath &gt;&gt;= walk seed

    walk seed (name:names) = do
      let path' = path &lt;/&gt; name
      info &lt;- getInfo path'
      case iter seed info of
        done@(Done _) -&gt; return done
        Skip seed'    -&gt; walk seed' names
        Continue seed'
          | isDirectory info -&gt; do
              next &lt;- fold seed' path'
              case next of
                done@(Done _) -&gt; return done
                seed''        -&gt; walk (unwrap seed'') names
          | otherwise -&gt; walk seed' names
    walk seed _ = return (Continue seed)</pre><br class="calibre48"/>
<a name="x_aQ" class="calibre27" id="x_aQ"></a><p class="docText">There are a few interesting things about the way this code
    is written. The first is the use of scoping to avoid having to pass extra
    parameters around. The top-level <i class="docEmphasis">foldTree</i> function is just a wrapper for
    <i class="docEmphasis">fold</i> that peels off the constructor
    of the <i class="docEmphasis">fold</i>'s final result.</p><a name="x_bQ" class="calibre27" id="x_bQ"></a><p class="docText">Because <i class="docEmphasis">fold</i> is a
    local function, we don't have to pass <i class="docEmphasis">foldTree</i>'s <span class="docMonofont">iter</span> variable
    into it; it can already access it in the outer scope. Similarly, <i class="docEmphasis">walk</i> can see <span class="docMonofont">path</span> in its
    outer scope.</p><a name="x_cQ" class="calibre27" id="x_cQ"></a><p class="docText">Another point to note is that <i class="docEmphasis">walk</i> is a tail recursive loop, instead of an
    anonymous function called by <i class="docEmphasis">forM</i> as
    in our earlier functions. By taking the reins ourselves, we can stop early
    if we need to, which lets us drop out when our iterator returns
    <tt class="calibre34">Done</tt>.</p><a name="x_dQ" class="calibre27" id="x_dQ"></a><p class="docText">Although <i class="docEmphasis">fold</i> calls
    <i class="docEmphasis">walk</i>, <i class="docEmphasis">walk</i> calls <i class="docEmphasis">fold</i> recursively to traverse subdirectories.
    Each function returns a seed wrapped in an Iterate: when
    <i class="docEmphasis">fold</i> is called by <i class="docEmphasis">walk</i> and returns, <i class="docEmphasis">walk</i> examines its result to see whether it
    should continue or drop out because it returned <tt class="calibre34">Done</tt>. In this
    way, a return of <i class="docEmphasis">Done</i> from the
    caller-supplied iterator immediately terminates all mutually recursive
    calls between the two functions.</p><a name="x_eQ" class="calibre27" id="x_eQ"></a><p class="docText">What does an iterator look like in practice? Here's a
    somewhat complicated example that looks for at most three bitmap images
    and won't recurse into Subversion metadata directories:</p><pre class="calibre39">-- file: ch09/FoldDir.hs
atMostThreePictures :: Iterator [FilePath]

atMostThreePictures paths info
    | length paths == 3
      = Done paths
    | isDirectory info &amp;&amp; takeFileName path == ".svn"
      = Skip paths
    | extension `elem` [".jpg", ".png"]
      = Continue (path : paths)
    | otherwise
      = Continue paths
  where extension = map toLower (takeExtension path)
        path = infoPath info</pre><br class="calibre48"/>
<a name="x_fQ" class="calibre27" id="x_fQ"></a><p class="docText">To use this, we'd call <tt class="calibre34">foldTree atMostThreePictures
    []</tt>, giving us a return value of type IO
    [FilePath].</p><a name="x_gQ" class="calibre27" id="x_gQ"></a><p class="docText">Of course, iterators don't have to be this complicated.
    Here's one that counts the number of directories it encounters:</p><pre class="calibre39">-- file: ch09/FoldDir.hs
countDirectories count info =
    Continue (if isDirectory info
              then count + 1
              else count)</pre><br class="calibre48"/>
<a name="x_hQ" class="calibre27" id="x_hQ"></a><p class="docText">Here, the initial seed that we pass to <i class="docEmphasis">foldTree</i> should be the number zero.</p><a name="I_sidebar9_d1e24763" class="calibre27" id="I_sidebar9_d1e24763"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

