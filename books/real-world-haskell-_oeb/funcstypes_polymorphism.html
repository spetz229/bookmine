---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect12_d1e4585.html
next: I_sect12_d1e5384_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect12_d1e4585.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect12_d1e5384_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="funcstypes_polymorphism" class="calibre27" id="funcstypes_polymorphism"></a><h3 id="title-IDAWI0NB" class="docSection1Title">2.11. Polymorphism in Haskell</h3><a name="x_he" class="calibre27" id="x_he"></a><p class="docText">When<a name="I_indexterm2_d1e5156" class="calibre27" id="I_indexterm2_d1e5156"></a><a name="ch02-polymorphism" class="calibre27" id="ch02-polymorphism"></a> we introduced lists, we mentioned that the list type is
    polymorphic. We'll talk about Haskell's polymorphism in more detail
    here.</p><a name="x_ie" class="calibre27" id="x_ie"></a><p class="docText">If we want to fetch the last element of a list, we
    use<a name="I_indexterm2_d1e5163" class="calibre27" id="I_indexterm2_d1e5163"></a> the <i class="docEmphasis">last</i> function. The
    value that it returns must have the same type as the elements of the list,
    but <i class="docEmphasis">last</i> operates in the same way no
    matter what type those elements actually are:</p><pre class="calibre39">ghci&gt; <b class="calibre40">last [1,2,3,4,5]</b>
5
ghci&gt; <b class="calibre40">last "baz"</b>
'z'</pre><a name="x_je" class="calibre27" id="x_je"></a><p class="docText">To capture this idea, its type signature <a name="I_indexterm2_d1e5186" class="calibre27" id="I_indexterm2_d1e5186"></a>contains a <span class="docEmphasis">type variable</span>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type last</b>
last :: [a] -&gt; a
</pre><a name="x_ke" class="calibre27" id="x_ke"></a><p class="docText">Here, <span class="docMonofont">a</span> is the type
    variable. We can read the signature as "takes a list, all of whose
    elements have some type a, and returns a value of the same type
    <tt class="calibre34">a</tt>."</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Identifying a type variable</p><a name="x_le" class="calibre27" id="x_le"></a><p class="docText">Type variables always start with a lowercase letter. You
      can always tell a type variable from a normal variable by context,
      because the languages of types and functions are separate: type
      variables live in type signatures, and regular variables live in normal
      expressions.</p><a name="x_me" class="calibre27" id="x_me"></a><p class="docText">It's common Haskell practice to keep the names of type
      variables very short. One letter is overwhelmingly common; longer names
      show up infrequently. Type signatures are usually brief; we gain more in
      read<span class="docEmphasis">ability</span> by keeping names short
      than we would by making them <span class="docEmphasis">descriptive</span>.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_c3" class="calibre27" id="x_c3"></a><p class="docText">When a function has type variables in its signature,
    indicating that some of its arguments can be of any type, we call the
    function polymorphic.</p><a name="x_ne" class="calibre27" id="x_ne"></a><p class="docText">When we want to apply <i class="docEmphasis">last</i> to, say, a list of Char, the
    compiler substitutes Char for each <span class="docMonofont">a</span> throughout the type signature. This gives us the
    type of <i class="docEmphasis">last</i> with an input of
    [Char] as [Char] -&gt; Char.</p><a name="x_oe" class="calibre27" id="x_oe"></a><p class="docText">This kind of polymorphism is called
    <span class="docEmphasis">parametric</span> polymorphism.<a name="I_indexterm2_d1e5253" class="calibre27" id="I_indexterm2_d1e5253"></a> The choice of naming is easy to understand by analogy: just
    as a function can have parameters that we can later bind to real values, a
    Haskell type can have parameters that we can later bind to other
    types.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">A little nomenclature</p><a name="x_pe" class="calibre27" id="x_pe"></a><p class="docText">If a type contains type parameters, we say that it is a
      <span class="docEmphasis">parameterized</span> type,<a name="I_indexterm2_d1e5266" class="calibre27" id="I_indexterm2_d1e5266"></a><a name="I_indexterm2_d1e5269" class="calibre27" id="I_indexterm2_d1e5269"></a> or a <span class="docEmphasis">polymorphic</span> type. If a function
      or value's type contains type <span class="docEmphasis">parameters</span>, we call it polymorphic.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_qe" class="calibre27" id="x_qe"></a><p class="docText">When we see a parameterized type, we've already noted that
    the code doesn't care what the actual type is. However, we can make a
    stronger statement: <span class="docEmphasis">it has no way to find out what the real type
    is</span>, or to manipulate a value of that type. It can't create a
    value; neither can it inspect one. All it can do is treat it as a fully
    abstract "black box." We'll cover one reason that this is
    important soon.</p><a name="x_re" class="calibre27" id="x_re"></a><p class="docText">Parametric polymorphism is the most visible kind of
    polymorphism that Haskell supports. Haskell's parametric polymorphism
    directly influenced the design of the generic facilities of the Java and
    C# languages. A parameterized type in Haskell is similar to a type
    variable in Java generics. C++ templates also bear a resemblance to
    parametric polymorphism.</p><a name="x_rm" class="calibre27" id="x_rm"></a><p class="docText">To make it clearer how Haskell's polymorphism differs from
    other languages, here are a few forms of polymorphism that are common in
    other languages, but not present in Haskell.</p><a name="x_se" class="calibre27" id="x_se"></a><p class="docText">In mainstream object-oriented languages,
    <span class="docEmphasis">subtype</span> polymorphism<a name="I_indexterm2_d1e5296" class="calibre27" id="I_indexterm2_d1e5296"></a> is more widespread than parametric polymorphism. The
    subclassing mechanisms of C++ and Java give them subtype polymorphism. A
    base class defines a set of behaviors that its subclasses can modify and
    extend. Since Haskell isn't an object-oriented language, it doesn't
    provide subtype polymorphism.</p><a name="x_te" class="calibre27" id="x_te"></a><p class="docText">Also common is <span class="docEmphasis">coercion</span>
    polymorphism,<a name="I_indexterm2_d1e5305" class="calibre27" id="I_indexterm2_d1e5305"></a> which allows a value of one type to be implicitly converted
    into a value of another type. Many languages provide some form of coercion
    polymorphism; one example is automatic conversion between integers and
    floating-point numbers. Haskell deliberately avoids even this kind of
    simple automatic coercion.</p><a name="x_ue" class="calibre27" id="x_ue"></a><p class="docText">This is not the whole story of polymorphism in Haskell.
    We'll return to the subject in <a class="docLink" href="typeclasses_split_000.html#typeclasses">Chapter 6</a>.</p><a name="funcstypes_polymorphismd1e5381" class="calibre27" id="funcstypes_polymorphismd1e5381"></a><h4 id="title-IDAZO0NB" class="docSection1Title">2.11.1. Reasoning About Polymorphic Functions</h4><a name="x_ve" class="calibre27" id="x_ve"></a><p class="docText">In <a class="docLink" href="funcstypes_sigs.html#funcstypes_sigs">Section 2.8</a> we talked about
      figuring out the behavior of a function based on its type signature. We
      can apply the same kind of reasoning to polymorphic functions. Let's
      look again at <i class="docEmphasis">fst</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type fst</b>
fst :: (a, b) -&gt; a
</pre><a name="x_we" class="calibre27" id="x_we"></a><p class="docText">First of all, notice that its argument contains two type
      variables, <span class="docMonofont">a</span> and <span class="docMonofont">b</span>, signifying that the elements of the tuple can
      be of different types.</p><a name="x_xe" class="calibre27" id="x_xe"></a><p class="docText">The result type of <i class="docEmphasis">fst</i> is<a name="I_indexterm2_d1e5344" class="calibre27" id="I_indexterm2_d1e5344"></a> <span class="docMonofont">a</span>. We've already mentioned
      that parametric polymorphism makes the real type inaccessible. <i class="docEmphasis">fst</i> doesn't have enough information to
      construct a value of type <span class="docMonofont">a</span>, nor can it
      turn an <span class="docMonofont">a</span> into a <span class="docMonofont">b</span>. So the <span class="docEmphasis">only</span> possible valid
      behavior (omitting infinite loops or crashes) it can have is to return
      the first element of the pair.</p><a name="funcstypes_polymorphismd1e5433" class="calibre27" id="funcstypes_polymorphismd1e5433"></a><h4 id="title-IDACR0NB" class="docSection1Title">2.11.2. Further Reading</h4><p class="docText">There is a deep mathematical sense in which any nonpathological
      function of type (a,b) -&gt; a must do exactly what
      <i class="docEmphasis">fst</i> does. Moreover, this line of
      reasoning extends to more complicated polymorphic functions. The paper
      "Theorems for free" by<a name="I_indexterm2_d1e5378" class="calibre27" id="I_indexterm2_d1e5378"></a> Philip Wadler ()
      covers this procedure in depth.</p>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect12_d1e4585.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect12_d1e5384_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

