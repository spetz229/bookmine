---
layout: page
title: "Real World Haskell, 1st Edition"
prev: glob_lazyfn.html
next: glob_use_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="glob_lazyfn.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="glob_errapi_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="glob_use" class="calibre27" id="glob_use"></a><h3 id="title-IDAR4Y5G" class="docSection1Title">8.7. Making Use of Our Pattern Matcher</h3><a name="x_cG" class="calibre27" id="x_cG"></a><p class="docText">It's all very well to have a function that can match glob
    patterns, but we'd like to be able to put this to practical use. On
    Unix-like systems, the <i class="docEmphasis">glob</i> function
    returns the names of all files and directories that match a given glob
    pattern. Let's build a similar function in Haskell. Following the Haskell
    norm of descriptive naming, we'll call our function <i class="docEmphasis">namesMatching</i>:</p><pre class="calibre39">-- file: ch08/Glob.hs
module Glob (namesMatching) where</pre><br class="calibre48"/>
<a name="x_sE1" class="calibre27" id="x_sE1"></a><p class="docText">We specify that <i class="docEmphasis">namesMatching</i> is the only name that users of
    our <tt class="calibre34">Glob</tt> module will be able to see.</p><a name="x_dG" class="calibre27" id="x_dG"></a><p class="docText">This function will obviously have to manipulate filesystem
    paths a lot, splicing and joining them as it goes. We'll need to use a few
    previously unfamiliar modules along the way.</p><a name="x_eG" class="calibre27" id="x_eG"></a><p class="docText">The <i class="docEmphasis">System.Directory</i>
    module provides standard functions for working with directories and their
    contents:</p><pre class="calibre39">-- file: ch08/Glob.hs
import System.Directory (doesDirectoryExist, doesFileExist,
                         getCurrentDirectory, getDirectoryContents)</pre><br class="calibre48"/>
<a name="x_fG" class="calibre27" id="x_fG"></a><p class="docText">The <i class="docEmphasis">System.FilePath</i>
    module abstracts the details of an operating system's path name
    conventions. The <i class="docEmphasis">(&lt;/&gt;)</i> function
    joins two path components:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +System.FilePath</b>ghci&gt; <b class="calibre40">"foo" &lt;/&gt; "bar"</b>
Loading package filepath-1.1.0.0 ... linking ... done.
"foo/bar"</pre><a name="x_tE1" class="calibre27" id="x_tE1"></a><p class="docText">The name of the <i class="docEmphasis">dropTrailingPathSeparator</i> function is perfectly
    descriptive:</p><pre class="calibre39">ghci&gt; <b class="calibre40">dropTrailingPathSeparator "foo/"</b>
"foo"
</pre><a name="x_uE1" class="calibre27" id="x_uE1"></a><p class="docText">The <i class="docEmphasis">splitFileName</i>
    function splits a path at the last slash:</p><pre class="calibre39">ghci&gt; <b class="calibre40">splitFileName "foo/bar/Quux.hs"</b>
("foo/bar/","Quux.hs")
ghci&gt; <b class="calibre40">splitFileName "zippity"</b>
("","zippity")</pre><a name="x_vE1" class="calibre27" id="x_vE1"></a><p class="docText">Using <tt class="calibre34">System.FilePath</tt> together with the
    <i class="docEmphasis">System.Directory</i> module, we can write
    a portable <i class="docEmphasis">namesMatching</i> function
    that will run on both Unix-like and Windows systems:</p><pre class="calibre39">-- file: ch08/Glob.hs
import System.FilePath (dropTrailingPathSeparator, splitFileName, (&lt;/&gt;))</pre><br class="calibre48"/>
<a name="x_gG" class="calibre27" id="x_gG"></a><p class="docText">In this module, we'll be emulating a "for"
    loop; getting our first taste of exception handling in Haskell; and of
    course using the <i class="docEmphasis">matchesGlob</i> function
    we just wrote:</p><pre class="calibre39">-- file: ch08/Glob.hs
import Control.Exception (handle)
import Control.Monad (forM)
import GlobRegex (matchesGlob)</pre><br class="calibre48"/>
<a name="x_hG" class="calibre27" id="x_hG"></a><p class="docText">Since directories and files live in the "real
    world" of activities that have effects, our globbing function will
    have to have <i class="docEmphasis">IO</i> in its result type.</p><a name="x_iG" class="calibre27" id="x_iG"></a><p class="docText">If the string we're passed contains no pattern characters,
    we simply check that the given name exists in the filesystem. (Notice that
    we use Haskell's function guard syntax here to write a nice tidy
    definition. An "if" would do but isn't as aesthetically
    pleasing.)</p><pre class="calibre39">-- file: ch08/Glob.hs
isPattern :: String -&gt; Bool
isPattern = any (`elem` "[*?")

namesMatching pat
  | not (isPattern pat) = do
    exists &lt;- doesNameExist pat
    return (if exists then [pat] else [])</pre><br class="calibre48"/>
<a name="x_jG" class="calibre27" id="x_jG"></a><p class="docText">The name <i class="docEmphasis">doesNameExist</i> refers to a function that we will
    define shortly.</p><a name="x_kG" class="calibre27" id="x_kG"></a><p class="docText">What if the string <span class="docEmphasis">is</span> a glob pattern?
    Our function definition continues:</p><pre class="calibre39">-- file: ch08/Glob.hs
  | otherwise = do
    case splitFileName pat of
      ("", baseName) -&gt; do
          curDir &lt;- getCurrentDirectory
          listMatches curDir baseName
      (dirName, baseName) -&gt; do
          dirs &lt;- if isPattern dirName
                  then namesMatching (dropTrailingPathSeparator dirName)
                  else return [dirName]
          let listDir = if isPattern baseName
                        then listMatches
                        else listPlain
          pathNames &lt;- forM dirs $ \dir -&gt; do
                           baseNames &lt;- listDir dir baseName
                           return (map (dir &lt;/&gt;) baseNames)
          return (concat pathNames)</pre><br class="calibre48"/>
<a name="x_lG" class="calibre27" id="x_lG"></a><p class="docText">We use <i class="docEmphasis">splitFileName</i>
    to split the string into a pair of "everything but the final
    name" and "the final name." If the first element is empty, we're
    looking for a pattern in the current directory. Otherwise, we must check
    the directory name and see if it contains patterns. If it does not, we
    create a singleton list of the directory name. If it contains a pattern,
    we list all of the matching directories.</p><a name="glob_used1e23091" class="calibre27" id="glob_used1e23091"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_nG" class="calibre27" id="x_nG"></a></p><p class="docText">The <i class="docEmphasis">System.FilePath</i>
      module<a name="I_indexterm8_d1e22738" class="calibre27" id="I_indexterm8_d1e22738"></a> can be a little tricky. The example just shown is a case
      in point; the <i class="docEmphasis">splitFileName</i>
      function leaves a trailing slash on the end of the directory name that
      it returns:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:module +System.FilePath</b>ghci&gt; <b class="calibre40">splitFileName "foo/bar"</b>
Loading package filepath-1.1.0.0 ... linking ... done.
("foo/","bar")</pre><a name="x_oG" class="calibre27" id="x_oG"></a><p class="docText">If we didn't remember (or know enough) to remove that
      slash, we'd recurse endlessly in <i class="docEmphasis">namesMatching</i>, because of the following
      behavior of <i class="docEmphasis">splitFileName</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">splitFileName "foo/"</b>
("foo/","")
</pre><a name="x_pG" class="calibre27" id="x_pG"></a><p class="docText">(You can guess what happened to us that led us to add
      this note!)</p></div><a name="x_qG" class="calibre27" id="x_qG"></a><p class="docText">Finally, we collect all matches in every directory, giving
    us a list of lists, and concatenate them into a single list of
    names.</p><a name="x_rG" class="calibre27" id="x_rG"></a><p class="docText">The unfamiliar <i class="docEmphasis">forM</i>
    function above acts a little like a "for" loop: it maps its
    second argument (an action) over its first (a list), and returns the list
    of results.</p><a name="x_sG" class="calibre27" id="x_sG"></a><p class="docText">We have a few loose ends to clean up. The first is the
    definition of the <i class="docEmphasis">doesNameExist</i>
    function, used above. The <i class="docEmphasis">System.Directory</i> module <a name="I_indexterm8_d1e22790" class="calibre27" id="I_indexterm8_d1e22790"></a>doesn't let us check to see if a name exists in the
    filesystem. It forces us to decide whether we want to check for a file or
    a directory. This API is ungainly, so we roll the two checks into a single
    function. In the name of performance, we make the check for a file first,
    since files are far more common than directories:</p><pre class="calibre39">-- file: ch08/Glob.hs
doesNameExist :: FilePath -&gt; IO Bool

doesNameExist name = do
    fileExists &lt;- doesFileExist name
    if fileExists
      then return True
      else doesDirectoryExist name</pre><br class="calibre48"/>
<a name="x_tG" class="calibre27" id="x_tG"></a><p class="docText">We have two other functions to define, each of which
    returns a list of names in a directory. The <i class="docEmphasis">listMatches</i> function returns a list of all
    files matching the given glob pattern in a directory:</p><pre class="calibre39">-- file: ch08/Glob.hs
listMatches :: FilePath -&gt; String -&gt; IO [String]
listMatches dirName pat = do
    dirName' &lt;- if null dirName
                then getCurrentDirectory
                else return dirName
    handle (const (return [])) $ do
        names &lt;- getDirectoryContents dirName'
        let names' = if isHidden pat
                     then filter isHidden names
                     else filter (not . isHidden) names
        return (filter (`matchesGlob` pat) names')

isHidden ('.':_) = True
isHidden _       = False</pre><br class="calibre48"/>
<a name="x_wE1" class="calibre27" id="x_wE1"></a><p class="docText">The <i class="docEmphasis">listPlain</i>
    function returns either an empty or singleton list, depending on whether
    the single name it's passed exists:</p><pre class="calibre39">-- file: ch08/Glob.hs
listPlain :: FilePath -&gt; String -&gt; IO [String]
listPlain dirName baseName = do
    exists &lt;- if null baseName
              then doesDirectoryExist dirName
              else doesNameExist (dirName &lt;/&gt; baseName)
    return (if exists then [baseName] else [])</pre><br class="calibre48"/>
<a name="x_uG" class="calibre27" id="x_uG"></a><p class="docText">If we look closely at the definition of <i class="docEmphasis">listMatches</i>, we'll see a call to a function
    named <i class="docEmphasis">handle</i>. Earlier on, we imported
    this from the <i class="docEmphasis">Control.Exception</i>
    module; as that import implies, this gives us our first taste of exception
    handling in Haskell. Let's drop into <i class="docEmphasis">ghci</i> and see what we can find out:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:module +Control.Exception</b>ghci&gt; <b class="calibre40">:type handle</b>
handle :: (Exception -&gt; IO a) -&gt; IO a -&gt; IO a</pre><a name="x_vG" class="calibre27" id="x_vG"></a><p class="docText">This is telling us that <i class="docEmphasis">handle</i> takes two arguments. The first is a
    function that is passed an exception value, and can have side effects (see
    the IO type in its return value); this is the handler to run
    if an exception is thrown. The second argument is the code that might
    throw an exception.</p><a name="x_wG" class="calibre27" id="x_wG"></a><p class="docText">As for the exception handler, the type of the <i class="docEmphasis">handle</i> constrains it to return the same type of
    value as the body of code that threw the exception. So its choices are to
    either throw an exception or, as in our case, return a list of
    Strings.</p><a name="x_xG" class="calibre27" id="x_xG"></a><p class="docText">The <i class="docEmphasis">const</i> function
    takes two arguments—it always returns its first argument, no matter what
    its second argument is:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type const</b>
const :: a -&gt; b -&gt; a
ghci&gt; <b class="calibre40">:type return []</b>
return [] :: (Monad m) =&gt; m [a]
ghci&gt; <b class="calibre40">:type handle (const (return []))</b>
handle (const (return [])) :: IO [a] -&gt; IO [a]</pre><a name="x_xE1" class="calibre27" id="x_xE1"></a><p class="docText">We use <i class="docEmphasis">const</i> to
    write an exception handler that ignores the exception it is passed.
    Instead, it causes our code to return an empty list if we catch an
    exception.</p><a name="x_yG" class="calibre27" id="x_yG"></a><p class="docText">We won't have anything more to say about exception
    handling here. There's plenty more to cover, though, so we'll be returning
    to the subject of exceptions in <a class="docLink" href="errors_split_000.html#errors">Chapter 19</a>.</p><a name="ch07_q_error" class="calibre27" id="ch07_q_error"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

