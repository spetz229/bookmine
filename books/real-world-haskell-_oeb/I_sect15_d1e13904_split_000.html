---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect15_d1e13839.html
next: I_sect15_d1e13904_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect15_d1e13839.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="library_package.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect15_d1e13904" class="calibre27" id="I_sect15_d1e13904"></a><h3 id="title-IDAPS4ZE" class="docSection1Title">5.13. Fleshing Out the Pretty-Printing Library</h3><a name="x_Ho" class="calibre27" id="x_Ho"></a><p class="docText">In our <tt class="calibre34">Prettify</tt> module, we represent our
    Doc type as an algebraic data type:</p><pre class="calibre39">-- file: ch05/Prettify.hs
data Doc = Empty
         | Char Char
         | Text String
         | Line
         | Concat Doc Doc
         | Union Doc Doc
           deriving (Show,Eq)</pre><br class="calibre48"/>
<a name="x_Io" class="calibre27" id="x_Io"></a><p class="docText">Observe that the Doc type is actually a tree.
    The <tt class="calibre34">Concat</tt> and <tt class="calibre34">Union</tt> constructors create an
    internal node from two other Doc values, while the
    <tt class="calibre34">Empty</tt> and other simple constructors build leaves.</p><a name="x_Jo" class="calibre27" id="x_Jo"></a><p class="docText">In the header of our module, we will export the name of
    the type, but none of its constructors. This will prevent modules that use
    the Doc type from creating and pattern matching against
    Doc values.</p><a name="x_Ko" class="calibre27" id="x_Ko"></a><p class="docText">Instead, to create a Doc, a user of the
    <tt class="calibre34">Prettify</tt> module will call a function that we provide. Here
    are the simple construction functions. As we add real definitions, we must
    replace any stubbed versions already in the <i class="docEmphasis">Prettify.hs</i> source file:</p><pre class="calibre39">-- file: ch05/Prettify.hs
empty :: Doc
empty = Empty

char :: Char -&gt; Doc
char c = Char c

text :: String -&gt; Doc
text "" = Empty
text s  = Text s

double :: Double -&gt; Doc
double d = text (show d)</pre><br class="calibre48"/>
<a name="x_Lo" class="calibre27" id="x_Lo"></a><p class="docText">The <tt class="calibre34">Line</tt> constructor<a name="I_indexterm5_d1e13960" class="calibre27" id="I_indexterm5_d1e13960"></a> represents a line break. The <i class="docEmphasis">line</i> function<a name="I_indexterm5_d1e13967" class="calibre27" id="I_indexterm5_d1e13967"></a> creates <span class="docEmphasis">hard</span> line breaks, which always
    appear in the pretty printer's output. Sometimes we'll want a
    <span class="docEmphasis">soft</span> line break, which is only used if a line is too
    wide to fit in a window or page (we'll introduce a <i class="docEmphasis">softline</i> function shortly):</p><pre class="calibre39">-- file: ch05/Prettify.hs
line :: Doc
line = Line</pre><br class="calibre48"/>
<a name="x_Mo" class="calibre27" id="x_Mo"></a><p class="docText">Almost as simple as the basic constructors is the
    <i class="docEmphasis">(&lt;&gt;)</i> function,<a name="I_indexterm5_d1e13988" class="calibre27" id="I_indexterm5_d1e13988"></a> which concatenates two Doc values:</p><pre class="calibre39">-- file: ch05/Prettify.hs
(&lt;&gt;) :: Doc -&gt; Doc -&gt; Doc
Empty &lt;&gt; y = y
x &lt;&gt; Empty = x
x &lt;&gt; y = x `Concat` y</pre><br class="calibre48"/>
<a name="x_No" class="calibre27" id="x_No"></a><p class="docText">We pattern-match against <tt class="calibre34">Empty</tt> so that
    concatenating a Doc value with <tt class="calibre34">Empty</tt> on the left
    or right will have no effect, which keeps us from bloating the tree with
    useless values:</p><pre class="calibre39">ghci&gt; <b class="calibre40">text "foo" &lt;&gt; text "bar"</b>
Concat (Text "foo") (Text "bar")
ghci&gt; <b class="calibre40">text "foo" &lt;&gt; empty</b>
Text "foo"
ghci&gt; <b class="calibre40">empty &lt;&gt; text "bar"</b>
Text "bar"</pre><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">A mathematical moment</p><a name="x_Oo" class="calibre27" id="x_Oo"></a><p class="docText">If we briefly put on our mathematical hats, we can say
      that <tt class="calibre34">Empty</tt> is the identity under concatenation, since
      nothing happens if we concatenate a Doc value with
      <tt class="calibre34">Empty</tt>. In a similar vein, 0 is the identity for adding
      numbers, and 1 is the identity for multiplying them. Taking the
      mathematical perspective has useful practical consequences, as we will
      see in a number of places throughout this book.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_Po" class="calibre27" id="x_Po"></a><p class="docText">Our <i class="docEmphasis">hcat</i> and
    <i class="docEmphasis">fsep</i> functions concatenate a list of
    Doc values into one. In <a class="docLink" href="#fp_fold_exercises">Exercises</a>
    and in <a class="docLink" href="fp_loop_split_000.html#fp_loop">Section 4.6</a>, we mentioned that we could define
    concatenation for lists using <i class="docEmphasis">foldr</i>:</p><pre class="calibre39">-- file: ch05/Concat.hs
concat :: [[a]] -&gt; [a]
concat = foldr (++) []</pre><br class="calibre48"/>
<a name="x_Qo" class="calibre27" id="x_Qo"></a><p class="docText">Since <i class="docEmphasis">(&lt;&gt;)</i> is
    analogous to <i class="docEmphasis">(++)</i>, and <i class="docEmphasis">empty</i> to <i class="docEmphasis">[]</i>, we can see how we might write <i class="docEmphasis">hcat</i> and <i class="docEmphasis">fsep</i> as folds, too:</p><pre class="calibre39">-- file: ch05/Prettify.hs
hcat :: [Doc] -&gt; Doc
hcat = fold (&lt;&gt;)

fold :: (Doc -&gt; Doc -&gt; Doc) -&gt; [Doc] -&gt; Doc
fold f = foldr f empty</pre><br class="calibre48"/>
<a name="x_Ro" class="calibre27" id="x_Ro"></a><p class="docText">The definition of <i class="docEmphasis">fsep</i> depends on several other functions:</p><pre class="calibre39">-- file: ch05/Prettify.hs
fsep :: [Doc] -&gt; Doc
fsep = fold (&lt;/&gt;)

(&lt;/&gt;) :: Doc -&gt; Doc -&gt; Doc
x &lt;/&gt; y = x &lt;&gt; softline &lt;&gt; y

softline :: Doc
softline = group line</pre><br class="calibre48"/>
<a name="x_So" class="calibre27" id="x_So"></a><p class="docText">These take a little explaining. The <i class="docEmphasis">softline</i> function should insert a newline if
    the current line has become too wide, or a space otherwise. How can we do
    this if our Doc type doesn't contain any information about
    rendering? Our answer is that every time we encounter a soft newline, we
    maintain <span class="docEmphasis">two</span> alternative representations of the
    document, using the <tt class="calibre34">Union</tt> constructor:</p><pre class="calibre39">-- file: ch05/Prettify.hs
group :: Doc -&gt; Doc
group x = flatten x `Union` x</pre><br class="calibre48"/>
<a name="x_To" class="calibre27" id="x_To"></a><p class="docText">Our <i class="docEmphasis">flatten</i> function
    replaces a <tt class="calibre34">Line</tt> with a space, turning two lines into one
    longer line:</p><pre class="calibre39">-- file: ch05/Prettify.hs
flatten :: Doc -&gt; Doc
flatten (x `Concat` y) = flatten x `Concat` flatten y
flatten Line           = Char ' '
flatten (x `Union` _)  = flatten x
flatten other          = other</pre><br class="calibre48"/>
<a name="x_Uo" class="calibre27" id="x_Uo"></a><p class="docText">Notice that we always call <i class="docEmphasis">flatten</i> on the left element of a
    <tt class="calibre34">Union</tt>: the left of each <tt class="calibre34">Union</tt> is always the same
    width (in characters) as, or wider than, the right. We'll make use of this
    property in our rendering functions that follow.</p><a name="I_sect15_d1e13904d1e14192" class="calibre27" id="I_sect15_d1e13904d1e14192"></a><h4 id="title-IDAN04ZE" class="docSection1Title">5.13.1. Compact Rendering</h4><a name="x_Wo" class="calibre27" id="x_Wo"></a><p class="docText">We frequently need to use a representation for a piece
      of data that contains as few characters as possible. For example, if
      we're sending JSON data over a network connection, there's no sense in
      laying it out nicely. The software on the far end won't care whether the
      data is pretty or not, and the added whitespace needed to make the
      layout look good would add a lot of overhead.</p><a name="x_Xo" class="calibre27" id="x_Xo"></a><p class="docText">For these cases, and because it's a simple piece of code
      to start with, we provide a bare-bones compact rendering
      function:</p><pre class="calibre39">-- file: ch05/Prettify.hs
compact :: Doc -&gt; String
compact x = transform [x]
    where transform [] = ""
          transform (d:ds) =
              case d of
                Empty        -&gt; transform ds
                Char c       -&gt; c : transform ds
                Text s       -&gt; s ++ transform ds
                Line         -&gt; '\n' : transform ds
                a `Concat` b -&gt; transform (a:b:ds)
                _ `Union` b  -&gt; transform (b:ds)</pre><br class="calibre48"/>
<a name="x_Yo" class="calibre27" id="x_Yo"></a><p class="docText">The <i class="docEmphasis">compact</i>
      function<a name="I_indexterm5_d1e14142" class="calibre27" id="I_indexterm5_d1e14142"></a> wraps its argument in a list and applies the <i class="docEmphasis">transform</i> helper function to it. The
      <i class="docEmphasis">transform</i> function treats its
      argument as a stack of items to process, where the first element of the
      list is the top of the stack.</p><a name="x_Zo" class="calibre27" id="x_Zo"></a><p class="docText">The <i class="docEmphasis">transform</i>
      function's <tt class="calibre34">(d:ds)</tt> pattern breaks the stack into its head,
      <span class="docMonofont">d</span>, and the remainder, <span class="docMonofont">ds</span>. In our
      <tt class="calibre34">case</tt> expression, the first several
      branches recurse on <span class="docMonofont">ds</span>, consuming one item from the
      stack for each recursive application. The last two branches add items in
      front of <span class="docMonofont">ds</span>; the <tt class="calibre34">Concat</tt> branch adds both
      elements to the stack, while the <tt class="calibre34">Union</tt> branch ignores its
      left element, on which we called <i class="docEmphasis">flatten</i>, and adds its right element to the
      stack.</p><a name="x_ao" class="calibre27" id="x_ao"></a><p class="docText">We have now fleshed out enough of our original skeletal
      definitions that we can try out our <i class="docEmphasis">compact</i> function in <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let value = renderJValue (JObject [("f", JNumber 1), ("q", JBool True)])</b>ghci&gt; <b class="calibre40">:type value</b>
value :: Doc
ghci&gt; <b class="calibre40">putStrLn (compact value)</b>
{"f": 1.0,
"q": true
}</pre><a name="x_bo" class="calibre27" id="x_bo"></a><p class="docText">To better understand how the code works, let's look at a
      simpler example in more detail:</p><pre class="calibre39">ghci&gt; <b class="calibre40">char 'f' &lt;&gt; text "oo"</b>
Concat (Char 'f') (Text "oo")
ghci&gt; <b class="calibre40">compact (char 'f' &lt;&gt; text "oo")</b>
"foo"</pre><a name="x_co" class="calibre27" id="x_co"></a><p class="docText">When we apply <i class="docEmphasis">compact</i>, it turns its argument into a list
      and applies <i class="docEmphasis">transform </i>(the degree
      of indentation below reflects the depth of recursion):</p><ul class="calibre18"><li class="calibre19"><p class="docText">The <i class="docEmphasis">transform</i>
          function receives a one-item list, which matches the
          <tt class="calibre34">(d:ds)</tt> pattern. Thus <span class="docMonofont">d</span> is the value
          <tt class="calibre34">Concat (Char 'f') (Text "oo")</tt>, and
          <span class="docMonofont">ds</span> is the empty list, <tt class="calibre34">[]</tt>.</p><p class="docText">Since <span class="docMonofont">d</span>'s constructor is
          <tt class="calibre34">Concat</tt>, the <tt class="calibre34">Concat</tt> pattern matches in the
          <tt class="calibre34">case</tt> expression. On the righthand
          side, we add <tt class="calibre34">Char 'f'</tt> and <tt class="calibre34">Text "oo"</tt> to the
          stack and then apply <i class="docEmphasis">transform</i>,
          recursively.</p></li><li class="calibre19"><p class="docText">The <i class="docEmphasis">transform</i> function
          receives a two-item list, again matching the <tt class="calibre34">(d:ds)</tt>
          pattern. The variable <span class="docMonofont">d</span> is bound to <tt class="calibre34">Char
          'f'</tt>, and <span class="docMonofont">ds</span> to <tt class="calibre34">[Text
          "oo"]</tt>.</p><ul class="calibre51"><li class="calibre19"><p class="docText">The <tt class="calibre34">case</tt> expression
              matches in the <tt class="calibre34">Char</tt> branch. On the righthand side,
              we use <i class="docEmphasis">(:)</i> to construct a
              list whose head is <tt class="calibre34">'f'</tt>, and whose body is the
              result of a recursive application of <i class="docEmphasis">transform</i>.</p><ul class="calibre53"><li class="calibre19"><p class="docText">The recursive invocation receives a one-item list. The
                  variable <span class="docMonofont">d</span> is bound to <tt class="calibre34">Text
                  "oo"</tt>, and <span class="docMonofont">ds</span> to
                  <tt class="calibre34">[]</tt>.</p><p class="docText">The <tt class="calibre34">case</tt> expression
                  matches in the <tt class="calibre34">Text</tt> branch. On the righthand
                  side, we use <i class="docEmphasis">(++)</i> to
                  concatenate <tt class="calibre34">"oo"</tt> with the result of a recursive
                  application of <i class="docEmphasis">transform</i>.</p><ul class="calibre53"><li class="calibre19"><p class="docText">In the final invocation, <i class="docEmphasis">transform</i> is invoked with an
                      empty list and returns an empty string.</p></li></ul></li><li class="calibre19"><p class="docText">The result is <tt class="calibre34">"oo" ++ ""</tt>.</p></li><li class="calibre19"><p class="docText">The result is <tt class="calibre34">'f' : "oo" ++ ""</tt>.</p></li></ul></li></ul></li></ul><a name="I_sect15_d1e13904d1e14434" class="calibre27" id="I_sect15_d1e13904d1e14434"></a><h4 id="title-IDADC5ZE" class="docSection1Title">5.13.2. True Pretty Printing</h4><a name="x_mo" class="calibre27" id="x_mo"></a><p class="docText">While our <i class="docEmphasis">compact</i>
      function is useful for machine-to-machine communication, its result is
      not always easy for a human to follow: there's very little information
      on each line. To generate more readable output, we'll write another
      function, <i class="docEmphasis">pretty</i>. Compared to
      <i class="docEmphasis">compact</i>, <i class="docEmphasis">pretty</i> takes one extra argument: the maximum
      width of a line, in columns (we're assuming that our typeface is of
      fixed width):</p><pre class="calibre39">-- file: ch05/Prettify.hs
pretty :: Int -&gt; Doc -&gt; String</pre><br class="calibre48"/>
<a name="x_no" class="calibre27" id="x_no"></a><p class="docText">To be more precise, this Int parameter
      controls the behavior of <i class="docEmphasis">pretty</i>
      when it encounters a <i class="docEmphasis">softline</i>. Only
      at a <i class="docEmphasis">softline</i> does <i class="docEmphasis">pretty</i> have the option of either continuing
      the current line or beginning a new one. Elsewhere, we must strictly
      follow the directives set out by the person using our pretty-printing
      functions.</p><a name="x_oo" class="calibre27" id="x_oo"></a><p class="docText">Here's the core of our implementation:</p><pre class="calibre39">-- file: ch05/Prettify.hs
pretty width x = best 0 [x]
    where best col (d:ds) =
              case d of
                Empty        -&gt; best col ds
                Char c       -&gt; c :  best (col + 1) ds
                Text s       -&gt; s ++ best (col + length s) ds
                Line         -&gt; '\n' : best 0 ds
                a `Concat` b -&gt; best col (a:b:ds)
                a `Union` b  -&gt; nicest col (best col (a:ds))
                                           (best col (b:ds))
          best _ _ = ""

          nicest col a b | (width - least) `fits` a = a
                         | otherwise                = b
                         where least = min width col</pre><br class="calibre48"/>
<a name="x_po" class="calibre27" id="x_po"></a><p class="docText">Our <i class="docEmphasis">best</i> helper
      function takes two arguments: the number of columns emitted so far on
      the current line and the list of remaining Doc values to
      process.</p><a name="x_qo" class="calibre27" id="x_qo"></a><p class="docText">In the simple cases, <i class="docEmphasis">best</i> updates the <span class="docMonofont">col</span>
      variable in straightforward ways as it consumes the input. Even the
      <tt class="calibre34">Concat</tt> case is obvious: we push the two concatenated
      components onto our stack/list, and we don't touch
      <span class="docMonofont">col</span>.</p><a name="x_ro" class="calibre27" id="x_ro"></a><p class="docText">The interesting case involves the <tt class="calibre34">Union</tt>
      constructor. Recall that we applied <i class="docEmphasis">flatten</i> to the left element and did nothing
      to the right. Also, remember that <i class="docEmphasis">flatten</i> replaces newlines with spaces.
      Therefore, our job is to see which (if either) of the two layouts—the
      <i class="docEmphasis">flatten</i>ed one or the original—will
      fit into our <span class="docMonofont">width</span> restriction.</p><a name="x_so" class="calibre27" id="x_so"></a><p class="docText">To do this, we write a small helper function that
      determines whether a single line of a rendered Doc value
      will fit into a given number of columns:</p><pre class="calibre39">-- file: ch05/Prettify.hs
fits :: Int -&gt; String -&gt; Bool
w `fits` _ | w &lt; 0 = False
w `fits` ""        = True
w `fits` ('\n':_)  = True
w `fits` (c:cs)    = (w - 1) `fits` cs</pre><br class="calibre48"/>
<a name="I_sect15_d1e13904d1e14520" class="calibre27" id="I_sect15_d1e13904d1e14520"></a><h4 id="title-IDAMF5ZE" class="docSection1Title">5.13.3. Following the Pretty Printer</h4><a name="x_to" class="calibre27" id="x_to"></a><p class="docText">In order to understand how this code works, let's first
      consider a simple Doc value:</p><pre class="calibre39">ghci&gt; <b class="calibre40">empty &lt;/&gt; char 'a'</b>
Concat (Union (Char ' ') Line) (Char 'a')
</pre><a name="x_uo" class="calibre27" id="x_uo"></a><p class="docText">We'll apply <i class="docEmphasis">pretty
      2</i> on this value. When we first apply <i class="docEmphasis">best</i>, the value of <tt class="calibre34">col</tt> is zero.
      It matches the <tt class="calibre34">Concat</tt> case, pushes the values <tt class="calibre34">Union
      (Char ' ') Line</tt> and <tt class="calibre34">Char 'a'</tt> onto the stack, and
      applies itself recursively. In the recursive application, it matches on
      <tt class="calibre34">Union (Char ' ') Line</tt>.</p><a name="x_vo" class="calibre27" id="x_vo"></a><p class="docText">At this point, we're going to ignore Haskell's usual
      order of evaluation. This keeps our explanation of what's going on
      simple, without changing the end result. We now have two subexpressions:
      <tt class="calibre34">best 0 [Char ' ', Char 'a']</tt> and <tt class="calibre34">best 0 [Line, Char
      'a']</tt>. The first evaluates to <tt class="calibre34">" a"</tt>, and the second to
      <tt class="calibre34">"\na"</tt>. We then substitute these into the outer expression
      to give <tt class="calibre34">nicest 0 " a" "\na"</tt>.</p><a name="x_wo" class="calibre27" id="x_wo"></a><p class="docText">To figure out what the result of <i class="docEmphasis">nicest</i> is here, we do a little substitution.
      The values of <span class="docMonofont">width</span> and <span class="docMonofont">col</span> are 0
      and 2, respectively, so <span class="docMonofont">least</span> is 0, and <tt class="calibre34">width -
      least</tt> is 2. We quickly evaluate <tt class="calibre34">2 `fits` " a"</tt> in
      <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">2 `fits` " a"</b>
True
</pre><a name="x_xo" class="calibre27" id="x_xo"></a><p class="docText">Since this evaluates to <tt class="calibre34">true</tt>, the result of
      <i class="docEmphasis">nicest</i> here is <tt class="calibre34">"
      a"</tt>.</p><a name="x_yo" class="calibre27" id="x_yo"></a><p class="docText">If we apply our <i class="docEmphasis">pretty</i> function to the same JSON data that we
      did earlier, we can see that it produces different output depending on
      the width that we give it:</p><pre class="calibre39">ghci&gt; <b class="calibre40">putStrLn (pretty 10 value)</b>
{"f": 1.0,
"q": true
}
ghci&gt; <b class="calibre40">putStrLn (pretty 20 value)</b>
{"f": 1.0, "q": true
}
ghci&gt; <b class="calibre40">putStrLn (pretty 30 value)</b>
{"f": 1.0, "q": true }</pre><a name="fp_fold_exercises" class="calibre27" id="fp_fold_exercises"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

