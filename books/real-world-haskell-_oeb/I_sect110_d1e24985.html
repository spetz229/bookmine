---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect110_d1e24938.html
next: I_sect110_d1e25091.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="I_sect110_d1e24938.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect110_d1e25091.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect110_d1e24985" class="calibre27" id="I_sect110_d1e24985"></a><h3 id="643999-831" class="docSection1Title">10.2. Parsing a Raw PGM File</h3><a name="x_yQ" class="calibre27" id="x_yQ"></a><p class="docText">For our first try at a parsing function, we'll only worry
    about raw<a name="ch10-pgmfiles" class="calibre27" id="ch10-pgmfiles"></a> PGM files. We'll write our PGM parser as a
    <span class="docEmphasis">pure</span> function. <a name="I_indexterm10_d1e24997" class="calibre27" id="I_indexterm10_d1e24997"></a>It's won't be responsible for obtaining the data to parse,
    just for the actual parsing. This is a common approach in Haskell
    programs. By separating the reading of the data from what we subsequently
    do with it, we gain flexibility in where we take the data from.</p><a name="x_zQ" class="calibre27" id="x_zQ"></a><p class="docText">We'll use the ByteString type<a name="I_indexterm10_d1e25008" class="calibre27" id="I_indexterm10_d1e25008"></a> to store our graymap data, because it's compact. Since the
    header of a PGM file is ASCII text but its body is binary, we import both
    the text- and binary-oriented ByteString modules:</p><pre class="calibre39">-- file: ch10/PNM.hs
import qualified Data.ByteString.Lazy.Char8 as L8
import qualified Data.ByteString.Lazy as L
import Data.Char (isSpace)</pre><br class="calibre48"/>
<a name="x_AR" class="calibre27" id="x_AR"></a><p class="docText">For our purposes, it doesn't matter whether we use a lazy
    or strict ByteString, so we've somewhat arbitrarily chosen
    the lazy kind.</p><a name="x_CR" class="calibre27" id="x_CR"></a><p class="docText">We'll use a straightforward data type to represent PGM
    images:</p><pre class="calibre39">-- file: ch10/PNM.hs
data Greymap = Greymap {
      greyWidth :: Int
    , greyHeight :: Int
    , greyMax :: Int
    , greyData :: L.ByteString
    } deriving (Eq)</pre><br class="calibre48"/>
<a name="x_DR" class="calibre27" id="x_DR"></a><p class="docText">Normally, a Haskell Show instance should
    produce a string representation that we can read back by calling <i class="docEmphasis">read</i>. However, for a bitmap graphics file, this
    would potentially produce huge text strings, for example, if we were to
    <i class="docEmphasis">show</i> a photo. For this reason, we're
    not going to let the compiler automatically derive a Show
    instance for us; we'll write our own and intentionally simplify it:</p><pre class="calibre39">-- file: ch10/PNM.hs
instance Show Greymap where
    show (Greymap w h m _) = "Greymap " ++ show w ++ "x" ++ show h ++
                             " " ++ show m</pre><br class="calibre48"/>
<a name="x_ER" class="calibre27" id="x_ER"></a><p class="docText">Because our Show instance intentionally
    avoids printing the bitmap data, there's no point in writing a
    Read instance, as we can't reconstruct a valid
    Greymap from the result of <i class="docEmphasis">show</i>.</p><a name="x_FR" class="calibre27" id="x_FR"></a><p class="docText">Here's an obvious type for our parsing function:</p><pre class="calibre39">-- file: ch10/PNM.hs
parseP5 :: L.ByteString -&gt; Maybe (Greymap, L.ByteString)</pre><br class="calibre48"/>
<a name="x_GR" class="calibre27" id="x_GR"></a><p class="docText">This will take a ByteString, and if the parse
    succeeds, it will return a single parsed Greymap, along with
    the string that remains after parsing. That residual string will be
    available for future parses.</p><a name="x_HR" class="calibre27" id="x_HR"></a><p class="docText">Our parsing function has to consume a little bit of its
    input at a time. First, we need to assure ourselves that we're really
    looking at a raw PGM file; then we need to parse the numbers from the
    remainder of the header; and then we consume the bitmap data. Here's an
    obvious way to express this, which we will use as a base for later <span class="docEmphasis">improvements</span>:</p><pre class="calibre39">-- file: ch10/PNM.hs
matchHeader :: L.ByteString -&gt; L.ByteString -&gt; Maybe L.ByteString

-- "nat" here is short for "natural number"
getNat :: L.ByteString -&gt; Maybe (Int, L.ByteString)

getBytes :: Int -&gt; L.ByteString
         -&gt; Maybe (L.ByteString, L.ByteString)

parseP5 s =
  case matchHeader (L8.pack "P5") s of
    Nothing -&gt; Nothing
    Just s1 -&gt;
      case getNat s1 of
        Nothing -&gt; Nothing
        Just (width, s2) -&gt;
          case getNat (L8.dropWhile isSpace s2) of
            Nothing -&gt; Nothing
            Just (height, s3) -&gt;
              case getNat (L8.dropWhile isSpace s3) of
                Nothing -&gt; Nothing
                Just (maxGrey, s4)
                  | maxGrey &gt; 255 -&gt; Nothing
                  | otherwise -&gt;
                      case getBytes 1 s4 of
                        Nothing -&gt; Nothing
                        Just (_, s5) -&gt;
                          case getBytes (width * height) s5 of
                            Nothing -&gt; Nothing
                            Just (bitmap, s6) -&gt;
                              Just (Greymap width height maxGrey bitmap, s6)</pre><br class="calibre48"/>
<a name="x_IR" class="calibre27" id="x_IR"></a><p class="docText">This is a very literal piece of code, performing all of
    the parsing in one long staircase of <tt class="calibre34">case</tt> expressions. Each function returns the
    residual ByteString left over after it has consumed all it
    needs from its input string. We pass each residual string along to the
    next step. We deconstruct each result in turn, either returning
    <tt class="calibre34">Nothing</tt> if the parsing step fails, or building up a piece of
    the final result as we proceed. Here are the bodies of the functions that
    we apply during parsing (their types are commented out because we already
    presented them):</p><pre class="calibre39">-- file: ch10/PNM.hs
-- L.ByteString -&gt; L.ByteString -&gt; Maybe L.ByteString
matchHeader prefix str
    | prefix `L8.isPrefixOf` str
        = Just (L8.dropWhile isSpace (L.drop (L.length prefix) str))
    | otherwise
        = Nothing

-- L.ByteString -&gt; Maybe (Int, L.ByteString)
getNat s = case L8.readInt s of
             Nothing -&gt; Nothing
             Just (num,rest)
                 | num &lt;= 0    -&gt; Nothing
                 | otherwise -&gt; Just (fromIntegral num, rest)

-- Int -&gt; L.ByteString -&gt; Maybe (L.ByteString, L.ByteString)
getBytes n str = let count           = fromIntegral n
                     both@(prefix,_) = L.splitAt count str
                 in if L.length prefix &lt; count
                    then Nothing
                    else Just both</pre><br class="calibre48"/>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="I_sect110_d1e24938.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect110_d1e25091.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

