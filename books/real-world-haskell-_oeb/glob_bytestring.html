---
layout: page
title: "Real World Haskell, 1st Edition"
prev: glob_split_001.html
next: glob_fnmatch.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="glob_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="glob_fnmatch.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="glob_bytestring" class="calibre27" id="glob_bytestring"></a><h3 id="643999-824" class="docSection1Title">8.1. Efficient File Processing</h3><a name="x_HE1" class="calibre27" id="x_HE1"></a><p class="docText">This simple <a name="I_indexterm8_d1e21115" class="calibre27" id="I_indexterm8_d1e21115"></a><a name="ch07-fileprocessing001" class="calibre27" id="ch07-fileprocessing001"></a>microbenchmark reads a text file full of numbers and prints
    their sum:</p><pre class="calibre39">-- file: ch08/SumFile.hs
main = do
    contents &lt;- getContents
    print (sumFile contents)
  where sumFile = sum . map read . words</pre><br class="calibre48"/>
<a name="x_IE1" class="calibre27" id="x_IE1"></a><p class="docText">Although the String type is the default used
    for reading and writing files, it is not efficient, so a simple program
    like this will perform badly.</p><a name="x_JE1" class="calibre27" id="x_JE1"></a><p class="docText">A String is<a name="I_indexterm8_d1e21138" class="calibre27" id="I_indexterm8_d1e21138"></a> represented as a list of Char values; each
    element of a list is allocated <span class="docEmphasis">individually</span> and has some bookkeeping
    overhead. These factors affect the memory consumption and performance of a
    program that must read or write text or binary data. On simple benchmarks
    like this, even programs written in interpreted languages such as Python
    can outperform Haskell code that uses String by an order of
    magnitude.</p><a name="x_KE1" class="calibre27" id="x_KE1"></a><p class="docText">The <tt class="calibre34">bytestring</tt> library<a name="I_indexterm8_d1e21158" class="calibre27" id="I_indexterm8_d1e21158"></a> provides a fast, cheap alternative to the
    String type. Code written with <tt class="calibre34">bytestring</tt> can
    often match or exceed the performance and memory footprint of C, while
    maintaining Haskell's expressivity and conciseness.</p><a name="x_LE1" class="calibre27" id="x_LE1"></a><p class="docText">The library supplies two modules—each defines functions
    that are nearly drop-in <span class="docEmphasis">replacements</span>
    for their String counterparts:</p><a name="I_indexterm8_d1e21187" class="calibre27" id="I_indexterm8_d1e21187"></a><a name="I_indexterm8_d1e21207" class="calibre27" id="I_indexterm8_d1e21207"></a><a name="I_indexterm8_d1e21211" class="calibre27" id="I_indexterm8_d1e21211"></a><dl class="docList1"><dt class="calibre48"><br class="calibre48"/><p class="calibre37"><span class="docPubcolor">
<span class="docPubcolor"><span class="docMonofont">Data.ByteString</span></span>
</span></p></dt><dd class="calibre49"><p class="docText">Defines a <span class="docEmphasis">strict</span> type<a name="I_indexterm8_d1e21187" class="calibre27" id="I_indexterm8_d1e21187"></a> named ByteString. This represents a
          string of binary or text data in a single array.</p></dd><dt class="calibre48"><br class="calibre48"/><p class="calibre37"><span class="docPubcolor">
<span class="docPubcolor"><span class="docMonofont">Data.ByteString.Lazy</span></span>
</span></p></dt><dd class="calibre49"><p class="docText">Provides a <span class="docEmphasis">lazy</span> type, also named
          ByteString. This<a name="I_indexterm8_d1e21207" class="calibre27" id="I_indexterm8_d1e21207"></a> represents a string of data as a list<a name="I_indexterm8_d1e21211" class="calibre27" id="I_indexterm8_d1e21211"></a> of <span class="docEmphasis">chunks</span>, arrays of up to 64 KB
          in size.</p></dd></dl><a name="x_OE1" class="calibre27" id="x_OE1"></a><p class="docText">Each ByteString type performs better under
    particular circumstances. For streaming a large quantity (hundreds of
    megabytes to terabytes) of data, the lazy ByteString type is
    usually best. Its chunk size is tuned to be friendly to a modern CPU's L1
    cache, and a garbage collector can quickly discard chunks of streamed data
    that are no longer being used.</p><a name="x_PE1" class="calibre27" id="x_PE1"></a><p class="docText">The strict ByteString type performs best for
    applications that are less concerned with memory footprint or that need to
    access data randomly.</p><a name="glob_bytestringd1e21593" class="calibre27" id="glob_bytestringd1e21593"></a><h4 id="title-IDAKTB0G" class="docSection1Title">8.1.1. Binary I/O and Qualified Imports</h4><a name="x_QE1" class="calibre27" id="x_QE1"></a><p class="docText">Let's<a name="I_indexterm8_d1e21236" class="calibre27" id="I_indexterm8_d1e21236"></a><a name="I_indexterm8_d1e21239" class="calibre27" id="I_indexterm8_d1e21239"></a><a name="I_indexterm8_d1e21244" class="calibre27" id="I_indexterm8_d1e21244"></a> develop a small function to illustrate some of the
      <tt class="calibre34">ByteString</tt> API. We will determine if a file is an<a name="I_indexterm8_d1e21251" class="calibre27" id="I_indexterm8_d1e21251"></a> ELF object file—this is the format used for executables
      on almost all modern Unix-like systems.</p><a name="x_RE1" class="calibre27" id="x_RE1"></a><p class="docText">This is a simple matter of looking at the first four
      bytes in the file and seeing if they match a specific sequence of bytes.
      A byte sequence that identifies a file's type is often known <a name="I_indexterm8_d1e21257" class="calibre27" id="I_indexterm8_d1e21257"></a>as a <span class="docEmphasis">magic number</span>:</p><pre class="calibre39">-- file: ch08/ElfMagic.hs
import qualified Data.ByteString.Lazy as L

hasElfMagic :: L.ByteString -&gt; Bool
hasElfMagic content = L.take 4 content == elfMagic
    where elfMagic = L.pack [0x7f, 0x45, 0x4c, 0x46]</pre><br class="calibre48"/>
<a name="x_SE1" class="calibre27" id="x_SE1"></a><p class="docText">We import the <tt class="calibre34">ByteString</tt> modules using
      Haskell's <span class="docEmphasis">qualified import</span> syntax,<a name="I_indexterm8_d1e21274" class="calibre27" id="I_indexterm8_d1e21274"></a> the <tt class="calibre34">import qualified</tt> that<a name="I_indexterm8_d1e21283" class="calibre27" id="I_indexterm8_d1e21283"></a> we just saw. This lets us refer to a module with a name
      of our choosing.</p><a name="x_TE1" class="calibre27" id="x_TE1"></a><p class="docText">For instance, when we want to refer to the lazy
      <tt class="calibre34">ByteString</tt> module's <i class="docEmphasis">take</i> function, we must write <i class="docEmphasis">L.take</i>, since we imported the module under
      the name <tt class="calibre34">L</tt>. If we are not explicit about which version of,
      for example, <i class="docEmphasis">take</i> we want, the
      compiler will report an error.</p><a name="x_UE1" class="calibre27" id="x_UE1"></a><p class="docText">We will always use qualified import syntax with the
      <tt class="calibre34">ByteString</tt> modules, because they provide many functions
      that have the same names as <tt class="calibre34">Prelude</tt> functions.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_VE1" class="calibre27" id="x_VE1"></a><p class="docText">Qualified imports make it easy to switch between
        ByteString types. All you should need to do is modify an
        <tt class="calibre34">import</tt> declaration at the top of your source file; the
        rest of your code will probably not need any changes. You can thus
        handily benchmark the two types, to see which is best suited to your
        application's needs</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_WE1" class="calibre27" id="x_WE1"></a><p class="docText">Whether or not we use qualified imports, we can always
      use the entire name of a module to identify something unambiguously.
      Both <i class="docEmphasis">Data.ByteString.Lazy.length</i>
      and <i class="docEmphasis">L.length</i>, for instance,
      identify the same function, as do <i class="docEmphasis">Prelude.sum</i> and <i class="docEmphasis">sum</i>.</p><a name="x_XE1" class="calibre27" id="x_XE1"></a><p class="docText">The lazy and strict <tt class="calibre34">ByteString</tt> modules are
      intended for binary I/O. The Haskell data type for representing bytes is
      Word8; if we need to refer to it by name, we import it from
      the <tt class="calibre34">Data.Word</tt> module.</p><a name="x_YE1" class="calibre27" id="x_YE1"></a><p class="docText">The <i class="docEmphasis">L.pack</i>
      function<a name="I_indexterm8_d1e21353" class="calibre27" id="I_indexterm8_d1e21353"></a> takes a list of Word8 values, and packs them
      into a lazy ByteString. (The <i class="docEmphasis">L.unpack</i> function performs the reverse
      conversion.) Our <i class="docEmphasis">hasElfMagic</i>
      function simply compares the first four bytes of a
      <tt class="calibre34">ByteString</tt> against a magic number.</p><a name="x_ZE1" class="calibre27" id="x_ZE1"></a><p class="docText">We are writing in classic Haskell style, where
      <a name="I_indexterm8_d1e21376" class="calibre27" id="I_indexterm8_d1e21376"></a>our <i class="docEmphasis">hasElfMagic</i>
      function does not perform I/O. Here is the function that uses it on a
      file:</p><pre class="calibre39">-- file: ch08/ElfMagic.hs
isElfFile :: FilePath -&gt; IO Bool
isElfFile path = do
  content &lt;- L.readFile path
  return (hasElfMagic content)</pre><br class="calibre48"/>
<a name="x_aE1" class="calibre27" id="x_aE1"></a><p class="docText">The <i class="docEmphasis">L.readFile</i>
<a name="I_indexterm8_d1e21390" class="calibre27" id="I_indexterm8_d1e21390"></a>function<a name="I_indexterm8_d1e21394" class="calibre27" id="I_indexterm8_d1e21394"></a> is the lazy ByteString equivalent of
      <i class="docEmphasis">readFile</i>. It operates lazily,
      reading the file as data is demanded. It is also efficient, reading
      chunks of up to 64 KB at once. The lazy ByteString is a
      good choice for our task: since we only need to read at most the first
      four bytes of the file, we can safely use this function on a file of any
      size.</p><a name="glob_bytestringd1e21771" class="calibre27" id="glob_bytestringd1e21771"></a><h4 id="title-IDAQZB0G" class="docSection1Title">8.1.2. Text I/O</h4><a name="x_bE1" class="calibre27" id="x_bE1"></a><p class="docText">For<a name="ch07-textio" class="calibre27" id="ch07-textio"></a><a name="I_indexterm8_d1e21417" class="calibre27" id="I_indexterm8_d1e21417"></a><a name="ch07-iotext" class="calibre27" id="ch07-iotext"></a> convenience, the<a name="I_indexterm8_d1e21428" class="calibre27" id="I_indexterm8_d1e21428"></a> <tt class="calibre34">bytestring</tt> library provides two other
      modules with limited text I/O capabilities,
      <tt class="calibre34">Data.ByteString.Char8</tt> and
      <tt class="calibre34">Data.ByteString.Lazy.Char8</tt>. These<a name="I_indexterm8_d1e21444" class="calibre27" id="I_indexterm8_d1e21444"></a><a name="I_indexterm8_d1e21447" class="calibre27" id="I_indexterm8_d1e21447"></a> expose individual string elements as Char
      instead of Word8.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="warning_yellow.gif" alt="" class="calibre44"/></td><td valign="top" class="v3"><a name="x_cE1" class="calibre27" id="x_cE1"></a><p class="docText">The functions in these modules only work with
        byte-sized Char values, so they are only suitable for use
        with ASCII and some European character sets. Values above 255 are
        truncated.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_dE1" class="calibre27" id="x_dE1"></a><p class="docText">The character-oriented <tt class="calibre34">bytestring</tt> modules
      provide useful functions for text processing. Here is a file that
      contains monthly stock prices for a well-known Internet company from
      mid-2008:</p><pre class="calibre39">ghci&gt; <b class="calibre40">putStr =&lt;&lt; readFile "prices.csv"</b>
Date,Open,High,Low,Close,Volume,Adj Close
2008-08-01,20.09,20.12,19.53,19.80,19777000,19.80
2008-06-30,21.12,21.20,20.60,20.66,17173500,20.66
2008-05-30,27.07,27.10,26.63,26.76,17754100,26.76
2008-04-30,27.17,27.78,26.76,27.41,30597400,27.41
</pre><a name="x_eE1" class="calibre27" id="x_eE1"></a><p class="docText">How can we find the highest closing price from a series
      of entries like this? Closing prices are in the fourth comma-separated
      column. This function obtains a closing price from one line of
      data:</p><pre class="calibre39">-- file: ch08/HighestClose.hs
import qualified Data.ByteString.Lazy.Char8 as L

closing = readPrice . (!!4) . L.split ','</pre><br class="calibre48"/>
<a name="x_fE1" class="calibre27" id="x_fE1"></a><p class="docText">Since this function is written in point-free style, we
      read from right to left. The <i class="docEmphasis">L.split</i> function<a name="I_indexterm8_d1e21484" class="calibre27" id="I_indexterm8_d1e21484"></a> splits a lazy ByteString into a list of
      them, every time it finds a matching character. <a name="I_indexterm8_d1e21491" class="calibre27" id="I_indexterm8_d1e21491"></a>The <i class="docEmphasis">(!!)</i> operator
      retrieves the <span class="docEmphasis">k</span>th element of a list. Our <i class="docEmphasis">readPrice</i> function turns a string
      representing a fractional price into a whole number:</p><pre class="calibre39">-- file: ch08/HighestClose.hs
readPrice :: L.ByteString -&gt; Maybe Int
readPrice str =
    case L.readInt str of
      Nothing             -&gt; Nothing
      Just (dollars,rest) -&gt;
        case L.readInt (L.tail rest) of
          Nothing           -&gt; Nothing
          Just (cents,more) -&gt;
            Just (dollars * 100 + cents)</pre><br class="calibre48"/>
<a name="x_gE1" class="calibre27" id="x_gE1"></a><p class="docText">We use the <i class="docEmphasis">L.readInt</i> function,<a name="I_indexterm8_d1e21512" class="calibre27" id="I_indexterm8_d1e21512"></a> which<a name="I_indexterm8_d1e21516" class="calibre27" id="I_indexterm8_d1e21516"></a> parses an integer. It returns both the integer and the
      remainder of the string once a run of digits is consumed. Our definition
      is slightly complicated by <i class="docEmphasis">L.readInt</i> returning <tt class="calibre34">Nothing</tt> if
      parsing fails.</p><a name="x_hE1" class="calibre27" id="x_hE1"></a><p class="docText">Our function for finding the highest closing price is
      straightforward:</p><pre class="calibre39">-- file: ch08/HighestClose.hs
highestClose = maximum . (Nothing:) . map closing . L.lines

highestCloseFrom path = do
    contents &lt;- L.readFile path
    print (highestClose contents)</pre><br class="calibre48"/>
<a name="x_iE1" class="calibre27" id="x_iE1"></a><p class="docText">We use one trick to work around the fact that we cannot
      supply an empty list to<a name="I_indexterm8_d1e21533" class="calibre27" id="I_indexterm8_d1e21533"></a> the <i class="docEmphasis">maximum</i>
      function:</p><pre class="calibre39">ghci&gt; <b class="calibre40">maximum [3,6,2,9]</b>
9
ghci&gt; <b class="calibre40">maximum []</b>
*** Exception: Prelude.maximum: empty list</pre><a name="x_jE1" class="calibre27" id="x_jE1"></a><p class="docText">Since we do not want our code to throw an exception if
      we have no stock data, the <tt class="calibre34">(Nothing:)</tt> expression ensures
      that the list of Maybe Int values that we supply to
      <i class="docEmphasis">maximum</i> will never be empty:</p><pre class="calibre39">ghci&gt; <b class="calibre40">maximum [Nothing, Just 1]</b>
Just 1
ghci&gt; <b class="calibre40">maximum [Nothing]</b>
Nothing</pre><a name="x_kE1" class="calibre27" id="x_kE1"></a><p class="docText">Does our function work?</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load HighestClose</b>
[1 of 1] Compiling Main             ( HighestClose.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">highestCloseFrom "prices.csv"</b>
Loading package array-0.1.0.0 ... linking ... done.
Loading package bytestring-0.9.0.1.1 ... linking ... done.
Just 2741</pre><a name="x_lE1" class="calibre27" id="x_lE1"></a><p class="docText">Since we have separated our I/O from our logic, we can
      test the no-data case without having to create an empty file:</p><pre class="calibre39">ghci&gt; <b class="calibre40">highestClose L.empty</b>
Nothing
</pre>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="glob_split_000.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="glob_fnmatch.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

