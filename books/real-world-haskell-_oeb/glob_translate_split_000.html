---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect18_d1e22097_split_001.html
next: glob_translate_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect18_d1e22097_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="glob_lazyfn.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="glob_translate" class="calibre27" id="glob_translate"></a><h3 id="title-IDA5FXON" class="docSection1Title">8.5. Translating a glob Pattern into a Regular Expression</h3><a name="x_nF" class="calibre27" id="x_nF"></a><p class="docText">Now<a name="I_indexterm8_d1e22270" class="calibre27" id="I_indexterm8_d1e22270"></a><a name="ch07-regexpglob" class="calibre27" id="ch07-regexpglob"></a><a name="I_indexterm8_d1e22276" class="calibre27" id="I_indexterm8_d1e22276"></a> that we've seen the myriad of ways to match text against
    regular expressions, let's turn our attention back to glob patterns. We
    want to write a function that will take a glob pattern and return its
    representation as a regular expression. Both glob patterns and regexps are
    text strings, so the type that our function ought to have seems
    clear:</p><pre class="calibre39">-- file: ch08/GlobRegex.hs
module GlobRegex
    (
      globToRegex
    , matchesGlob
    ) where

import Text.Regex.Posix ((=~))

globToRegex :: String -&gt; String</pre><br class="calibre48"/>
<a name="x_oF" class="calibre27" id="x_oF"></a><p class="docText">The regular expression that we generate must<a name="I_indexterm8_d1e22286" class="calibre27" id="I_indexterm8_d1e22286"></a> be <span class="docEmphasis">anchored</span> so that it starts matching
    from the beginning of a string and finishes at the end:</p><pre class="calibre39">-- file: ch08/GlobRegex.hs
globToRegex cs = '^' : globToRegex' cs ++ "$"</pre><br class="calibre48"/>
<a name="x_pF" class="calibre27" id="x_pF"></a><p class="docText">Recall that the String is just a synonym for
    [Char], a list of Chars. <a name="I_indexterm8_d1e22306" class="calibre27" id="I_indexterm8_d1e22306"></a>The <i class="docEmphasis">:</i> operator puts a
    value (the <tt class="calibre34">^</tt> character in this case)
    onto the front of a list, where the list is the value returned by the
    yet-to-be-seen <i class="docEmphasis">globToRegex'</i>
    function.</p><a name="glob_translated1e22683" class="calibre27" id="glob_translated1e22683"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_rF" class="calibre27" id="x_rF"></a></p><p class="docText">Haskell does not require that a value or function be
      declared or defined in a source file before it's used. It's perfectly
      normal for a definition to come <span class="docEmphasis">after</span> the first
      place it's used. The Haskell compiler doesn't care about ordering at
      this level. This grants us the flexibility to structure our code in the
      manner that makes most logical sense to us, rather than follow an order
      that makes the compiler writer's life easiest.</p><a name="x_sF" class="calibre27" id="x_sF"></a><p class="docText">Haskell module writers often use this flexibility to put
      "more important" code earlier in a source file, relegating
      "plumbing" to later. This is exactly how we are presenting
      the <i class="docEmphasis">globToRegex</i> function and its
      helpers here.</p></div><a name="x_tF" class="calibre27" id="x_tF"></a><p class="docText">With the regular expression rooted, the <i class="docEmphasis">globToRegex'</i> function will do the bulk of the
    translation work. We'll use the convenience of Haskell's pattern matching
    to enumerate each of the cases we'll need to cover:</p><pre class="calibre39">-- file: ch08/GlobRegex.hs
globToRegex' :: String -&gt; String
globToRegex' "" = ""

globToRegex' ('*':cs) = ".*" ++ globToRegex' cs

globToRegex' ('?':cs) = '.' : globToRegex' cs

globToRegex' ('[':'!':c:cs) = "[^" ++ c : charClass cs
globToRegex' ('[':c:cs)     = '['  :  c : charClass cs
globToRegex' ('[':_)        = error "unterminated character class"

globToRegex' (c:cs) = escape c ++ globToRegex' cs</pre><br class="calibre48"/>
<a name="x_uF" class="calibre27" id="x_uF"></a><p class="docText">Our first clause stipulates that if we hit the end of our
    glob pattern (by which time we'll be looking at the empty string), we
    return <tt class="calibre34">$</tt>, the regular expression symbol
    for "match end-of-line." Following this is a series of clauses that switch
    our pattern from glob syntax to regexp syntax. The last clause passes
    every other character through, possibly escaping it first.</p><a name="x_CG" class="calibre27" id="x_CG"></a><p class="docText">The <i class="docEmphasis">escape</i> function
    ensures that the regexp engine will not interpret certain characters as
    pieces of regular expression syntax:</p><pre class="calibre39">-- file: ch08/GlobRegex.hs
escape :: Char -&gt; String
escape c | c `elem` regexChars = '\\' : [c]
         | otherwise = [c]
    where regexChars = "\\+()^$.{}]|"</pre><br class="calibre48"/>
<a name="x_DG" class="calibre27" id="x_DG"></a><p class="docText">The <i class="docEmphasis">charClass</i> helper
    function only checks that a character class is correctly terminated. It
    passes its input through unmodified until it hits a <tt class="calibre34">]</tt>, when it hands control back to <i class="docEmphasis">globToRegex'</i>:</p><pre class="calibre39">-- file: ch08/GlobRegex.hs
charClass :: String -&gt; String
charClass (']':cs) = ']' : globToRegex' cs
charClass (c:cs)   = c : charClass cs
charClass []       = error "unterminated character class"</pre><br class="calibre48"/>
<a name="x_EG" class="calibre27" id="x_EG"></a><p class="docText">Now that we've finished defining <i class="docEmphasis">globToRegex</i> and its helpers, let's load it into
    <i class="docEmphasis">ghci</i> and try it out:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load GlobRegex.hs</b>
[1 of 1] Compiling GlobRegex        ( GlobRegex.hs, interpreted )
Ok, modules loaded: GlobRegex.
ghci&gt; <b class="calibre40">:module +Text.Regex.Posix</b>
ghci&gt; <b class="calibre40">globToRegex "f??.c"</b>
Loading package array-0.1.0.0 ... linking ... done.
Loading package bytestring-0.9.0.1.1 ... linking ... done.
Loading package regex-base-0.72.0.1 ... linking ... done.
Loading package regex-posix-0.72.0.2 ... linking ... done.
"^f..\\.c$"</pre><a name="x_FG" class="calibre27" id="x_FG"></a><p class="docText">Sure enough, that looks like a reasonable regexp. Can we
    use it to match against a string?</p><pre class="calibre39">ghci&gt; <b class="calibre40">"foo.c" =~ globToRegex "f??.c" :: Bool</b>
True
ghci&gt; <b class="calibre40">"test.c" =~ globToRegex "t[ea]s*" :: Bool</b>
True
ghci&gt; <b class="calibre40">"taste.txt" =~ globToRegex "t[ea]s*" :: Bool</b>
True</pre><a name="x_GG" class="calibre27" id="x_GG"></a><p class="docText">It works! Now let's play around a little with <i class="docEmphasis">ghci</i>. We can create a temporary definition for
    <i class="docEmphasis">fnmatch</i> and try it out:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let fnmatch pat name  =  name =~ globToRegex pat :: Bool</b>ghci&gt; <b class="calibre40">:type fnmatch</b>
fnmatch :: (Text.Regex.Base.RegexLike.RegexLike Regex source1) =&gt;
           String -&gt; source1 -&gt; Bool
ghci&gt; <b class="calibre40">fnmatch "d*" "myname"</b>
False</pre><a name="x_HG" class="calibre27" id="x_HG"></a><p class="docText">The name <i class="docEmphasis">fnmatch</i>
    doesn't really have the "Haskell nature," though. By far the most common
    Haskell style is for functions to have descriptive, "camel
    cased" names.<a name="I_indexterm8_d1e22446" class="calibre27" id="I_indexterm8_d1e22446"></a> Camel casing concatenates words, capitalizing all but
    possibly the first word. For instance, the words "filename
    matches" would become the name <tt class="calibre34">fileNameMatches</tt>. The
    name "camel case" comes from the "humps"
    introduced by the capital letters. In our library, we'll give this
    function the name <i class="docEmphasis">matchesGlob</i>:</p><pre class="calibre39">-- file: ch08/GlobRegex.hs
matchesGlob :: FilePath -&gt; String -&gt; Bool
name `matchesGlob` pat = name =~ globToRegex pat</pre><br class="calibre48"/>
<a name="x_qE1" class="calibre27" id="x_qE1"></a><p class="docText">You may have noticed that most of the names that we have
    used for variables so far have been short. As a rule of thumb, descriptive
    variable names are more useful in longer function definitions, as they aid
    readability. For a two-line function, a long variable name has less
    value.</p><a name="I_sidebar8_d1e22471" class="calibre27" id="I_sidebar8_d1e22471"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

