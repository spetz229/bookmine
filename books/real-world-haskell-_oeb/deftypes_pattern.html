---
layout: page
title: "Real World Haskell, 1st Edition"
prev: deftypes_adt.html
next: deftypes_record.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="deftypes_adt.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="deftypes_record.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="deftypes_pattern" class="calibre27" id="deftypes_pattern"></a><h3 id="title-IDA40ETE" class="docSection1Title">3.4. Pattern Matching</h3><a name="x_Z5" class="calibre27" id="x_Z5"></a><p class="docText">Now<a name="I_indexterm3_d1e6441" class="calibre27" id="I_indexterm3_d1e6441"></a><a name="I_indexterm3_d1e6442" class="calibre27" id="I_indexterm3_d1e6442"></a><a name="ch03-patternmatching" class="calibre27" id="ch03-patternmatching"></a> that we've seen how to construct values with algebraic data
    types, let's discuss how we work with these values. If we have a value of
    some type, there are two things we would like to be able to do:</p><ul class="calibre18"><li class="calibre19"><p class="docText">If the type has more than one value constructor, we
        need to be able to tell which value constructor was used to create the
        value.</p></li><li class="calibre19"><p class="docText">If the value constructor has data components, we need
        to be able to extract those values.</p></li></ul><a name="x_if" class="calibre27" id="x_if"></a><p class="docText">Haskell has a simple, but tremendously useful,
    <span class="docEmphasis">pattern matching</span> facility that lets us do both of
    these things.</p><a name="x_a5" class="calibre27" id="x_a5"></a><p class="docText">A pattern lets us look inside a value and bind variables
    to the data it contains. Here's an example of pattern matching in action
    on a Bool value; we're going to reproduce the <i class="docEmphasis">not</i> function:</p><pre class="calibre39">-- file: ch03/add.hs
myNot True  = False
myNot False = True</pre><br class="calibre48"/>
<a name="x_e5" class="calibre27" id="x_e5"></a><p class="docText">It might seem that we have two functions named <i class="docEmphasis">myNot</i> here, but Haskell lets us define a
    function as a <span class="docEmphasis">series of equations</span>: these two clauses
    are defining the behavior of the same function for different patterns of
    input. On each line, the patterns are the items following the function
    name, up until the <tt class="calibre34">=</tt> sign.</p><a name="x_jf" class="calibre27" id="x_jf"></a><p class="docText">To understand how pattern matching works, let's step
    through an example—say, <tt class="calibre34">myNot False</tt>.</p><a name="x_kf" class="calibre27" id="x_kf"></a><p class="docText">When we apply <i class="docEmphasis">myNot</i>,
    the Haskell runtime checks the value we supply against the value
    constructor in the first pattern. This does not match, so it tries against
    the second pattern. That match succeeds, so it uses the righthand side of
    that equation as the result of the function application.</p><a name="x_xB1" class="calibre27" id="x_xB1"></a><p class="docText">Here is a slightly more extended example. This function
    adds together the elements of a list:</p><pre class="calibre39">-- file: ch03/add.hs
sumList (x:xs) = x + sumList xs
sumList []     = 0</pre><br class="calibre48"/>
<a name="x_yB1" class="calibre27" id="x_yB1"></a><p class="docText">Let us step through the evaluation of <tt class="calibre34">sumList
    [1,2]</tt>. The list notation <tt class="calibre34">[1,2]</tt> is shorthand for the
    expression <tt class="calibre34">(1:(2:[]))</tt>. We begin by trying to match the
    pattern in the first equation of the definition of <tt class="calibre34">sumList</tt>.
    In the <tt class="calibre34">(x:xs)</tt> pattern, the <tt class="calibre34">:</tt> is the
    familiar list constructor, <i class="docEmphasis">(:)</i>.
    <a name="I_indexterm3_d1e6519" class="calibre27" id="I_indexterm3_d1e6519"></a>We are now using it to match against a value, not to
    construct one. The value <tt class="calibre34">(1:(2:[]))</tt> was constructed with
    <tt class="calibre34">(:)</tt>, so the constructor in the value matches the constructor
    in the pattern. We say that the pattern <span class="docEmphasis">matches</span> or
    that the match <span class="docEmphasis">succeeds</span>.</p><a name="x_zB1" class="calibre27" id="x_zB1"></a><p class="docText">The variables <span class="docMonofont">x</span> and
    <span class="docMonofont">xs</span> are now "bound to" the constructor's
    arguments, so <span class="docMonofont">x</span> is given the value <tt class="calibre34">1</tt>, and
    <tt class="calibre34">xs</tt> the value <tt class="calibre34">2:[]</tt>.</p><a name="x_lf" class="calibre27" id="x_lf"></a><p class="docText">The expression we are now evaluating is <tt class="calibre34">1 + sumList
    (2:[])</tt>. We must recursively apply <i class="docEmphasis">sumList</i> to the value <tt class="calibre34">2:[]</tt>. Once
    again, this was constructed using <tt class="calibre34">(:)</tt>, so the match succeeds.
    In our recursive application of <i class="docEmphasis">sumList</i>, <span class="docMonofont">x</span> is now bound to
    <tt class="calibre34">2</tt>, and <span class="docMonofont">xs</span> to <tt class="calibre34">[]</tt>.</p><a name="x_d5" class="calibre27" id="x_d5"></a><p class="docText">We are now evaluating <tt class="calibre34">1 + (2 + sumList [])</tt>.
    In this recursive application of <i class="docEmphasis">sumList</i>, the value we are matching against is
    <tt class="calibre34">[]</tt>. The value's constructor does not match the constructor in
    the first pattern, so we skip this equation. Instead, we "fall
    through" to the next pattern, which matches. The righthand side of
    this equation is thus chosen as the result of this application.</p><a name="x_mf" class="calibre27" id="x_mf"></a><p class="docText">The result of <tt class="calibre34">sumList [1,2]</tt> is thus <tt class="calibre34">1 +
    (2 + (0))</tt>, or <tt class="calibre34">3</tt>.</p><a name="deftypes_patternd1e6684" class="calibre27" id="deftypes_patternd1e6684"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_m5" class="calibre27" id="x_m5"></a></p><p class="docText">As we already mentioned, a Haskell implementation checks
      patterns for matches in the order in which we specify them in our
      equations. Matching proceeds from top to bottom and stops at the first
      success. Equations that are below a successful match have no
      effect.</p></div><a name="x_nf" class="calibre27" id="x_nf"></a><p class="docText">As a final note, there is a standard function, <i class="docEmphasis">sum</i>, that performs this sum-of-a-list for us.
    Our <i class="docEmphasis">sumList</i> is purely for
    illustration.</p><a name="deftypes_patternd1e6697" class="calibre27" id="deftypes_patternd1e6697"></a><h4 id="title-IDAEBFTE" class="docSection1Title">3.4.1. Construction and Deconstruction</h4><a name="x_of" class="calibre27" id="x_of"></a><p class="docText">Let's<a name="I_indexterm3_d1e6635" class="calibre27" id="I_indexterm3_d1e6635"></a><a name="I_indexterm3_d1e6638" class="calibre27" id="I_indexterm3_d1e6638"></a> step back and take a look at the relationship between
      constructing a value and pattern matching on it.</p><a name="x_pf" class="calibre27" id="x_pf"></a><p class="docText">We apply a value constructor to build a value. The
      expression <tt class="calibre34">Book 9 "Close Calls" ["John Long"]</tt> applies the
      <i class="docEmphasis">Book</i> constructor to the values
      <tt class="calibre34">9</tt>, <tt class="calibre34">"Close Calls"</tt>, and <tt class="calibre34">["John
      Long"]</tt> in order to produce a new value of type
      BookInfo.</p><a name="x_qf" class="calibre27" id="x_qf"></a><p class="docText">When we pattern match against the <i class="docEmphasis">Book</i> constructor, we
      <span class="docEmphasis">reverse</span> the construction process. First of all, we
      check to see if the value was created using that constructor. If it was,
      we inspect it to obtain the individual values that we originally
      supplied to the constructor when we created the value.</p><a name="x_rf" class="calibre27" id="x_rf"></a><p class="docText">Let's consider what happens if we match the pattern
      <tt class="calibre34">(Book id name authors)</tt> against our example
      expression:</p><ul class="calibre18"><li class="calibre19"><p class="docText">The match will succeed, because the constructor in
          the value matches the one in our pattern.</p></li><li class="calibre19"><p class="docText">The variable <span class="docMonofont">id</span> will be bound to
          <tt class="calibre34">9</tt>.</p></li><li class="calibre19"><p class="docText">The variable <span class="docMonofont">name</span> will be bound
          to <tt class="calibre34">"Close Calls"</tt>.</p></li><li class="calibre19"><p class="docText">The variable <span class="docMonofont">authors</span> will be
          bound to <tt class="calibre34">["John Long"]</tt>.</p></li></ul><a name="x_wf" class="calibre27" id="x_wf"></a><p class="docText">Because pattern matching acts as the inverse of
      construction, it's sometimes referred to as
      <span class="docEmphasis">de</span>construction.</p><a name="idd1e6779" class="calibre27" id="idd1e6779"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_xf" class="calibre27" id="x_xf"></a></p><p class="docText">If you're steeped in object-oriented programming
        jargon, don't confuse deconstruction with destruction! Matching a
        pattern has no effect on the value we're examining: it just lets us
        "look inside" it.</p></div><a name="deftypes_patternd1e6787" class="calibre27" id="deftypes_patternd1e6787"></a><h4 id="title-IDA3DFTE" class="docSection1Title">3.4.2. Further Adventures</h4><a name="x_f5" class="calibre27" id="x_f5"></a><p class="docText">The syntax for pattern matching on a tuple is similar to
      the syntax for constructing a tuple. Here's a function that returns the
      last element of a 3-tuple:</p><pre class="calibre39">-- file: ch03/Tuple.hs
third (a, b, c) = c</pre><br class="calibre48"/>
<a name="x_g5" class="calibre27" id="x_g5"></a><p class="docText">There's no limit on how "deep" within a
      value a pattern can look. This definition looks both inside a tuple and
      inside a list within that tuple:</p><pre class="calibre39">-- file: ch03/Tuple.hs
complicated (True, a, x:xs, 5) = (a, xs)</pre><br class="calibre48"/>
<a name="x_h5" class="calibre27" id="x_h5"></a><p class="docText">We can try this out interactively:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load Tuple.hs</b>
[1 of 1] Compiling Main             ( Tuple.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">complicated (True, 1, [1,2,3], 5)</b>
(1,[2,3])</pre><a name="x_i5" class="calibre27" id="x_i5"></a><p class="docText">Wherever a literal value is present in a pattern
      (<tt class="calibre34">TRue</tt> and <tt class="calibre34">5</tt> in the preceding pattern), that value must
      match exactly for the pattern match to succeed. If every pattern within
      a series of equations fails to match, we get a runtime error:</p><pre class="calibre39">ghci&gt; <b class="calibre40">complicated (False, 1, [1,2,3], 5)</b>
*** Exception: Tuple.hs:10:0-39: Non-exhaustive patterns in function complicated
</pre><a name="x_yf" class="calibre27" id="x_yf"></a><p class="docText">For an explanation of this error message, skip forward
      to the section <a class="docLink" href="#deftypes_patterns_nonexhaustive">Section 3.4.5</a>.</p><a name="x_j5" class="calibre27" id="x_j5"></a><p class="docText">We can pattern match on an algebraic data type using its
      value constructors. Recall the <tt class="calibre34">BookInfo</tt> type we defined
      earlier; we can extract the values from a <tt class="calibre34">BookInfo</tt> as
      follows:</p><pre class="calibre39">-- file: ch03/BookStore.hs
bookID      (Book id title authors) = id
bookTitle   (Book id title authors) = title
bookAuthors (Book id title authors) = authors</pre><br class="calibre48"/>
<a name="x_k5" class="calibre27" id="x_k5"></a><p class="docText">Let's see it in action:</p><pre class="calibre39">ghci&gt; <b class="calibre40">bookID (Book 3 "Probability Theory" ["E.T.H. Jaynes"])</b>
3
ghci&gt; <b class="calibre40">bookTitle (Book 3 "Probability Theory" ["E.T.H. Jaynes"])</b>
"Probability Theory"
ghci&gt; <b class="calibre40">bookAuthors (Book 3 "Probability Theory" ["E.T.H. Jaynes"])</b>
["E.T.H. Jaynes"]</pre><a name="x_l5" class="calibre27" id="x_l5"></a><p class="docText">The compiler can infer the types of the accessor
      functions based on the constructor that we're using in our
      pattern:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type bookID</b>
bookID :: BookInfo -&gt; Int
ghci&gt; <b class="calibre40">:type bookTitle</b>
bookTitle :: BookInfo -&gt; String
ghci&gt; <b class="calibre40">:type bookAuthors</b>
bookAuthors :: BookInfo -&gt; [String]</pre><a name="x_IL" class="calibre27" id="x_IL"></a><p class="docText">If we use a literal value in a pattern, the
      corresponding part of the value that we're matching against must contain
      an identical value. For instance, the pattern <tt class="calibre34">(3:xs)</tt> first
      checks that a value is a nonempty list, by matching against the
      <i class="docEmphasis">(:)</i> constructor. It also ensures
      that the head of the list has the exact value <tt class="calibre34">3</tt>. If both of these conditions hold, the tail
      of the list will be bound to the variable <span class="docMonofont">xs</span>.</p><a name="deftypes_patternd1e6894" class="calibre27" id="deftypes_patternd1e6894"></a><h4 id="title-IDA2HFTE" class="docSection1Title">3.4.3. Variable Naming in Patterns</h4><a name="x_zf" class="calibre27" id="x_zf"></a><p class="docText">As you read functions<a name="I_indexterm3_d1e6832" class="calibre27" id="I_indexterm3_d1e6832"></a> that match on lists, you'll frequently find that the
      names of the variables inside a pattern resemble <tt class="calibre34">(x:xs)</tt> or
      <tt class="calibre34">(d:ds)</tt>. This is a popular naming convention. The idea is
      that the name <span class="docMonofont">xs</span> has an <tt class="calibre34">s</tt> on the end of
      its name as if it's the "plural" of <span class="docMonofont">x</span>,
      because <span class="docMonofont">x</span> contains the head of the list, and
      <span class="docMonofont">xs</span> contains the remaining elements.</p><a name="deftypes_wildcard" class="calibre27" id="deftypes_wildcard"></a><h4 id="title-IDA2IFTE" class="docSection1Title">3.4.4. The Wild Card Pattern</h4><a name="x_o5" class="calibre27" id="x_o5"></a><p class="docText">We can<a name="I_indexterm3_d1e6868" class="calibre27" id="I_indexterm3_d1e6868"></a><a name="I_indexterm3_d1e6871" class="calibre27" id="I_indexterm3_d1e6871"></a> indicate that we don't care what is present in part of a
      pattern. The notation for this is the <a name="I_indexterm3_d1e6877" class="calibre27" id="I_indexterm3_d1e6877"></a><a name="I_indexterm3_d1e6880" class="calibre27" id="I_indexterm3_d1e6880"></a>underscore character (_), which we call a
      <span class="docEmphasis">wild card</span>. We use it as follows:</p><pre class="calibre39">-- file: ch03/BookStore.hs
nicerID      (Book id _     _      ) = id
nicerTitle   (Book _  title _      ) = title
nicerAuthors (Book _  _     authors) = authors</pre><br class="calibre48"/>
<a name="x_p5" class="calibre27" id="x_p5"></a><p class="docText">Here, we have tidier versions of the accessor functions
      that we introduced earlier. Now, there's no question about which element
      we're using in each function.</p><a name="x_KL" class="calibre27" id="x_KL"></a><p class="docText">In a pattern, a wild card acts similarly to a variable,
      but it doesn't bind a new variable. As the previous examples indicate,
      we can use more than one wild card in a single pattern.</p><a name="x_LL" class="calibre27" id="x_LL"></a><p class="docText">Another advantage of wild cards is
      that a Haskell compiler can warn us if we introduce a variable name in a
      pattern, but then not use it in a function's body. Defining a variable
      but forgetting to use it can often indicate the presence of a bug, so
      this is a helpful feature. If we use a wild card instead of a variable
      that we do not intend to use, the compiler won't complain.</p><a name="deftypes_patterns_nonexhaustive" class="calibre27" id="deftypes_patterns_nonexhaustive"></a><h4 id="title-IDAGKFTE" class="docSection1Title">3.4.5. Exhaustive Patterns and Wild Cards</h4><a name="x_Ag" class="calibre27" id="x_Ag"></a><p class="docText">When writing a series of patterns, it's important to
      cover all of a type's<a name="I_indexterm3_d1e6904" class="calibre27" id="I_indexterm3_d1e6904"></a> constructors. For example, if we're inspecting a list, we
      should have one equation that matches the non-empty constructor
      <i class="docEmphasis">(:)</i> and one that matches the
      empty-list <a name="I_indexterm3_d1e6911" class="calibre27" id="I_indexterm3_d1e6911"></a><a name="I_indexterm3_d1e6916" class="calibre27" id="I_indexterm3_d1e6916"></a>constructor <i class="docEmphasis">[]</i>.</p><a name="x_Bg" class="calibre27" id="x_Bg"></a><p class="docText">Let's see what happens if we fail to cover all the
      cases. Here, we deliberately omit a check for the <i class="docEmphasis">[]</i> constructor:</p><pre class="calibre39">-- file: ch03/BadPattern.hs
badExample (x:xs) = x + badExample xs</pre><br class="calibre48"/>
<a name="x_Cg" class="calibre27" id="x_Cg"></a><p class="docText">If we apply this to a value that it cannot match, we'll
      get an error at runtime—our software has a bug!</p><pre class="calibre39">ghci&gt; <b class="calibre40">badExample []</b>
*** Exception: BadPattern.hs:4:0-36: Non-exhaustive patterns in function badExample
</pre><a name="x_Dg" class="calibre27" id="x_Dg"></a><p class="docText">In this example, no equation in the function's
      definition matches the value <tt class="calibre34">[]</tt>.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Warning about incomplete patterns</p><a name="x_Eg" class="calibre27" id="x_Eg"></a><p class="docText"><span class="docMonofont">GHC</span>
        provides a helpful compilation<a name="I_indexterm3_d1e6952" class="calibre27" id="I_indexterm3_d1e6952"></a> option,<i class="docEmphasis"> -fwarn-incomplete-</i><i class="docEmphasis">patterns</i>, that will cause it to print a
        warning during compilation if a sequence of patterns doesn't match all
        of a type's value constructors.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_Fg" class="calibre27" id="x_Fg"></a><p class="docText">If we need to provide a default behavior in cases where
      we don't care about specific constructors, we can use a wild card
      pattern:</p><pre class="calibre39">-- file: ch03/BadPattern.hs
goodExample (x:xs) = x + goodExample xs
goodExample _      = 0</pre><br class="calibre48"/>
<a name="x_Gg" class="calibre27" id="x_Gg"></a><p class="docText">The wild card shown in the preceding code will match the
      <tt class="calibre34">[]</tt> constructor, so applying this function does not lead to
      a crash:</p><pre class="calibre39">ghci&gt; <b class="calibre40">goodExample []</b>
0
ghci&gt; <b class="calibre40">goodExample [1,2]</b>
3</pre>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="deftypes_adt.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="deftypes_record.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

