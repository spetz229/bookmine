---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect16_d1e17476.html
next: jsonclass_instances_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect16_d1e17476.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="jsonclass_instances_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect16_d1e17824" class="calibre27" id="I_sect16_d1e17824"></a><h3 id="title-IDALQJIL" class="docSection1Title">6.8. How to Give a Type a New Identity</h3><a name="x_Q01" class="calibre27" id="x_Q01"></a><p class="docText">In<a name="I_indexterm6_d1e17829" class="calibre27" id="I_indexterm6_d1e17829"></a><a name="I_indexterm6_d1e17830" class="calibre27" id="I_indexterm6_d1e17830"></a><a name="ch06-newidenty" class="calibre27" id="ch06-newidenty"></a> addition to the familiar <tt class="calibre34">data</tt> keyword, Haskell provides us with another
    way to create a new type, using<a name="ch06-newtypekeyword" class="calibre27" id="ch06-newtypekeyword"></a> the <tt class="calibre34">newtype</tt> keyword:</p><pre class="calibre39">-- file: ch06/Newtype.hs
data DataInt = D Int
    deriving (Eq, Ord, Show)

newtype NewtypeInt = N Int
    deriving (Eq, Ord, Show)</pre><br class="calibre48"/>
<a name="x_R01" class="calibre27" id="x_R01"></a><p class="docText">The purpose of a <tt class="calibre34">newtype</tt> declaration is to
    rename an existing type, giving it a distinct identity. As we can see, it
    is similar in appearance to a type declared using the <tt class="calibre34">data</tt> keyword.</p><a name="I_sect16_d1e17824d1e18212" class="calibre27" id="I_sect16_d1e17824d1e18212"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_CE1" class="calibre27" id="x_CE1"></a></p><p class="docText">Although their names are similar, the <tt class="calibre34">type</tt> and <tt class="calibre34">newtype</tt> keywords have
      different purposes. The <tt class="calibre34">type</tt> keyword
      gives us another way of referring to a type, like a nickname for a
      friend. We and the compiler know that [Char] and
      String names refer to the same type.</p><a name="x_DE1" class="calibre27" id="x_DE1"></a><p class="docText">In contrast, the <tt class="calibre34">newtype</tt> keyword exists to
      <span class="docEmphasis">hide</span> the nature of a type. Consider a
      UniqueID type:</p><pre class="calibre39">-- file: ch06/Newtype.hs
newtype UniqueID = UniqueID Int
    deriving (Eq)</pre><br class="calibre48"/>
<a name="x_EE1" class="calibre27" id="x_EE1"></a><p class="docText">The compiler treats UniqueID as a
      different type from Int. As a user of a
      UniqueID, we know only that we have a unique identifier; we
      cannot see that it is implemented as an Int.</p></div><a name="x_S01" class="calibre27" id="x_S01"></a><p class="docText">When we declare a <tt class="calibre34">newtype</tt>, we must choose
    which of the underlying type's typeclass instances we want to expose.
    Here, we've elected to make NewtypeInt provide
    Int's instances for Eq, Ord, and
    Show. As a result, we can compare and print values of type
    NewtypeInt:</p><pre class="calibre39">ghci&gt; <b class="calibre40">N 1 &lt; N 2</b>
True
</pre><a name="x_T01" class="calibre27" id="x_T01"></a><p class="docText">Since we are <span class="docEmphasis">not</span> exposing
    Int's Num or Integral instances,
    values of type NewtypeInt are not numbers. For instance, we
    can't add them:</p><pre class="calibre39">ghci&gt; <b class="calibre40">N 313 + N 37</b>

&lt;interactive&gt;:1:0:
    No instance for (Num NewtypeInt)
      arising from a use of `+' at &lt;interactive&gt;:1:0-11
    Possible fix: add an instance declaration for (Num NewtypeInt)
    In the expression: N 313 + N 37
    In the definition of `it': it = N 313 + N 37
</pre><a name="x_U01" class="calibre27" id="x_U01"></a><p class="docText">As with the<a name="I_indexterm6_d1e17959" class="calibre27" id="I_indexterm6_d1e17959"></a> <tt class="calibre34">data</tt> keyword, we can use
    a <tt class="calibre34">newtype</tt>'s value constructor to create a new value or to
    pattern match on an existing value.</p><a name="x_FE1" class="calibre27" id="x_FE1"></a><p class="docText">If a <tt class="calibre34">newtype</tt> does not use automatic deriving
    to expose the underlying type's implementation of a typeclass, we are free
    to either write a new instance or leave the typeclass
    unimplemented.</p><a name="I_sect16_d1e17824d1e18332" class="calibre27" id="I_sect16_d1e17824d1e18332"></a><h4 id="title-IDAKVJIL" class="docSection1Title">6.8.1. Differences Between Data and Newtype Declarations</h4><a name="x_V01" class="calibre27" id="x_V01"></a><p class="docText">The <tt class="calibre34">newtype</tt> keyword exists to give an
      existing type a new identity, and it has more restrictions on its uses
      than the <tt class="calibre34">data</tt> keyword. Specifically,
      a <tt class="calibre34">newtype</tt> can have only one value constructor, which must
      have exactly one field:</p><pre class="calibre39">-- file: ch06/NewtypeDiff.hs
-- ok: any number of fields and constructors
data TwoFields = TwoFields Int Int

-- ok: exactly one field
newtype Okay = ExactlyOne Int

-- ok: type parameters are no problem
newtype Param a b = Param (Either a b)

-- ok: record syntax is fine
newtype Record = Record {
      getInt :: Int
    }

-- bad: no fields
newtype TooFew = TooFew

-- bad: more than one field
newtype TooManyFields = Fields Int Int

-- bad: more than one constructor
newtype TooManyCtors = Bad Int
                     | Worse Int</pre><br class="calibre48"/>
<a name="x_W01" class="calibre27" id="x_W01"></a><p class="docText">Beyond this, there's another important difference
      between <tt class="calibre34">data</tt> and
      <tt class="calibre34">newtype</tt>. A type created with the <tt class="calibre34">data</tt> keyword has a bookkeeping cost at
      runtime, for example, in order to track which constructor created a
      value. A <tt class="calibre34">newtype</tt> value, on the other hand, can have only
      one constructor and so does not need this overhead. This makes it more
      space- and time-efficient at runtime.</p><a name="x_X01" class="calibre27" id="x_X01"></a><p class="docText">Because a <tt class="calibre34">newtype</tt>'s constructor is used
      only at compile time and does not even exist at runtime, pattern
      matching on <tt class="calibre34">undefined</tt> behaves differently for types defined
      using <tt class="calibre34">newtype</tt> than for those that use <tt class="calibre34">data</tt>.</p><a name="x_Y01" class="calibre27" id="x_Y01"></a><p class="docText">To understand the difference, let's first review what
      we might expect with a normal data type. We are already familiar with
      the idea that if <tt class="calibre34">undefined</tt> is evaluated at runtime, it
      causes a crash:</p><pre class="calibre39">ghci&gt; <b class="calibre40">undefined</b>
*** Exception: Prelude.undefined
</pre><a name="x_Z01" class="calibre27" id="x_Z01"></a><p class="docText">Here is a pattern match where we construct a
      DataInt using the <tt class="calibre34">D</tt> constructor and put
      <tt class="calibre34">undefined</tt> inside:</p><pre class="calibre39">ghci&gt; <b class="calibre40">case D undefined of D _ -&gt; 1</b>
1
</pre><a name="x_a01" class="calibre27" id="x_a01"></a><p class="docText">Since our pattern matches<a name="I_indexterm6_d1e18051" class="calibre27" id="I_indexterm6_d1e18051"></a> against the constructor but doesn't inspect the payload,
      <tt class="calibre34">undefined</tt> remains unevaluated and does not cause an
      exception to be thrown.</p><a name="x_b01" class="calibre27" id="x_b01"></a><p class="docText">In this example, we're not using the <tt class="calibre34">D</tt>
      constructor, so the unprotected <tt class="calibre34">undefined</tt> is evaluated when
      the pattern match occurs, and we throw an exception:</p><pre class="calibre39">ghci&gt; <b class="calibre40">case undefined of D _ -&gt; 1</b>
*** Exception: Prelude.undefined
</pre><a name="x_c01" class="calibre27" id="x_c01"></a><p class="docText">When we use the <tt class="calibre34">N</tt> constructor for the
      NewtypeInt type, we see the same behavior that we did with
      the DataInt type's <tt class="calibre34">D</tt> constructor—no
      exception:</p><pre class="calibre39">ghci&gt; <b class="calibre40">case N undefined of N _ -&gt; 1</b>
1
</pre><a name="x_d01" class="calibre27" id="x_d01"></a><p class="docText">The crucial difference arises when we get rid of the
      <tt class="calibre34">N</tt> constructor from the expression and match against an
      unprotected <tt class="calibre34">undefined</tt>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">case undefined of N _ -&gt; 1</b>
1
</pre><a name="x_e01" class="calibre27" id="x_e01"></a><p class="docText">We don't crash! Because there's no constructor present
      at runtime, matching against <tt class="calibre34">N _</tt> is in fact equivalent to
      matching against the plain wild card (<tt class="calibre34">_</tt>). Since the wild
      card always matches, the expression does not need to be
      evaluated.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Another perspective on newtype constructors</p><a name="x_f01" class="calibre27" id="x_f01"></a><p class="docText">Even though we use the value constructor for a
        <tt class="calibre34">newtype</tt> in the same way as that of a type defined using
        the <tt class="calibre34">data</tt> keyword, all it does is
        coerce a value between its "normal" type and its
        <tt class="calibre34">newtype</tt> type.</p><a name="x_g01" class="calibre27" id="x_g01"></a><p class="docText">In other words, when we apply the <tt class="calibre34">N</tt>
        constructor in an expression, we coerce an expression from type
        Int to type NewtypeInt as far as we and the
        compiler are concerned, but absolutely nothing occurs at
        runtime.</p><a name="x_h01" class="calibre27" id="x_h01"></a><p class="docText">Similarly, when we match on the <tt class="calibre34">N</tt>
        constructor in a pattern, we coerce an expression from type
        NewtypeInt to Int, but again there's no
        overhead involved at runtime.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="I_sect16_d1e17824d1e18511" class="calibre27" id="I_sect16_d1e17824d1e18511"></a><h4 id="title-IDA50JIL" class="docSection1Title">6.8.2. Summary: The Three Ways of Naming Types</h4><a name="x_i01" class="calibre27" id="x_i01"></a><p class="docText">Here's a brief recap of Haskell's three ways to
      introduce new names for types:</p><ul class="calibre18"><li class="calibre19"><p class="docText">The <tt class="calibre34">data</tt> keyword introduces a truly
          new algebraic data type.</p></li><li class="calibre19"><p class="docText">The <tt class="calibre34">type</tt> keyword gives us a synonym to
          use for an existing type. We can use the type and its synonym
          interchangeably.</p></li><li class="calibre19"><p class="docText">The <tt class="calibre34">newtype</tt> keyword gives an existing
          type a distinct identity. The original type and the new type are
          <span class="docEmphasis">not</span> interchangeable.</p></li></ul>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect16_d1e17476.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="jsonclass_instances_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

