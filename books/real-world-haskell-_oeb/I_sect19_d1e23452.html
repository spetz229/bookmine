---
layout: page
title: "Real World Haskell, 1st Edition"
prev: find_simpleFind.html
next: I_sect19_d1e23695_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="find_simpleFind.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect19_d1e23695_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect19_d1e23452" class="calibre27" id="I_sect19_d1e23452"></a><h3 id="title-IDA03OTH" class="docSection1Title">9.4. Predicates: From Poverty to Riches, While Remaining Pure</h3><a name="x_PO" class="calibre27" id="x_PO"></a><p class="docText">Our <a name="ch09-predicates" class="calibre27" id="ch09-predicates"></a><a name="I_indexterm9_d1e23462" class="calibre27" id="I_indexterm9_d1e23462"></a>predicates can only look at filenames. This excludes a wide
    variety of interesting behaviors—for instance, what if we'd like to list
    files greater than a given size?</p><a name="x_QO" class="calibre27" id="x_QO"></a><p class="docText">An easy reaction to this is to reach for IO:
    instead of our predicate being of type FilePath -&gt; Bool,
    why don't we change it to FilePath -&gt; IO Bool? This would
    let us perform arbitrary I/O as part of our predicate. As appealing as
    this might seem, it's also potentially a problem: such a predicate could
    have arbitrary side effects, since a function with return type IO
    a can have whatever side effects it pleases.</p><a name="x_RO" class="calibre27" id="x_RO"></a><p class="docText">Let's enlist the type system in our quest to write more
    predictable, less buggy code; we'll keep predicates pure by avoiding the
    taint of "IO." This will ensure that they can't have any nasty side
    effects. We'll feed them more information, too, so that they can gain the
    expressiveness we want without also becoming potentially dangerous.</p><a name="x_SO" class="calibre27" id="x_SO"></a><p class="docText">Haskell's portable <tt class="calibre34">System.Directory</tt> module
    provides a useful, albeit limited, set of file metadata:</p><pre class="calibre39">        ghci&gt; 
        <b class="calibre40">:m +System.Directory</b></pre><p class="docText">We can use <i class="docEmphasis">doesFileExist</i> and
    <i class="docEmphasis">doesDirectoryExist</i> to determine
    whether a directory entry is a file or a directory. There are not yet
    portable ways to query for other file types that have become widely
    available in recent years, such as named pipes, hard links, and symbolic
    links:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type doesFileExist</b>
doesFileExist :: FilePath -&gt; IO Bool
ghci&gt; <b class="calibre40">doesFileExist "."</b>
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package directory-1.0.0.1 ... linking ... done.
False
ghci&gt; <b class="calibre40">:type doesDirectoryExist</b>
doesDirectoryExist :: FilePath -&gt; IO Bool
ghci&gt; <b class="calibre40">doesDirectoryExist "."</b>
True</pre><br class="calibre48"/>
<p class="docText">The <i class="docEmphasis">getPermissions</i> function
    lets us find out whether certain operations on a file or directory are
    allowed:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type getPermissions</b>
getPermissions :: FilePath -&gt; IO Permissions
ghci&gt; <b class="calibre40">:info Permissions</b>
data Permissions
  = Permissions {readable :: Bool,
                 writable :: Bool,
                 executable :: Bool,
                 searchable :: Bool}
  	-- Defined in System.Directory
instance Eq Permissions -- Defined in System.Directory
instance Ord Permissions -- Defined in System.Directory
instance Read Permissions -- Defined in System.Directory
instance Show Permissions -- Defined in System.Directory
ghci&gt; <b class="calibre40">getPermissions "."</b>
Permissions {readable = True, writable = True, executable = False, searchable = True}
ghci&gt; <b class="calibre40">:type searchable</b>
searchable :: Permissions -&gt; Bool
ghci&gt; <b class="calibre40">searchable it</b>
True</pre><br class="calibre48"/>
<p class="docText">Finally, <i class="docEmphasis">getModificationTime</i>
    tells us when an entry was last modified:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type getModificationTime</b>
getModificationTime :: FilePath -&gt; IO System.Time.ClockTime
ghci&gt; <b class="calibre40">getModificationTime "."</b>
Sat Aug 23 22:28:16 PDT 2008</pre><br class="calibre48"/>
<a name="x_XO" class="calibre27" id="x_XO"></a><p class="docText">If we stick with portable, standard Haskell code, these
    functions are all we have at our disposal. (We can also find a file's size
    using a small hack; see below.) They're also quite enough to let us
    illustrate the principles we're interested in, without letting us get
    carried away with an example that's too expansive. If you need to write
    more demanding code, <a name="I_indexterm9_d1e23575" class="calibre27" id="I_indexterm9_d1e23575"></a><a name="I_indexterm9_d1e23578" class="calibre27" id="I_indexterm9_d1e23578"></a>the <tt class="calibre34">System.Posix</tt> and <tt class="calibre34">System.Win32</tt>
    module families provide much more detailed file metadata for the two major
    modern computing platforms. There also exists a <tt class="calibre34">unix-compat</tt>
    package<a name="I_indexterm9_d1e23591" class="calibre27" id="I_indexterm9_d1e23591"></a> on Hackage, which provides a Unix-like API on
    Windows.</p><a name="x_YO" class="calibre27" id="x_YO"></a><p class="docText">How many pieces of data does our new, richer predicate
    need to see? Since we can find out whether an entry is a file or a
    directory by looking at its Permissions, we don't need to
    pass in the results of <i class="docEmphasis">doesFileExist</i>
    or <i class="docEmphasis">doesDirectoryExist</i>. We thus have
    four pieces of data that a richer predicate needs to look at:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
import Control.Monad (filterM)
import System.Directory (Permissions(..), getModificationTime, getPermissions)
import System.Time (ClockTime(..))
import System.FilePath (takeExtension)
import Control.Exception (bracket, handle)
import System.IO (IOMode(..), hClose, hFileSize, openFile)

-- the function we wrote earlier
import RecursiveContents (getRecursiveContents)

type Predicate =  FilePath      -- path to directory entry
               -&gt; Permissions   -- permissions
               -&gt; Maybe Integer -- file size (Nothing if not file)
               -&gt; ClockTime     -- last modified
               -&gt; Bool</pre><br class="calibre48"/>
<a name="x_zE1" class="calibre27" id="x_zE1"></a><p class="docText">Our Predicate type is just a synonym for a
    function of four arguments. It will save us a little keyboard work and
    screen space.</p><a name="x_ZO" class="calibre27" id="x_ZO"></a><p class="docText">Notice that the return value of this predicate is
    Bool, not IO Bool: the predicate is pure and
    cannot perform I/O. With this type in hand, our more expressive finder
    function is still quite trim:</p><pre class="calibre39">-- file: ch09/BetterPredicate.hs
-- soon to be defined
getFileSize :: FilePath -&gt; IO (Maybe Integer)

betterFind :: Predicate -&gt; FilePath -&gt; IO [FilePath]

betterFind p path = getRecursiveContents path &gt;&gt;= filterM check
    where check name = do
            perms &lt;- getPermissions name
            size &lt;- getFileSize name
            modified &lt;- getModificationTime name
            return (p name perms size modified)</pre><br class="calibre48"/>
<a name="x_aO" class="calibre27" id="x_aO"></a><p class="docText">Let's walk through the code. We'll talk about <i class="docEmphasis">getFileSize</i> in some detail soon, so let's skip
    over it for now.</p><a name="x_bO" class="calibre27" id="x_bO"></a><p class="docText">We can't use <i class="docEmphasis">filter</i>
    to call our predicate <span class="docMonofont">p</span>, as <span class="docMonofont">p</span>'s
    purity means it cannot do the I/O needed to gather the metadata it
    requires.</p><a name="x_cO" class="calibre27" id="x_cO"></a><p class="docText">This leads us to the unfamiliar function <i class="docEmphasis">filterM</i>. It behaves like the normal <i class="docEmphasis">filter</i> function, but in this case it evaluates
    its predicate in the IO monad, allowing the predicate to
    perform I/O:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad</b>ghci&gt; <b class="calibre40">:type filterM</b>
filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]</pre><a name="x_dO" class="calibre27" id="x_dO"></a><p class="docText">Our <i class="docEmphasis">check</i> predicate
    is an I/O-capable wrapper for our pure predicate <span class="docMonofont">p</span>. It
    does all the "dirty" work of I/O on <span class="docMonofont">p</span>'s
    behalf so that we can keep <span class="docMonofont">p</span> incapable of unwanted side
    effects. After gathering the metadata, <i class="docEmphasis">check</i> calls <span class="docMonofont">p</span>, and then uses
    <i class="docEmphasis">return</i> to wrap <span class="docMonofont">p</span>'s
    result with IO.</p>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="find_simpleFind.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect19_d1e23695_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

