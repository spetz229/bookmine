---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect114_d1e31941.html
next: monads_do.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect114_d1e31941.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="monads_do.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect114_d1e32163" class="calibre27" id="I_sect114_d1e32163"></a><h3 id="title-IDA2PCZG" class="docSection1Title">14.11. The List Monad</h3><a name="x_eY" class="calibre27" id="x_eY"></a><p class="docText">While <a name="ch14-listsmonads" class="calibre27" id="ch14-listsmonads"></a><a name="ch14-monlistds" class="calibre27" id="ch14-monlistds"></a>the <tt class="calibre34">Maybe</tt> type can represent either no value or
    one, there are many situations where we might want to return some number
    of results that we do not know in advance. Obviously, a list is well
    suited to this purpose. The type of a list suggests that we might be able
    to use it as a monad, because its type constructor has one free variable.
    And sure enough, we can use a list as a monad.</p><a name="x_fY" class="calibre27" id="x_fY"></a><p class="docText">Rather than simply present the
    <tt class="calibre34">Prelude</tt>'s <tt class="calibre34">Monad</tt> instance for the list
    type, let's try to figure out what an instance <span class="docEmphasis">ought</span>
    to look like. This is easy to do: we'll look at the types of <i class="docEmphasis">(&gt;&gt;=)</i> and<a name="I_indexterm14_d1e32196" class="calibre27" id="I_indexterm14_d1e32196"></a> <tt class="calibre34">return</tt>, perform some
    substitutions, and see if we can use a few familiar list functions.</p><a name="x_gY" class="calibre27" id="x_gY"></a><p class="docText">The more obvious of the two functions is <tt class="calibre34">return</tt>. We<a name="I_indexterm14_d1e32211" class="calibre27" id="I_indexterm14_d1e32211"></a> know that it takes a type <span class="docMonofont">a</span>,
    and wraps it in a type constructor <span class="docMonofont">m</span> to
    give the type <span class="docMonofont">m a</span>. We also know that the
    type constructor here is []. Substituting this type
    constructor for the type variable <span class="docMonofont">m</span> gives
    us the type [] a (yes, this really is valid notation!), which
    we can rewrite in more familiar form as [a].</p><a name="x_hY" class="calibre27" id="x_hY"></a><p class="docText">We now know that <tt class="calibre34">return</tt>
    for lists should have the type <tt class="calibre34">a -&gt; [a]</tt>. There are only a
    few sensible possibilities for an implementation of this function. It
    might return the empty list, a singleton list, or an infinite list. The
    most appealing behavior, based on what we know so far about monads, is the
    singleton list—it doesn't throw away information, nor does it repeat it
    infinitely:</p><pre class="calibre39">-- file: ch14/ListMonad.hs
returnSingleton :: a -&gt; [a]
returnSingleton x = [x]</pre><br class="calibre48"/>
<a name="x_iY" class="calibre27" id="x_iY"></a><p class="docText">If we perform the same substitution trick on the type of
    <i class="docEmphasis">(&gt;&gt;=)</i> as we did with <tt class="calibre34">return</tt>, we discover that it should have the type
    <tt class="calibre34">[a] -&gt; (a -&gt; [b]) -&gt; [b]</tt>. This seems close to the
    type of <i class="docEmphasis">map</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (&gt;&gt;=)</b>
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
ghci&gt; <b class="calibre40">:type map</b>
map :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre><a name="x_jY" class="calibre27" id="x_jY"></a><p class="docText">The ordering of the types in <i class="docEmphasis">map</i>'s arguments doesn't match, but that's easy
    to fix:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (&gt;&gt;=)</b>
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
ghci&gt; <b class="calibre40">:type flip map</b>
flip map :: [a] -&gt; (a -&gt; b) -&gt; [b]</pre><a name="x_kY" class="calibre27" id="x_kY"></a><p class="docText">We've still got a problem: the second argument of
    <tt class="calibre34">flip map</tt> has the type <tt class="calibre34">a -&gt; b</tt>, whereas the
    second argument of <i class="docEmphasis">(&gt;&gt;=)</i> for
    lists has the type <tt class="calibre34">a -&gt; [b]</tt>. What do we do about
    this?</p><a name="x_lY" class="calibre27" id="x_lY"></a><p class="docText">Let's do a little more substitution and see what happens
    with the types. The function <tt class="calibre34">flip map</tt> can return any type
    <span class="docMonofont">b</span> as its result. If we substitute <span class="docMonofont">[b]</span> for <span class="docMonofont">b</span> in both
    places where it appears in <tt class="calibre34">flip map</tt>'s type signature, its
    type signature reads as <tt class="calibre34">a -&gt; (a -&gt; [b]) -&gt; [[b]]</tt>. In
    other words, if we map a function that returns a list over a list, we get
    a list of lists back:</p><pre class="calibre39">ghci&gt; <b class="calibre40">flip map [1,2,3] (\a -&gt; [a,a+100])</b>
[[1,101],[2,102],[3,103]]
</pre><a name="x_mY" class="calibre27" id="x_mY"></a><p class="docText">Interestingly, we haven't really changed how closely our
    type signatures match. The type of <i class="docEmphasis">(&gt;&gt;=)</i> is <tt class="calibre34">[a] -&gt; (a -&gt; [b])
    -&gt; [b]</tt>, while that of <tt class="calibre34">flip map</tt> when the mapped
    function returns a list is <tt class="calibre34">[a] -&gt; (a -&gt; [b]) -&gt;
    [[b]]</tt>. There's still a mismatch in one type term—we've just moved
    that term from the middle of the type signature to the end. However, our
    juggling wasn't in vain—we now need a function that takes a
    [[b]] and returns a [b], and one readily
    suggests itself in the form<a name="I_indexterm14_d1e32353" class="calibre27" id="I_indexterm14_d1e32353"></a> of <i class="docEmphasis">concat</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type concat</b>
concat :: [[a]] -&gt; [a]
</pre><a name="x_nY" class="calibre27" id="x_nY"></a><p class="docText">The types suggest that we should flip the arguments to
    <i class="docEmphasis">map</i>, and then <i class="docEmphasis">concat</i> the results to give a single
    list:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type \xs f -&gt; concat (map f xs)</b>
\xs f -&gt; concat (map f xs) :: [a] -&gt; (a -&gt; [a1]) -&gt; [a1]
</pre><a name="x_oY" class="calibre27" id="x_oY"></a><p class="docText">This is exactly the definition of <i class="docEmphasis">(&gt;&gt;=)</i> for lists:</p><pre class="calibre39">-- file: ch14/ListMonad.hs
instance Monad [] where
    return x = [x]
    xs &gt;&gt;= f = concat (map f xs)</pre><br class="calibre48"/>
<a name="x_pY" class="calibre27" id="x_pY"></a><p class="docText">It applies <span class="docMonofont">f</span> to every element in the
    list <span class="docMonofont">xs</span>, and concatenates the results to return a
    single list.</p><a name="x_qY" class="calibre27" id="x_qY"></a><p class="docText">With our two core <tt class="calibre34">Monad</tt> definitions in hand,
    the implementations of the noncore definitions that remain, <i class="docEmphasis">(&gt;&gt;)</i> and <i class="docEmphasis">fail</i>, ought to be obvious:</p><pre class="calibre39">-- file: ch14/ListMonad.hs
    xs &gt;&gt; f = concat (map (\_ -&gt; f) xs)
    fail _ = []</pre><br class="calibre48"/>
<a name="I_sect114_d1e32163d1e32745" class="calibre27" id="I_sect114_d1e32163d1e32745"></a><h4 id="title-IDAUYCZG" class="docSection1Title">14.11.1. Understanding the List Monad</h4><a name="x_rY" class="calibre27" id="x_rY"></a><p class="docText">The list monad is similar to a familiar Haskell tool,
      the list comprehension. We can illustrate this similarity by computing
      the Cartesian product of two lists. First, we'll write a list
      comprehension:</p><pre class="calibre39">-- file: ch14/CartesianProduct.hs
comprehensive xs ys = [(x,y) | x &lt;- xs, y &lt;- ys]</pre><br class="calibre48"/>
<a name="x_sY" class="calibre27" id="x_sY"></a><p class="docText">For once, we'll use bracketed notation for the monadic
      code instead of layout notation. This will highlight how structurally
      similar the monadic code is to the list <span class="docEmphasis">comprehension</span>:</p><pre class="calibre39">-- file: ch14/CartesianProduct.hs
monadic xs ys = do { x &lt;- xs; y &lt;- ys; return (x,y) }</pre><br class="calibre48"/>
<a name="x_tY" class="calibre27" id="x_tY"></a><p class="docText">The only real difference is that the value we're
      constructing comes at the end of the sequence of expressions, instead of
      at the beginning as in the list comprehension. Also, the results of the
      two functions are identical:</p><pre class="calibre39">ghci&gt; <b class="calibre40">comprehensive [1,2] "bar"</b>
[(1,'b'),(1,'a'),(1,'r'),(2,'b'),(2,'a'),(2,'r')]
ghci&gt; <b class="calibre40">comprehensive [1,2] "bar" == monadic [1,2] "bar"</b>
True</pre><a name="x_uY" class="calibre27" id="x_uY"></a><p class="docText">It's easy to be baffled by the list monad early on, so
      let's walk through our monadic Cartesian product code again in more
      detail. This time, we'll rearrange the function to use layout instead of
      brackets:</p><pre class="calibre39">-- file: ch14/CartesianProduct.hs
blockyDo xs ys = do
    x &lt;- xs
    y &lt;- ys
    return (x, y)</pre><br class="calibre48"/>
<a name="x_vY" class="calibre27" id="x_vY"></a><p class="docText">For every element in the list <span class="docMonofont">xs</span>, the
      rest of the function is evaluated once, with <span class="docMonofont">x</span> bound
      to a different value from the list each time. Then for every element in
      the list <span class="docMonofont">ys</span>, the remainder of the function is
      evaluated once, with <span class="docMonofont">y</span> bound to a different value
      from the list each time.</p><a name="x_wY" class="calibre27" id="x_wY"></a><p class="docText">What we really have here is a doubly nested loop! This
      highlights an important fact about monads: you
      <span class="docEmphasis">cannot</span> predict how a block of monadic code will
      behave unless you know what monad it will execute in.</p><a name="x_xY" class="calibre27" id="x_xY"></a><p class="docText">We'll now walk through the code even more explicitly,
      but first let's get rid of the <tt class="calibre34">do</tt>
      notation to make the underlying structure clearer. We've indented the
      code a little unusually to make the loop nesting more obvious:</p><pre class="calibre39">-- file: ch14/CartesianProduct.hs
blockyPlain xs ys =
    xs &gt;&gt;=
    \x -&gt; ys &gt;&gt;=
    \y -&gt; return (x, y)

blockyPlain_reloaded xs ys =
    concat (map (\x -&gt;
                 concat (map (\y -&gt;
                              return (x, y))
                         ys))
            xs)</pre><br class="calibre48"/>
<a name="x_yY" class="calibre27" id="x_yY"></a><p class="docText">If <span class="docMonofont">xs</span> has the value
      <tt class="calibre34">[1,2,3]</tt>, the two lines that follow are evaluated with
      <span class="docMonofont">x</span> bound to <tt class="calibre34">1</tt>, then to <tt class="calibre34">2</tt>,
      and finally to <span class="docMonofont">3</span>. If <span class="docMonofont">ys</span> has the
      value <tt class="calibre34">[TRue, False]</tt>, the final line is evaluated
      <span class="docEmphasis">six</span> times: once with <span class="docMonofont">x</span> as
      <tt class="calibre34">1</tt> and <span class="docMonofont">y</span> as <tt class="calibre34">true</tt>; again with
      <span class="docMonofont">x</span> as <tt class="calibre34">1</tt> and <span class="docMonofont">y</span> as
      <tt class="calibre34">False</tt>; and so on. The <tt class="calibre34">return</tt> expression wraps each tuple in a
      single-element list.</p><a name="I_sect114_d1e32163d1e32862" class="calibre27" id="I_sect114_d1e32163d1e32862"></a><h4 id="title-IDAE2CZG" class="docSection1Title">14.11.2. Putting the List Monad to Work</h4><a name="x_gG1" class="calibre27" id="x_gG1"></a><p class="docText">Here is a simple brute-force constraint solver. Given
      an integer, it finds all pairs of positive integers that, when
      multiplied, give that value (this is the constraint being
      solved):</p><pre class="calibre39">-- file: ch14/MultiplyTo.hs
guarded :: Bool -&gt; [a] -&gt; [a]
guarded True  xs = xs
guarded False _  = []

multiplyTo :: Int -&gt; [(Int, Int)]
multiplyTo n = do
  x &lt;- [1..n]
  y &lt;- [x..n]
  guarded (x * y == n) $
    return (x, y)</pre><br class="calibre48"/>
<a name="x_hG1" class="calibre27" id="x_hG1"></a><p class="docText">Let's try this in <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">multiplyTo 8</b>
[(1,8),(2,4)]
ghci&gt; <b class="calibre40">multiplyTo 100</b>
[(1,100),(2,50),(4,25),(5,20),(10,10)]
ghci&gt; <b class="calibre40">multiplyTo 891</b>
[(1,891),(3,297),(9,99),(11,81),(27,33)]</pre>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="I_sect114_d1e31941.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="monads_do.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

