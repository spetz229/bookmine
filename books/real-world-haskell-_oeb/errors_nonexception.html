---
layout: page
title: "Real World Haskell, 1st Edition"
prev: errors_split_001.html
next: errors_exceptions_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="errors_split_000.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="errors_exceptions_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="errors_nonexception" class="calibre27" id="errors_nonexception"></a><h3 id="title-IDAHFQ0E" class="docSection1Title">19.1. Error Handling with Data Types</h3><a name="x_zy" class="calibre27" id="x_zy"></a><p class="docText">Let's begin our discussion<a name="ch19-typeserrorhandle" class="calibre27" id="ch19-typeserrorhandle"></a><a name="ch19-errorhandledata" class="calibre27" id="ch19-errorhandledata"></a> of error handling with a very simple function. Let's say
    that we wish to perform division on a series of numbers. We have a
    constant numerator but wish to vary the denominator. We might come up with
    a function like this:</p><pre class="calibre39">-- file: ch19/divby1.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; [a]
divBy numerator = map (numerator `div`)</pre><br class="calibre48"/>
<a name="x_Az" class="calibre27" id="x_Az"></a><p class="docText">Very simple, right? We can play around with this a bit in
    <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
[50,25,10,6,5]
ghci&gt; <b class="calibre40">take 5 (divBy 100 [1..])</b>
[100,50,33,25,20]</pre><a name="x_Bz" class="calibre27" id="x_Bz"></a><p class="docText">This behaves as expected: <tt class="calibre34">50 /
    1</tt> is <tt class="calibre34">50</tt>, <tt class="calibre34">50 / 2</tt> is <tt class="calibre34">25</tt>,
    and so forth.<sup class="docFootnote"><a class="docLink1" href="#x_Bzd1e41256">[40]</a></sup> This even worked with the infinite list <tt class="calibre34">[1..]</tt>. What happens if we sneak a <tt class="calibre34">0</tt> into our list somewhere?</p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_Bzd1e41256" class="calibre5" id="x_Bzd1e41256">[40]</a></sup> We're using integral division here, so <tt class="calibre34">50 / 8</tt> shows as <tt class="calibre34">6</tt> instead of <tt class="calibre34">6.25</tt>. We're not using floating-point
        arithmetic in this example because division by zero with a <tt class="calibre34">Double</tt> produces the special value <tt class="calibre34">Infinity</tt> rather than an error.</p></blockquote><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,0,8,10]</b>
[50,25,*** Exception: divide by zero
</pre><a name="x_Dz" class="calibre27" id="x_Dz"></a><p class="docText">Isn't that interesting? <i class="docEmphasis">ghci</i> started displaying the output, and then
    stopped with an exception when it got to the zero. That's lazy evaluation
    at work—it calculated results as needed.</p><a name="x_Ez" class="calibre27" id="x_Ez"></a><p class="docText">As we will see later in this chapter, in the absence of an
    explicit exception handler, this exception will crash the program. That's
    obviously not desirable, so let's consider better ways we could indicate
    an error in this pure function.</p><a name="errors_maybe" class="calibre27" id="errors_maybe"></a><h4 id="title-IDA4IQ0E" class="docSection1Title">19.1.1. Use of Maybe</h4><a name="x_Fz" class="calibre27" id="x_Fz"></a><p class="docText">One immediately recognizable and easy way to indicate
      failure is to <a name="ch19-maybemonads" class="calibre27" id="ch19-maybemonads"></a>use <tt class="calibre34">Maybe</tt>.<sup class="docFootnote"><a class="docLink1" href="#x_Fzd1e41307">[41]</a></sup> Instead of just returning a list and throwing an exception
      on failure, we can return <tt class="calibre34">Nothing</tt> if
      the input list contains a zero anywhere, or return <tt class="calibre34">Just</tt> with the results otherwise. Here's an
      implementation of such an algorithm:</p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_Fzd1e41307" class="calibre5" id="x_Fzd1e41307">[41]</a></sup> For an introduction to <tt class="calibre34">Maybe</tt>, refer to <a class="docLink" href="deftypes_error.html#deftypes_morecontrolled">Section 3.8.1</a>.</p></blockquote><pre class="calibre39">-- file: ch19/divby2.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; Maybe [a]
divBy _ [] = Just []
divBy _ (0:_) = Nothing
divBy numerator (denom:xs) =
    case divBy numerator xs of
      Nothing -&gt; Nothing
      Just results -&gt; Just ((numerator `div` denom) : results)</pre><br class="calibre48"/>
<a name="x_Hz" class="calibre27" id="x_Hz"></a><p class="docText">If you try it out in <i class="docEmphasis">ghci</i>, you'll see that it works:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
Just [50,25,10,6,5]
ghci&gt; <b class="calibre40">divBy 50 [1,2,0,8,10]</b>
Nothing</pre><a name="x_Iz" class="calibre27" id="x_Iz"></a><p class="docText">The function that calls <tt class="calibre34">divBy</tt> can now use a <tt class="calibre34">case</tt> statement to see if the call was
      successful, just as <tt class="calibre34">divBy</tt> does when
      it calls itself.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_YJ1" class="calibre27" id="x_YJ1"></a><p class="docText">You may note that you could use a monadic
        implementation of the preceding example, like so:</p><pre class="calibre39">-- file: ch19/divby2m.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; Maybe [a]
divBy numerator denominators = 
    mapM (numerator `safeDiv`) denominators
    where safeDiv _ 0 = Nothing
          safeDiv x y = x `div` y</pre><br class="calibre48"/>
<a name="x_ZJ1" class="calibre27" id="x_ZJ1"></a><p class="docText">We will avoid the monadic implementation in this
        chapter for simplicity but wanted to point out that it exists.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="errors_maybe_laziness" class="calibre27" id="errors_maybe_laziness"></a><h5 id="title-IDA0LQ0E" class="docSection3Title">19.1.1.1. Loss and preservation of laziness</h5><a name="x_Jz" class="calibre27" id="x_Jz"></a><p class="docText">The use of <tt class="calibre34">Maybe</tt> is
        convenient, but it has come at a cost. <tt class="calibre34">divBy</tt> can no longer handle infinite lists as
        input. Since the result is <tt class="calibre34">Maybe
        [a]</tt>, the entire input list must be examined before we can be
        sure that we won't be returning <tt class="calibre34">Nothing</tt> due to a zero somewhere in it. You
        can verify this is the case by attempting one of our earlier
        examples:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 100 [1..] </b>
*** Exception: stack overflow
</pre><a name="x_Kz" class="calibre27" id="x_Kz"></a><p class="docText">Note that you don't start seeing partial output here;
        you get <span class="docEmphasis">no</span> output. Notice that at each step in
        <tt class="calibre34">divBy</tt> (except for the case of an
        empty input list or a zero at the start of the list), the results from
        every subsequent element must be known before the results from the
        current element can be known. Thus this algorithm can't work on
        infinite lists, and it is also not very space-efficient for large
        finite lists.</p><a name="x_Lz" class="calibre27" id="x_Lz"></a><p class="docText">Having said all that, <tt class="calibre34">Maybe</tt> is often a fine choice. In this
        particular case, we don't know whether there will be a problem until
        we get into evaluating the entire input. Sometimes we know of a
        problem up front—for instance, <tt class="calibre34">tail
        []</tt> in <i class="docEmphasis">ghci</i> produces an
        exception. We could easily write an infinite-capable <tt class="calibre34">tail</tt> that doesn't have this problem:</p><pre class="calibre39">-- file: ch19/safetail.hs
safeTail :: [a] -&gt; Maybe [a]
safeTail [] = Nothing
safeTail (_:xs) = Just xs</pre><br class="calibre48"/>
<a name="x_Mz" class="calibre27" id="x_Mz"></a><p class="docText">This simply returns <tt class="calibre34">Nothing</tt> if given an empty input list or
        <tt class="calibre34">Just</tt> with the result for anything
        else. Since we have only to make sure the list is nonempty before
        knowing whether or not we have an error, using <tt class="calibre34">Maybe</tt> here doesn't reduce our laziness. We
        can test this out in <i class="docEmphasis">ghci</i> and see
        how it compares with regular <tt class="calibre34">tail</tt>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">tail [1,2,3,4,5]</b>
[2,3,4,5]
ghci&gt; <b class="calibre40">safeTail [1,2,3,4,5]</b>
Just [2,3,4,5]
ghci&gt; <b class="calibre40">tail []</b>
*** Exception: Prelude.tail: empty list
ghci&gt; <b class="calibre40">safeTail []</b>
Nothing</pre><a name="x_Nz" class="calibre27" id="x_Nz"></a><p class="docText">Here, we can see our <tt class="calibre34">safeTail</tt> performed as expected. But what
        about infinite lists? We don't want to print out an infinite number of
        results, so we can test with <tt class="calibre34">take 5 (tail
        [1..])</tt> and a similar construction with <tt class="calibre34">safeTail</tt>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">take 5 (tail [1..])</b>
[2,3,4,5,6]
ghci&gt; <b class="calibre40">case safeTail [1..] of {Nothing -&gt; Nothing; Just x -&gt; Just (take 5 x)}</b>
Just [2,3,4,5,6]
ghci&gt; <b class="calibre40">take 5 (tail [])</b>
*** Exception: Prelude.tail: empty list
ghci&gt; <b class="calibre40">case safeTail [] of {Nothing -&gt; Nothing; Just x -&gt; Just (take 5 x)}</b>
Nothing</pre><a name="x_Oz" class="calibre27" id="x_Oz"></a><p class="docText">Here you can see that both <tt class="calibre34">tail</tt> and <tt class="calibre34">safeTail</tt> handled infinite lists just fine.
        Note that we were able to deal better with an empty input list;
        instead of throwing an exception, we decided to return <tt class="calibre34">Nothing</tt> in that situation. We were able to
        achieve error handling at no expense to laziness.</p><a name="x_Pz" class="calibre27" id="x_Pz"></a><p class="docText">But how do we apply this to our <tt class="calibre34">divBy</tt> example? Let's consider the situation
        there. Failure is a property of an individual bad input, not of the
        input list itself. How about making failure a property of an
        individual output element, rather than the output list itself? That
        is, instead of a function of type <tt class="calibre34">a -&gt; [a] -&gt; Maybe [a]</tt>, we will
        have <tt class="calibre34">a -&gt; [a] -&gt; [Maybe a]</tt>.
        This will have the benefit of preserving laziness, plus the caller
        will be able to determine exactly where in the list the problem is—or
        even just filter out the problem results if desired. Here's an
        implementation:</p><pre class="calibre39">-- file: ch19/divby3.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; [Maybe a]
divBy numerator denominators =
    map worker denominators
    where worker 0 = Nothing
          worker x = Just (numerator `div` x)</pre><br class="calibre48"/>
<a name="x_Qz" class="calibre27" id="x_Qz"></a><p class="docText">Take a look at this function. We're back to using
        <tt class="calibre34">map</tt>, which is a good thing for both
        laziness and simplicity. We can try it out in <i class="docEmphasis">ghci</i> and see that it works for finite and
        infinite lists just fine:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
[Just 50,Just 25,Just 10,Just 6,Just 5]
ghci&gt; <b class="calibre40">divBy 50 [1,2,0,8,10]</b>
[Just 50,Just 25,Nothing,Just 6,Just 5]
ghci&gt; <b class="calibre40">take 5 (divBy 100 [1..])</b>
[Just 100,Just 50,Just 33,Just 25,Just 20]</pre><a name="x_Rz" class="calibre27" id="x_Rz"></a><p class="docText">We hope that you can take from this discussion the
        point that there is a distinction between the input not being
        well-formed (as in the case of <tt class="calibre34">safeTail</tt>) and the input potentially
        containing some bad data, as in the case of <tt class="calibre34">divBy</tt>. These two cases can often justify
        different handling of the results.</p><a name="errors_maybe_monad" class="calibre27" id="errors_maybe_monad"></a><h5 id="title-IDATSQ0E" class="docSection3Title">19.1.1.2. Usage of the Maybe monad</h5><a name="x_Sz" class="calibre27" id="x_Sz"></a><p class="docText">Back in <a class="docLink" href="#errors_maybe">Section 19.1.1</a>, we had an
        example program named <i class="docEmphasis">divby2.hs</i>. This example
        didn't preserve laziness but returned a value of type <tt class="calibre34">Maybe [a]</tt>. The exact same algorithm could be
        expressed using a monadic style. For more information and important
        background on monads, please refer to <a class="docLink" href="monads_split_000.html#monads">Chapter 14</a>.
        Here's our new monadic-style algorithm:</p><pre class="calibre39">-- file: ch19/divby4.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; Maybe [a]
divBy _ [] = return []
divBy _ (0:_) = fail "division by zero in divBy"
divBy numerator (denom:xs) =
    do next &lt;- divBy numerator xs
       return ((numerator `div` denom) : next)</pre><br class="calibre48"/>
<a name="x_Tz" class="calibre27" id="x_Tz"></a><p class="docText">The <tt class="calibre34">Maybe</tt> monad
        makes the expression of this algorithm look nicer. For the <tt class="calibre34">Maybe</tt> monad, <tt class="calibre34">return</tt> is the same as <tt class="calibre34">Just</tt>, and <tt class="calibre34">fail _ =
        Nothing</tt>, so our error explanation string is never actually
        seen anywhere. We can test this algorithm with the same tests we used
        against <i class="docEmphasis">divby2.hs</i> if we want:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
Just [50,25,10,6,5]
ghci&gt; <b class="calibre40">divBy 50 [1,2,0,8,10]</b>
Nothing
ghci&gt; <b class="calibre40">divBy 100 [1..] </b>
*** Exception: stack overflow</pre><a name="x_Uz" class="calibre27" id="x_Uz"></a><p class="docText">The code we wrote actually isn't specific to the
        <tt class="calibre34">Maybe</tt> monad. By simply changing the
        type, we can make it work for <span class="docEmphasis">any</span> monad. Let's
        try it:</p><pre class="calibre39">-- file: ch19/divby5.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; Maybe [a]
divBy = divByGeneric

divByGeneric :: (Monad m, Integral a) =&gt; a -&gt; [a] -&gt; m [a]
divByGeneric _ [] = return []
divByGeneric _ (0:_) = fail "division by zero in divByGeneric"
divByGeneric numerator (denom:xs) =
    do next &lt;- divByGeneric numerator xs
       return ((numerator `div` denom) : next)</pre><br class="calibre48"/>
<a name="x_Vz" class="calibre27" id="x_Vz"></a><p class="docText">The <tt class="calibre34">divByGeneric</tt>
        function contains the same code as <tt class="calibre34">divBy</tt> did before; we just gave it a more
        general type. This is, in fact, the type that <i class="docEmphasis">ghci</i> infers if no type is given. We also
        defined a convenience function <tt class="calibre34">divBy</tt> with a more specific type.</p><a name="x_Wz" class="calibre27" id="x_Wz"></a><p class="docText">Let's try this out in <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:l divby5.hs</b>
[1 of 1] Compiling Main             ( divby5.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
Just [50,25,10,6,5]
ghci&gt; <b class="calibre40">(divByGeneric 50 [1,2,5,8,10])::(Integral a =&gt; Maybe [a])</b>
Just [50,25,10,6,5]
ghci&gt; <b class="calibre40">divByGeneric 50 [1,2,5,8,10]</b>
[50,25,10,6,5]
ghci&gt; <b class="calibre40">divByGeneric 50 [1,2,0,8,10]</b>
*** Exception: user error (division by zero in divByGeneric)</pre><a name="x_Xz" class="calibre27" id="x_Xz"></a><p class="docText">The first two inputs both produce the same output that
        we saw earlier. Since <tt class="calibre34">divByGeneric</tt> doesn't have a specific
        return type, we must either give one or let the interpreter infer one
        from the environment. If we don't give a specific return type,
        <i class="docEmphasis">ghci</i> infers the IO
        monad. You can see that in the third and fourth examples. The
        IO monad converts <i class="docEmphasis">fail</i> into an exception, as you can see with
        the fourth example.</p><a name="x_Yz" class="calibre27" id="x_Yz"></a><p class="docText">The <tt class="calibre34">Control.Monad.Error</tt> module<a name="I_indexterm19_d1e41337" class="calibre27" id="I_indexterm19_d1e41337"></a> in the <tt class="calibre34">mtl</tt> package
        makes <tt class="calibre34">Either String</tt> into a monad as
        well. If you use <tt class="calibre34">Either</tt>, you can
        get a pure result that preserves the error message, like so:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad.Error</b>ghci&gt; <b class="calibre40">(divByGeneric 50 [1,2,5,8,10])::(Integral a =&gt; Either String [a])</b>
Loading package mtl-1.1.0.1 ... linking ... done.
Right [50,25,10,6,5]
ghci&gt; <b class="calibre40">(divByGeneric 50 [1,2,0,8,10])::(Integral a =&gt; Either String [a])</b>
Left "division by zero in divByGeneric"</pre><a name="x_Zz" class="calibre27" id="x_Zz"></a><p class="docText">This leads us into our next topic of discussion: using
        <tt class="calibre34">Either</tt> for returning error <span class="docEmphasis">information</span>.</p><a name="errors_either" class="calibre27" id="errors_either"></a><h4 id="title-IDAFBR0E" class="docSection1Title">19.1.2. Use of Either</h4><a name="x_az" class="calibre27" id="x_az"></a><p class="docText">The <tt class="calibre34">Either</tt>
      type<a name="ch19-eithertype" class="calibre27" id="ch19-eithertype"></a><a name="I_indexterm19_d1e41385" class="calibre27" id="I_indexterm19_d1e41385"></a> is similar to the <tt class="calibre34">Maybe</tt> type, with one key difference: it can
      carry attached data both for an error and a success ("the
      <tt class="calibre34">Right</tt> answer").<sup class="docFootnote"><a class="docLink1" href="#x_azd1e41723">[42]</a></sup> Although the language imposes no restrictions, by
      convention, a function returning an <tt class="calibre34">Either</tt> uses a <tt class="calibre34">Left</tt> return value<a name="I_indexterm19_d1e41412" class="calibre27" id="I_indexterm19_d1e41412"></a><a name="I_indexterm19_d1e41415" class="calibre27" id="I_indexterm19_d1e41415"></a> to indicate an error, and it uses <tt class="calibre34">Right</tt> to indicate success. If it helps you
      remember, you can think of getting the <tt class="calibre34">Right</tt> answer. We can start with our
      <i class="docEmphasis">divby2.hs</i> example from the earlier section on
      <tt class="calibre34">Maybe</tt> and adapt it to work with
      <tt class="calibre34">Either</tt>:</p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_azd1e41723" class="calibre5" id="x_azd1e41723">[42]</a></sup> For more information on <tt class="calibre34">Either</tt>, refer to <a class="docLink" href="glob_errapi_split_000.html#glob_errapi">Section 8.8</a>.</p></blockquote><pre class="calibre39">-- file: ch19/divby6.hs
divBy :: Integral a =&gt; a -&gt; [a] -&gt; Either String [a]
divBy _ [] = Right []
divBy _ (0:_) = Left "divBy: division by 0"
divBy numerator (denom:xs) =
    case divBy numerator xs of
      Left x -&gt; Left x
      Right results -&gt; Right ((numerator `div` denom) : results)</pre><br class="calibre48"/>
<a name="x_cz" class="calibre27" id="x_cz"></a><p class="docText">This code is almost identical to the <tt class="calibre34">Maybe</tt> code; we've substituted <tt class="calibre34">Right</tt> for every <tt class="calibre34">Just</tt>. <tt class="calibre34">Left</tt>
      compares to <tt class="calibre34">Nothing</tt>, but now it can
      carry a message. Let's check it out in <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
Right [50,25,10,6,5]
ghci&gt; <b class="calibre40">divBy 50 [1,2,0,8,10]</b>
Left "divBy: division by 0"</pre><a name="errors_eitherd1e41796" class="calibre27" id="errors_eitherd1e41796"></a><h5 id="title-IDAFFR0E" class="docSection3Title">19.1.2.1. Custom data types for errors</h5><a name="x_dz" class="calibre27" id="x_dz"></a><p class="docText">While a <tt class="calibre34">String</tt>
        indicating<a name="I_indexterm19_d1e41477" class="calibre27" id="I_indexterm19_d1e41477"></a><a name="I_indexterm19_d1e41482" class="calibre27" id="I_indexterm19_d1e41482"></a> the cause of an error may be useful to humans down the
        road, it's often helpful to define a custom error type that we can use
        to programmatically decide on a course of action based upon exactly
        what the problem was. For instance, let's say that for some reason,
        besides 0, we also don't want to divide by 10 or 20. We could define a
        custom error type like so:</p><pre class="calibre39">-- file: ch19/divby7.hs
data DivByError a = DivBy0
                 | ForbiddenDenominator a
                   deriving (Eq, Read, Show)

divBy :: Integral a =&gt; a -&gt; [a] -&gt; Either (DivByError a) [a]
divBy _ [] = Right []
divBy _ (0:_) = Left DivBy0
divBy _ (10:_) = Left (ForbiddenDenominator 10)
divBy _ (20:_) = Left (ForbiddenDenominator 20)
divBy numerator (denom:xs) =
    case divBy numerator xs of
      Left x -&gt; Left x
      Right results -&gt; Right ((numerator `div` denom) : results)</pre><br class="calibre48"/>
<a name="x_ez" class="calibre27" id="x_ez"></a><p class="docText">Now, in the event of an error, the <tt class="calibre34">Left</tt> data could<a name="I_indexterm19_d1e41493" class="calibre27" id="I_indexterm19_d1e41493"></a> be inspected to find the exact cause. Or, it could
        simply be printed out with <tt class="calibre34">show</tt>,
        which will generate a reasonable idea of the problem as well. Here's
        this function in action:</p><pre class="calibre39">ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8]</b>
Right [50,25,10,6]
ghci&gt; <b class="calibre40">divBy 50 [1,2,5,8,10]</b>
Left (ForbiddenDenominator 10)
ghci&gt; <b class="calibre40">divBy 50 [1,2,0,8,10]</b>
Left DivBy0</pre><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="warning_yellow.gif" alt="" class="calibre44"/></td><td valign="top" class="v3"><a name="x_fz" class="calibre27" id="x_fz"></a><p class="docText">All of these <tt class="calibre34">Either</tt> examples suffer from the lack of
          laziness that our early <tt class="calibre34">Maybe</tt>
          examples suffered from. We address that in an exercise question at
          the end of this chapter.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="errors_eitherd1e41852" class="calibre27" id="errors_eitherd1e41852"></a><h5 id="title-IDALHR0E" class="docSection3Title">19.1.2.2. Monadic use of Either</h5><a name="x_gz" class="calibre27" id="x_gz"></a><p class="docText">Back in <a class="docLink" href="#errors_maybe_monad">Section 19.1.1.2</a>,
        we<a name="I_indexterm19_d1e41532" class="calibre27" id="I_indexterm19_d1e41532"></a> showed you how to use <tt class="calibre34">Maybe</tt> in a monad. <tt class="calibre34">Either</tt> can be used in a monad too, but it
        can be slightly more complicated. The reason is that <i class="docEmphasis">fail</i> is hardcoded to accept only a <tt class="calibre34">String</tt> as the failure code, so we have to
        have a way to map such a string into whatever type we used for
        <tt class="calibre34">Left</tt>. As you saw earlier, <tt class="calibre34">Control.Monad.Error</tt> provides<a name="I_indexterm19_d1e41557" class="calibre27" id="I_indexterm19_d1e41557"></a> built-in support for <tt class="calibre34">Either
        String a</tt>, which involves no mapping for the argument to
        <i class="docEmphasis">fail</i>. Here's how we can set up
        our example to work with <tt class="calibre34">Either</tt> in
        the monadic style:</p><pre class="calibre39">-- file: ch19/divby8.hs
{-# LANGUAGE FlexibleContexts #-}

import Control.Monad.Error

data Show a =&gt; 
    DivByError a = DivBy0
                  | ForbiddenDenominator a
                  | OtherDivByError String
                    deriving (Eq, Read, Show)

instance Error (DivByError a) where
    strMsg x = OtherDivByError x

divBy :: Integral a =&gt; a -&gt; [a] -&gt; Either (DivByError a) [a]
divBy = divByGeneric

divByGeneric :: (Integral a, MonadError (DivByError a) m) =&gt;
                 a -&gt; [a] -&gt; m [a]
divByGeneric _ [] = return []
divByGeneric _ (0:_) = throwError DivBy0
divByGeneric _ (10:_) = throwError (ForbiddenDenominator 10)
divByGeneric _ (20:_) = throwError (ForbiddenDenominator 20)
divByGeneric numerator (denom:xs) =
    do next &lt;- divByGeneric numerator xs
       return ((numerator `div` denom) : next)</pre><br class="calibre48"/>
<a name="x_hz" class="calibre27" id="x_hz"></a><p class="docText"><a name="I_indexterm19_d1e41574" class="calibre27" id="I_indexterm19_d1e41574"></a>Here, we needed to turn on the <tt class="calibre34">FlexibleContexts</tt> language extension in order
        to provide the type signature for <tt class="calibre34">divByGeneric</tt>. The <tt class="calibre34">divBy</tt> function works exactly the same as
        before. For <tt class="calibre34">divByGeneric</tt>, we make
        <tt class="calibre34">divByError</tt> a member of the <tt class="calibre34">Error</tt> class by defining what happens when
        someone calls <tt class="calibre34">fail</tt> (the <tt class="calibre34">strMsg</tt> function). We also convert <tt class="calibre34">Right</tt> to <tt class="calibre34">return</tt> and <tt class="calibre34">Left</tt> to <tt class="calibre34">throwError</tt> to enable this to be
        generic.</p>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="errors_split_000.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="errors_exceptions_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

