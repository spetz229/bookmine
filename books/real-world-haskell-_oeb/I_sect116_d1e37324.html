---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect116_d1e37117.html
next: I_sect116_d1e37427_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="I_sect116_d1e37117.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect116_d1e37427_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect116_d1e37324" class="calibre27" id="I_sect116_d1e37324"></a><h3 id="title-IDAA5PBD" class="docSection1Title">16.11. Parsing JSON Data</h3><a name="x_Hk" class="calibre27" id="x_Hk"></a><p class="docText">To give ourselves<a name="ch16-jsonparsing" class="calibre27" id="ch16-jsonparsing"></a> a better feel for parsing with applicative functors, and to
    explore a few more corners of Parsec, we'll write a JSON parser that
    follows the definition in RFC 4627.</p><a name="x_Ik" class="calibre27" id="x_Ik"></a><p class="docText">At the top level, a JSON value must be either an object or
    an array:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_text :: CharParser () JValue
p_text = spaces *&gt; text
     &lt;?&gt; "JSON text"
    where text = JObject &lt;$&gt; p_object
             &lt;|&gt; JArray &lt;$&gt; p_array</pre><br class="calibre48"/>
<a name="x_Jk" class="calibre27" id="x_Jk"></a><p class="docText">These are structurally similar, with an opening character,
    followed by one or more items separated by commas, followed by a closing
    character. We capture this similarity by writing a small helper
    function:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_series :: Char -&gt; CharParser () a -&gt; Char -&gt; CharParser () [a]
p_series left parser right =
    between (char left &lt;* spaces) (char right) $
            (parser &lt;* spaces) `sepBy` (char ',' &lt;* spaces)</pre><br class="calibre48"/>
<a name="x_Kk" class="calibre27" id="x_Kk"></a><p class="docText">Here, we finally have a use for the <i class="docEmphasis">(&lt;*)</i> combinator<a name="I_indexterm16_d1e37348" class="calibre27" id="I_indexterm16_d1e37348"></a> that we introduced earlier. We use it to skip over any
    whitespace that might follow certain tokens. With this <i class="docEmphasis">p_series</i> function, parsing an array is
    simple:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_array :: CharParser () (JAry JValue)
p_array = JAry &lt;$&gt; p_series '[' p_value ']'</pre><br class="calibre48"/>
<a name="x_Lk" class="calibre27" id="x_Lk"></a><p class="docText">Dealing with a JSON object is hardly more complicated,
    requiring just a little additional effort to produce a name/value pair for
    each of the object's fields:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_object :: CharParser () (JObj JValue)
p_object = JObj &lt;$&gt; p_series '{' p_field '}'
    where p_field = (,) &lt;$&gt; (p_string &lt;* char ':' &lt;* spaces) &lt;*&gt; p_value</pre><br class="calibre48"/>
<a name="x_Mk" class="calibre27" id="x_Mk"></a><p class="docText">Parsing an individual value is a matter of calling an
    existing parser, and then wrapping its result with the appropriate
    JValue constructor:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_value :: CharParser () JValue
p_value = value &lt;* spaces
  where value = JString &lt;$&gt; p_string
            &lt;|&gt; JNumber &lt;$&gt; p_number
            &lt;|&gt; JObject &lt;$&gt; p_object
            &lt;|&gt; JArray &lt;$&gt; p_array
            &lt;|&gt; JBool &lt;$&gt; p_bool
            &lt;|&gt; JNull &lt;$ string "null"
            &lt;?&gt; "JSON value"

p_bool :: CharParser () Bool
p_bool = True &lt;$ string "true"
     &lt;|&gt; False &lt;$ string "false"</pre><br class="calibre48"/>
<a name="x_xG1" class="calibre27" id="x_xG1"></a><p class="docText">The <i class="docEmphasis">choice</i>
    combinator allows us to represent this kind of ladder-of-alternatives as a
    list. It returns the result of the first parser to succeed:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_value_choice = value &lt;* spaces
  where value = choice [ JString &lt;$&gt; p_string
                       , JNumber &lt;$&gt; p_number
                       , JObject &lt;$&gt; p_object
                       , JArray &lt;$&gt; p_array
                       , JBool &lt;$&gt; p_bool
                       , JNull &lt;$ string "null"
                       ]
                &lt;?&gt; "JSON value"</pre><br class="calibre48"/>
<a name="x_Nk" class="calibre27" id="x_Nk"></a><p class="docText">This leads us to the two most interesting parsers, for
    numbers and strings. We'll deal with numbers first, since they're
    simpler:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_number :: CharParser () Double
p_number = do s &lt;- getInput
              case readSigned readFloat s of
                [(n, s')] -&gt; n &lt;$ setInput s'
                _         -&gt; empty</pre><br class="calibre48"/>
<a name="x_Ok" class="calibre27" id="x_Ok"></a><p class="docText">Our trick here is to take advantage of Haskell's standard
    number parsing library functions, which are defined in the
    <tt class="calibre34">Numeric</tt> module. The <i class="docEmphasis">readFloat</i> function reads an unsigned
    floating-point number; <i class="docEmphasis">readSigned</i>
    takes a parser for an unsigned number and turns it into a parser for
    possibly signed numbers.</p><a name="x_Pk" class="calibre27" id="x_Pk"></a><p class="docText">Since these functions know nothing about Parsec, we have
    to work with them specially. Parsec's <i class="docEmphasis">getInput</i> function gives us direct access to
    Parsec's unconsumed input stream. If <tt class="calibre34">readSigned readFloat</tt>
    succeeds, it returns both the parsed number and the rest of the unparsed
    input. We then use <i class="docEmphasis">setInput</i> to give
    this back to Parsec as its new unconsumed input stream.</p><a name="x_Qk" class="calibre27" id="x_Qk"></a><p class="docText">Parsing a string isn't difficult, merely detailed:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_string :: CharParser () String
p_string = between (char '\"') (char '\"') (many jchar)
    where jchar = char '\\' *&gt; (p_escape &lt;|&gt; p_unicode)
              &lt;|&gt; satisfy (`notElem` "\"\\")</pre><br class="calibre48"/>
<a name="x_Rk" class="calibre27" id="x_Rk"></a><p class="docText">We can parse and decode an escape sequence with the help
    of the <i class="docEmphasis">choice</i> combinator that we just
    met:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_escape = choice (zipWith decode "bnfrt\\\"/" "\b\n\f\r\t\\\"/")
    where decode c r = r &lt;$ char c</pre><br class="calibre48"/>
<a name="x_Tk" class="calibre27" id="x_Tk"></a><p class="docText">Finally, JSON lets us encode a Unicode character in a
    string as <tt class="calibre34">\u</tt>, followed by four hexadecimal
    digits:</p><pre class="calibre39">-- file: ch16/JSONParsec.hs
p_unicode :: CharParser () Char
p_unicode = char 'u' *&gt; (decode &lt;$&gt; count 4 hexDigit)
    where decode x = toEnum code
              where ((code,_):_) = readHex x</pre><br class="calibre48"/>
<a name="x_Uk" class="calibre27" id="x_Uk"></a><p class="docText">The only piece of functionality that applicative functors
    are missing, compared to monads, is the ability to bind a value to a
    variable, which we need here in order to be able to validate the value
    we're trying to decode.</p><a name="x_Vk" class="calibre27" id="x_Vk"></a><p class="docText">This is the one place in our parser that we've needed to
    use a monadic function. This pattern extends to more complicated parsers,
    too—only infrequently do we need the extra bit of power that monads
    offer.</p><a name="x_Wk" class="calibre27" id="x_Wk"></a><p class="docText">As of this writing, applicative functors are still quite
    new to Haskell, and people are only beginning to explore the possible uses
    for them beyond the realm of parsing.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="I_sect116_d1e37117.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect116_d1e37427_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

