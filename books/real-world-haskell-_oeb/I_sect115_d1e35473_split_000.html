---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect115_d1e35298.html
next: I_sect115_d1e35473_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="I_sect115_d1e35298.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="parsec_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect115_d1e35473" class="calibre27" id="I_sect115_d1e35473"></a><h3 id="title-IDAUTDUL" class="docSection1Title">15.8. Hiding the IO Monad</h3><a name="x_Rs" class="calibre27" id="x_Rs"></a><p class="docText">The<a name="ch15-iomonad" class="calibre27" id="ch15-iomonad"></a> blessing and curse of the IO monad is that it
    is extremely powerful. If we believe that careful use of types helps us to
    avoid programming mistakes, then the IO monad should be a
    great source of unease. Because the IO monad imposes no
    restrictions on what we can do, it leaves us vulnerable to all kinds of
    accidents.</p><a name="x_Ss" class="calibre27" id="x_Ss"></a><p class="docText">How can we tame its power? Let's say that we would like
    guarantee to ourselves that a piece of code can read and write files on
    the local filesystem, but it will not access the network. We can't use the
    plain IO monad, because it won't restrict us.</p><a name="I_sect115_d1e35473d1e35836" class="calibre27" id="I_sect115_d1e35473d1e35836"></a><h4 id="title-IDAMUDUL" class="docSection1Title">15.8.1. Using a newtype</h4><a name="x_Ts" class="calibre27" id="x_Ts"></a><p class="docText">Let's create a module that provides a small set of
      functionality for reading and writing files:</p><pre class="calibre39">-- file: ch15/HandleIO.hs
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module HandleIO
    (
      HandleIO
    , Handle
    , IOMode(..)
    , runHandleIO
    , openFile
    , hClose
    , hPutStrLn
    ) where
    
import System.IO (Handle, IOMode(..))
import qualified System.IO</pre><br class="calibre48"/>
<a name="x_Us" class="calibre27" id="x_Us"></a><p class="docText">Our first approach to creating a restricted version of
      IO is to wrap it with a <tt class="calibre34">newtype</tt>:</p><pre class="calibre39">-- file: ch15/HandleIO.hs
newtype HandleIO a = HandleIO { runHandleIO :: IO a }
    deriving (Monad)</pre><br class="calibre48"/>
<a name="x_Vs" class="calibre27" id="x_Vs"></a><p class="docText">We do the by now familiar trick of exporting the type
      constructor and the <i class="docEmphasis">runHandleIO</i>
      execution function from our module, but not the data constructor. This
      will prevent code running within the HandleIO monad from
      getting hold of the IO monad that it wraps.</p><a name="x_Ws" class="calibre27" id="x_Ws"></a><p class="docText">All that remains is for us to wrap each of the actions
      that we want our monad to allow. This is a simple matter of wrapping
      each IO with a HandleIO data
      constructor:</p><pre class="calibre39">-- file: ch15/HandleIO.hs
openFile :: FilePath -&gt; IOMode -&gt; HandleIO Handle
openFile path mode = HandleIO (System.IO.openFile path mode)

hClose :: Handle -&gt; HandleIO ()
hClose = HandleIO . System.IO.hClose

hPutStrLn :: Handle -&gt; String -&gt; HandleIO ()
hPutStrLn h s = HandleIO (System.IO.hPutStrLn h s)</pre><br class="calibre48"/>
<a name="x_Xs" class="calibre27" id="x_Xs"></a><p class="docText">We can now use our restricted HandleIO
      monad to perform I/O:</p><pre class="calibre39">-- file: ch15/HandleIO.hs
safeHello :: FilePath -&gt; HandleIO ()
safeHello path = do
  h &lt;- openFile path WriteMode
  hPutStrLn h "hello world"
  hClose h</pre><br class="calibre48"/>
<a name="x_Ys" class="calibre27" id="x_Ys"></a><p class="docText">To run this action, we use <i class="docEmphasis">runHandleIO</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load HandleIO</b>
[1 of 1] Compiling HandleIO         ( HandleIO.hs, interpreted )
Ok, modules loaded: HandleIO.
ghci&gt; <b class="calibre40">runHandleIO (safeHello "hello_world_101.txt")</b>
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package filepath-1.1.0.0 ... linking ... done.
Loading package directory-1.0.0.1 ... linking ... done.
Loading package mtl-1.1.0.1 ... linking ... done.
ghci&gt; <b class="calibre40">:m +System.Directory</b>ghci&gt; <b class="calibre40">removeFile "hello_world_101.txt"</b></pre><a name="x_Zs" class="calibre27" id="x_Zs"></a><p class="docText">If we try to sequence an action that runs in the
      HandleIO monad with one that is not permitted, the type
      system will forbid it:</p><pre class="calibre39">ghci&gt; <b class="calibre40">runHandleIO (safeHello "goodbye" &gt;&gt; removeFile "goodbye")</b>

&lt;interactive&gt;:1:36:
    Couldn't match expected type `HandleIO a'
           against inferred type `IO ()'
    In the second argument of `(&gt;&gt;)', namely `removeFile "goodbye"'
    In the first argument of `runHandleIO', namely
        `(safeHello "goodbye" &gt;&gt; removeFile "goodbye")'
    In the expression:
        runHandleIO (safeHello "goodbye" &gt;&gt; removeFile "goodbye")
</pre><a name="I_sect115_d1e35473d1e35917" class="calibre27" id="I_sect115_d1e35473d1e35917"></a><h4 id="title-IDAIXDUL" class="docSection1Title">15.8.2. Designing for Unexpected Uses</h4><a name="x_as" class="calibre27" id="x_as"></a><p class="docText">There's one small, but significant, problem with our
      HandleIO monad: it doesn't take into account the
      possibility that we might occasionally need an escape hatch. If we
      define a monad such as this, it is likely that we will occasionally need
      to perform an <span class="docEmphasis">I/O</span> action that
      isn't allowed for by the design of our monad.</p><a name="x_bs" class="calibre27" id="x_bs"></a><p class="docText">Our purpose in defining a monad like this is to make it
      easier for us to write solid code in the common case, not to make corner
      cases impossible. Let's give ourselves a way out.</p><a name="x_cs" class="calibre27" id="x_cs"></a><p class="docText">The <tt class="calibre34">Control.Monad.Trans</tt> module<a name="I_indexterm15_d1e35597" class="calibre27" id="I_indexterm15_d1e35597"></a> defines a "standard escape hatch," the
      MonadIO typeclass. This<a name="I_indexterm15_d1e35604" class="calibre27" id="I_indexterm15_d1e35604"></a> defines a single function, <i class="docEmphasis">liftIO</i>, which lets us embed an
      IO action in another monad:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad.Trans</b>ghci&gt; <b class="calibre40">:info MonadIO</b>
class (Monad m) =&gt; MonadIO m where liftIO :: IO a -&gt; m a
  	-- Defined in Control.Monad.Trans
instance MonadIO IO -- Defined in Control.Monad.Trans</pre><a name="x_ds" class="calibre27" id="x_ds"></a><p class="docText">Our implementation of this typeclass is trivial; we just
      wrap IO with our data <span class="docEmphasis">constructor</span>:</p><pre class="calibre39">-- file: ch15/HandleIO.hs
import Control.Monad.Trans (MonadIO(..))

instance MonadIO HandleIO where
    liftIO = HandleIO</pre><br class="calibre48"/>
<a name="x_es" class="calibre27" id="x_es"></a><p class="docText">With judicious use of <i class="docEmphasis">liftIO</i>, we can escape our shackles and invoke
      IO actions where necessary:</p><pre class="calibre39">-- file: ch15/HandleIO.hs
tidyHello :: FilePath -&gt; HandleIO ()
tidyHello path = do
  safeHello path
  liftIO (removeFile path)</pre><br class="calibre48"/>
<p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Automatic derivation and MonadIO</p><a name="x_fs" class="calibre27" id="x_fs"></a><p class="docText">We could have had the compiler automatically derive an
        instance of MonadIO for us by adding the typeclass to the
        <tt class="calibre34">deriving</tt> clause of HandleIO. In fact, in
        production code, this would be our usual strategy. We avoided that
        here simply to separate the presentation of the earlier material from
        that of MonadIO.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="monadcase_io_class" class="calibre27" id="monadcase_io_class"></a><h4 id="title-IDAG0DUL" class="docSection1Title">15.8.3. Using Typeclasses</h4><a name="x_gs" class="calibre27" id="x_gs"></a><p class="docText">The disadvantage of hiding<a name="I_indexterm15_d1e35668" class="calibre27" id="I_indexterm15_d1e35668"></a> IO in another monad is that we're still tied
      to a concrete implementation. If we want to swap HandleIO
      for some other monad, we must change the type of every action that uses
      HandleIO.</p><a name="x_hs" class="calibre27" id="x_hs"></a><p class="docText">As an alternative, we can create a typeclass that
      specifies the interface we want from a monad that manipulates
      files:</p><pre class="calibre39">-- file: ch15/MonadHandle.hs
{-# LANGUAGE FunctionalDependencies, MultiParamTypeClasses #-}

module MonadHandle (MonadHandle(..)) where

import System.IO (IOMode(..))

class Monad m =&gt; MonadHandle h m | m -&gt; h where
    openFile :: FilePath -&gt; IOMode -&gt; m h
    hPutStr :: h -&gt; String -&gt; m ()
    hClose :: h -&gt; m ()
    hGetContents :: h -&gt; m String

    hPutStrLn :: h -&gt; String -&gt; m ()
    hPutStrLn h s = hPutStr h s &gt;&gt; hPutStr h "\n"</pre><br class="calibre48"/>
<a name="x_is" class="calibre27" id="x_is"></a><p class="docText">Here, we've chosen to abstract away both the type of the
      monad and the type of a file handle. To satisfy the type checker, we've
      added a functional dependency: for any instance of
      MonadHandle, there is exactly one handle type that we can
      use. When we make the IO monad an instance of this class,
      we use a regular Handle:</p><pre class="calibre39">-- file: ch15/MonadHandleIO.hs
{-# LANGUAGE FunctionalDependencies, MultiParamTypeClasses #-}

import MonadHandle
import qualified System.IO

import System.IO (IOMode(..))
import Control.Monad.Trans (MonadIO(..), MonadTrans(..))
import System.Directory (removeFile)

import SafeHello

instance MonadHandle System.IO.Handle IO where
    openFile = System.IO.openFile
    hPutStr = System.IO.hPutStr
    hClose = System.IO.hClose
    hGetContents = System.IO.hGetContents
    hPutStrLn = System.IO.hPutStrLn</pre><br class="calibre48"/>
<a name="x_js" class="calibre27" id="x_js"></a><p class="docText">Because any MonadHandle must also be a
      Monad, we can write code that manipulates files using
      normal <tt class="calibre34">do</tt> notation, without caring
      what monad it will finally execute in:</p><pre class="calibre39">-- file: ch15/SafeHello.hs
safeHello :: MonadHandle h m =&gt; FilePath -&gt; m ()
safeHello path = do
  h &lt;- openFile path WriteMode
  hPutStrLn h "hello world"
  hClose h</pre><br class="calibre48"/>
<a name="x_ks" class="calibre27" id="x_ks"></a><p class="docText">Because we made IO an instance of this
      typeclass, we can execute this action from <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">safeHello "hello to my fans in domestic surveillance"</b>
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package filepath-1.1.0.0 ... linking ... done.
Loading package directory-1.0.0.1 ... linking ... done.
Loading package mtl-1.1.0.1 ... linking ... done.
ghci&gt; <b class="calibre40">removeFile "hello to my fans in domestic surveillance"</b></pre><a name="x_ls" class="calibre27" id="x_ls"></a><p class="docText">The beauty of the typeclass approach is that we can swap
      one underlying monad for another without touching much code, as most of
      our code doesn't know or care about the implementation. For instance, we
      could replace IO with a monad that compresses files as it
      writes them out.</p><a name="x_vG1" class="calibre27" id="x_vG1"></a><p class="docText">Defining a monad's interface through a typeclass has a
      further benefit. It lets another user hide our implementation in a
      <tt class="calibre34">newtype</tt> wrapper and automatically derive instances of just
      the typeclasses she wants to expose.</p><a name="I_sect115_d1e35473d1e36079" class="calibre27" id="I_sect115_d1e35473d1e36079"></a><h4 id="title-IDA02DUL" class="docSection1Title">15.8.4. Isolation and Testing</h4><a name="x_ms" class="calibre27" id="x_ms"></a><p class="docText">In fact, because our <i class="docEmphasis">safeHello</i> function doesn't use the
      IO type, we can even use a monad that
      <span class="docEmphasis">can't</span> perform I/O. This allows us to test code that
      would normally have side effects in a completely pure, controlled
      environment.</p><a name="x_ns" class="calibre27" id="x_ns"></a><p class="docText">To do this, we will create a monad that doesn't perform
      I/O but instead logs every file-related event for later
      processing:</p><pre class="calibre39">-- file: ch15/WriterIO.hs
data Event = Open FilePath IOMode
           | Put String String
           | Close String
           | GetContents String
             deriving (Show)</pre><br class="calibre48"/>
<a name="x_os" class="calibre27" id="x_os"></a><p class="docText">Although we already developed a Logger type
      in <a class="docLink" href="monads_logger.html#monads_logger">Section 14.6</a>, here we'll use the standard, and
      more general, Writer monad. Like other <tt class="calibre34">mtl</tt>
      monads, the API provided by Writer is defined in a
      typeclass—in this case, MonadWriter. Its most useful method
      is <i class="docEmphasis">tell</i>, which logs a value:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m +Control.Monad.Writer</b>ghci&gt; <b class="calibre40">:type tell</b>
tell :: (MonadWriter w m) =&gt; w -&gt; m ()</pre><a name="x_ps" class="calibre27" id="x_ps"></a><p class="docText">The values we log can be of any Monoid
      type. Since the list type is a Monoid, we'll log to a list
      of Event.</p><a name="x_qs" class="calibre27" id="x_qs"></a><p class="docText">We could make Writer [Event] an instance of
      MonadHandle, but it's cheap, easy, and safer to make a
      special-purpose monad:</p><pre class="calibre39">-- file: ch15/WriterIO.hs
newtype WriterIO a = W { runW :: Writer [Event] a }
    deriving (Monad, MonadWriter [Event])</pre><br class="calibre48"/>
<a name="x_rs" class="calibre27" id="x_rs"></a><p class="docText">Our execution function simply removes the
      <tt class="calibre34">newtype</tt> wrapper we added, and then calls the normal
      Writer monad's execution function:</p><pre class="calibre39">-- file: ch15/WriterIO.hs
runWriterIO :: WriterIO a -&gt; (a, [Event])
runWriterIO = runWriter . runW</pre><br class="calibre48"/>
<a name="x_ss" class="calibre27" id="x_ss"></a><p class="docText">When we try this code out in <i class="docEmphasis">ghci</i>, it gives us a log of the function's file
      activities:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load WriterIO</b>
[1 of 3] Compiling MonadHandle      ( MonadHandle.hs, interpreted )
[2 of 3] Compiling SafeHello        ( SafeHello.hs, interpreted )
[3 of 3] Compiling WriterIO         ( WriterIO.hs, interpreted )
Ok, modules loaded: MonadHandle, SafeHello, WriterIO.
ghci&gt; <b class="calibre40">runWriterIO (safeHello "foo")</b>
((),[Open "foo" WriteMode,Put "foo" "hello world",Put "foo" "\n",Close "foo"])</pre><a name="monadcase_writer_dlist" class="calibre27" id="monadcase_writer_dlist"></a><h4 id="title-IDAIAEUL" class="docSection1Title">15.8.5. The Writer Monad and Lists</h4><a name="x_ts" class="calibre27" id="x_ts"></a><p class="docText">The <tt class="calibre34">Writer</tt> monad uses<a name="I_indexterm15_d1e35851" class="calibre27" id="I_indexterm15_d1e35851"></a> the <tt class="calibre34">Monoid</tt>'s <i class="docEmphasis">mappend</i> function every time we use <i class="docEmphasis">tell</i>. Because <i class="docEmphasis">mappend</i> for lists is <i class="docEmphasis">(++)</i>, lists are not a good practical choice
      for use with Writer: repeated appends are expensive. We
      used lists previously purely for simplicity.</p><a name="x_us" class="calibre27" id="x_us"></a><p class="docText">In production code, if you want to use the
      Writer monad and you need list-like behavior, use a type
      with better append characteristics. One such type is the difference
      list, which we introduced in <a class="docLink" href="data_dlist_split_000.html#data_dlist">Section 13.6</a>. You don't
      need to roll your own difference list implementation: a well-tuned
      library is available for download from Hackage, the Haskell package
      database. Alternatively, you can use the Seq type from the
      <tt class="calibre34">Data.Sequence</tt> module, which we introduced in <a class="docLink" href="data_seq.html#data_seq">Section 13.7</a>.</p><a name="I_sect115_d1e35473d1e36224" class="calibre27" id="I_sect115_d1e35473d1e36224"></a><h4 id="title-IDADCEUL" class="docSection1Title">15.8.6. Arbitrary I/O Revisited</h4><a name="x_vs" class="calibre27" id="x_vs"></a><p class="docText">If we use the typeclass<a name="I_indexterm15_d1e35894" class="calibre27" id="I_indexterm15_d1e35894"></a> approach to restricting IO, we may still
      want to retain the ability to perform arbitrary I/O actions. We might
      try adding MonadIO as a constraint on our typeclass:</p><pre class="calibre39">-- file: ch15/MonadHandleIO.hs
class (MonadHandle h m, MonadIO m) =&gt; MonadHandleIO h m | m -&gt; h

instance MonadHandleIO System.IO.Handle IO

tidierHello :: (MonadHandleIO h m) =&gt; FilePath -&gt; m ()
tidierHello path = do
  safeHello path
  liftIO (removeFile path)</pre><br class="calibre48"/>
<a name="x_ws" class="calibre27" id="x_ws"></a><p class="docText">This approach has a problem, though: the added
      MonadIO constraint strips us of the ability to test our
      code in a pure environment, because we can no longer tell whether a test
      might have damaging side effects. The alternative is to move this
      constraint from the typeclass—where it "infects" all
      functions—to only those functions that really need to perform
      I/O:</p><pre class="calibre39">-- file: ch15/MonadHandleIO.hs
tidyHello :: (MonadIO m, MonadHandle h m) =&gt; FilePath -&gt; m ()
tidyHello path = do
  safeHello path
  liftIO (removeFile path)</pre><br class="calibre48"/>
<a name="x_xs" class="calibre27" id="x_xs"></a><p class="docText">We can use pure property tests on the functions that
      lack MonadIO constraints and traditional unit tests on the
      rest.</p><a name="x_ys" class="calibre27" id="x_ys"></a><p class="docText">Unfortunately, we've substituted one problem for
      another: we can't invoke code with both MonadIO and
      MonadHandle constraints from code that has the
      MonadHandle constraint alone. If we find that somewhere
      deep in our MonadHandle-only code that we really need the
      MonadIO constraint, we must add it to all the code paths
      that lead to this point.</p><a name="x_zs" class="calibre27" id="x_zs"></a><p class="docText">Allowing arbitrary I/O is risky, and it has a profound
      effect on how we develop and test our code. When we have to choose
      between being permissive on the one hand, and easier reasoning and
      testing on the other, we usually opt for the<a name="I_indexterm15_d1e35940" class="calibre27" id="I_indexterm15_d1e35940"></a><a name="I_indexterm15_d1e35941" class="calibre27" id="I_indexterm15_d1e35941"></a> latter.</p><a name="I_sidebar15_d1e35944" class="calibre27" id="I_sidebar15_d1e35944"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

