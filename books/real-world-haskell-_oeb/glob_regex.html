---
layout: page
title: "Real World Haskell, 1st Edition"
prev: glob_fnmatch.html
next: I_sect18_d1e22097_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="glob_fnmatch.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect18_d1e22097_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="glob_regex" class="calibre27" id="glob_regex"></a><h3 id="title-IDANFMVG" class="docSection1Title">8.3. Regular Expressions in Haskell</h3><a name="x_LF" class="calibre27" id="x_LF"></a><p class="docText">In this section,<a name="ch07-regularexpressions" class="calibre27" id="ch07-regularexpressions"></a> we assume that you are already familiar with regular
    expressions by way of some other language, such as Python, Perl, or
    Java.<sup class="docFootnote"><a class="docLink1" href="#x_LFd1e22171">[27]</a></sup></p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_LFd1e22171" class="calibre5" id="x_LFd1e22171">[27]</a></sup> If you are not acquainted with regular expressions,
        we recommend Jeffrey Friedl's book <span class="docEmphasis">Mastering Regular
        Expressions</span> (O'Reilly).</p></blockquote><a name="x_nE1" class="calibre27" id="x_nE1"></a><p class="docText">For brevity, we will abbreviate "regular
    expression" <a name="I_indexterm8_d1e21820" class="calibre27" id="I_indexterm8_d1e21820"></a>as <span class="docEmphasis">regexp</span> from here on.</p><a name="x_oE1" class="calibre27" id="x_oE1"></a><p class="docText">Rather than introduce regexps as something new, we will
    focus on what's different about regexp handling in Haskell, compared to
    other languages. Haskell's regular expression matching libraries are a lot
    more expressive than those of other languages, so there's plenty to talk
    about.</p><a name="x_MF" class="calibre27" id="x_MF"></a><p class="docText">To begin our exploration of the regexp libraries, the only
    module we'll need to work with<a name="I_indexterm8_d1e21833" class="calibre27" id="I_indexterm8_d1e21833"></a> is <i class="docEmphasis">Text.Regex.Posix</i>.
    As usual, the most convenient way to explore this module is by interacting
    with it via <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">        ghci&gt; 
        <b class="calibre40">:module +Text.Regex.Posix</b></pre><a name="x_NF" class="calibre27" id="x_NF"></a><p class="docText">The only function that we're likely to need for normal use
    is the regexp matching function, an infix operator named <i class="docEmphasis">(=~)</i> (borrowed from Perl). The first hurdle to
    overcome is that Haskell's regexp libraries make heavy use of
    polymorphism. As a result, the type signature of the <i class="docEmphasis">(=~)</i> operator<a name="I_indexterm8_d1e21857" class="calibre27" id="I_indexterm8_d1e21857"></a> is difficult to understand, so we will not explain it
    here.</p><a name="x_OF" class="calibre27" id="x_OF"></a><p class="docText">The <i class="docEmphasis">=~</i> operator uses
    typeclasses for both of its arguments and also for its return type. The
    first argument (on the left of the <i class="docEmphasis">=~</i>) is the text to match; the second (on the
    right) is the regular expression to match against. We can pass either a
    String or a ByteString as argument.</p><a name="glob_regexd1e22238" class="calibre27" id="glob_regexd1e22238"></a><h4 id="title-IDALIMVG" class="docSection1Title">8.3.1. The Many Types of Result</h4><a name="x_PF" class="calibre27" id="x_PF"></a><p class="docText">The <i class="docEmphasis">=~</i> operator is
      polymorphic in its return type, so the Haskell compiler needs some way
      to know what type of result we would like. In real code, it may be able
      to infer the right type, due to the way we subsequently use the result.
      But such cues are often lacking when we're exploring <a name="I_indexterm8_d1e21883" class="calibre27" id="I_indexterm8_d1e21883"></a>with <i class="docEmphasis">ghci</i>. If we omit a
      specific type for the result, we'll get an error from the interpreter,
      as it does not have enough information to successfuly infer the result
      type.</p><a name="x_QF" class="calibre27" id="x_QF"></a><p class="docText">When <i class="docEmphasis">ghci</i> can't infer
      the <span class="docMonofont">target</span> type, we tell it what
      we'd like the type to be. If we want a result of type Bool,
      we'll get a pass/fail answer:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"my left foot" =~ "foo" :: Bool</b>
Loading package array-0.1.0.0 ... linking ... done.
Loading package bytestring-0.9.0.1.1 ... linking ... done.
Loading package regex-base-0.72.0.1 ... linking ... done.
Loading package regex-posix-0.72.0.2 ... linking ... done.
True
ghci&gt; <b class="calibre40">"your right hand" =~ "bar" :: Bool</b>
False
ghci&gt; <b class="calibre40">"your right hand" =~ "(hand|foot)" :: Bool</b>
True</pre><a name="x_RF" class="calibre27" id="x_RF"></a><p class="docText">In the bowels of the regexp libraries, there's a
      typeclass <a name="I_indexterm8_d1e21921" class="calibre27" id="I_indexterm8_d1e21921"></a>named <i class="docEmphasis">RegexContext</i> that describes
      how a <span class="docMonofont">target</span> type should behave;
      the base library defines many instances of this typeclass for us. The
      Bool type is an instance of this typeclass, so we get back
      a usable result. Another such instance is Int, which gives
      us a count of the number of times the regexp matches:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"a star called henry" =~ "planet" :: Int</b>
0
ghci&gt; <b class="calibre40">"honorificabilitudinitatibus" =~ "[aeiou]" :: Int</b>
13</pre><a name="x_SF" class="calibre27" id="x_SF"></a><p class="docText">If we ask for a String result, we'll get
      the first substring that matches or an empty string if nothing
      matches:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: String</b>
"ii"
ghci&gt; <b class="calibre40">"hi ludi, F. Baconis nati, tuiti orbi" =~ "Shakespeare" :: String</b>
""</pre><a name="x_TF" class="calibre27" id="x_TF"></a><p class="docText">Another valid type of result is [String],
      which returns a list of <span class="docEmphasis">all</span> matching
      strings:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [String]</b>
["ii","uu"]
ghci&gt; <b class="calibre40">"hi ludi, F. Baconis nati, tuiti orbi" =~ "Shakespeare" :: [String]</b>
[]</pre><a name="idd1e22346" class="calibre27" id="idd1e22346"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_UF" class="calibre27" id="x_UF"></a></p><p class="docText">If you want a result that's a plain
        String, beware. Since <i class="docEmphasis">(=~)</i> returns an empty string to signify
        "no match", this poses an obvious difficulty if the empty
        string could also be a valid match for the regexp. If such a case
        arises, you should use a different return type instead, such as
        [String].</p></div><a name="x_VF" class="calibre27" id="x_VF"></a><p class="docText">That's about it for "simple" result types,
      but we're not by any means finished. Before we continue, let's use a
      single pattern for our remaining examples. We can define this pattern as
      a variable in <i class="docEmphasis">ghci</i>, to save a little
      typing:</p><pre class="calibre39">          ghci&gt; 
          <b class="calibre40">let pat = "(foo[a-z]*bar|quux)"</b></pre><a name="x_WF" class="calibre27" id="x_WF"></a><p class="docText">We can obtain quite a lot of information about the
      context in which a match occurs. If we ask for a (String, String,
      String) tuple, we'll get back the text
      <span class="docEmphasis">before</span> the first match, the text
      <span class="docEmphasis">of</span> that match, and the text that
      <span class="docEmphasis">follows</span> it:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"before foodiebar after" =~ pat :: (String,String,String)</b>
("before ","foodiebar"," after")
</pre><a name="x_XF" class="calibre27" id="x_XF"></a><p class="docText">If the match fails, the entire text is returned as the
      "before" element of the tuple, with the other two elements
      left empty:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"no match here" =~ pat :: (String,String,String)</b>
("no match here","","")
</pre><a name="x_YF" class="calibre27" id="x_YF"></a><p class="docText">Asking for a four-element tuple gives us a fourth
      element that's a list of all groups in the pattern that matched:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"before foodiebar after" =~ pat :: (String,String,String,[String])</b>
("before ","foodiebar"," after",["foodiebar"])
</pre><a name="x_ZF" class="calibre27" id="x_ZF"></a><p class="docText">We can get numeric information about matches, too. A
      pair of Ints gives us the starting offset of the first
      match, and its length. If we ask for a list of these pairs, we'll get
      this information for all matches:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"before foodiebar after" =~ pat :: (Int,Int)</b>
(7,9)
ghci&gt; <b class="calibre40">"i foobarbar a quux" =~ pat :: [(Int,Int)]</b>
[(2,9),(14,4)]</pre><a name="x_aF" class="calibre27" id="x_aF"></a><p class="docText">A failed match is represented by the value <tt class="calibre34">-1</tt> as the first element of the tuple (the
      match offset) if we've asked for a single tuple, or an empty list if
      we've asked for a list of tuples:</p><pre class="calibre39">ghci&gt; <b class="calibre40">"eleemosynary" =~ pat :: (Int,Int)</b>
(-1,0)
ghci&gt; <b class="calibre40">"mondegreen" =~ pat :: [(Int,Int)]</b>
[]</pre><a name="x_bF" class="calibre27" id="x_bF"></a><p class="docText">This is not a comprehensive list of built-in instances
      of the <i class="docEmphasis">RegexContext</i> typeclass. For a complete
      list, see the documentation for the <i class="docEmphasis">Text.Regex.Base.Context</i> module.</p><a name="x_pE1" class="calibre27" id="x_pE1"></a><p class="docText">This ability to make a function polymorphic in its
      result type is an unusual feature for a statically typed
      language.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="glob_fnmatch.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect18_d1e22097_split_000.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

