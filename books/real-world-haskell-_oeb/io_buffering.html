---
layout: page
title: "Real World Haskell, 1st Edition"
prev: io_sideeffects.html
next: io_args.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="io_sideeffects.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="io_args.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="io_buffering" class="calibre27" id="io_buffering"></a><h3 id="title-IDAXL1VD" class="docSection1Title">7.8. Buffering</h3><a name="x_kE" class="calibre27" id="x_kE"></a><p class="docText">The I/O subsystem<a name="I_indexterm7_d1e20907" class="calibre27" id="I_indexterm7_d1e20907"></a><a name="I_indexterm7_d1e20910" class="calibre27" id="I_indexterm7_d1e20910"></a> is one of the slowest parts of a modern computer.
    Completing a write to disk can take thousands of times as long as a write
    to memory. A write over the network can be hundreds or thousands of times
    slower yet. Even if your operation doesn't directly communicate with the
    disk—perhaps because the data is cached—<span class="docEmphasis">I/O</span> still involves a system call, which
    slows things down by itself.</p><a name="x_lE" class="calibre27" id="x_lE"></a><p class="docText">For this reason, modern operating systems and programming
    languages both provide tools to help programs perform better where I/O is
    concerned. The operating system typically performs caching—storing
    frequently used pieces of data in memory for faster access.</p><a name="x_mE" class="calibre27" id="x_mE"></a><p class="docText">Programming languages typically perform buffering. This
    means that they may request one large chunk of data from the operating
    system, even if the code underneath is processing data one character at a
    time. By doing this, they can achieve remarkable performance gains because
    each request for I/O to the operating system carries a processing cost.
    Buffering allows us to read the same amount of data with far fewer I/O
    requests.</p><a name="x_nE" class="calibre27" id="x_nE"></a><p class="docText">Haskell, too, provides buffering in its I/O system. In
    many cases, it is even on by default. Up until now, we have pretended it
    isn't there. Haskell usually is good about picking a good default
    buffering mode, but it is rarely the fastest. If you have speed-critical
    <span class="docEmphasis">I/O</span> code, changing buffering could
    have a significant impact on your program.</p><a name="io_bufferingd1e21286" class="calibre27" id="io_bufferingd1e21286"></a><h4 id="title-IDAZM1VD" class="docSection1Title">7.8.1. Buffering Modes</h4><a name="x_oE" class="calibre27" id="x_oE"></a><p class="docText">There are three different buffering modes in Haskell.
      They are defined<a name="I_indexterm7_d1e20933" class="calibre27" id="I_indexterm7_d1e20933"></a><a name="I_indexterm7_d1e20936" class="calibre27" id="I_indexterm7_d1e20936"></a><a name="I_indexterm7_d1e20939" class="calibre27" id="I_indexterm7_d1e20939"></a><a name="I_indexterm7_d1e20942" class="calibre27" id="I_indexterm7_d1e20942"></a> as the <tt class="calibre34">BufferMode</tt> type: <tt class="calibre34">NoBuffering</tt>, <tt class="calibre34">LineBuffering</tt>, and <tt class="calibre34">BlockBuffering</tt>.</p><a name="x_pE" class="calibre27" id="x_pE"></a><p class="docText"><tt class="calibre34">NoBuffering</tt> does just
      what it sounds like—no buffering. Data read via functions like <tt class="calibre34">hGetLine</tt> will be read from the OS one
      character at a time. Data written will be written immediately, and also
      often will be written one character at a time. For this reason, <tt class="calibre34">NoBuffering</tt> is usually a very poor performer
      and not suitable for general-purpose use.</p><a name="x_qE" class="calibre27" id="x_qE"></a><p class="docText"><tt class="calibre34">LineBuffering</tt> causes
      the output buffer to be written whenever the newline character is
      output, or whenever it gets too large. On input, it will usually attempt
      to read whatever data is available in chunks until it first sees the
      newline character. When reading from the terminal, it should return data
      immediately after each press of Enter. It is often a reasonable
      default.</p><a name="x_rE" class="calibre27" id="x_rE"></a><p class="docText"><tt class="calibre34">BlockBuffering</tt> causes
      Haskell to read or write data in fixed-size chunks when possible. This
      is the best performer when processing large amounts of data in batch,
      even if that data is line-oriented. However, it is unusable for
      interactive programs because it will block input until a full block is
      read. <tt class="calibre34">BlockBuffering</tt> accepts one
      parameter of type <tt class="calibre34">Maybe</tt>; if <tt class="calibre34">Nothing</tt>, it will use an implementation-defined
      buffer size. Or, you can use a setting such as <tt class="calibre34">Just 4096</tt> to set the buffer to 4096
      bytes.</p><a name="x_sE" class="calibre27" id="x_sE"></a><p class="docText">The default buffering mode is dependent upon the
      operating system and Haskell implementation. You can ask the system for
      the current buffering mode by calling <tt class="calibre34">hGetBuffering</tt>. The current mode can be
      set with <tt class="calibre34">hSetBuffering</tt>, which accepts
      a <tt class="calibre34">Handle</tt> and
      <tt class="calibre34">BufferMode</tt>. You can say <tt class="calibre34">hSetBuffering stdin (BlockBuffering
      Nothing)</tt>, for example.</p><a name="io_bufferingd1e21364" class="calibre27" id="io_bufferingd1e21364"></a><h4 id="title-IDAJQ1VD" class="docSection1Title">7.8.2. Flushing The Buffer</h4><a name="x_tE" class="calibre27" id="x_tE"></a><p class="docText">For any type of buffering, you may sometimes want to
      force Haskell to write out any data that has been saved up in the
      buffer. There are a few times when this will happen automatically: a
      call to <tt class="calibre34">hClose</tt>, for instance.
      Sometimes you may want to instead call <tt class="calibre34">hFlush</tt>, <a name="I_indexterm7_d1e21017" class="calibre27" id="I_indexterm7_d1e21017"></a>which will force any pending data to be written
      immediately. This could be useful when the <tt class="calibre34">Handle</tt> is a network socket and you want the
      data to be transmitted immediately, or when you want to make the data on
      disk available to other programs that might be reading it
      concurrently.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"><a href="21061538.html" class="calibre2"><img src="btn_next_.gif" alt="Next" border="0" class="calibre31"/></a> 
           
          <span class="calibre33"><a target="_self" href="io_sideeffects.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="io_args.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

