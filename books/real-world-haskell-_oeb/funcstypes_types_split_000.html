---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect12_d1e2872.html
next: funcstypes_types_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="I_sect12_d1e2872.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect12_d1e3131.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="funcstypes_types" class="calibre27" id="funcstypes_types"></a><h3 id="title-IDACOTOB" class="docSection1Title">2.2. Haskell's Type System</h3><a name="x_o2" class="calibre27" id="x_o2"></a><p class="docText">There are three interesting aspects to types in Haskell:
    they are <span class="docEmphasis">strong</span>, they are
    <span class="docEmphasis">static</span>, and they can be automatically
    <span class="docEmphasis">inferred</span>. Let's talk in more detail about each of
    these ideas. When possible, we'll present similarities between concepts
    from Haskell's type system and related ideas in other languages. We'll
    also touch on the respective strengths and weaknesses of each of these
    properties.</p><a name="funcstypes_typesd1e3004" class="calibre27" id="funcstypes_typesd1e3004"></a><h4 id="title-IDAPOTOB" class="docSection1Title">2.2.1. Strong Types</h4><a name="x_q2" class="calibre27" id="x_q2"></a><p class="docText">When<a name="I_indexterm2_d1e2950" class="calibre27" id="I_indexterm2_d1e2950"></a> we say that Haskell has a <span class="docEmphasis">strong</span>
      type system, we mean that the type system guarantees that a program
      cannot contain certain kinds of errors. These errors come from trying to
      write expressions that don't make sense, such as using an integer as a
      function. For instance, if a function expects to work with integers and
      we pass it a string, a Haskell compiler will reject this.</p><a name="x_Yd" class="calibre27" id="x_Yd"></a><p class="docText">We call an expression that obeys a language's type
      rules<a name="I_indexterm2_d1e2959" class="calibre27" id="I_indexterm2_d1e2959"></a><a name="I_indexterm2_d1e2962" class="calibre27" id="I_indexterm2_d1e2962"></a><a name="I_indexterm2_d1e2965" class="calibre27" id="I_indexterm2_d1e2965"></a> <span class="docEmphasis">well typed</span>. An expression that
      disobeys the type rules is <span class="docEmphasis">ill typed</span>, and it will
      cause a <span class="docEmphasis">type error</span>.</p><a name="x_BN" class="calibre27" id="x_BN"></a><p class="docText">Another aspect of Haskell's view of strong typing is
      that it will not automatically<a name="I_indexterm2_d1e2982" class="calibre27" id="I_indexterm2_d1e2982"></a> coerce values from one type to another. (Coercion is also
      known as casting or conversion.) For example, a C compiler will
      automatically and silently coerce a value of type int into
      a float on our behalf if a function expects a parameter of
      type float, but a Haskell compiler will raise a compilation
      error in a similar situation. We must explicitly coerce types by
      applying coercion functions.</p><a name="x_sl" class="calibre27" id="x_sl"></a><p class="docText">Strong typing does occasionally make it more difficult
      to write certain kinds of code. For example, a classic way to write
      low-level code in the C language is to be given a byte array and cast it
      to treat the bytes as if they're really a complicated data structure.
      This is very efficient, since it doesn't require us to copy the bytes
      around. Haskell's type system does not allow this sort of coercion. In
      order to get the same structured view of the data, we would need to do
      some copying, which would cost a little in performance.</p><a name="x_tl" class="calibre27" id="x_tl"></a><p class="docText">The huge benefit of strong typing is that it catches
      real bugs in our code before they can cause problems. For example, in a
      strongly typed language, we can't accidentally use a string where an
      integer is expected.</p><a name="I_sidebar2_d1e3001" class="calibre27" id="I_sidebar2_d1e3001"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

