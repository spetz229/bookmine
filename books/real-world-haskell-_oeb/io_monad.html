---
layout: page
title: "Real World Haskell, 1st Edition"
prev: io_lazy.html
next: io_imperative.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="io_lazy.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="io_imperative.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="io_monad" class="calibre27" id="io_monad"></a><h3 id="title-IDA2CVTH" class="docSection1Title">7.5. The IO Monad</h3><a name="x_GE" class="calibre27" id="x_GE"></a><p class="docText">You've<a name="I_indexterm7_d1e20420" class="calibre27" id="I_indexterm7_d1e20420"></a><a name="I_indexterm7_d1e20421" class="calibre27" id="I_indexterm7_d1e20421"></a><a name="I_indexterm7_d1e20422" class="calibre27" id="I_indexterm7_d1e20422"></a><a name="I_indexterm7_d1e20423" class="calibre27" id="I_indexterm7_d1e20423"></a><a name="ch07-monad" class="calibre27" id="ch07-monad"></a><a name="ch07-iomonad" class="calibre27" id="ch07-iomonad"></a> seen a number of examples of I/O in Haskell by this point.
    Let's take a moment to step back and think about how I/O relates to the
    broader Haskell language.</p><a name="x_HE" class="calibre27" id="x_HE"></a><p class="docText">Since Haskell is a pure language, if you give a certain
    function a specific argument, the function will return the same result
    every time you give it that argument. Moreover, the function will not
    change anything about the program's overall state.</p><a name="x_IE" class="calibre27" id="x_IE"></a><p class="docText">You may be wondering, then, how I/O fits into this
    picture. Surely if you want to read a line of input from the keyboard, the
    function to read input can't possibly return the same result every time it
    is run, right? Moreover, I/O is all about changing state. I/O could cause
    pixels on a terminal to light up, cause paper to start coming out of a
    printer, or even to cause a package to be shipped from a warehouse on a
    different continent. <span class="docEmphasis">I/O</span> doesn't
    just change the state of a program. You can think of I/O as changing the
    state of the world.</p><a name="io_monad_actions" class="calibre27" id="io_monad_actions"></a><h4 id="title-IDAMEVTH" class="docSection1Title">7.5.1. Actions</h4><a name="x_JE" class="calibre27" id="x_JE"></a><p class="docText">Most languages do not make a distinction between a pure
      function and an impure one. Haskell has functions in the mathematical
      sense: they are purely computations that cannot be altered by anything
      external. Moreover, the computation can be performed at any time—or even
      never, if its result is never needed.</p><a name="x_KE" class="calibre27" id="x_KE"></a><p class="docText">Clearly, then, we need some other tool to work with I/O.
      That tool in Haskell is <a name="I_indexterm7_d1e20445" class="calibre27" id="I_indexterm7_d1e20445"></a>called <span class="docEmphasis">actions</span>. Actions resemble
      functions. They do nothing when they are defined, but perform some task
      when they are invoked. I/O actions are defined within the
      IO monad. Monads are a powerful way of chaining functions
      together purely and are covered in <a class="docLink" href="monads_split_000.html#monads">Chapter 14</a>. It's not
      necessary to understand monads in order to understand I/O. Just
      understand that the result type of actions is "tagged" with
      IO. Let's take a look at some types:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type putStrLn</b>
putStrLn :: String -&gt; IO ()
ghci&gt; <b class="calibre40">:type getLine</b>
getLine :: IO String</pre><a name="x_LE" class="calibre27" id="x_LE"></a><p class="docText">The type of <tt class="calibre34">putStrLn</tt>
      is just<a name="I_indexterm7_d1e20476" class="calibre27" id="I_indexterm7_d1e20476"></a> like any other function. The function takes one parameter
      and returns an <tt class="calibre34">IO ()</tt>. This <tt class="calibre34">IO ()</tt> is the action. You can store and pass
      actions in pure code if you wish, though this isn't frequently done. An
      action doesn't do anything until it is invoked. Let's look at an example
      of this:</p><pre class="calibre39">-- file: ch07/actions.hs
str2action :: String -&gt; IO ()
str2action input = putStrLn ("Data: " ++ input)

list2actions :: [String] -&gt; [IO ()]
list2actions = map str2action

numbers :: [Int]
numbers = [1..10]

strings :: [String]
strings = map show numbers

actions :: [IO ()]
actions = list2actions strings

printitall :: IO ()
printitall = runall actions

-- Take a list of actions, and execute each of them in turn.
runall :: [IO ()] -&gt; IO ()
runall [] = return ()
runall (firstelem:remainingelems) = 
    do firstelem
       runall remainingelems

main = do str2action "Start of the program"
          printitall
          str2action "Done!"</pre><br class="calibre48"/>
<a name="x_ME" class="calibre27" id="x_ME"></a><p class="docText"><tt class="calibre34">str2action</tt> is a
      function that takes one parameter and returns an <tt class="calibre34">IO ()</tt>. As you can see at the end of <tt class="calibre34">main</tt>, you could use this directly in another
      action and it will print out a line right away. Or, you can store—but
      not execute—the action from pure code. You can see an example of that in
      <tt class="calibre34">list2actions</tt>—we use <tt class="calibre34">map</tt> over <tt class="calibre34">str2action</tt> and return a list of actions, just
      like we would with other pure data. You can see that everything up
      through <tt class="calibre34">printitall</tt> is built up with
      pure tools.</p><a name="x_NE" class="calibre27" id="x_NE"></a><p class="docText">Although we define <tt class="calibre34">printitall</tt>, it doesn't get executed until its
      action is evaluated somewhere else. Notice in <tt class="calibre34">main</tt> how we use <tt class="calibre34">str2action</tt> as an I/O action to be executed,
      but earlier we used it outside of the I/O monad and assembled results
      into a list.</p><a name="x_OE" class="calibre27" id="x_OE"></a><p class="docText">You could think of it this way: every statement, except
      <tt class="calibre34">let</tt>, in a <tt class="calibre34">do</tt> block must yield an I/O action that will be
      executed.</p><a name="x_PE" class="calibre27" id="x_PE"></a><p class="docText">The call to <tt class="calibre34">printitall</tt> finally executes all those actions.
      Actually, since Haskell is lazy, the actions aren't generated until here
      either.</p><a name="x_QE" class="calibre27" id="x_QE"></a><p class="docText">When you run the program, your output will look like
      this:</p><pre class="calibre39">Data: Start of the program
Data: 1
Data: 2
Data: 3
Data: 4
Data: 5
Data: 6
Data: 7
Data: 8
Data: 9
Data: 10
Data: Done!</pre><a name="x_RE" class="calibre27" id="x_RE"></a><p class="docText">We can actually write this in a much more compact way.
      Consider this revision of the example:</p><pre class="calibre39">-- file: ch07/actions2.hs
str2message :: String -&gt; String
str2message input = "Data: " ++ input

str2action :: String -&gt; IO ()
str2action = putStrLn . str2message

numbers :: [Int]
numbers = [1..10]

main = do str2action "Start of the program"
          mapM_ (str2action . show) numbers
          str2action "Done!"</pre><br class="calibre48"/>
<a name="x_SE" class="calibre27" id="x_SE"></a><p class="docText">Notice in <tt class="calibre34">str2action</tt>
      the use of the standard function composition operator. In <tt class="calibre34">main</tt>, there's a<a name="I_indexterm7_d1e20554" class="calibre27" id="I_indexterm7_d1e20554"></a> call to <tt class="calibre34">mapM_</tt>. This
      function is similar to <tt class="calibre34">map</tt>. It takes
      a function and a list. The function supplied to <tt class="calibre34">mapM_</tt> is an I/O action that is executed for
      every item in the list. <tt class="calibre34">mapM_</tt> tHRows
      out the result of the function, though you can use <tt class="calibre34">mapM</tt> to return a list of I/O results if you
      want them. Take a look at their types:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type mapM</b>
mapM :: (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
ghci&gt; <b class="calibre40">:type mapM_</b>
mapM_ :: (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()</pre><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_TE" class="calibre27" id="x_TE"></a><p class="docText">These functions actually work for more than just I/O;
        they work for any <tt class="calibre34">Monad</tt>. For now,
        wherever you see "M," just think "IO." Also, functions that end with
        an underscore typically discard their result.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_UE" class="calibre27" id="x_UE"></a><p class="docText">Why a <tt class="calibre34">mapM</tt> when we
      already have <tt class="calibre34">map</tt>? Because <tt class="calibre34">map</tt> is a pure function that returns a list. It
      doesn't—and can't—actually execute actions directly. <tt class="calibre34">mapM</tt> is a utility that lives in the
      IO monad and thus can actually execute the
      actions.<sup class="docFootnote"><a class="docLink1" href="#x_UEd1e20967">[26]</a></sup></p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_UEd1e20967" class="calibre5" id="x_UEd1e20967">[26]</a></sup> Technically speaking, <tt class="calibre34">mapM</tt> combines a bunch of separate I/O
          actions into one big action. The separate actions are executed when
          the big action is.</p></blockquote><a name="x_VE" class="calibre27" id="x_VE"></a><p class="docText">Going back to <tt class="calibre34">main</tt>,
      <tt class="calibre34">mapM_</tt> applies <tt class="calibre34">(str2action . show)</tt> to every element in
      <tt class="calibre34">numbers</tt>. <tt class="calibre34">show</tt> converts each number to a <tt class="calibre34">String</tt> and <tt class="calibre34">str2action</tt> converts each <tt class="calibre34">String</tt> to an action. <tt class="calibre34">mapM_</tt> combines these individual actions into
      one big action that prints out lines.</p><a name="io_bind" class="calibre27" id="io_bind"></a><h4 id="title-IDAZMVTH" class="docSection1Title">7.5.2. Sequencing</h4><a name="x_WE" class="calibre27" id="x_WE"></a><p class="docText"><tt class="calibre34">do</tt> blocks<a name="I_indexterm7_d1e20652" class="calibre27" id="I_indexterm7_d1e20652"></a> are<a name="I_indexterm7_d1e20658" class="calibre27" id="I_indexterm7_d1e20658"></a> actually shortcut notations for joining together actions.
      There are two operators that you can use instead<a name="I_indexterm7_d1e20662" class="calibre27" id="I_indexterm7_d1e20662"></a><a name="I_indexterm7_d1e20665" class="calibre27" id="I_indexterm7_d1e20665"></a> of <tt class="calibre34">do</tt> blocks: <tt class="calibre34">&gt;&gt;</tt> and <tt class="calibre34">&gt;&gt;=</tt>. Let's look at their types in
      <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (&gt;&gt;)</b>
(&gt;&gt;) :: (Monad m) =&gt; m a -&gt; m b -&gt; m b
ghci&gt; <b class="calibre40">:type (&gt;&gt;=)</b>
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</pre><a name="x_XE" class="calibre27" id="x_XE"></a><p class="docText">The <tt class="calibre34">&gt;&gt;</tt> operator
      sequences two actions together: the first action is performed, and then
      the second. The result of the computation is the result of the second
      action. The result of the first action is thrown away. This is similar
      to simply having a line in a <tt class="calibre34">do</tt>
      block. You might write <tt class="calibre34">putStrLn "line 1"
      </tt><tt class="calibre34">&gt;&gt;</tt> putStrLn "line 2"
      to test this out. It will print out two lines, discard the result from
      the first <tt class="calibre34">putStrLn</tt>, and provide the
      result from the second.</p><a name="x_YE" class="calibre27" id="x_YE"></a><p class="docText">The <tt class="calibre34">&gt;&gt;=</tt>
      operator runs an action, and then passes its result to a function that
      returns an action. That second action is run as well, and the result of
      the entire expression is the result of that second action. As an
      example, you could write <tt class="calibre34">getLine </tt><tt class="calibre34">&gt;&gt;=</tt> putStrLn, which would read
      a line from the keyboard and then display it back out.</p><a name="x_ZE" class="calibre27" id="x_ZE"></a><p class="docText">Let's rewrite one of our examples to avoid <tt class="calibre34">do</tt> blocks. Remember this example from the
      start of the chapter?</p><pre class="calibre39">-- file: ch07/basicio.hs
main = do
       putStrLn "Greetings!  What is your name?"
       inpStr &lt;- getLine
       putStrLn $ "Welcome to Haskell, " ++ inpStr ++ "!"</pre><br class="calibre48"/>
<a name="x_aE" class="calibre27" id="x_aE"></a><p class="docText">Let's write that without a <tt class="calibre34">do</tt> block:</p><pre class="calibre39">-- file: ch07/basicio-nodo.hs
main =
    putStrLn "Greetings!  What is your name?" &gt;&gt;
    getLine &gt;&gt;=
    (\inpStr -&gt; putStrLn $ "Welcome to Haskell, " ++ inpStr ++ "!")</pre><br class="calibre48"/>
<a name="x_bE" class="calibre27" id="x_bE"></a><p class="docText">The Haskell compiler internally performs a translation
      just like this when you define a <tt class="calibre34">do</tt>
      block.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_iN" class="calibre27" id="x_iN"></a><p class="docText">Forgetting how to use <tt class="calibre34">\</tt> (lambda expressions)? See <a class="docLink" href="fp_anonymous.html#fp_anonymous">Section 4.7</a>.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="io_return" class="calibre27" id="io_return"></a><h4 id="title-IDAIRVTH" class="docSection1Title">7.5.3. The True Nature of Return</h4><a name="x_jN" class="calibre27" id="x_jN"></a><p class="docText">Earlier in this<a name="I_indexterm7_d1e20753" class="calibre27" id="I_indexterm7_d1e20753"></a> chapter, we mentioned that <tt class="calibre34">return</tt> is probably not what it looks like.
      Many languages have a keyword named <tt class="calibre34">return</tt> that aborts execution of a function
      immediately and returns a value to the caller.</p><a name="x_kN" class="calibre27" id="x_kN"></a><p class="docText">The Haskell <tt class="calibre34">return</tt>
      function is quite different. In Haskell, <tt class="calibre34">return</tt> is used to wrap data in a monad. When
      speaking about I/O, <tt class="calibre34">return</tt> is used to
      take pure data and bring it into the <tt class="calibre34">IO</tt> monad.</p><a name="x_lN" class="calibre27" id="x_lN"></a><p class="docText">Now, why would we want to do that? Remember that
      anything whose result depends on I/O must be within the
      <tt class="calibre34">IO</tt> monad. So if we are writing a function that
      performs <tt class="calibre34">I/O</tt>, and then a pure
      computation, we will need to use <tt class="calibre34">return</tt> to make this pure computation the
      proper return value of the function. Otherwise, a type error would
      occur. Here's an example:</p><pre class="calibre39">-- file: ch07/return1.hs
import Data.Char(toUpper)

isGreen :: IO Bool
isGreen =
    do putStrLn "Is green your favorite color?"
       inpStr &lt;- getLine
       return ((toUpper . head $ inpStr) == 'Y')</pre><br class="calibre48"/>
<a name="x_mN" class="calibre27" id="x_mN"></a><p class="docText">We have a pure computation that yields a <tt class="calibre34">Bool</tt>. That computation is passed to <tt class="calibre34">return</tt>, which puts it into the IO
      monad. Since it is the last value in the <tt class="calibre34">do</tt> block, it becomes the return value of
      <tt class="calibre34">isGreen</tt>, but this is not because we
      used the <tt class="calibre34">return</tt> function.</p><a name="x_nN" class="calibre27" id="x_nN"></a><p class="docText">Here's a version of the same program with the pure
      computation broken out into a separate function. This helps keep the
      pure code separate and can also make the intent more clear:</p><pre class="calibre39">-- file: ch07/return2.hs
import Data.Char(toUpper)

isYes :: String -&gt; Bool
isYes inpStr = (toUpper . head $ inpStr) == 'Y'

isGreen :: IO Bool
isGreen =
    do putStrLn "Is green your favorite color?"
       inpStr &lt;- getLine
       return (isYes inpStr)</pre><br class="calibre48"/>
<a name="x_oN" class="calibre27" id="x_oN"></a><p class="docText">Finally, here's a contrived example to show that
      <tt class="calibre34">return</tt> truly does not have to occur
      at the end of a <tt class="calibre34">do</tt> block. In
      practice, it usually does, but it need not be so.</p><pre class="calibre39">-- file: ch07/return3.hs
returnTest :: IO ()
returnTest =
    do one &lt;- return 1
       let two = 2
       putStrLn $ show (one + two)</pre><br class="calibre48"/>
<a name="x_pN" class="calibre27" id="x_pN"></a><p class="docText">Notice that we used <tt class="calibre34">&lt;-</tt> in combination with <tt class="calibre34">return</tt>, but <tt class="calibre34">let</tt> in combination with the simple literal.
      That's because we needed both values to be pure in order to add them,
      and <tt class="calibre34">&lt;-</tt> pulls things out of monads,
      effectively reversing the effect of <tt class="calibre34">return</tt>. Run this in <i class="docEmphasis">ghci</i> and you'll see <tt class="calibre34">3</tt> displayed, as expected.</p>
<ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="io_lazy.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="io_imperative.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

