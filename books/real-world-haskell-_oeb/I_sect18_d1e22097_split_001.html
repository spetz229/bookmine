---
layout: page
title: "Real World Haskell, 1st Edition"
prev: I_sect18_d1e22097_split_000.html
next: glob_translate_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<p class="calibre37"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="sfbody1"><tr class="calibre16"><td class="v3"><h2 class="docSidebarTitle" id="calibre_pb_0">Perl and POSIX Regular Expressions</h2><a name="x_jF" class="calibre27" id="x_jF"></a><p class="docText">If you're <a name="I_indexterm8_d1e22232" class="calibre27" id="I_indexterm8_d1e22232"></a><a name="I_indexterm8_d1e22237" class="calibre27" id="I_indexterm8_d1e22237"></a>coming to Haskell from a language like Perl, Python, or
        Java, and you've used regular expressions in one of those languages,
        you should be aware that the POSIX regexps handled by the <i class="docEmphasis">Text.Regex.Posix</i> module are different in
        some significant ways from Perl-style regexps. Here are a few of the
        more notable differences.</p><a name="x_kF" class="calibre27" id="x_kF"></a><p class="docText">Perl regexp engines perform left-biased matching when
        matching alternatives, whereas POSIX engines choose the greediest
        match. What this means is that given a regexp of <tt class="calibre34">(foo|fo*)</tt> and a text string of <tt class="calibre34">foooooo</tt>, a Perl-style engine will give a
        match of <tt class="calibre34">foo</tt> (the leftmost match),
        while a POSIX engine will match the entire string (the greediest
        match).</p><a name="x_lF" class="calibre27" id="x_lF"></a><p class="docText">POSIX regexps have less uniform syntax than Perl-style
        regexps. They also lack a number of capabilities provided by
        Perl-style regexps, such as zero-width assertions and control over
        greedy matching.</p></td></tr></table></p><br class="calibre20"/><a name="x_mF" class="calibre5" id="x_mF"></a><p class="docText">Other Haskell regexp packages are available for download
      from Hackage. Some provide better performance than the current POSIX
      engine (e.g., <tt class="calibre34">regex-tdfa</tt>); others provide the Perl-style
      matching that most programmers are now familiar with (e.g.,
      <tt class="calibre34">regex-pcre</tt>). All follow the standard API that we have
      covered in this section.</p>
<ul class="calibre28"></ul><table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody"><tr class="calibre6"><td valign="middle" class="v1" height="5"><img src="pixel.gif" alt="" border="0" class="calibre8"/></td></tr><tr class="calibre6"><td valign="middle" class="v1"><table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody"><tr class="calibre6"><td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td></tr></table></td><td class="v1"/><td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="glob_regex.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="glob_translate_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody"><tr class="calibre6"><td valign="top" class="v2"><span class="calibre9"></span></td></tr></table><!--IP User 2--><td class="calibre7">
                         
                      </td><tr class="calibre6"><td colspan="3" valign="bottom" class="calibre7"><br class="calibre20"/><p class="v4"></p><br class="calibre20"/></td></tr></div>

{% endraw %}

