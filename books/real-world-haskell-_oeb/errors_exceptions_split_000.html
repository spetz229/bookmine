---
layout: page
title: "Real World Haskell, 1st Edition"
prev: errors_nonexception.html
next: errors_exceptions_split_001.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="errors_nonexception.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect119_d1e42478_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="errors_exceptions" class="calibre27" id="errors_exceptions"></a><h3 id="643999-938" class="docSection1Title">19.2. Exceptions</h3><a name="errors_exceptionsd1e41948" class="calibre27" id="errors_exceptionsd1e41948"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"></p><p class="docText">Version 6.10.1 of GHC was released as this book went to press. It
      introduces an extensible extension system. In the sections that follow,
      we document the older exception system. The two are similar, but not
      completely compatible.</p></div><a name="x_U11" class="calibre27" id="x_U11"></a><p class="docText">Exception<a name="I_indexterm19_d1e41626" class="calibre27" id="I_indexterm19_d1e41626"></a><a name="I_indexterm19_d1e41627" class="calibre27" id="I_indexterm19_d1e41627"></a><a name="I_indexterm19_d1e41628" class="calibre27" id="I_indexterm19_d1e41628"></a><a name="ch19-exceptions" class="calibre27" id="ch19-exceptions"></a> handling is found in many programming languages, including
    Haskell. It can be useful because, when a problem occurs, exception
    handling can provide an easy way of handling it, even if it occurs several
    layers down through a chain of function calls. With exceptions, it's not
    necessary to check the return value of every function call for errors, and
    we must take care to produce a return value that reflects the error, as C
    programmers must do. In Haskell, thanks to monads and the <tt class="calibre34">Either</tt> and <tt class="calibre34">Maybe</tt> types, we can often achieve the same
    effects in pure code without the need to use exceptions and exception
    handling.</p><a name="x_V11" class="calibre27" id="x_V11"></a><p class="docText">Some problems—especially those involving I/O—call for
    working with exceptions. In Haskell, exceptions may be thrown from any
    location in the program. However, due to the unspecified evaluation order,
    they can only be caught in the IO monad. Haskell exception
    handling doesn't involve special syntax as it does in Python or Java.
    Rather, the mechanisms to catch and handle exceptions
    are—surprise—functions.</p><a name="errors_exceptions_firststeps" class="calibre27" id="errors_exceptions_firststeps"></a><h4 id="title-IDA3ORWD" class="docSection1Title">19.2.1. First Steps with Exceptions</h4><a name="x_W11" class="calibre27" id="x_W11"></a><p class="docText">In the <tt class="calibre34">Control.Exception</tt> module,<a name="I_indexterm19_d1e41652" class="calibre27" id="I_indexterm19_d1e41652"></a> various functions and types<a name="I_indexterm19_d1e41656" class="calibre27" id="I_indexterm19_d1e41656"></a> relating to exceptions are defined. There is an <tt class="calibre34">Exception</tt> type<a name="I_indexterm19_d1e41665" class="calibre27" id="I_indexterm19_d1e41665"></a> defined there; all exceptions are of type <tt class="calibre34">Exception</tt>. There are also
      functions for catching and handling exceptions. Let's start by looking
      at <tt class="calibre34">try</tt>, which has type <tt class="calibre34">IO a -&gt; IO (Either Exception a)</tt>. This wraps
      an IO action with exception handling. If an exception is
      thrown, it will return a <tt class="calibre34">Left</tt> value
      with the exception; otherwise, it returns a <tt class="calibre34">Right</tt> value with the original result. Let's
      try this out in <i class="docEmphasis">ghci</i>. We'll first
      trigger an unhandled exception, and then try to catch it:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m Control.Exception</b>ghci&gt; <b class="calibre40">let x = 5 `div` 0</b>ghci&gt; <b class="calibre40">let y = 5 `div` 1</b>ghci&gt; <b class="calibre40">print x</b>
*** Exception: divide by zero
ghci&gt; <b class="calibre40">print y</b>
5
ghci&gt; <b class="calibre40">try (print x)</b>
Left divide by zero
ghci&gt; <b class="calibre40">try (print y)</b>
5
Right ()</pre><a name="x_X11" class="calibre27" id="x_X11"></a><p class="docText">Notice that no exception was thrown by the <tt class="calibre34">let</tt> statements. That's<a name="I_indexterm19_d1e41734" class="calibre27" id="I_indexterm19_d1e41734"></a> to be expected due to lazy evaluation; the division by
      zero won't be attempted until it is demanded by the attempt to print out
      <tt class="calibre34">x</tt>. Also, notice that there were two
      lines of output from <tt class="calibre34">TRy</tt> <tt class="calibre34">(print y)</tt>. The first line was produced by
      <tt class="calibre34">print</tt>, which displayed the digit
      <tt class="calibre34">5</tt> on the terminal. The second was produced by
      <i class="docEmphasis">ghci</i> and shows us that <tt class="calibre34">print y</tt> returned <tt class="calibre34">()</tt> and didn't throw an exception.</p><a name="errors_exceptions_lazy" class="calibre27" id="errors_exceptions_lazy"></a><h4 id="title-IDAITRWD" class="docSection1Title">19.2.2. Laziness and Exception Handling</h4><a name="x_Y11" class="calibre27" id="x_Y11"></a><p class="docText">Now that you know how <tt class="calibre34">TRy</tt> works, let's try another experiment. Let's
      say we want to catch the result of <tt class="calibre34">TRy</tt> for future evaluation, so we can handle
      the result of division. Perhaps we would do it like this:</p><pre class="calibre39">ghci&gt; <b class="calibre40">result &lt;- try (return x)</b>
Right *** Exception: divide by zero
</pre><a name="x_Z11" class="calibre27" id="x_Z11"></a><p class="docText">What happened here? Let's try to piece it together, and
      illustrate with another attempt:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let z = undefined</b>ghci&gt; <b class="calibre40">try (print z)</b>
Left Prelude.undefined
ghci&gt; <b class="calibre40">result &lt;- try (return z)</b>
Right *** Exception: Prelude.undefined</pre><a name="x_a11" class="calibre27" id="x_a11"></a><p class="docText">As before, assigning <tt class="calibre34">undefined</tt> to <tt class="calibre34">z</tt> was not a problem. The key to this puzzle,
      and to the division puzzle, lies with lazy evaluation. Specifically, it
      lies with <tt class="calibre34">return</tt>, which does not
      force the evaluation of its argument; it only wraps it up. So, the
      result of <tt class="calibre34">try (return undefined)</tt>
      would be <tt class="calibre34">Right undefined</tt>. Now,
      <i class="docEmphasis">ghci</i> wants to display this result on
      the terminal. It gets as far as printing out <tt class="calibre34">"Right "</tt>, but we can't print out
      <tt class="calibre34">undefined</tt> (or the result of division by zero). So when we
      see the exception message, it's coming from <i class="docEmphasis">ghci</i>, not your program.</p><a name="x_b11" class="calibre27" id="x_b11"></a><p class="docText">This is a key point. Let's think about why our earlier
      example worked and this one didn't. Earlier, we put <tt class="calibre34">print x</tt> inside <tt class="calibre34">try</tt>. Printing the value of something, of
      course, requires it to be evaluated, so the exception was detected at
      the right place. But simply using <tt class="calibre34">return</tt> does not force evaluation. To solve
      this problem, the <tt class="calibre34">Control.Exception</tt>
      module defines the <i class="docEmphasis">evaluate</i>
      function. It behaves just like <tt class="calibre34">return</tt>
      but forces its argument to be evaluated immediately. Let's try
      it:</p><pre class="calibre39">ghci&gt; <b class="calibre40">let z = undefined</b>ghci&gt; <b class="calibre40">result &lt;- try (evaluate z)</b>
Left Prelude.undefined
ghci&gt; <b class="calibre40">result &lt;- try (evaluate x)</b>
Left divide by zero</pre><a name="x_c11" class="calibre27" id="x_c11"></a><p class="docText">There, that's what was expected. This worked for both
      <tt class="calibre34">undefined</tt> and our division by zero example.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_d11" class="calibre27" id="x_d11"></a><p class="docText">Remember: whenever you are trying to catch exceptions
        thrown by pure code, use <i class="docEmphasis">evaluate</i>
        instead of <tt class="calibre34">return</tt> inside your
        exception-catching function.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="errors_exceptions_handle" class="calibre27" id="errors_exceptions_handle"></a><h4 id="title-IDASXRWD" class="docSection1Title">19.2.3. Using handle</h4><a name="x_e11" class="calibre27" id="x_e11"></a><p class="docText">Often, you may wish to perform one action<a name="I_indexterm19_d1e41886" class="calibre27" id="I_indexterm19_d1e41886"></a> if a piece of code completes without an exception, and
      perform a different action otherwise. For situations such as this,
      there's a function called <tt class="calibre34">handle</tt>.
      This function has type <tt class="calibre34">(Exception -&gt; IO a)
      -&gt; IO a -&gt; IO a</tt>. That is, it takes two parameters. The
      first is a function to call in the event where there is an exception
      while performing the second. Here's one way we could use it:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:m Control.Exception</b>ghci&gt; <b class="calibre40">let x = 5 `div` 0</b>ghci&gt; <b class="calibre40">let y = 5 `div` 1</b>ghci&gt; <b class="calibre40">handle (\_ -&gt; putStrLn "Error calculating result") (print x)</b>
Error calculating result
ghci&gt; <b class="calibre40">handle (\_ -&gt; putStrLn "Error calculating result") (print y)</b>
5</pre><a name="x_f11" class="calibre27" id="x_f11"></a><p class="docText">This way, we can print out a nice message if there is
      an error in the calculations. It's nicer than having the program crash
      with a division by zero error, for sure.</p><a name="errors_exceptions_selective" class="calibre27" id="errors_exceptions_selective"></a><h4 id="title-IDAERO0E" class="docSection1Title">19.2.4. Selective Handling of Exceptions</h4><a name="x_g11" class="calibre27" id="x_g11"></a><p class="docText">One problem<a name="I_indexterm19_d1e41930" class="calibre27" id="I_indexterm19_d1e41930"></a> with the previous example is that it prints <tt class="calibre34">"Error calculating result"</tt> for
      <span class="docEmphasis">any</span> exception. There may have been an exception
      other than a division by zero exception. For instance, there may have
      been an error displaying the output, or some other exception could have
      been thrown by the pure code.</p><a name="x_h11" class="calibre27" id="x_h11"></a><p class="docText">There's a function <tt class="calibre34">handleJust</tt> for<a name="I_indexterm19_d1e41947" class="calibre27" id="I_indexterm19_d1e41947"></a> these situations. It lets you specify a test to see
      whether you are interested in a given exception. Let's take a
      look:</p><pre class="calibre39">-- file: ch19/hj1.hs
import Control.Exception

catchIt :: Exception -&gt; Maybe ()
catchIt (ArithException DivideByZero) = Just ()
catchIt _ = Nothing

handler :: () -&gt; IO ()
handler _ = putStrLn "Caught error: divide by zero"

safePrint :: Integer -&gt; IO ()
safePrint x = handleJust catchIt handler (print x)</pre><br class="calibre48"/>
<a name="x_i11" class="calibre27" id="x_i11"></a><p class="docText"><tt class="calibre34">catchIt</tt> defines a
      function that decides whether or not we're interested in a given
      exception. It returns <tt class="calibre34">Just</tt> if so, and
      <tt class="calibre34">Nothing</tt> if not. Also, the value
      attached to <tt class="calibre34">Just</tt> will be passed to
      our handler. We can now use <tt class="calibre34">safePrint</tt>
      nicely:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:l hj1.hs</b>
[1 of 1] Compiling Main             ( hj1.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">let x = 5 `div` 0</b>
ghci&gt; <b class="calibre40">let y = 5 `div` 1</b>
ghci&gt; <b class="calibre40">safePrint x</b>
Caught error: divide by zero
ghci&gt; <b class="calibre40">safePrint y</b>
5</pre><a name="x_j11" class="calibre27" id="x_j11"></a><p class="docText">The <tt class="calibre34">Control.Exception</tt> module<a name="I_indexterm19_d1e42001" class="calibre27" id="I_indexterm19_d1e42001"></a> also presents a number of functions that we can use as
      part of the test in <tt class="calibre34">handleJust</tt> to
      narrow down the kinds of exceptions we care about. For instance, there
      is a function <tt class="calibre34">arithExceptions</tt> of type
      <tt class="calibre34">Exception -&gt; Maybe</tt> <tt class="calibre34">ArithException</tt> that will pick out any
      <tt class="calibre34">ArithException</tt>, but ignore any other
      one. We could use it like this:</p><pre class="calibre39">-- file: ch19/hj2.hs
import Control.Exception

handler :: ArithException -&gt; IO ()
handler e = putStrLn $ "Caught arithmetic error: " ++ show e

safePrint :: Integer -&gt; IO ()
safePrint x = handleJust arithExceptions handler (print x)</pre><br class="calibre48"/>
<a name="x_k11" class="calibre27" id="x_k11"></a><p class="docText">In this way, we can catch all types of <tt class="calibre34">ArithException</tt>, but still let other exceptions
      pass through unmodified and uncaught. We can see it work like so:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:l hj2.hs</b>
[1 of 1] Compiling Main             ( hj2.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">let x = 5 `div` 0</b>
ghci&gt; <b class="calibre40">let y = 5 `div` 1</b>
ghci&gt; <b class="calibre40">safePrint x</b>
Caught arithmetic error: divide by zero
ghci&gt; <b class="calibre40">safePrint y</b>
5</pre><a name="x_l11" class="calibre27" id="x_l11"></a><p class="docText">Of particular interest is the <tt class="calibre34">ioErrors</tt> test, which corresponds to the large
      class of I/O-related exceptions.</p><a name="errors_exceptions_io" class="calibre27" id="errors_exceptions_io"></a><h4 id="title-IDAAWO0E" class="docSection1Title">19.2.5. I/O Exceptions</h4><a name="x_m11" class="calibre27" id="x_m11"></a><p class="docText">Perhaps<a name="ch19-ioexceptions" class="calibre27" id="ch19-ioexceptions"></a><a name="I_indexterm19_d1e42070" class="calibre27" id="I_indexterm19_d1e42070"></a> the largest source of exceptions in any program is I/O.
      All sorts of things can go wrong when dealing with the outside world:
      disks can be full, networks can go down, or files can be empty when you
      expect them to have data. In Haskell, an I/O exception is just like any
      other exception in that the <tt class="calibre34">Exception</tt>
      data type can represent it. On the other hand, because there are so many
      types of I/O exceptions, a special module, <tt class="calibre34">System.IO.Error</tt>, exists<a name="I_indexterm19_d1e42082" class="calibre27" id="I_indexterm19_d1e42082"></a> for dealing with them.</p><a name="x_n11" class="calibre27" id="x_n11"></a><p class="docText"><tt class="calibre34">System.IO.Error</tt>
      defines two functions, <tt class="calibre34">catch</tt> and
      <tt class="calibre34">try</tt>, that,<a name="I_indexterm19_d1e42096" class="calibre27" id="I_indexterm19_d1e42096"></a><a name="I_indexterm19_d1e42103" class="calibre27" id="I_indexterm19_d1e42103"></a> like their counterparts in <tt class="calibre34">Control.Exception</tt>, are used to deal with
      exceptions. Unlike the <tt class="calibre34">Control.Exception</tt> functions, however, these
      functions will trap only I/O errors and will pass all other exceptions
      through uncaught. In Haskell, I/O errors all have type <tt class="calibre34">IOError</tt>, which is defined as the same as
      <tt class="calibre34">IOException</tt>.</p><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="warning_yellow.gif" alt="" class="calibre44"/></td><td valign="top" class="v3"><p class="docCautionsTitle">Be careful which names you use</p><a name="x_o11" class="calibre27" id="x_o11"></a><p class="docText">Because both <tt class="calibre34">System.IO.Error</tt> and <tt class="calibre34">Control.Exception</tt> define functions with the
        same names, if you import both in your program, you will get an error
        message about an ambiguous reference to a function. You can import one
        or the other module <tt class="calibre34">qualified</tt>, or
        hide the symbols from one module or the other.</p><a name="x_D31" class="calibre27" id="x_D31"></a><p class="docText">Note that <tt class="calibre34">Prelude</tt>
        exports <tt class="calibre34">System.IO.Error</tt>'s version
        of <tt class="calibre34">catch</tt>, <span class="docEmphasis">not</span>
        the version provided by <tt class="calibre34">Control.Exception</tt>. Remember that
        the former can catch only I/O errors, while the latter can catch all
        exceptions. In other words, the <tt class="calibre34">catch</tt> in <tt class="calibre34">Control.Exception</tt> is
        almost always the one you will want, but it is
        <span class="docEmphasis">not</span> the one you will get by default.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_p11" class="calibre27" id="x_p11"></a><p class="docText">Let's take a look at one approach to using exceptions
      in the I/O system to our benefit. Back in <a class="docLink" href="io_files.html#io_files">Section 7.2</a>,
      we presented a program that used an imperative style to read lines from
      a file one by one. Although we subsequently demonstrated more compact,
      "Haskelly" ways to solve that problem, let's revisit that example here.
      In the <tt class="calibre34">mainloop</tt> function, we had to
      explicitly test if we were at the end of the input file before each
      attempt to read a line from it. Instead, we could check if the attempt
      to read a line resulted in an EOF error, like so:</p><pre class="calibre39">-- file: ch19/toupper-impch20.hs
import System.IO
import System.IO.Error
import Data.Char(toUpper)

main :: IO ()
main = do 
       inh &lt;- openFile "input.txt" ReadMode
       outh &lt;- openFile "output.txt" WriteMode
       mainloop inh outh
       hClose inh
       hClose outh

mainloop :: Handle -&gt; Handle -&gt; IO ()
mainloop inh outh = 
    do input &lt;- try (hGetLine inh)
       case input of
         Left e -&gt; 
             if isEOFError e
                then return ()
                else ioError e
         Right inpStr -&gt;
             do hPutStrLn outh (map toUpper inpStr)
                mainloop inh outh</pre><br class="calibre48"/>
<a name="x_q11" class="calibre27" id="x_q11"></a><p class="docText">Here, we use the <tt class="calibre34">System.IO.Error</tt> version of <tt class="calibre34">TRy</tt> to check whether <tt class="calibre34">hGetLine</tt> threw an <tt class="calibre34">IOError</tt>. If it did, we use <tt class="calibre34">isEOFError</tt> (defined in <tt class="calibre34">System.IO.Error</tt>) to see if the thrown
      exception indicated that we reached the end of the file. If it did, we
      exit the loop. If the exception was something else, we call <tt class="calibre34">ioError</tt> to rethrow it.</p><a name="x_r11" class="calibre27" id="x_r11"></a><p class="docText">There are many such tests and ways to extract
      information from <tt class="calibre34">IOError</tt> defined in
      <tt class="calibre34">System.IO.Error</tt>. We recommend that
      you consult that page in the library reference when you need to know
      about them.</p><a name="errors_exceptions_raising" class="calibre27" id="errors_exceptions_raising"></a><h4 id="title-IDAU1O0E" class="docSection1Title">19.2.6. Throwing Exceptions</h4><a name="x_s11" class="calibre27" id="x_s11"></a><p class="docText">Thus<a name="I_indexterm19_d1e42207" class="calibre27" id="I_indexterm19_d1e42207"></a><a name="I_indexterm19_d1e42212" class="calibre27" id="I_indexterm19_d1e42212"></a> far, we have talked in detail
      about handling exceptions. There is another piece to the puzzle:
      throwing exceptions.<sup class="docFootnote"><a class="docLink1" href="#x_s11d1e42532">[43]</a></sup> In the examples we have visited so far in this chapter,
      the Haskell system throws exceptions for you. However, it is possible to
      throw any exception yourself. We'll show you how.</p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_s11d1e42532" class="calibre5" id="x_s11d1e42532">[43]</a></sup> In some other languages, throwing an exception is
          referred to as <span class="docEmphasis">raising</span> it.</p></blockquote><a name="x_t11" class="calibre27" id="x_t11"></a><p class="docText">You'll notice that most of these functions appear to
      return a value of type <tt class="calibre34">a</tt> or <tt class="calibre34">IO a</tt>. This means that the function can appear
      to return a value of any type. In fact, because these functions throw
      exceptions, they never "return" anything in the normal sense. These
      return values let you use these functions in various contexts where
      various different types are expected.</p><a name="x_u11" class="calibre27" id="x_u11"></a><p class="docText">Let's start our tour of ways to throw exceptions with
      the functions in <tt class="calibre34">Control.Exception</tt>. The most generic
      function<a name="I_indexterm19_d1e42234" class="calibre27" id="I_indexterm19_d1e42234"></a> is <tt class="calibre34">tHRow</tt>, which has
      type <tt class="calibre34">Exception -&gt; a</tt>. This function
      can throw any <tt class="calibre34">Exception</tt>, and can do
      so in a pure context. There is a companion function—<tt class="calibre34">tHRowIO</tt> with type <tt class="calibre34">Exception -&gt; IO a</tt>—that throws an exception
      in the IO monad. Both functions require an <tt class="calibre34">Exception</tt> to throw. You can craft an <tt class="calibre34">Exception</tt> by hand or reuse an <tt class="calibre34">Exception</tt> that was previously created.</p><a name="x_v11" class="calibre27" id="x_v11"></a><p class="docText">There is also a function <tt class="calibre34">ioError</tt>, which is defined identically in
      <tt class="calibre34">Control.Exception</tt> and <tt class="calibre34">System.IO.Error</tt> with type <tt class="calibre34">IOError -&gt; IO a</tt>. This is used when you want
      to generate an arbitrary I/O-related exception.</p><a name="errors_exceptions_dynamic" class="calibre27" id="errors_exceptions_dynamic"></a><h4 id="title-IDA24O0E" class="docSection1Title">19.2.7. Dynamic Exceptions</h4><a name="x_z11" class="calibre27" id="x_z11"></a><p class="docText">Dynamic Exceptions make<a name="ch19-dynamicexceptions" class="calibre27" id="ch19-dynamicexceptions"></a><a name="ch19-exceptiondynamic" class="calibre27" id="ch19-exceptiondynamic"></a> use of two little-used Haskell modules: <tt class="calibre34">Data.Dynamic</tt> and <tt class="calibre34">Data.Typeable</tt>. We<a name="I_indexterm19_d1e42300" class="calibre27" id="I_indexterm19_d1e42300"></a><a name="I_indexterm19_d1e42303" class="calibre27" id="I_indexterm19_d1e42303"></a> will not go into a great level of detail on those modules
      here, but we will give you the tools you need to craft and use your own
      dynamic exception type.</p><a name="x_A21" class="calibre27" id="x_A21"></a><p class="docText">In <a class="docLink" href="databases_split_000.html#databases">Chapter 21</a>, you will see that the
      HDBC database library uses dynamic exceptions to indicate errors from
      SQL databases back to applications. Errors from database <span class="docEmphasis">engines</span> often have three components: an
      integer that represents an error code, a state, and a human-readable
      error message. We will build up our own implementation of the HDBC
      <tt class="calibre34">SqlError</tt> type here. Let's start with
      the data structure representing the error itself:</p><pre class="calibre39">-- file: ch19/dynexc.hs
{-# LANGUAGE DeriveDataTypeable #-}

import Data.Dynamic
import Control.Exception

data SqlError = SqlError {seState :: String,
                          seNativeError :: Int,
                          seErrorMsg :: String}
                deriving (Eq, Show, Read, Typeable)</pre><br class="calibre48"/>
<a name="x_B21" class="calibre27" id="x_B21"></a><p class="docText">By deriving the Typeable
      typeclass,<a name="I_indexterm19_d1e42324" class="calibre27" id="I_indexterm19_d1e42324"></a> we've made this type available for dynamically typed
      programming. In order for <span class="docMonofont">GHC</span>
      to automatically generate a Typeable instance, we had to
      enable the <tt class="calibre34">DeriveDataTypeable</tt> language<a name="I_indexterm19_d1e42338" class="calibre27" id="I_indexterm19_d1e42338"></a><a name="I_indexterm19_d1e42343" class="calibre27" id="I_indexterm19_d1e42343"></a> extension.<sup class="docFootnote"><a class="docLink1" href="#x_B21d1e42665">[44]</a></sup></p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_B21d1e42665" class="calibre5" id="x_B21d1e42665">[44]</a></sup> It is possible to derive Typeable
          instances by hand, but that is cumbersome.</p></blockquote><a name="x_C21" class="calibre27" id="x_C21"></a><p class="docText">Now, let's define a <tt class="calibre34">catchSql</tt> and a <tt class="calibre34">handleSql</tt> that can be used to catch an
      exception that is an <tt class="calibre34">SqlError</tt> (note
      that the regular <tt class="calibre34">catch</tt> and <tt class="calibre34">handle</tt> functions cannot catch our <tt class="calibre34">SqlError</tt>, because it is not a type of <tt class="calibre34">Exception</tt>):</p><pre class="calibre39">-- file: ch19/dynexc.hs
{- | Execute the given IO action.

If it raises a 'SqlError', then execute the supplied 
handler and return its return value.  Otherwise, proceed
as normal. -}
catchSql :: IO a -&gt; (SqlError -&gt; IO a) -&gt; IO a
catchSql = catchDyn

{- | Like 'catchSql', with the order of arguments reversed. -}
handleSql :: (SqlError -&gt; IO a) -&gt; IO a -&gt; IO a
handleSql = flip catchSql</pre><br class="calibre48"/>
<a name="x_D21" class="calibre27" id="x_D21"></a><p class="docText">These functions are simply thin wrappers around
      <tt class="calibre34">catchDyn</tt>, which has type <tt class="calibre34">Typeable exception =&gt; IO a -&gt; (exception -&gt; IO
      a) -&gt; IO a</tt>. We simply restrict the type of this here so
      that it catches only SQL exceptions.</p><a name="x_E21" class="calibre27" id="x_E21"></a><p class="docText">Normally, when an exception is thrown but not caught
      anywhere, the program will crash and display the exception to standard
      error. With a dynamic exception, however, the system will not know how
      to display this, so we will simply see an unhelpful "unknown exception"
      message. We can provide a utility so that application writers can simply
      say <tt class="calibre34">main = handleSqlError $ do ...</tt>
      and have confidence that any exceptions thrown (in that thread) will be
      displayed. Here's how to write <tt class="calibre34">handleSqlError</tt>:</p><pre class="calibre39">-- file: ch19/dynexc.hs
{- | Catches 'SqlError's, and re-raises them as IO errors with fail.
Useful if you don't care to catch SQL errors, but want to see a sane
error message if one happens.  One would often use this as a 
high-level wrapper around SQL calls. -}
handleSqlError :: IO a -&gt; IO a
handleSqlError action =
    catchSql action handler
    where handler e = fail ("SQL error: " ++ show e)</pre><br class="calibre48"/>
<a name="x_F21" class="calibre27" id="x_F21"></a><p class="docText">Finally, here's an example of how to throw an <tt class="calibre34">SqlError</tt> as an exception. Here's a function
      that will do just that:</p><pre class="calibre39">-- file: ch19/dynexc.hs
throwSqlError :: String -&gt; Int -&gt; String -&gt; a
throwSqlError state nativeerror errormsg =
    throwDyn (SqlError state nativeerror errormsg)

throwSqlErrorIO :: String -&gt; Int -&gt; String -&gt; IO a
throwSqlErrorIO state nativeerror errormsg =
    evaluate (throwSqlError state nativeerror errormsg)</pre><br class="calibre48"/>
<p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><a name="x_cJ1" class="calibre27" id="x_cJ1"></a><p class="docText">As a reminder, <tt class="calibre34">evaluate</tt> is like <tt class="calibre34">return</tt> but forces the evaluation of its
        argument.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_G21" class="calibre27" id="x_G21"></a><p class="docText">This completes our dynamic exception support. That was
      a lot of code, and you may not have needed that much, but we wanted to
      give you an example of the dynamic exception itself and the utilities
      that often go with it. In fact, these examples reflect almost exactly
      what is present in the HDBC library. Let's play with these in <i class="docEmphasis">ghci</i> for a bit:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:l dynexc.hs</b>
[1 of 1] Compiling Main             ( dynexc.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">throwSqlErrorIO "state" 5 "error message"</b>
*** Exception: (unknown)
ghci&gt; <b class="calibre40">handleSqlError $ throwSqlErrorIO "state" 5 "error message"</b>
*** Exception: user error (SQL error: SqlError {seState = "state", seNativeError = 5,
seErrorMsg = "error message"})
ghci&gt; <b class="calibre40">handleSqlError $ fail "other error"</b>
*** Exception: user error (other error)</pre><a name="x_H21" class="calibre27" id="x_H21"></a><p class="docText">From this, you can see that <i class="docEmphasis">ghci</i> doesn't know how to display an SQL error
      by itself. However, you can also see that our <tt class="calibre34">handleSqlError</tt> function helped out with that
      but also passed through other errors unmodified. Let's finally try out a
      custom handler:</p><pre class="calibre39">ghci&gt; <b class="calibre40">handleSql (fail . seErrorMsg) (throwSqlErrorIO "state" 5 "my error")</b>
*** Exception: user error (my error)
</pre><a name="x_I21" class="calibre27" id="x_I21"></a><p class="docText">Here, we defined a custom error handler that threw a
      new exception, consisting of the message in the <tt class="calibre34">seErrorMsg</tt> field of the <tt class="calibre34">SqlError</tt>. You can see that it worked as
      intended.</p><a name="I_sidebar19_d1e42462" class="calibre27" id="I_sidebar19_d1e42462"></a></td>
                    </tr>
                  </table>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

