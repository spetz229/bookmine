---
layout: page
title: "Real World Haskell, 1st Edition"
prev: funcstypes_srcfile.html
next: funcstypes_polymorphism.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="funcstypes_srcfile.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="funcstypes_polymorphism.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="I_sect12_d1e4585" class="calibre27" id="I_sect12_d1e4585"></a><h3 id="title-IDANAISI" class="docSection1Title">2.10. Understanding Evaluation by Example</h3><a name="x_Ce" class="calibre27" id="x_Ce"></a><p class="docText">In<a name="I_indexterm2_d1e4590" class="calibre27" id="I_indexterm2_d1e4590"></a><a name="I_indexterm2_d1e4591" class="calibre27" id="I_indexterm2_d1e4591"></a><a name="I_indexterm2_d1e4592" class="calibre27" id="I_indexterm2_d1e4592"></a><a name="ch02-evaluation" class="calibre27" id="ch02-evaluation"></a> our description of <i class="docEmphasis">myDrop</i>, we have so far focused on surface
    features. We need to go deeper and develop a useful mental model of how
    function application works. To do this, we'll first work through a few
    simple examples, until we can walk through the evaluation of the
    expression <tt class="calibre34">myDrop 2 "abcd"</tt>.</p><a name="x_De" class="calibre27" id="x_De"></a><p class="docText">We've talked a lot about substituting an expression for a
    variable, and we'll make use of this capability here. Our procedure will
    involve rewriting expressions over and over, substituting expressions for
    variables until we reach a final result. This would be a good time to
    fetch a pencil and paper, so you can follow our descriptions by trying
    them yourself.</p><a name="I_sect12_d1e4585d1e4671" class="calibre27" id="I_sect12_d1e4585d1e4671"></a><h4 id="title-IDASBISI" class="docSection1Title">2.10.1. Lazy Evaluation</h4><a name="x_bm" class="calibre27" id="x_bm"></a><p class="docText">We will begin by looking <a name="I_indexterm2_d1e4610" class="calibre27" id="I_indexterm2_d1e4610"></a>at the definition of a simple, nonrecursive
      function:</p><pre class="calibre39">-- file: ch02/RoundToEven.hs
isOdd n = mod n 2 == 1</pre><br class="calibre48"/>
<a name="x_cm" class="calibre27" id="x_cm"></a><p class="docText">Here, <i class="docEmphasis">mod</i> is the
      standard modulo function. The first big step to understanding how
      evaluation works in Haskell is figuring out the result of evaluating the
      expression <tt class="calibre34">isOdd (1 + 2)</tt>.</p><a name="x_dm" class="calibre27" id="x_dm"></a><p class="docText">Before we explain how evaluation proceeds in Haskell,
      let us recap the sort of evaluation strategy more familiar languages
      use. First, evaluate the subexpression <tt class="calibre34">1 + 2</tt>, to give
      <tt class="calibre34">3</tt>. Then apply the <i class="docEmphasis">odd</i>
      function with <span class="docMonofont">n</span> bound to <tt class="calibre34">3</tt>. Finally,
      evaluate <tt class="calibre34">mod 3 2</tt> to give <tt class="calibre34">1</tt>, and <tt class="calibre34">1 ==
      1</tt> to give <tt class="calibre34">true</tt>.</p><a name="x_em" class="calibre27" id="x_em"></a><p class="docText">In a language that uses <span class="docEmphasis">strict</span>
      evaluation, <a name="I_indexterm2_d1e4659" class="calibre27" id="I_indexterm2_d1e4659"></a>the arguments to a function are evaluated before the
      function is applied. Haskell chooses another path:
      <span class="docEmphasis">nonstrict</span> <a name="I_indexterm2_d1e4666" class="calibre27" id="I_indexterm2_d1e4666"></a>evaluation.</p><a name="x_fm" class="calibre27" id="x_fm"></a><p class="docText">In Haskell, the subexpression <tt class="calibre34">1 + 2</tt> is
      <span class="docEmphasis">not</span> reduced to the value <tt class="calibre34">3</tt>. Instead,
      we create a "promise" that when the value of the expression
      <tt class="calibre34">isOdd (1 + 2)</tt> is needed, we'll be able to compute it. The
      record that we use to track an unevaluated expression is referred to as
      <a name="I_indexterm2_d1e4688" class="calibre27" id="I_indexterm2_d1e4688"></a>a <span class="docEmphasis">thunk</span>. This is
      <span class="docEmphasis">all</span> that happens: we create a thunk and defer the
      actual evaluation until it's really needed. If the result of this
      expression is never subsequently used, we will not compute its value at
      all.</p><a name="x_gm" class="calibre27" id="x_gm"></a><p class="docText">Nonstrict evaluation is often referred to as
      <span class="docEmphasis">lazy evaluation.</span><sup class="docFootnote"><a class="docLink1" href="#x_gmd1e4768">[6]</a></sup></p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_gmd1e4768" class="calibre5" id="x_gmd1e4768">[6]</a></sup> The terms "nonstrict" and
          "lazy" have slightly different technical meanings, but
          we won't go into the details of the distinction here.</p></blockquote><a name="I_sect12_d1e4585d1e4777" class="calibre27" id="I_sect12_d1e4585d1e4777"></a><h4 id="title-IDAXEISI" class="docSection1Title">2.10.2. A More Involved Example</h4><a name="x_om" class="calibre27" id="x_om"></a><p class="docText">Let us now look at the evaluation of the expression
      <tt class="calibre34">myDrop 2 "abcd"</tt>, where we use <i class="docEmphasis">print</i> to ensure that it will be
      evaluated:</p><pre class="calibre39">ghci&gt; <b class="calibre40">print (myDrop 2 "abcd")</b>
"cd"
</pre><a name="x_pm" class="calibre27" id="x_pm"></a><p class="docText">Our first step is to attempt to apply <i class="docEmphasis">print</i>, which needs its argument to be
      evaluated. To do that, we apply the function <i class="docEmphasis">myDrop</i> to the values <tt class="calibre34">2</tt> and
      <tt class="calibre34">"abcd"</tt>. We bind the variable <span class="docMonofont">n</span> to the
      value <tt class="calibre34">2</tt>, and <span class="docMonofont">xs</span> to <tt class="calibre34">"abcd"</tt>.
      If we substitute these values into <i class="docEmphasis">myDrop</i>'s predicate, we get the following
      expression:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type  2 &lt;= 0 || null "abcd"</b>
2 &lt;= 0 || null "abcd" :: Bool
</pre><a name="x_Fe" class="calibre27" id="x_Fe"></a><p class="docText">We then evaluate enough of the predicate to find out
      what its value is. This requires that we evaluate the <i class="docEmphasis">(||)</i> expression.<a name="I_indexterm2_d1e4769" class="calibre27" id="I_indexterm2_d1e4769"></a> To determine its value, the <i class="docEmphasis">(||)</i> operator needs to examine the value of
      its left operand first:</p><pre class="calibre39">ghci&gt; <b class="calibre40">2 &lt;= 0</b>
False
</pre><a name="x_Ge" class="calibre27" id="x_Ge"></a><p class="docText">Substituting that value into the <i class="docEmphasis">(||)</i> expression leads to the following
      expression:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type  False || null "abcd"</b>
False || null "abcd" :: Bool
</pre><a name="x_He" class="calibre27" id="x_He"></a><p class="docText">If the left operand had evaluated to <tt class="calibre34">true</tt>, <i class="docEmphasis">(||)</i> would not need to evaluate its right
      operand, since it could not affect the result of the expression. Since
      it evaluates to <tt class="calibre34">False</tt>, <i class="docEmphasis">(||)</i> must evaluate the right operand:</p><pre class="calibre39">ghci&gt; <b class="calibre40">null "abcd"</b>
False
</pre><a name="x_Ie" class="calibre27" id="x_Ie"></a><p class="docText">We now substitute this value back into the <i class="docEmphasis">(||)</i> expression. Since both operands evaluate
      to <tt class="calibre34">False</tt>, the <i class="docEmphasis">(||)</i> expression does too, and thus the
      predicate evaluates to <tt class="calibre34">False</tt>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">False || False</b>
False
</pre><a name="x_Je" class="calibre27" id="x_Je"></a><p class="docText">This causes the <tt class="calibre34">if</tt>
      expression's <tt class="calibre34">else</tt> branch to be evaluated. This branch
      contains a recursive application of <i class="docEmphasis">myDrop</i>.</p><a name="idd1e4911" class="calibre27" id="idd1e4911"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_qm" class="calibre27" id="x_qm"></a></p><p class="docText">Many languages need to treat the logical-or operator
        specially so that it short-circuits if its left operand evaluates to
        <tt class="calibre34">true</tt>. In Haskell, <i class="docEmphasis">(||)</i> is an ordinary function: nonstrict
        evaluation builds this capability into the language.</p><a name="x_mB1" class="calibre27" id="x_mB1"></a><p class="docText">In Haskell, we can easily define a new function that
        short-circuits:</p><pre class="calibre39">-- file: ch02/shortCircuit.hs
newOr a b = if a then a else b</pre><br class="calibre48"/>
<a name="x_nB1" class="calibre27" id="x_nB1"></a><p class="docText">If we write an expression such as <tt class="calibre34">newOr True
        (length [1..] &gt; 0)</tt>, it will not evaluate its second
        argument. (This is just as well: that expression tries to compute the
        length of an infinite list. If it were evaluated, it would hang
        <i class="docEmphasis">ghci</i>, looping infinitely until we
        killed it.)</p><a name="x_oB1" class="calibre27" id="x_oB1"></a><p class="docText">Were we to write a comparable function in, say,
        Python, strict evaluation would bite us: both arguments would be
        evaluated before being passed to <i class="docEmphasis">newOr</i>, and we would not be able to avoid
        the infinite loop on the second argument.</p></div><a name="I_sect12_d1e4585d1e4939" class="calibre27" id="I_sect12_d1e4585d1e4939"></a><h4 id="title-IDA5KISI" class="docSection1Title">2.10.3. Recursion</h4><a name="x_Ke" class="calibre27" id="x_Ke"></a><p class="docText">When we<a name="ch02-recursion" class="calibre27" id="ch02-recursion"></a> apply <i class="docEmphasis">myDrop</i>
      recursively, <span class="docMonofont">n</span> is bound to the thunk <tt class="calibre34">2 -
      1</tt>, and <span class="docMonofont">xs</span> is bound to <tt class="calibre34">tail
      "abcd"</tt>.</p><a name="x_Le" class="calibre27" id="x_Le"></a><p class="docText">We're now evaluating <i class="docEmphasis">myDrop</i> from the beginning again. We
      substitute the new values of <span class="docMonofont">n</span> and
      <span class="docMonofont">xs</span> into the predicate:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (2 - 1) &lt;= 0 || null (tail "abcd")</b>
(2 - 1) &lt;= 0 || null (tail "abcd") :: Bool
</pre><a name="x_Me" class="calibre27" id="x_Me"></a><p class="docText">Here's a condensed version of the evaluation of the left
      operand:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (2 - 1) &lt;= 0</b>
(2 - 1) &lt;= 0 :: Bool
ghci&gt; <b class="calibre40">2 - 1</b>
1
ghci&gt; <b class="calibre40">1 &lt;= 0</b>
False</pre><a name="x_Ne" class="calibre27" id="x_Ne"></a><p class="docText">As we should now expect, we didn't evaluate the
      expression <tt class="calibre34">2 - 1</tt> until we needed its value. We also
      evaluate the right operand lazily, deferring<a name="I_indexterm2_d1e4938" class="calibre27" id="I_indexterm2_d1e4938"></a> <tt class="calibre34">tail "abcd"</tt> until we need its value:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type null (tail "abcd")</b>
null (tail "abcd") :: Bool
ghci&gt; <b class="calibre40">tail "abcd"</b>
"bcd"
ghci&gt; <b class="calibre40">null "bcd"</b>
False</pre><a name="x_Oe" class="calibre27" id="x_Oe"></a><p class="docText">The predicate again evaluates to <tt class="calibre34">False</tt>, causing the <tt class="calibre34">else</tt> branch to
      be evaluated once more.</p><a name="x_Pe" class="calibre27" id="x_Pe"></a><p class="docText">Because we've had to evaluate the expressions for
      <span class="docMonofont">n</span> and <span class="docMonofont">xs</span> to evaluate the
      predicate, we now know that in this application of <i class="docEmphasis">myDrop</i>, <span class="docMonofont">n</span> has the value
      <tt class="calibre34">1</tt> and <span class="docMonofont">xs</span> has the value
      <tt class="calibre34">"bcd"</tt>.</p><a name="I_sect12_d1e4585d1e5059" class="calibre27" id="I_sect12_d1e4585d1e5059"></a><h4 id="title-IDAWOISI" class="docSection1Title">2.10.4. Ending the Recursion</h4><a name="x_Qe" class="calibre27" id="x_Qe"></a><p class="docText">In the next recursive application of <i class="docEmphasis">myDrop</i>, we bind <span class="docMonofont">n</span> to
      <tt class="calibre34">1 - 1</tt> and <span class="docMonofont">xs</span> to <i class="docEmphasis">tail "bcd"</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (1 - 1) &lt;= 0 || null (tail "bcd")</b>
(1 - 1) &lt;= 0 || null (tail "bcd") :: Bool
</pre><a name="x_Re" class="calibre27" id="x_Re"></a><p class="docText">Once again, <i class="docEmphasis">(||)</i>
      needs to evaluate its left operand first:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type (1 - 1) &lt;= 0</b>
(1 - 1) &lt;= 0 :: Bool
ghci&gt; <b class="calibre40">1 - 1</b>
0
ghci&gt; <b class="calibre40">0 &lt;= 0</b>
True</pre><a name="x_Se" class="calibre27" id="x_Se"></a><p class="docText">Finally, this expression evaluates to <tt class="calibre34">true</tt>!</p><pre class="calibre39">ghci&gt; <b class="calibre40">True || null (tail "bcd")</b>
True
</pre><a name="x_Te" class="calibre27" id="x_Te"></a><p class="docText">Because the right operand cannot affect the
      result<a name="I_indexterm2_d1e5053" class="calibre27" id="I_indexterm2_d1e5053"></a> of <i class="docEmphasis">(||)</i>, it is not
      evaluated, and the result of the predicate is <tt class="calibre34">TRue</tt>. This causes us to evaluate the
      <tt class="calibre34">then</tt> branch:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type tail "bcd"</b>
tail "bcd" :: [Char]
</pre><a name="I_sect12_d1e4585d1e5140" class="calibre27" id="I_sect12_d1e4585d1e5140"></a><h4 id="title-IDAXRISI" class="docSection1Title">2.10.5. Returning from the Recursion</h4><a name="x_Ue" class="calibre27" id="x_Ue"></a><p class="docText">Remember, we're now inside our second recursive
      application of <i class="docEmphasis">myDrop</i>. This
      application evaluates to <tt class="calibre34">tail "bcd"</tt>. We return from the
      application of the function, substituting this expression for
      <tt class="calibre34">myDrop (1 - 1) (tail "bcd"</tt><tt class="calibre34">)</tt> to become the
      result of this application:</p><pre class="calibre39">ghci&gt; <b class="calibre40">myDrop (1 - 1) (tail "bcd") == tail "bcd"</b>
True
</pre><a name="x_Ve" class="calibre27" id="x_Ve"></a><p class="docText">We then return from the first recursive application,
      substituting the result of the second recursive application for
      <tt class="calibre34">myDrop (2 - 1) (tail "abcd") </tt>to become the result of this
      application:</p><pre class="calibre39">ghci&gt; <b class="calibre40">myDrop (2 - 1) (tail "abcd") == tail "bcd"</b>
True
</pre><a name="x_We" class="calibre27" id="x_We"></a><p class="docText">Finally, we return from our original application,
      substituting the result of the first recursive application:</p><pre class="calibre39">ghci&gt; <b class="calibre40">myDrop 2 "abcd" == tail "bcd"</b>
True
</pre><a name="x_Xe" class="calibre27" id="x_Xe"></a><p class="docText">Notice that as we return from each successive recursive
      application, none of them needs to evaluate the expression <tt class="calibre34">tail
      "bcd"</tt>: the final result of evaluating the original expression is
      a thunk. The thunk is only evaluated when <i class="docEmphasis">ghci</i> needs to print it.</p><pre class="calibre39">ghci&gt; <b class="calibre40">myDrop 2 "abcd"</b>
"cd"
ghci&gt; <b class="calibre40">tail "bcd"</b>
"cd"</pre><a name="I_sect12_d1e4585d1e5200" class="calibre27" id="I_sect12_d1e4585d1e5200"></a><h4 id="title-IDA2TISI" class="docSection1Title">2.10.6. What Have We Learned?</h4><a name="x_Ye" class="calibre27" id="x_Ye"></a><p class="docText">We<a name="I_indexterm2_d1e5139" class="calibre27" id="I_indexterm2_d1e5139"></a> have established several
      important points:</p><ul class="calibre18"><li class="calibre19"><p class="docText">It makes sense to use substitution and rewriting to
          understand the evaluation of a Haskell expression.</p></li><li class="calibre19"><p class="docText">Laziness leads us to defer evaluation until we need
          a value and to evaluate just enough of an expression to establish
          its value.</p></li><li class="calibre19"><p class="docText">The result of applying a function may be a thunk (a
          deferred expression).</p></li></ul>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="funcstypes_srcfile.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="funcstypes_polymorphism.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

