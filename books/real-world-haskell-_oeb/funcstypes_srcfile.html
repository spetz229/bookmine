---
layout: page
title: "Real World Haskell, 1st Edition"
prev: funcstypes_sigs.html
next: I_sect12_d1e4585.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

    <a name="toppage" class="calibre5" id="toppage"></a>
    <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody">
      <tr valign="top" class="calibre6">
        <td class="calibre7">
          <a name="MainContent" class="calibre5" id="MainContent"></a>
          <table width="95%" class="sfbody">
            <tr class="calibre6">
              <td class="v">
                <!--Copyright (c) 2002 Safari Tech Books Online-->
                <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody">
                  <tr class="calibre6">
                    <td valign="middle" class="v1" height="5">
                      <img src="pixel.gif" alt="" border="0" class="calibre8"/>
                    </td>
                  </tr>
                  <tr class="calibre6">
                    <td valign="middle" class="v1">
                      <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody">
                        <tr class="calibre6">
                          <td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td>
                        </tr>
                      </table>
                    </td>
                    <td class="v1"/>
                    <td valign="middle" class="v2"> 
           
          <span class="calibre9"><a target="_self" href="funcstypes_sigs.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="I_sect12_d1e4585.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td>
                  </tr>
                </table>
                <div id="section" class="calibre15">
                  <table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v3">Safari IT Books Language Constructs Functional Programming Haskell Safari IT Books Programming Programming Programming Bryan O'Sullivan  Donald Bruce Stewart  John Goerzen  O'Reilly Media, Inc. Real World Haskell, 1st Edition<a name="funcstypes_srcfile" class="calibre27" id="funcstypes_srcfile"></a><h3 id="title-IDAEAHUD" class="docSection1Title">2.9. Haskell Source Files, and Writing Simple Functions</h3><a name="x_h3" class="calibre27" id="x_h3"></a><p class="docText">Now<a name="ch02-functions001" class="calibre27" id="ch02-functions001"></a><a name="ch02-sourcefiles" class="calibre27" id="ch02-sourcefiles"></a><a name="ch02-funtionswriting" class="calibre27" id="ch02-funtionswriting"></a> that we know how to apply functions, it's time we turned
    our attention to writing them. While we can write functions in <i class="docEmphasis">ghci</i>, it's not a good environment for this. It
    accepts only a highly restricted subset of Haskell—most importantly, the
    syntax it uses for defining functions is not the same as we use in a
    Haskell source file.<sup class="docFootnote"><a class="docLink1" href="#x_h3d1e4128">[5]</a></sup> Instead, we'll finally break down and create a source
    file.</p><blockquote class="calibre30"><p class="docFootnote1"><sup class="calibre50"><a name="x_h3d1e4128" class="calibre5" id="x_h3d1e4128">[5]</a></sup> The environment in which <i class="docEmphasis">ghci</i> operates is called the IO
        monad. In <a class="docLink" href="io_split_000.html#io">Chapter 7</a>, we will cover the IO
        monad in depth, and the seemingly arbitrary restrictions that <i class="docEmphasis">ghci</i> places on us will make more
        sense.</p></blockquote><a name="x_i3" class="calibre27" id="x_i3"></a><p class="docText">Haskell source files are <a name="I_indexterm2_d1e4083" class="calibre27" id="I_indexterm2_d1e4083"></a>usually identified with a suffix of <i class="docEmphasis">.hs</i>. A simple function definition is to open up
    a file named <i class="docEmphasis">add.hs</i> and add these
    contents to it:</p><pre class="calibre39">-- file: ch03/add.hs
add a b = a + b</pre><br class="calibre48"/>
<a name="x_j3" class="calibre27" id="x_j3"></a><p class="docText">On the lefthand side of the <tt class="calibre34">=</tt> is the name of the function, followed by the
    arguments to the function. On the righthand side is the body of the
    function. With our source file saved, we can load it into <i class="docEmphasis">ghci</i>, and use our new <i class="docEmphasis">add</i> function straightaway (the prompt that
    <i class="docEmphasis">ghci</i> displays will change after you
    load your file):</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load add.hs</b>
[1 of 1] Compiling Main             ( add.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">add 1 2</b>
3</pre><a name="funcstypes_srcfiled1e4185" class="calibre27" id="funcstypes_srcfiled1e4185"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"><a name="x_od" class="calibre27" id="x_od"></a></p><p class="docText">When you run <i class="docEmphasis">ghci</i>, it
      may not be able to find your source file. It will search for source
      files in whatever directory it was run. If this is not the directory
      that your source file is actually in, you can use <i class="docEmphasis">ghci</i>'s <tt class="calibre34">:cd</tt> command<a name="I_indexterm2_d1e4134" class="calibre27" id="I_indexterm2_d1e4134"></a> to change its working directory:</p><pre class="calibre39">          ghci&gt; 
          <b class="calibre40">:cd /tmp</b></pre><a name="x_pd" class="calibre27" id="x_pd"></a><p class="docText">Alternatively, you can provide the path to your Haskell
      source file as the argument to <tt class="calibre34">:load</tt>. This path can be
      either absolute or relative to <i class="docEmphasis">ghci</i>'s
      current directory.</p></div><a name="x_k3" class="calibre27" id="x_k3"></a><p class="docText">When we apply <i class="docEmphasis">add</i> to
    the values <tt class="calibre34">1</tt> and <tt class="calibre34">2</tt>, the variables <span class="docMonofont">a</span> and
    <span class="docMonofont">b</span> on the lefthand side of our definition are given (or
    "bound to") the values <tt class="calibre34">1</tt>
    and <tt class="calibre34">2</tt>, so the result is the expression
    <tt class="calibre34">1 + 2</tt>.</p><a name="x_l3" class="calibre27" id="x_l3"></a><p class="docText">Haskell doesn't have a <i class="docEmphasis">return</i> keyword, because<a name="I_indexterm2_d1e4187" class="calibre27" id="I_indexterm2_d1e4187"></a> a function is a single expression, not a sequence of
    statements. The value of the expression is the result of the function.
    (Haskell does have a function called <i class="docEmphasis">return</i>, but we won't discuss it for a while; it
    has a different meaning than in imperative languages.)</p><a name="x_qd" class="calibre27" id="x_qd"></a><p class="docText">When you see an <tt class="calibre34">=</tt>
    symbol in Haskell code, it represents "meaning"—the name on
    the left is defined to be the expression on the right.</p><a name="funcstypes_variable" class="calibre27" id="funcstypes_variable"></a><h4 id="title-IDANGHUD" class="docSection1Title">2.9.1. Just What Is a Variable, Anyway?</h4><a name="x_sK" class="calibre27" id="x_sK"></a><p class="docText">In Haskell, a variable<a name="I_indexterm2_d1e4207" class="calibre27" id="I_indexterm2_d1e4207"></a> provides a way to give a name to an expression. Once a
      variable <a name="I_indexterm2_d1e4211" class="calibre27" id="I_indexterm2_d1e4211"></a>is <span class="docEmphasis">bound to</span> (i.e., associated with) a
      particular expression, its value does not change: we can always use the
      name of the variable instead of writing out the expression, and we will
      get the same result either way.</p><a name="x_rK" class="calibre27" id="x_rK"></a><p class="docText">If you're used to imperative programming languages,
      you're likely to think of a variable as a way of identifying<a name="I_indexterm2_d1e4220" class="calibre27" id="I_indexterm2_d1e4220"></a> a <span class="docEmphasis">memory location</span> (or some
      equivalent) that can hold different values at different times. In an
      imperative language, we can change a variable's value at any time, so
      that examining the memory location repeatedly can potentially give
      different results each time.</p><a name="x_rd" class="calibre27" id="x_rd"></a><p class="docText">The critical difference between these two notions of a
      variable is that in Haskell, once we've bound a variable to an
      expression, we know that we can always substitute it for that
      expression, because it will not change. In an imperative language, this
      notion of substitutability does not hold.</p><a name="x_Um" class="calibre27" id="x_Um"></a><p class="docText">For example, if we run the following tiny<a name="I_indexterm2_d1e4231" class="calibre27" id="I_indexterm2_d1e4231"></a> Python script, it will print the number 11:</p><pre class="calibre39">x = 10
x = 11
# value of x is now 11
print x</pre><br class="calibre48"/>
<a name="x_Vm" class="calibre27" id="x_Vm"></a><p class="docText">In contrast, trying the equivalent in Haskell results in
      an error:</p><pre class="calibre39">-- file: ch02/Assign.hs
x = 10
x = 11</pre><br class="calibre48"/>
<a name="x_Wm" class="calibre27" id="x_Wm"></a><p class="docText">We cannot assign a value to <span class="docMonofont">x</span>
      twice:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load Assign</b>
[1 of 1] Compiling Main             ( Assign.hs, interpreted )

Assign.hs:4:0:
    Multiple declarations of `Main.x'
    Declared at: Assign.hs:3:0
                 Assign.hs:4:0
Failed, modules loaded: none.
</pre><a name="funcstypes_if" class="calibre27" id="funcstypes_if"></a><h4 id="title-IDAQIHUD" class="docSection1Title">2.9.2. Conditional Evaluation</h4><a name="x_m3" class="calibre27" id="x_m3"></a><p class="docText">Like<a name="ch02-conditionalevaluation" class="calibre27" id="ch02-conditionalevaluation"></a> many other languages, Haskell has <a name="I_indexterm2_d1e4262" class="calibre27" id="I_indexterm2_d1e4262"></a>an <tt class="calibre34">if</tt> expression. Let's see it in action;
      then we'll explain what's going on. As an example, we'll write our own
      version of the standard <i class="docEmphasis">drop</i>
      function. <a name="I_indexterm2_d1e4272" class="calibre27" id="I_indexterm2_d1e4272"></a>Before we begin, let's probe a little into how <i class="docEmphasis">drop</i> behaves, so we can replicate its
      behavior:</p><pre class="calibre39">ghci&gt; <b class="calibre40">drop 2 "foobar"</b>
"obar"
ghci&gt; <b class="calibre40">drop 4 "foobar"</b>
"ar"
ghci&gt; <b class="calibre40">drop 4 [1,2]</b>
[]
ghci&gt; <b class="calibre40">drop 0 [1,2]</b>
[1,2]
ghci&gt; <b class="calibre40">drop 7 []</b>
[]
ghci&gt; <b class="calibre40">drop (-2) "foo"</b>
"foo"</pre><a name="x_n3" class="calibre27" id="x_n3"></a><p class="docText">From this code, it seems that <i class="docEmphasis">drop</i> returns the original list if the number
      to remove is less than or equal to zero. Otherwise, it removes elements
      until it either runs out or reaches the given number. Here's a <i class="docEmphasis">myDrop</i> function that has the same behavior,
      and that uses Haskell's <tt class="calibre34">if</tt> expression to decide what to do.
      The following <i class="docEmphasis">null</i> function below
      checks whether a list is empty:</p><pre class="calibre39">-- file: ch02/myDrop.hs
myDrop n xs = if n &lt;= 0 || null xs
              then xs
              else myDrop (n - 1) (tail xs)</pre><br class="calibre48"/>
<a name="x_Ym" class="calibre27" id="x_Ym"></a><p class="docText">In Haskell, indentation is important: it
      <span class="docEmphasis">continues</span> an existing definition, instead of
      starting a new one. Don't omit the indentation!</p><a name="x_iB1" class="calibre27" id="x_iB1"></a><p class="docText">You might wonder where the variable name
      <span class="docMonofont">xs</span> comes from in the Haskell function. This is a
      common naming pattern for lists. You can read the <tt class="calibre34">s</tt> as a
      suffix, so the name is essentially "plural of
      <tt class="calibre34">x</tt>."</p><a name="x_o3" class="calibre27" id="x_o3"></a><p class="docText">Let's save our Haskell function in a file named
      <i class="docEmphasis">myDrop.hs</i>, then load it into
      <i class="docEmphasis">ghci</i>:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:load myDrop.hs</b>
[1 of 1] Compiling Main             ( myDrop.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; <b class="calibre40">myDrop 2 "foobar"</b>
"obar"
ghci&gt; <b class="calibre40">myDrop 4 "foobar"</b>
"ar"
ghci&gt; <b class="calibre40">myDrop 4 [1,2]</b>
[]
ghci&gt; <b class="calibre40">myDrop 0 [1,2]</b>
[1,2]
ghci&gt; <b class="calibre40">myDrop 7 []</b>
[]
ghci&gt; <b class="calibre40">myDrop (-2) "foo"</b>
"foo"</pre><a name="x_p3" class="calibre27" id="x_p3"></a><p class="docText">Now that we've seen <i class="docEmphasis">myDrop</i> in action, let's return to the source
      code and look at all the novelties we've introduced.</p><a name="x_wd" class="calibre27" id="x_wd"></a><p class="docText">First of all, we have introduced <tt class="calibre34">--</tt>, the
      beginning of a single-line comment. This comment extends to the end of
      the line.</p><a name="x_q3" class="calibre27" id="x_q3"></a><p class="docText">Next is the <tt class="calibre34">if</tt> keyword itself. It
      introduces an expression that has three components:</p><ul class="calibre18"><li class="calibre19"><p class="docText">An expression of type Bool, immediately
          following the <tt class="calibre34">if</tt>. We refer to
          this as <a name="I_indexterm2_d1e4415" class="calibre27" id="I_indexterm2_d1e4415"></a>a <span class="docEmphasis">predicate</span>.</p></li><li class="calibre19"><p class="docText">A <tt class="calibre34">then</tt> keyword, followed by another
          expression. This expression will be used as the value of the
          <tt class="calibre34">if</tt> expression if the predicate
          evaluates to <tt class="calibre34">true</tt>.</p></li><li class="calibre19"><p class="docText">An <tt class="calibre34">else</tt> keyword, <a name="I_indexterm2_d1e4440" class="calibre27" id="I_indexterm2_d1e4440"></a>followed by another expression. This expression will
          be used as the value of the <tt class="calibre34">if</tt>
          expression if the predicate evaluates to <tt class="calibre34">False</tt>.</p></li></ul><a name="x_Ae" class="calibre27" id="x_Ae"></a><p class="docText">We'll refer to the expressions that follow the
      <tt class="calibre34">then</tt> and <tt class="calibre34">else</tt> keywords as
      "branches." The branches must have the same types; the
      <tt class="calibre34">if</tt> expression will also have this
      type. An expression such as <tt class="calibre34">if True then 1 else "foo"</tt> has
      different types for its branches, so it is ill typed and a compiler or
      interpreter will reject it.</p><a name="x_s3" class="calibre27" id="x_s3"></a><p class="docText">Recall that Haskell is an expression-oriented language.
      In an imperative language, it can make sense to omit the
      <tt class="calibre34">else</tt> branch from an <tt class="calibre34">if</tt>, because we're working
      with <span class="docEmphasis"><span class="docEmphasis">statements</span></span>, not expressions.
      However, when we're working with expressions, an <tt class="calibre34">if</tt> that
      was missing an <tt class="calibre34">else</tt> wouldn't have a result or type if the
      predicate evaluated to <i class="docEmphasis">False</i>, so it
      would be nonsensical.</p><a name="x_t3" class="calibre27" id="x_t3"></a><p class="docText">Our predicate contains a few more novelties. The
      <i class="docEmphasis">null</i> function<a name="I_indexterm2_d1e4494" class="calibre27" id="I_indexterm2_d1e4494"></a> indicates whether a list is empty, while the <i class="docEmphasis">(||)</i> operator<a name="I_indexterm2_d1e4501" class="calibre27" id="I_indexterm2_d1e4501"></a> performs a logical "or" of its
      Bool-typed arguments:</p><pre class="calibre39">ghci&gt; <b class="calibre40">:type null</b>
null :: [a] -&gt; Bool
ghci&gt; <b class="calibre40">:type (||)</b>
(||) :: Bool -&gt; Bool -&gt; Bool</pre><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docNormalTitle">Operators are not special</p><a name="x_Be" class="calibre27" id="x_Be"></a><p class="docText">Notice that we were able to find the type of <i class="docEmphasis">(||)</i> by wrapping it in <span class="docEmphasis">parentheses</span>. The <i class="docEmphasis">(||)</i> operator isn't built into the
        language; it's an ordinary function.</p><a name="x_am" class="calibre27" id="x_am"></a><p class="docText">The <i class="docEmphasis">(||)</i> operator
        "short circuits": if its left operand evaluates to
        <tt class="calibre34">TRue</tt>, it doesn't evaluate its right operand. In most
        languages, short-circuit evaluation requires special support, but not
        in Haskell. We'll see why shortly.</p></td></tr></table></td></tr></table></p><br class="calibre48"/><a name="x_u3" class="calibre27" id="x_u3"></a><p class="docText">Next, our function applies itself recursively. This is
      our first example of recursion, which we'll talk about in some detail
      soon.</p><a name="x_v3" class="calibre27" id="x_v3"></a><p class="docText">Finally, our <tt class="calibre34">if</tt> expression spans several
      lines. We align<a name="I_indexterm2_d1e4555" class="calibre27" id="I_indexterm2_d1e4555"></a> the <tt class="calibre34">then</tt> and <tt class="calibre34">else</tt> branches
      under the <tt class="calibre34">if</tt> for neatness. So long as we use some
      indentation, the exact amount is not important. If we wish, we can write
      the entire expression on a single line:</p><pre class="calibre39">-- file: ch02/myDrop.hs
myDropX n xs = if n &lt;= 0 || null xs then xs else myDropX (n - 1) (tail xs)</pre><br class="calibre48"/>
<a name="x_jB1" class="calibre27" id="x_jB1"></a><p class="docText">The length of this version makes it more difficult to
      read. We will usually break an <tt class="calibre34">if</tt>
      expression across several lines to keep the predicate and each of the
      branches easier to follow.</p><a name="x_kB1" class="calibre27" id="x_kB1"></a><p class="docText">For comparison, here is a Python equivalent of the
      Haskell <i class="docEmphasis">myDrop</i>. The two are
      structured similarly—each decrements a counter while removing an element
      from the head of the list:</p><pre class="calibre39">def myDrop(n, elts):
    while n &gt; 0 and elts:
        n = n - 1
        elts = elts[1:]
    return elts</pre><br class="calibre48"/>
<a href="21061538.html" class="calibre2"><img src="pixel.gif" alt="" border="0" class="calibre31"/></a><ul class="calibre18"></ul></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="middle" class="v3" height="5">
                        <img src="pixel.gif" alt="" border="0" class="calibre32"/>
                      </td>
                    </tr>
                    <tr class="calibre16">
                      <td valign="middle" class="v3">
                        <table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody1">
                          <tr class="calibre16">
                            <td class="v5"><span class="calibre33"> </span>
                   
                  <span class="calibre33">   </span>
             <span class="calibre33"> </span></td>
                          </tr>
                        </table>
                      </td>
                      <td class="v3"/>
                      <td valign="middle" class="v6"> 
           
          <span class="calibre33"><a target="_self" href="funcstypes_sigs.html" title="Previous section" class="calibre2"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre17"/></a></span>
				
				 
				
				<span class="calibre33"><a target="_self" href="I_sect12_d1e4585.html" title="Next section" class="calibre2"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre17"/></a></span></td>
                    </tr>
                  </table>
                  <table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody1">
                    <tr class="calibre16">
                      <td valign="top" class="v6">
                        <span class="calibre33"></span>
                      </td>
                    </tr>
                  </table>
                </div>
                <!--IP User 2-->
              </td>
            </tr>
          </table>
        </td>
        <td class="calibre7">
                         
                      </td>
      </tr>
      <tr class="calibre6">
        <td colspan="3" valign="bottom" class="calibre7">
          <br class="calibre20"/>
          <p class="v4"></p>
          <br class="calibre20"/>
        </td>
      </tr>
    </table>
  </div>

{% endraw %}

